<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring Boot从入门到实战 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot从入门到实战">
<meta property="og:url" content="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-09T07:04:53.000Z">
<meta property="article:modified_time" content="2023-10-11T06:42:37.404Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot从入门到实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-11 14:42:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Boot从入门到实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-11T06:42:37.404Z" title="更新于 2023-10-11 14:42:37">2023-10-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot从入门到实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第1章-初识Spring-Boot"><a href="#第1章-初识Spring-Boot" class="headerlink" title="第1章　初识Spring Boot"></a>第1章　初识Spring Boot</h1><h2 id="1-1-Spring-Boot是什么"><a href="#1-1-Spring-Boot是什么" class="headerlink" title="1.1　Spring Boot是什么"></a>1.1　Spring Boot是什么</h2><p>Spring Boot是由Pivotal团队提供的基于Spring的全新框架</p>
<p>Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。</p>
<p>Spring Boot的核心设计思想是“约定优于配置”</p>
<p>比如在使用Spring开发Web项目时，我们需要配置web.xml、Spring和MyBatis等，还需要将它们集成在一起。而使用Spring Boot一切将变得极其简单，它采用了大量的默认配置来简化这些文件的配置过程，只需引入对应的<strong>Starters</strong>（启动器）。</p>
<p>Spring Boot可以构建一切。设计它就是为了使用最少的配置，以最快的速度来启动和运行Spring项目。</p>
<h3 id="1-Spring-Boot的背景"><a href="#1-Spring-Boot的背景" class="headerlink" title="1. Spring Boot的背景"></a>1. Spring Boot的背景</h3><p>Spring Boot建立在Spring基础之上，遵循“约定优于配置”的原则，避免了创建项目或框架时必须做的繁杂配置，帮助开发者以最少的工作量，更加简单、方便地使用现有Spring中的所有功能组件。</p>
<h3 id="2-Spring-Boot的特性"><a href="#2-Spring-Boot的特性" class="headerlink" title="2. Spring Boot的特性"></a>2. Spring Boot的特性</h3><p>Spring Boot的一系列特性使得微服务架构的落地变得非常容易，对于目前众多的技术栈，Spring Boot是Java领域微服务架构的最优落地技术。图1-1所示为Spring Boot的一些特性。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091507170.png" alt="image-20231009150724075"></p>
<h3 id="3-Spring-Boot的核心组件"><a href="#3-Spring-Boot的核心组件" class="headerlink" title="3. Spring Boot的核心组件"></a>3. Spring Boot的核心组件</h3><p>Spring Boot官方提供了很多当前流行的基础功能组件的封装，命名一般以<strong>spring-boot-starter</strong>开头，比如spring-boot-starter-quartz定时任务组件和spring-boot-starter-thymeleaf页面模板引擎等</p>
<p>很多第三方中间件也按照Spring Boot的规范提供了针对Spring Boot项目的Starters（启动器），一般以组件名开头，比如MyBatis针对Spring Boot提供的组件包<strong>mybatis-spring-boot-starter</strong>。</p>
<h2 id="1-2-Spring-Boot的优点"><a href="#1-2-Spring-Boot的优点" class="headerlink" title="1.2　Spring Boot的优点"></a>1.2　Spring Boot的优点</h2><ol>
<li>遵循“约定优于配置”的原则</li>
<li>使用JavaConfig，避免使用XML的烦琐。</li>
<li>提供Starters（启动器），简化Maven配置，避免依赖冲突。</li>
<li>提供内嵌Servlet容器，可选择内嵌Tomcat、Jetty等容器，不需要单独的Web服务器。这意味着不再需要启动Tomcat或其他任何中间件。</li>
<li>提供了一系列项目中常见的非功能特性，如安全监控、应用监控、健康检测等。</li>
<li>与云计算、微服务的天然集成。</li>
</ol>
<p>Spring Boot就是尽可能地简化应用开发的门槛，让应用开发、测试、部署变得更加简单。</p>
<h2 id="1-3-为什么学习Spring-Boot"><a href="#1-3-为什么学习Spring-Boot" class="headerlink" title="1.3　为什么学习Spring Boot"></a>1.3　为什么学习Spring Boot</h2><p>最近几年，Spring生态圈最流行的技术框架莫过于Spring Boot和Spring Cloud。目前，各个企业都在推动微服务技术架构的落地，将一个复杂的应用拆分成多个小的独立模块，分开部署，互不干扰，从而达到松散耦合、提高开发效率和降低运维成本的目的。</p>
<p>Spring Boot作为微服务框架的基础被越来越多地应用于企业级开发中，它是Spring Cloud的基础。要学习Spring Cloud，就必须了解Spring Boot框架的架构和设计理念。</p>
<p>Spring Boot是Spring生态下的一个子项目，用于快速、敏捷地开发新一代基于Spring框架的应用程序。同时，它将目前各种比较成熟的服务框架和第三方组件组合起来（如Redis、MongoDB、JPA、RabbitMQ、Quartz等），按照“约定优于配置”的设计思想封装成Starters组件。这样，我们在Spring Boot应用中几乎可以零配置地使用这些组件，达到开箱即用的效果，从而从繁杂的配置中解放出来，更加专注于业务逻辑的开发。</p>
<p>Spring Boot让构建、编码、配置、部署、监控都变得非常简单</p>
<p>pring Boot不是新的语言、新的技术，它只是把现有的比较流行的框架集成在一起，遵循“约定优于配置”的原则，开箱即用，使得我们不需要再去关注那些烦琐的配置</p>
<h2 id="1-4-什么是“约定优于配置”"><a href="#1-4-什么是“约定优于配置”" class="headerlink" title="1.4　什么是“约定优于配置”"></a>1.4　什么是“约定优于配置”</h2><p>从本质上来说，系统、类库或框架应该约定合理的默认值，开发者仅需规定应用中不符合约定的部分。例如，如果模型中有一个名为Product的类，那么数据库中对应的表就会默认命名为product，只有在偏离这个约定时才需要定义有关这个名字的配置，例如将该表命名为product_info。</p>
<p>简单来说“约定优于配置”就是遵循约定。如果你所用工具的约定配置符合你的要求，那么就可以省去此配置；不符合，就通过修改相关的配置来达到你所期待的方式。</p>
<p>Spring Boot是Spring对“约定优于配置”的最佳实践产物。小到配置文件、中间件的默认配置，大到内置容器、Spring生态中的各种Starters，无不遵循“约定优于配置”的设计思想。</p>
<h2 id="1-5-Spring、Spring-Boot和Spring-Cloud的关系"><a href="#1-5-Spring、Spring-Boot和Spring-Cloud的关系" class="headerlink" title="1.5　Spring、Spring Boot和Spring Cloud的关系"></a>1.5　Spring、Spring Boot和Spring Cloud的关系</h2><p>Spring是一个开源生态体系，是集大成者。其核心是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）。正是IoC和AOP这两个核心功能成就了强大的Spring，Spring在这两大核心功能上不断地发展壮大，才有了Spring MVC等一系列成熟的产品，最终构建了功能强大的Spring生态帝国。</p>
<p>Spring Boot是在Spring的基础上发展而来的，它不是为了取代Spring，而是为了简化Spring应用的创建、运行、调试、部署，让开发者更容易地使用Spring。它将目前各种比较成熟的服务框架和第三方组件组合起来，按照“约定优于配置”的设计思想进行重新封装，屏蔽掉复杂的配置和实现，最终给开发者提供一套简单、易用、易部署、易维护的分布式系统开发工具包。</p>
<p>Spring Cloud是基于Spring Boot实现的分布式微服务框架，它利用Spring Boot简单、易用、便利的特性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、断路器、数据监控等基础组件都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>我们都知道，采用微服务架构，服务的数量会非常多，管理特别麻烦，而Spring Cloud就是一套分布式微服务治理框架，可以说是这些微服务的大管家。作为大管家Spring Cloud就需要提供各种组件和方案来治理与维护整个微服务系统，比如服务之间的通信、熔断、监控等。Spring Cloud利用Spring Boot的特性集成了开源行业中优秀的组件，在微服务架构中对外提供了一套服务治理的解决方案。</p>
<p>Spring Boot在Spring Cloud中起到了承上启下的作用，如果要学习Spring Cloud，则必须学习Spring Boot。三者之间的关系如图1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091515451.png" alt="image-20231009151526413"></p>
<h1 id="第2章-开始Spring-Boot之旅"><a href="#第2章-开始Spring-Boot之旅" class="headerlink" title="第2章　开始Spring Boot之旅"></a>第2章　开始Spring Boot之旅</h1><p>本章主要介绍如何开始Spring Boot项目，通过一个简单的helloworld程序演示Spring Boot的项目结构与启动流程，然后介绍Spring Boot是如何进行单元测试的，最后介绍非常实用的功能：配置开发环境热部署</p>
<h2 id="2-1-第一个Spring-Boot项目：helloworld"><a href="#2-1-第一个Spring-Boot项目：helloworld" class="headerlink" title="2.1　第一个Spring Boot项目：helloworld"></a>2.1　第一个Spring Boot项目：helloworld</h2><p>本节从简单的helloworld程序开始介绍创建Spring Boot项目的方法和流程，以及Spring Boot项目结构，最后介绍项目中非常重要的pom.xml文件。</p>
<h3 id="2-1-1-创建Spring-Boot项目"><a href="#2-1-1-创建Spring-Boot项目" class="headerlink" title="2.1.1　创建Spring Boot项目"></a>2.1.1　创建Spring Boot项目</h3><p>有两种方式来构建Spring Boot项目的基础框架：第一种是使用Spring官网提供的构建页面，第二种是使用IntelliJ IDEA中的Spring插件。</p>
<h4 id="1-使用Spring官网提供的构建页面"><a href="#1-使用Spring官网提供的构建页面" class="headerlink" title="1. 使用Spring官网提供的构建页面"></a>1. 使用Spring官网提供的构建页面</h4><p>步骤01 访问Spring官网。</p>
<p>步骤02 选择构建工具为Maven Project，编程语言选择Java，Spring Boot版本为2.3.7，填写项目基本信息，具体如图2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091519078.png" alt="image-20231009151910048"></p>
<p>步骤03 单击Generate创建并下载项目压缩包。</p>
<p>步骤04 解压后，使用IDEA引入项目，选择File→Open File or Project，选择解压后的文件夹，单击OK按钮，项目即可创建完成。</p>
<h4 id="2-使用IDEA构建"><a href="#2-使用IDEA构建" class="headerlink" title="2. 使用IDEA构建"></a>2. 使用IDEA构建</h4><p>步骤01 选择File→New→Project命令，弹出新建项目的对话框。</p>
<p>步骤02 选择Spring Initializr，单击Next按钮出现配置界面，IDEA已经帮助做了集成。如图2-2所示，IDEA界面中的Group、Artifact等输入框就对应着项目的pom.xml中的groupId、artifactId等配置项。</p>
<p>填完相关的信息之后，直接单击NEXT按钮来创建项目。</p>
<h3 id="2-1-2-项目结构"><a href="#2-1-2-项目结构" class="headerlink" title="2.1.2　项目结构"></a>2.1.2　项目结构</h3><p>Spring Boot的基础结构共有3个主要目录，具体如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/java：程序开发以及主程序目录。src/main/resources：配置文件和资源文件目录。src/test/java：测试程序目录。</span><br></pre></td></tr></table></figure>
<p>从上面我们可以了解到，新建的helloworld项目只有java、resources、test三个基础结构目录。通常，完整的项目包括前台页面、model实体、数据库访问、公共基础类等非常多的文件和目录，Spring Boot建议的目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">myproject</span><br><span class="line">        +-src</span><br><span class="line">                +- main</span><br><span class="line">                        +- java</span><br><span class="line">                                +- com.example.myproject</span><br><span class="line">                                        +- comm</span><br><span class="line">                                        +- model</span><br><span class="line">                                        +- repository</span><br><span class="line">                                        +- service</span><br><span class="line">                                        +- web</span><br><span class="line">                                        +- Application.java</span><br><span class="line">                        +- resources</span><br><span class="line">                                +- <span class="keyword">static</span></span><br><span class="line">                                +- templates</span><br><span class="line">                                +- application.properties</span><br><span class="line">                        +- test</span><br><span class="line">        +-pom.xml</span><br></pre></td></tr></table></figure>
<p>如上所示，其实就是把java、resources、test三大基础目录进行细化，定义每个子目录存放的文件和作用。</p>
<p>1）java目录下的com.example.myproject为后台java文件的根目录，包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application.java：建议放到根目录下，是项目的启动类，注意Spring Boot项目只能有一个main()方法入口。</span><br><span class="line">comm：建议放置公共的类，如全局的配置文件、工具类等。</span><br><span class="line">model：主要用于实体（Entity）。</span><br><span class="line">repository：主要是数据库访问层代码。</span><br><span class="line">service：主要是业务类代码。</span><br><span class="line">web：负责前台页面访问的Controller路由。</span><br></pre></td></tr></table></figure>
<p>2）resources目录下包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static：存放Web访问的静态资源，如JS、CSS、图片等。</span><br><span class="line">templates：存放页面模板。</span><br><span class="line">application.properties：存放项目的配置信息。</span><br></pre></td></tr></table></figure>
<p>3）test目录存放单元测试的代码，目录结构和java目录保持一致。</p>
<p>4）pom.xml用于配置项目依赖包以及其他配置。</p>
<p>采用Spring Boot推荐的默认配置可以省掉很多设置。当然，也可以根据技术规范进行调整。至此，我们的第一个Spring Boot项目就创建完成了。</p>
<h3 id="2-1-3-pom-xml详解"><a href="#2-1-3-pom-xml详解" class="headerlink" title="2.1.3　pom.xml详解"></a>2.1.3　pom.xml详解</h3><p>pom.xml配置文件主要分为四部分，下面就来一一介绍pom.xml文件的各个组成部分以及它们的作用。</p>
<h4 id="1-项目的描述信息"><a href="#1-项目的描述信息" class="headerlink" title="1. 项目的描述信息"></a>1. 项目的描述信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wei<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置内容基本是创建项目时定义的有关项目的基本描述信息，其中比较重要的是groupId、artifactId。各个属性说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupId：项目的包路径。</span><br><span class="line">artifactId：项目名称。</span><br><span class="line">version：项目版本号。</span><br><span class="line">packaging：一般有jar、war两个值，表示使用Maven打包时是构建成JAR包还是WAR包。</span><br><span class="line">name：项目名称。d</span><br><span class="line">escription：项目描述。</span><br></pre></td></tr></table></figure>
<h4 id="2-项目的依赖配置信息"><a href="#2-项目的依赖配置信息" class="headerlink" title="2. 项目的依赖配置信息"></a>2. 项目的依赖配置信息</h4><p>此部分为项目的依赖信息，主要包括Spring Boot的版本信息和第三方组件的版本信息。示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>项目的依赖信息主要分为parent和dependencies两部分。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent：配置父级项目的信息。Maven支持项目的父子结构，引入后会默认继承父级的配置。此项目		中引入spring-boot-starter-parent定义Spring Boot的基础版本。</span><br><span class="line">dependencies：配置项目所需要的依赖包，Spring Boot体系内的依赖组件不需要填写具体版本		号，spring-boot-starter-parent维护了体系内所有依赖包的版本信息。</span><br></pre></td></tr></table></figure>
<p>另外，<dependency>标签是Maven项目定义依赖库的重要标签，通过groupId、artifactId等“坐标”信息定义依赖库的路径信息。</p>
<h4 id="3-构建时需要的公共变量"><a href="#3-构建时需要的公共变量" class="headerlink" title="3. 构建时需要的公共变量"></a>3. 构建时需要的公共变量</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置了项目构建时所使用的编码、输出所使用的编码，最后指定了项目使用的JDK版本。</p>
<h4 id="4-构建配置"><a href="#4-构建配置" class="headerlink" title="4. 构建配置"></a>4. 构建配置</h4><p>此部分为构建配置信息，这里使用Maven构建Spring Boot项目，所以必须在<plugins>中添加spring-boot-maven-plugin插件，它能够以Maven的方式为应用提供Spring Boot的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置spring-boot-maven-plugin构建插件，将Spring Boot应用打包为可执行的JAR或WAR文件，然后以简单的方式运行Spring Boot应用。如果需要更改为Docker构建方式，则只要更改此部分即可。</p>
<h3 id="2-1-4-第一个helloworld程序"><a href="#2-1-4-第一个helloworld程序" class="headerlink" title="2.1.4　第一个helloworld程序"></a>2.1.4　第一个helloworld程序</h3><p>步骤01 在目录src\main\java\com\weiz\helloworld\controller下创建HelloController，然后添加/hello的路由地址和方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Hello @ Spring Boot!!! &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了HelloController并创建了一个hello()方法，最后使用@RestController和@RequestMapping注解实现HTTP路由。</p>
<p>1）@RestController表示HelloController为数据处理控制器。Spring Boot中有Controller和RestController两种控制器，都用来表示Spring中某个类是否可以接收HTTP请求，但不同的是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Controller：返回数据和页面，处理HTTP请求。</span><br><span class="line">@RestController：返回客户端数据请求，主要用于RESTful接口。</span><br></pre></td></tr></table></figure>
<p>可以说@RestController是@Controller与@ResponseBody的结合体，因而具有两个标注合并起来的作用。</p>
<p>2）@RequestMapping(“/hello”)提供路由映射，意思是”/hello”路径的HTTP请求都会被映射到hello()方法上进行处理。</p>
<p>步骤02 运行helloworld程序。</p>
<p>​    右击项目中的HelloApplication→run命令就可以启动项目，若出现如图2-4所示的内容则表    示启动成功。</p>
<p>​    通过系统的启动日志可以看到，系统运行在8080端口。如果需要切换到其他端口，可在        application.properties配置文件中自行定义。</p>
<p>步骤03 打开浏览器，访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。">http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091710024.png" alt="image-20231009171027923"></p>
<h2 id="2-2-单元测试"><a href="#2-2-单元测试" class="headerlink" title="2.2　单元测试"></a>2.2　单元测试</h2><p>单元测试在日常项目开发中必不可少，Spring Boot提供了完善的单元测试框架和工具用于测试开发的应用。接下来介绍Spring Boot为单元测试提供了哪些支持，以及如何在Spring Boot项目中进行单元测试。</p>
<h3 id="2-2-1-Spring-Boot集成单元测试"><a href="#2-2-1-Spring-Boot集成单元测试" class="headerlink" title="2.2.1　Spring Boot集成单元测试"></a>2.2.1　Spring Boot集成单元测试</h3><p>单元测试主要用于测试单个代码组件，以确保代码按预期方式工作。目前流行的有JUnit或TestNG等测试框架。Spring Boot封装了单元测试组件spring-boot-starter-test。下面通过示例演示Spring Boot是如何实现单元测试的。</p>
<h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><p>首先创建Spring Boot项目。在项目中引入spring-boot-starter-test组件，示例配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建单元测试"><a href="#2-创建单元测试" class="headerlink" title="2. 创建单元测试"></a>2. 创建单元测试</h4><p>在src/test目录下新建一个HelloTest测试类，如果只想输出一句“Hello Spring Boot Test”，只需要用一个@Test注解即可。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Spring Boot Test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的上面添加@SpringBootTest注解，系统会自动把这段程序加载到Spring Boot容器。@Test注解表示该方法为单元测试方法。</p>
<h4 id="3-运行单元测试"><a href="#3-运行单元测试" class="headerlink" title="3. 运行单元测试"></a>3. 运行单元测试</h4><p>单击Run Test或在方法上右击，再选择“Run ‘hello’”，运行测试方法，运行结果如图2-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091731926.png" alt="image-20231009173126887"></p>
<p>由图2-6可知，单元测试方法运行成功并输出相应的结果，同时IDEA也会显示运行的所有单元测试结果，包括测试是否通过、运行时间、测试总数和成功次数等。以上示例中的测试方法只是spring-boot-starter-test组件中的一部分功能，Spring Boot自带的spring-boot-starter-test框架对测试的支持非常完善，包括Web请求测试、Service方法测试等，后面会逐一介绍。</p>
<h3 id="2-2-2-测试Service方法"><a href="#2-2-2-测试Service方法" class="headerlink" title="2.2.2　测试Service方法"></a>2.2.2　测试Service方法</h3><p>一般使用Spring Boot进行单元测试主要是针对Service和API（Controller）进行。接下来通过示例演示Spring Boot如何测试Service方法。</p>
<h4 id="1-创建Service测试类"><a href="#1-创建Service测试类" class="headerlink" title="1. 创建Service测试类"></a>1. 创建Service测试类</h4><p>创建Service测试类非常简单，使用IDEA可以一键自动创建单元测试类。首先，选择需要测试的Service类或方法，然后在对应的Service类中右击，选择Go To→Test→Create New Test，打开如图2-7所示的创建测试类界面。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091732413.png" alt="image-20231009173236378"></p>
<p>单击OK按钮，IDEA会在Test目录下创建一个UserServiceTest测试类，并为勾选的测试类自动生成单元测试的方法。</p>
<h4 id="2-实现单元测试"><a href="#2-实现单元测试" class="headerlink" title="2. 实现单元测试"></a>2. 实现单元测试</h4><p>在上面创建好的UserServiceTest类中会自动创建对应的单元测试方法，我们只需要在测试方法中实现对应的测试代码即可，具体的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;1002&quot;</span>, userService.findOne());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如以上示例代码所示，在自动测试类上增加@SpringBootTest注解即可。首先注入需要测试的Service，然后在单元测试中调用该方法，最后通过Assert断句判断返回结果是否正确。</p>
<p>执行单元测试也非常简单，只需将鼠标放在对应的方法上，右击并选择Run执行该方法即可。</p>
<h3 id="2-2-3-测试Controller接口方法"><a href="#2-2-3-测试Controller接口方法" class="headerlink" title="2.2.3　测试Controller接口方法"></a>2.2.3　测试Controller接口方法</h3><p>上面是针对Service进行测试，但是有时需要对API（Controller）进行测试，这时需要用到MockMvc类。MockMvc能够模拟HTTP请求，使用网络的形式请求Controller中的方法，这样可以使得测试速度快、不依赖网络环境，而且它提供了一套完善的结果验证工具，测试和验证也非常简单、高效。</p>
<p>spring-boot-starter-test具备强大的Mock能力，使用@WebMvcTest等注解实现模拟HTTP请求测试。下面通过示例演示如何测试Controller接口。</p>
<p>步骤01 创建Controller的测试类HelloControllerTest，实现单元测试方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HelloController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/hello&quot;</span>)   <span class="comment">//执行一个请求</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))       <span class="comment">//接收的数据类型</span></span><br><span class="line">                .andExpect(status().isOk())  <span class="comment">//添加执行完成后的断句，请求的状态响应码//是否为200，如果不是则测试不通过</span></span><br><span class="line">                .andDo(print()); <span class="comment">//添加一个结果处理程序，表示要对结果进行处理，比如此处//使用print()输出整个响应结果信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过使用MockMvc构造一个post请求，MockMvcRequestBuilders可以支持post和get请求，调用print()方法将请求和相应的过程都打印出来。示例代码说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MockMvcRequestBuilders.post(&quot;/hello&quot;)：构造一个post请求。</span><br><span class="line">contentType (MediaType.APPLICATION<span class="emphasis">_JSON))：设置JSON返回编码，避免出现中文乱码的问题。</span></span><br><span class="line"><span class="emphasis">andExpect(status().isOk())：执行完成后的断句，请求的状态响应码是否为200，如果不是则测试不通过。</span></span><br><span class="line"><span class="emphasis">andDo(print())：添加一个结果处理程序，表示要对结果进行处理，比如此处调用print()输出整个响应结果信息。</span></span><br></pre></td></tr></table></figure>
<p>步骤02 执行单元测试。</p>
<p>完成测试方法之后，执行测试方法：将鼠标放在对应的方法上，右击并选择Run执行该方法即可。可以看到输出如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line"><span class="code">      HTTP Method = POST</span></span><br><span class="line"><span class="code">      Request URI = /hello</span></span><br><span class="line"><span class="code">       Parameters = &#123;&#125;</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;application/json;charset=UTF-8&quot;]</span></span><br><span class="line"><span class="code">             Body = null</span></span><br><span class="line"><span class="code">    Session Attrs = &#123;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Handler:</span><br><span class="line"><span class="code">             Type = com.weiz.helloworld.web.HelloController</span></span><br><span class="line"><span class="code">           Method = com.weiz.helloworld.web.HelloController#hello()</span></span><br><span class="line"><span class="code">Async:</span></span><br><span class="line"><span class="code">    Async started = false</span></span><br><span class="line"><span class="code">     Async result = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Resolved Exception:</span><br><span class="line"><span class="code">             Type = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">ModelAndView:</span><br><span class="line"><span class="code">        View name = null</span></span><br><span class="line"><span class="code">             View = null</span></span><br><span class="line"><span class="code">            Model = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">FlashMap:</span><br><span class="line"><span class="code">       Attributes = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line"><span class="code">           Status = 200</span></span><br><span class="line"><span class="code">    Error message = null</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;text/plain;charset=UTF-8&quot;, Content-Length:&quot;17&quot;]</span></span><br><span class="line"><span class="code">     Content type = text/plain;charset=UTF-8</span></span><br><span class="line"><span class="code">             Body = hello Spring Boot</span></span><br><span class="line"><span class="code">    Forwarded URL = null</span></span><br><span class="line"><span class="code">   Redirected URL = null</span></span><br><span class="line"><span class="code">          Cookies = []</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出中可以看到，返回完整的Http Response，包括Status=200、Body = hello Spring Boot，说明接口请求成功并成功返回。</p>
<p>如果接口有登录验证，则需要通过MockHttpSession注入用户登录信息，或者修改登录拦截器取消对单元测试的登录验证。</p>
<h3 id="2-2-4-常用的单元测试注解"><a href="#2-2-4-常用的单元测试注解" class="headerlink" title="2.2.4　常用的单元测试注解"></a>2.2.4　常用的单元测试注解</h3><p>在实际项目中，除了@SpringBootTest、@Test等注解之外，单元测试还有很多非常实用的注解，具体说明如表2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091815842.png" alt="image-20231009181555796"></p>
<h2 id="2-3-开发环境热部署"><a href="#2-3-开发环境热部署" class="headerlink" title="2.3　开发环境热部署"></a>2.3　开发环境热部署</h2><p>本节介绍Spring Boot非常实用的功能：开发环境热部署。在实际的项目开发调试过程中会频繁地修改后台类文件，导致需要重新编译、重新启动，整个过程非常麻烦，影响开发效率。下面介绍Spring Boot如何解决这个问题。</p>
<h3 id="2-3-1-devtools实现原理"><a href="#2-3-1-devtools实现原理" class="headerlink" title="2.3.1　devtools实现原理"></a>2.3.1　devtools实现原理</h3><p>我们在开发调试Spring Boot项目时，需要经历重新编译、重新启动程序的过程。由于系统启动时，需要加载一系列的组件和依赖包，因此整个过程非常耗时，大大影响开发效率。</p>
<p>Spring Boot在这方面做了很好的支持，提供了spring-boot-devtools组件，使得无须手动重启Spring Boot应用即可重新编译、启动项目，大大缩短编译、启动的时间，从而提高开发效率。</p>
<p>spring-boot-devtools的核心是两个类加载器（ClassLoader）：一个是Base类加载器（Base ClassLoader），负责加载那些不会改变的类，如第三方JAR包等；另一个是Restart类加载器（Restart ClassLoader），负责加载那些正在开发的会改变的类。这样如果只修改Java代码，devtools只会重新加载被修改的类文件，不会重新加载其他第三方的JAR包，所以重启较快，从而达到热部署的效果。</p>
<p>我们在项目中引入devtools组件之后，devtools会监听classpath下的文件变动，当文件被修改时会重新编译，重新生成类文件；devtools监听到类文件变动，触发Restart类加载器重新加载该类，从而实现类文件和属性文件的热部署。</p>
<p>需要注意的是，并不是所有的更改都需要重启应用（如静态资源、视图模板）。我们可以通过设置spring.devtools.restart.exclude属性来指定一些文件或目录的修改不用重启应用。例如，可以设置/static和/public下的所有文件更新都不触发应用重启。</p>
<h3 id="2-3-2-配置开发环境热部署"><a href="#2-3-2-配置开发环境热部署" class="headerlink" title="2.3.2　配置开发环境热部署"></a>2.3.2　配置开发环境热部署</h3><p>步骤01 在pom.xml配置文件中添加dev-tools依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    &lt;!— optional依赖是否传递，设置为true时，表示依赖不会传递 --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用optional=true表示依赖不会传递，即该项目依赖devtools；其他项目如果引入此项目生成的JAR包，则不会包含devtools，如果想要使用devtools，则需要重新引入。</p>
<p>步骤02 在application.properties中配置devtools。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 热部署生效</span><br><span class="line">spring.devtools.restart.enabled=true</span><br><span class="line"># 设置重启的目录</span><br><span class="line">spring.devtools.restart.additional-paths=src/main/java</span><br><span class="line"># classpath目录下的WEB-INF文件夹内容修改不重启</span><br><span class="line">spring.devtools.restart.exclude=WEB-INF/**</span><br></pre></td></tr></table></figure>
<p>上面的配置主要是打开devtools热部署，然后指定监控的后台文件目录，最后指明文件变更不需要重新编译部署的目录。配置完成之后，devtools会监听classpath下的文件变动，并且会立即重启应用。</p>
<p>需要注意的是，devtools也可以实现前台页面热部署，即页面修改后会立即生效，需要在application.properties文件中配置spring.thymeleaf.cache=false，以指定不缓存前端页面。</p>
<p>步骤03 验证配置是否生效。</p>
<p>配置完成后，需要验证热部署是否生效。首先启动项目，修改项目中的某个java文件，然后在IDEA后台可以看到devtools自动重启应用，后台日志输出如图2-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091834482.png" alt="image-20231009183402406"></p>
<p>我们手动修改java后台代码就会发现Spring Boot已经重新编译该文件，然后自动重新加载，无须手动重启。</p>
<h1 id="第3章-Spring-Boot的系统配置"><a href="#第3章-Spring-Boot的系统配置" class="headerlink" title="第3章　Spring Boot的系统配置"></a>第3章　Spring Boot的系统配置</h1><p>我们知道Spring Boot遵循“约定优于配置”的原则，绝大部分配置项都约定了默认值，Spring Boot甚至可以做到无须任何手动配置就能启动成功，这大大降低了系统配置的复杂程度。当然，Spring Boot也支持自定义修改系统配置，比如系统端口、启动图案、数据库连接等配置。下面介绍Spring Boot在实际项目中使用到的系统配置、如何自定义配置。</p>
<h2 id="3-1-系统配置文件"><a href="#3-1-系统配置文件" class="headerlink" title="3.1　系统配置文件"></a>3.1　系统配置文件</h2><p>本节讲述Spring Boot的系统配置文件，包括application.properties和application.yml配置文件的使用以及YML和Properties配置文件有什么区别，最后介绍如何更改Spring Boot的启动图案。</p>
<h3 id="3-1-1-application-properties"><a href="#3-1-1-application-properties" class="headerlink" title="3.1.1　application.properties"></a>3.1.1　application.properties</h3><p>Spring Boot支持两种不同格式的配置文件：一种是Properties，另一种是YML。Spring Boot默认使用application.properties作为系统配置文件，项目创建成功后会默认在resources目录下生成application.properties文件。该文件包含Spring Boot项目的<strong>全局配置</strong>。我们可以在application.properties文件中配置Spring Boot支持的所有配置项，比如端口号、数据库连接、日志、启动图案等。接下来将介绍在Spring Boot项目开发过程中与配置相关的一些知识。</p>
<h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>Spring Boot项目创建成功后会默认resources目录下会自动创建application.properties文件。使用也非常简单，配置格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<p>在上面的示例中配置了应用的启动端口。如果不配置此项，则默认使用8080端口；如果需要使用其他端口，则通过server.port=8081修改系统启动端口。</p>
<p>此外，Properties文件中的配置项可以是无序的，但是为了保证配置文件清晰易读，建议把相关的配置项放在一起，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># thymeleaf 模板</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">spring.thymeleaf.mode=HTML</span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br></pre></td></tr></table></figure>
<p>以上示例将thymeleaf模板相关的配置放在一起，这样看起来清晰明了，从而便于快速找到thymeleaf的所有配置。</p>
<h4 id="2-配置文件加载顺序"><a href="#2-配置文件加载顺序" class="headerlink" title="2. 配置文件加载顺序"></a>2. 配置文件加载顺序</h4><p>Spring Boot项目的配置文件默认存放在resources目录中。实际上，Spring Boot系统启动时会读取4个不同路径下的配置文件：</p>
<p>1）项目根目录下的config目录。</p>
<p>2）项目根目录。</p>
<p>3）classpath下的config目录。</p>
<p>4）classpath目录。</p>
<p>Spring Boot会从这4个位置全部加载主配置文件，这4个位置中的application.properties文件的优先级按照上面列出的顺序依次降低。如果同一个属性都出现在这4个文件中，则以优先级高的文件为准。</p>
<h4 id="3-修改默认配置文件名"><a href="#3-修改默认配置文件名" class="headerlink" title="3. 修改默认配置文件名"></a>3. 修改默认配置文件名</h4><p>可能有人会问，项目的配置文件必须命名为application.properties吗？当然不是，我们可以通过修改项目启动类，调用SpringApplicationBuilder类的properties()方法来实现自定义配置文件名称。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(ApplicationDemo.class)</span><br><span class="line">           .properties(<span class="string">&quot;spring.config.location=classpath:/ application.propertie&quot;</span>).run(args);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot项目启动加载时默认读取更改名称的配置文件，即可修改默认加载的application.yml文件名。</p>
<h3 id="3-1-2-application-yml"><a href="#3-1-2-application-yml" class="headerlink" title="3.1.2　application.yml"></a>3.1.2　application.yml</h3><p>application.yml是以yml为后缀，使用YAML（YAML Ain’t a Markup Language）的配置文件。与XML等标记语言相比，YMAL结构更清晰易读，更适合用作属性配置文件。</p>
<h4 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>YML基本语法为key:（空格）value的键值对形式，冒号后面必须加上空格。通过空格的缩进来控制属性的层级关系，只要是左对齐的一列数据，都是同一个层级的。具体格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">max-history:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">10MB</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，自定义配置了系统的日志级别、文件路径等属性。可以看到logging下包含level和file两个子配置项。</p>
<p>YML文件虽然格式简洁直观，但是对格式要求较高，使用YML配置文件时需要注意以下几点：</p>
<p>1）属性值和冒号中间必须有空格，如name: Weiz正确，使用name:Weiz就会报错。</p>
<p>2）需要注意各属性之间的缩进和对齐。</p>
<p>3）缩进不允许使用tab，只允许空格。</p>
<p>4）属性和值区分字母大小写。</p>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h4><p>YML文件以数据为中心，支持数组、JSON对象、Map等多种数据格式，因此更适合用作配置文件。</p>
<p>（1）普通的值（数字、字符串、布尔值）</p>
<p>普通的数据通过k:v的键值对形式直接编写，普通的值类型或字符串默认不用加上单引号或者双引号。</p>
<p>当然，也可以使用双引号（””）来转义字符串中的特殊字符，特殊字符转义后就表示它自身的意思，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;zhangsan \n lisi&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br></pre></td></tr></table></figure>
<p>使用单引号（’’）不会转义特殊字符，所有字符都按照普通字符处理，作为字符串数据，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&#x27;zhangsan \n lisi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：zhangsan \n lisi。“\n”字符作为普通的字符串，而不转义为换行。</p>
<p>（2）对象、Map（属性和值）</p>
<p>对象同样是以k:v的键值对方式展现的，只是对象的各个属性和值的关系通过换行和缩进方式来编写。示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>如果使用行内写法，可以将对象的属性和值写成JSON格式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（3）数组（List、Set）</p>
<p>数组是以- value的形式表示数组中的元素的，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">wangwu</span></span><br></pre></td></tr></table></figure>
<p>还可以采用行内写法，数组使用中括号的形式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span> [<span class="string">zhangsan</span>, <span class="string">lisi</span>, <span class="string">wangwu</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以看到，YML文件除了支持基本的数据类型之外，还支持对象、Map、JSON、数组等格式，这样可以在配置文件中直接定义想要的数据类型，无须额外转换。这也是程序员喜欢用application.yml的原因之一。</p>
<h3 id="3-1-3-Properties与YML配置文件的区别"><a href="#3-1-3-Properties与YML配置文件的区别" class="headerlink" title="3.1.3　Properties与YML配置文件的区别"></a>3.1.3　Properties与YML配置文件的区别</h3><p>Spring Boot中的配置文件有Properties或者YML两种格式。一般情况下，两者可以随意使用，我们可以根据自己的使用习惯选择适合的配置文件格式。这两者完全一样吗？肯定不是，YML和Properties配置文件的区别如下：</p>
<p>1）YML文件以数据为中心，对于数据的支持和展现非常友好。</p>
<p>2）Properties文件对格式的要求没那么严格，而YML文件以空格的缩进来控制层级关系，对格式的要求比较高，缩进格式不对时容易出错。</p>
<p>3）Properties文件支持@PropertySource注解，而YML文件不支持。</p>
<p>4）YML文件支持多文档块的使用方式，使用起来非常灵活。</p>
<p>5）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<h3 id="3-1-4-实战：自定义系统的启动图案"><a href="#3-1-4-实战：自定义系统的启动图案" class="headerlink" title="3.1.4　实战：自定义系统的启动图案"></a>3.1.4　实战：自定义系统的启动图案</h3><p>我们知道Spring Boot程序启动时，控制台会输出由一串字符组成的Spring符号的启动图案（Banner）以及版本信息（见图3-1）。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091848972.png" alt="image-20231009184827930"></p>
<p>Spring Boot自带的启动图案是否可以自定义呢？答案是肯定的。下面通过示例来演示如何自定义Spring Boot的启动图案。</p>
<p>步骤01 在项目的resources目录下新建banner.txt，示例代码如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">##     ## ###### ##       ##        #######</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">######## ######  ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ###### ####### #######  #######</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">Application Name: $&#123;application.title&#125;</span><br><span class="line">Application Version: $&#123;application.formatted-version&#125;</span><br><span class="line">Spring Boot Version: $&#123;spring-boot.formatted-version&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，通过${}获取application.properties配置文件中的相关配置信息，如Spring Boot版本、应用的版本、应用名称等信息。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;：设置控制台中输出内容的颜色，可以自定义，具体参考  			org.springframework.boot.ansi.AnsiColor。</span><br><span class="line">$&#123;application.version&#125;：用来获取MANIFEST.MF文件中的版本号，这就是在		  		Application.java中指定SpringVersion.class的原因。</span><br><span class="line">$&#123;application.formatted-version&#125;：格式化后的&#123;application.version&#125;版本信息。$&#123;spring-boot.version&#125;：Spring Boot的版本号。</span><br><span class="line">$&#123;spring-boot.formatted-version&#125;：格式化后的&#123;spring-boot.version&#125;版本信息。</span><br></pre></td></tr></table></figure>
<p>步骤02 在application.properties中配置banner.txt的路径等信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Banner 配置文件的位置</span></span><br><span class="line"><span class="string">spring.banner.location=/banner.txt</span></span><br><span class="line"><span class="comment"># 是否显示横幅图案</span></span><br><span class="line"><span class="comment"># 可选值有3个，一般不需要修改</span></span><br><span class="line"><span class="comment"># console:显示在控制台</span></span><br><span class="line"><span class="comment"># log:显示在文件</span></span><br><span class="line"><span class="comment"># off:不显示</span></span><br><span class="line"><span class="comment"># spring.main.banner-mode=console</span></span><br><span class="line"><span class="string">application.version=1.0.0.0</span></span><br><span class="line"><span class="string">application.formatted-version=v1.0.0.0</span></span><br><span class="line"><span class="string">spring-boot.version=2.1.2.RELEASE</span></span><br><span class="line"><span class="string">spring-boot.formatted-version=v2.1.2.RELEASE</span></span><br><span class="line"><span class="string">application.title=My</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>在上面的配置中，在application中设置banner.txt文件的路径、应用的版本、Spring Boot的版本等信息。</p>
<p>步骤03 启动项目，查看修改之后的启动横幅图案是否生效，如图3-2所示</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091850116.png" alt="image-20231009185040066"></p>
<p>通过系统输出的启动日志可以看到，系统的启动图案已经变成我们自定义的样子，也就是Spring Boot的默认启动图案已经更改成自定义的启动图案。</p>
<p>Spring Boot也支持使用GIF、JPG和PNG格式的图片文件来定义横幅图案。当然，并不会把图片直接输出在控制台上，而是将图片中的像素解析并转换成ASCII编码字符之后再输出到控制台上。</p>
<h2 id="3-2-自定义配置项"><a href="#3-2-自定义配置项" class="headerlink" title="3.2　自定义配置项"></a>3.2　自定义配置项</h2><p>本节将介绍Spring Boot实现自定义配置项（也称为配置属性）。在项目开发的过程中，经常需要自定义系统业务方面的配置文件及配置项，Spring Boot如何实现自定义属性配置呢？其实非常简单，Spring Boot提供了@Value注解、@ConfigurationProperties注解和Environment接口等3种方式自定义配置项。</p>
<h3 id="3-2-1-Value"><a href="#3-2-1-Value" class="headerlink" title="3.2.1　@Value"></a>3.2.1　@Value</h3><p>在实际项目中，经常需要在配置文件中定义一些简单的配置项，Spring Boot提供@Value注解来设置简单的配置项，默认读取application.properties文件中的配置属性。下面通过示例来演示使用@Value注解添加自定义配置项。</p>
<p>首先，在application.properties配置文件中添加自定义配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们添加了firstname和secondname两个自定义配置项。</p>
<p>然后，在使用的位置调用@Value注解来获取配置项的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.firstname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String firstName;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.secondname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String secondName;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过@Value注解获取了配置文件中对应的配置项的值。</p>
<p>需要注意的是：</p>
<p>1）使用@Value注解时，所在类必须被Spring容器管理，也就是使用@Component、@Controller、@Service等注解定义的类。</p>
<p>2）@Value需要传入完整的配置项的Key值。</p>
<p>3）@Value注解默认读取application.properties配置文件，如果需要使用其他的配置文件，可以通过@PropertySource注解指定对应的配置文件。</p>
<h3 id="3-2-2-Environment"><a href="#3-2-2-Environment" class="headerlink" title="3.2.2　Environment"></a>3.2.2　Environment</h3><p>Environment是Spring为运行环境提供的高度抽象的接口，它会自动获取系统加载的全部配置项，包括命令行参数，系统属性，系统环境，随机数，配置文件等。使用时无须其他的额外配置，只要在使用的类中注入Environment即可。下面通过示例演示Environment读取系统自定义的配置项。</p>
<p>首先，在application.properties配置文件中增加如下的配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在application.properties中配置了firstname和secondname两个自定义配置项。Environment读取的是系统中所有的配置。我们既可以在application.properties中设置自定义的配置项，又可以在自定义配置文件中添加配置项。</p>
<p>然后，创建单元测试方法，并注入Environment读取系统配置。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getEnv</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.firstname&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.secondname&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Environment使用的示例代码，非常简单。不过，使用Environment时还需要注意以下两点：</p>
<p>1）使用Environment无须指定配置文件，其获取的是系统加载的全部配置文件中的配置项。</p>
<p>2）需要注意配置文件的编码格式，默认为ISO8859-1。</p>
<h3 id="3-2-3-ConfigurationProperties"><a href="#3-2-3-ConfigurationProperties" class="headerlink" title="3.2.3　@ConfigurationProperties"></a>3.2.3　@ConfigurationProperties</h3><p>在实际项目开发中，需要注入的配置项非常多时，前面所讲的@value和Environment两种方法就会比较烦琐。这时可以使用注解@ConfigurationProperties将配置项和实体Bean关联起来，实现配置项和实体类字段的关联，读取配置文件数据。下面通过示例演示@ConfigurationProperties注解如何读取配置文件。</p>
<h4 id="1-创建自定义配置文件"><a href="#1-创建自定义配置文件" class="headerlink" title="1. 创建自定义配置文件"></a>1. 创建自定义配置文件</h4><p>在resources下创建自定义的website.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.resource.name</span>=<span class="string">weiz</span></span><br><span class="line"><span class="attr">com.weiz.resource.website</span>=<span class="string">www.weiz.com</span></span><br><span class="line"><span class="attr">com.weiz.resource.language</span>=<span class="string">java</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，创建了自定义的website.properties配置文件。增加了name、website、language等三个配置项，这些配置项的名称的前缀都是com.weiz.resource。</p>
<h4 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2. 创建实体类"></a>2. 创建实体类</h4><p>创建WebSiteProperties自定义配置对象类，然后使用@ConfigurationProperties注解将配置文件中的配置项注入到自定义配置对象类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.weiz.resource&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line">    <span class="keyword">private</span> String language;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getWebsite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWebsite</span><span class="params">(String website)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.website = website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getLanguage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> language;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLanguage</span><span class="params">(String language)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.language = language;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，我们使用了@Configuration注解、@ConfigurationProperties和@PropertySource三个注解来定义WebSiteProperties实体类：</p>
<p>1）@Configuration定义此类为配置类，用于构建bean定义并初始化到Spring容器。</p>
<p>2）@ConfigurationProperties(prefix = “com.weiz.resource”)绑定配置项，其中prefix表示所绑定的配置项名的前缀。</p>
<p>3）@PropertySource(value = “classpath:website.properties”)指定读取的配置文件及其路径。@PropertySource不支持引入YML文件。</p>
<p>通过上面的WebSiteProperties类即可读取全部对应的配置项。</p>
<h4 id="3-调用配置项"><a href="#3-调用配置项" class="headerlink" title="3. 调用配置项"></a>3. 调用配置项</h4><p>使用配置实体类中的方式也非常简单，只需将WebSiteProperties注入到需要使用的类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSiteProperties website;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(website.getName());</span><br><span class="line">    System.out.println(website.getWebsite());</span><br><span class="line">    System.out.println(website.getLanguage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-使用配置文件注意事项"><a href="#3-2-4-使用配置文件注意事项" class="headerlink" title="3.2.4　使用配置文件注意事项"></a>3.2.4　使用配置文件注意事项</h3><p>在实际项目中会碰到很多读取配置文件的应用场景，需要注意各种坑，否则会让你很惆怅。所以，我总结了一些使用配置文件时需要注意的事项：</p>
<p>1）使用YML文件时注意空格和格式缩进。</p>
<p>2）Properties文件默认使用的是ISO8859-1编码格式，容易出现乱码问题。如果含有中文，加入spring.http.encoding.charset=UTF-8配置即可。</p>
<p>3）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<p>4）@PropertySource注解默认只会加载Properties文件，YML文件不能使用此注解。</p>
<p>5）简单值推荐使用@Value，复杂对象推荐使用@ConfigurationProperties。</p>
<p>6）只有Spring容器中的组件才能使用容器提供的各类方法，所以，配置读取类需要增加@Component注解才能加入Spring容器中。</p>
<h2 id="3-3-其他配置"><a href="#3-3-其他配置" class="headerlink" title="3.3　其他配置"></a>3.3　其他配置</h2><p>上一节介绍了自定义的配置，根据项目的需要自定义配置属性。Spring Boot支持很多非常实用的参数配置功能。本节介绍Spring Boot配置生成随机数、配置引用等实际项目中的实用配置。</p>
<h3 id="3-3-1-随机数"><a href="#3-3-1-随机数" class="headerlink" title="3.3.1　随机数"></a>3.3.1　随机数</h3><p>在项目开发过程中，可能需要配置生成随机数，比如说随机配置的服务器端口、随机生成登录密钥等等。Spring Boot支持在系统加载时配置随机数，使用${random}可以生成各种不同类型的随机值，从而简化代码生成的麻烦，例如生成int值、long值、string字符串。</p>
<p>Spring Boot提供的RandomValuePropertySource配置类可以很方便地生成随机数，可以生成integer、long、uuids和string类型的数据。下面通过示例来演示如何配置生成随机数。</p>
<p>首先，在application.properties中添加随机数的配置项。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机字符串</span></span><br><span class="line"><span class="attr">cfg.random.value</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="comment"># uuid</span></span><br><span class="line"><span class="attr">cfg.random.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="comment"># 随机int</span></span><br><span class="line"><span class="attr">cfg.random.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="comment"># 随机long</span></span><br><span class="line"><span class="attr">cfg.random.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="comment"># 10以内的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test1</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="comment"># 10-20的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test2</span>=<span class="string">$&#123;random.int[10,20]&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，在application.properties配置文件中增加配置项以使用${radom.xxx}的形式实现生成随机数。</p>
<p>然后，创建配置映射类ConfigRandomValue获取随机数配置项，读取配置项的方式和读取普通配置项的方式一样：通过@Value或者@ConfigurationProperties注解来读取。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigRandomValue</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.number&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.bignumber&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> bigNumber;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.uuid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number2;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，验证随机数配置是否生效。创建单元测试，验证随机数是否生成成功。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigRandomValue randomValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(randomValue.getSecret());</span><br><span class="line">    System.out.println(randomValue.getUuid());</span><br><span class="line">    System.out.println(randomValue.getBigNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber2());</span><br><span class="line">    System.out.println(randomValue.getNumber3());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先注入了自定义的随机数生成配置类，然后调用了相关的配置项来验证随机数规则是否生效。</p>
<h3 id="3-3-2-配置引用"><a href="#3-3-2-配置引用" class="headerlink" title="3.3.2　配置引用"></a>3.3.2　配置引用</h3><p>Spring Boot支持使用占位符获取之前的属性配置，也就是在后一个配置的值中直接引用先前定义过的配置项，直接解析其中的值。这样做的好处是：在多个具有相互关联的配置项中，只需要对其中一处配置项预先设置，其他地方都可以引用，省去了后续多处修改的麻烦。</p>
<p>使用格式为：${name}，name表示先前在配置文件中已经设置过的配置项名。下面通过示例演示如何在配置文件中实现参数引用。</p>
<p>我们修改application.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.name</span>=<span class="string">ZhangSan</span></span><br><span class="line"><span class="attr">my.sex</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name&#125;.</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先设置了my.name=ZhangSan；接着在my.des配置项中使用${my.name}来引用my.name配置项的值。my.des获取到的是：My name is ZhangSan。</p>
<p>${my.name}还可以使用“:”指定默认值，避免没有配置参数导致程序异常，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name:weiz&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过冒号“:”设置配置项的默认值为：weiz，如果配置项为空或者未找到该配置项，系统也不会出错，my.des获取到的是：My name is weiz。</p>
<p>随机数和配置引用非常简单，在项目开发过程中非常实用。</p>
<h2 id="3-4-日志配置"><a href="#3-4-日志配置" class="headerlink" title="3.4　日志配置"></a>3.4　日志配置</h2><p>我们知道日志对于系统监控、故障定位非常重要，比如当生产系统发生问题时，完整清晰的日志记录有助于快速定位问题。接下来介绍Spring Boot对日志的支持。</p>
<h3 id="3-4-1-Spring-Boot日志简介"><a href="#3-4-1-Spring-Boot日志简介" class="headerlink" title="3.4.1　Spring Boot日志简介"></a>3.4.1　Spring Boot日志简介</h3><p>Spring Boot自带spring-boot-starter-logging库实现系统日志功能，spring-boot-starter-logging组件默认使用LogBack日志记录工具。系统运行日志默认输出到控制台，也能输出到文件中。下面通过示例来演示Spring Boot项目配置日志的功能。</p>
<p>修改pom.xml文件，添加spring-boot-starter-logging依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动项目，查看控制台的日志输出情况，如图3-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092018150.png" alt="image-20231009201809999"></p>
<p>在默认情况下，Spring Boot会用LogBack来记录日志，并用INFO级别输出到控制台。运行应用程序，可以看到很多INFO级别的日志。</p>
<h3 id="3-4-2-配置日志格式"><a href="#3-4-2-配置日志格式" class="headerlink" title="3.4.2　配置日志格式"></a>3.4.2　配置日志格式</h3><p>在Spring Boot项目中配置日志功能之后，如何定制自己的日志格式、自定义记录的信息呢？Spring Boot提供了logging.pattern.console和logging.pattern.file配置项来定制日志输出格式，只需在application.properties文件中添加logging.pattern.console的配置项即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</span><br></pre></td></tr></table></figure>
<p>上述配置的示例中，对应符号的含义如下：</p>
<p>%d{HH:mm:ss.SSS}：日志输出时间。</p>
<p>%thread：输出日志的进程名，这在Web应用以及异步任务处理中很有用。</p>
<p>%-5level：日志级别，使用5个字符靠左对齐。</p>
<p>%logger-：日志输出者的名称。</p>
<p>%msg：日志消息。</p>
<p>%n：平台的换行符。</p>
<p>修改完配置项再重启项目，查看控制台的日志输出情况，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092035331.png" alt="image-20231009203539284"></p>
<p>Spring Boot控制台启动日志的格式已经改成配置的格式。</p>
<h3 id="3-4-3-日志输出级别"><a href="#3-4-3-日志输出级别" class="headerlink" title="3.4.3　日志输出级别"></a>3.4.3　日志输出级别</h3><p>一般而言，系统的日志级别为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt;FATAL，级别逐渐提高。如果日志级别设置为INFO，则意味着TRACE和DEBUG级别的日志都不会输出。</p>
<p>Spring Boot通过logging.level配置项来设置日志输出级别，下面通过示例演示Spring Boot日志输出级别。</p>
<p>首先，添加Log级别测试类LogDemo，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">logMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从trace到error日志级别由低到高</span></span><br><span class="line">        <span class="comment">// 可以调整输出的日志级别，日志就只会在这个级别后的高级别生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;LogDemo trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;LogDemo debug日志...&quot;</span>);</span><br><span class="line">        <span class="comment">// Spring Boot默认使用的是info级别，没有指定级别就用Spring Boot默认规定的级别，即root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;LogDemo info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;LogDemo warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;LogDemoerror日志...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello log&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，针对每个日志级别输出了一行日志。我们可以调整输出的日志级别，让其只在该级别以后的高级别生效。</p>
<p>然后，配置日志输出级别，在application.properties中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=warn</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用logging.level.root指定整个项目的日志级别为WARN。当然，我们也可以对某个包指定单独的日志级别，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=INFO</span><br><span class="line">logging.level.com.weiz.example01.log=WARN</span><br></pre></td></tr></table></figure>
<p>在上面的配置示例，我们将整个项目的日志级别设置为INFO，同时将指定包com.weiz.example01下的日志级别设置为WARN。</p>
<p>最后，启动项目验证日志的输出情况，如图3-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092037071.png" alt="image-20231009203750022"></p>
<p>如图3-5所示，Spring Boot控制台输出的系统启动日志为INFO级别，而com.weiz.example01.log下LogDemo的日志级别设置为WARN，输出了WARN、INFO和ERROR的日志。</p>
<h3 id="3-4-4-保存日志文件"><a href="#3-4-4-保存日志文件" class="headerlink" title="3.4.4　保存日志文件"></a>3.4.4　保存日志文件</h3><p>一般情况下，在开发环境中习惯通过控制台查看日志，但是生产环境中需要将日志信息保存到磁盘上，以便于日后的日志查询。应该如何配置才能将日志信息保存到日志文件内呢？下面演示保存日志文件的过程。</p>
<p>在resources目录下的application.properties配置文件中添加如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.file.name=D:/var/log/spring_log.log</span><br></pre></td></tr></table></figure>
<p>重新启动项目，可以看到在D:/var/log目录下生成了spring_log.log文件，该文件的内容和控制台打印输出的内容一致，如图3-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092043631.png" alt="image-20231009204300583"></p>
<h2 id="3-5-实战：实现系统多环境配置"><a href="#3-5-实战：实现系统多环境配置" class="headerlink" title="3.5　实战：实现系统多环境配置"></a>3.5　实战：实现系统多环境配置</h2><p>在实际项目开发的过程中，需要面对不同的运行环境，比如开发环境、测试环境、生产环境等，每个运行环境的数据库、Redis服务器等配置都不相同，每次发布测试、更新生产都需要手动修改相关系统配置。这种方式特别麻烦，费时费力，而且出错的概率极大。庆幸的是，Spring Boot为我们提供了更加简单方便的配置方案来解决多环境的配置问题，下面就来演示Spring Boot系统如何实现多环境配置。</p>
<h3 id="3-5-1-多环境的配置"><a href="#3-5-1-多环境的配置" class="headerlink" title="3.5.1　多环境的配置"></a>3.5.1　多环境的配置</h3><p>通常应用系统可能在开发环境（dev）、测试环境（test）、生产环境（prod）中运行，那么如何做到多个运行环境配置灵活、快速切换呢？Spring Boot提供了极简的解决方案，只需要简单的配置，应用系统就能灵活切换运行环境配置。</p>
<h4 id="1-创建多环境配置文件"><a href="#1-创建多环境配置文件" class="headerlink" title="1. 创建多环境配置文件"></a>1. 创建多环境配置文件</h4><p>创建多环境配置文件时，需要遵循Spring Boot允许的命名约定来命名，格式为application-{profile}.properties，其中{profile}为对应的环境标识。在项目resources目录下分别创建application-dev.properties、application-test.properties和application-prod.properties三个配置文件，对应开发环境、测试环境和生产环境，如图3-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092045861.png" alt="image-20231009204506816"></p>
<p>如图3-7所示，根据应用系统中常见的三个运行环境拆分成了多个不同的配置文件，分别独立配置上面各运行环境的配置项。具体如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties为项目主配置文件，包含项目所需的所有公共配置。</span><br><span class="line">application-dev.properties为开发环境配置文件，包含项目所需的单独配置。</span><br><span class="line">application-test.properties为测试环境配置文件。</span><br><span class="line">application-prod.properties为生产环境配置文件。</span><br></pre></td></tr></table></figure>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>通常情况下，开发环境、测试环境和生产环境使用的数据库是不一样的，所以接下来以不同环境配置不同数据库为例来演示多环境的配置。</p>
<p>首先，修改application.properties，配置系统的启动端口：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8088</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，application.properties包含项目所需的所有公共配置，这里配置系统的启动端口，所有环境的启动端口都是8088。</p>
<p>然后，修改application-dev.properties开发环境的配置，增加数据库的连接配置，代码示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 指定数据库驱动</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"># 数据库jdbc连接url地址</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/myapp_dev</span><br><span class="line"># 数据库账号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></table></figure>
<p>配置数据库连接的相关属性，我们看到开发环境配置的数据库是myapp_dev。</p>
<p>其他环境的配置文件修改对应的配置连接即可，以上项目的多环境配置就完成了。接下来演示切换项目运行环境。</p>
<h3 id="3-5-2-多环境的切换"><a href="#3-5-2-多环境的切换" class="headerlink" title="3.5.2　多环境的切换"></a>3.5.2　多环境的切换</h3><p>前面讲了如何配置多环境，那么，在实际测试、运行过程中如何切换系统运行环境呢？这个也非常简单，通过修改application.properties配置文件中的spring.profiles.active配置项来激活相应的运行环境。如果没有指定任何profile的配置文件，Spring Boot默认会启动application-default.properties（默认环境）。</p>
<p>指定项目的启动环境有以下3种方式：</p>
<p>（1）配置文件指定项目启动环境</p>
<p>Spring Boot支持通过spring.profiles.active配置项目启动环境，在application.properties配置文件中增加如下配置项指定对应的环境目录：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 系统运行环境</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过在application.properties配置文件中设置spring.profiles.active的配置项来配置系统的运行环境。这里配置的是dev开发环境。</p>
<p>（2）IDEA编译器指定项目启动环境</p>
<p>一般在IDEA启动时，直接在IDEA的Run/debug Configuration页面配置项目启动环境，如图3-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092048033.png" alt="image-20231009204827985"></p>
<p>如图3-8所示，项目调试运行时，IDEA编译器可以通过VM options、Program arguments、Active profiles三个参数设置启动方式。</p>
<p>（3）命令行启动指定项目环境</p>
<p>在命令行通过java -jar命令启动项目时，需要如下指定启动环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.<span class="property">jar</span> --spring.<span class="property">profiles</span>.<span class="property">active</span>=dev</span><br></pre></td></tr></table></figure>
<p>如上所示，程序打包之后，可以在命令行使用java -jar的方式启动，并设置启动参数spring.profiles.active=dev，以开发环境为默认配置。在application-{profile}.properties中配置完成后，启动项目时，在系统启动日志中可以看到加载的是哪个环境的配置文件，如图3-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092051552.png" alt="image-20231009205139509"></p>
<p>在上面的启动日志中可以看到系统目前启动的是dev开发环境。如果实现相关的数据库测试方法，可以验证相应的数据库操作是否生效。</p>
<h1 id="第4章-Web开发"><a href="#第4章-Web开发" class="headerlink" title="第4章　Web开发"></a>第4章　Web开发</h1><p>本章主要讲解Spring Boot开发Web应用的相关技术点，包括使用spring-boot-starter-web组件来实现Web应用开发、URL地址映射、参数传递、数据校验规则等，然后介绍统一数据返回和统一异常处理，最后介绍如何根据项目需求配置Web项目，包括拦截器、跨域访问、视图解析、数据格式化等。</p>
<h2 id="4-1-Web开发简介"><a href="#4-1-Web开发简介" class="headerlink" title="4.1　Web开发简介"></a>4.1　Web开发简介</h2><p>本节主要介绍Spring Boot对Web应用开发提供了哪些支持，首先介绍Spring Boot 提供的Web组件spring-boot-starter-web，然后介绍@Controller和@RestController注解，以及控制数据返回的@ResponseBody注解，最后介绍Web配置，以便让读者对使用Spring Boot开发Web系统有初步的了解。</p>
<h3 id="4-1-1-Web入门"><a href="#4-1-1-Web入门" class="headerlink" title="4.1.1　Web入门"></a>4.1.1　Web入门</h3><p>当前，Spring毫无疑问已经成为Java企业应用开发的标准框架之一，它提供了众多的可配置功能模块和第三方组件，几乎可以解决企业开发中的所有问题。不过，Spring也带来了复杂的配置项，这对初学者而言简直就是灾难，于是Spring Boot应运而生。Spring Boot将传统Web开发的mvc、json、validation、tomcat等框架整合，提供了spring-boot-starter-web组件，简化了Web应用配置、开发的难度，将初学者从繁杂的配置项中解放出来，专注于业务逻辑的实现。</p>
<h4 id="1-spring-boot-starter-web介绍"><a href="#1-spring-boot-starter-web介绍" class="headerlink" title="1. spring-boot-starter-web介绍"></a>1. spring-boot-starter-web介绍</h4><p>Spring Boot自带的spring-boot-starter-web组件为Web应用开发提供支持，它内嵌的Tomcat以及Spring MVC的依赖使用起来非常方便。</p>
<p>Spring Boot创建Web应用非常简单，先创建一个普通的Spring Boot项目，然后修改pom.xml文件将spring-boot-starter-web组件加入项目就可以创建Web应用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们使用IDEA编辑器打开新创建的Web项目。打开Maven中的Dependencies，查看spring-boot-starter-web启动器（Starters）会引入哪些依赖JAR包，如图4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092217758.png" alt="image-20231009221716617"></p>
<p>由图4-1可见，spring-boot-starter-web启动器主要包括web、webmvc、json、tomcat等基础依赖组件，作用是提供Web开发场景所需的所有底层依赖。其中webmvc为Web开发的基础框架，json为JSON数据解析组件，tomcat为自带的容器依赖。所以，只需引入spring-boot-starter-web启动器即可实现Web应用开发，而无须额外引入Tomcat以及其他Web依赖文件。</p>
<p>另外，开发Web应用可能还会用到模板引擎，Spring Boot提供了大量的模板引擎，包括FreeMarker、Groovy、Thymeleaf、Velocity和Mustache等。Spring Boot官方推荐使用Thymeleaf。</p>
<h4 id="2-Web项目结构"><a href="#2-Web项目结构" class="headerlink" title="2. Web项目结构"></a>2. Web项目结构</h4><p>Spring Boot的Web应用与其他的Spring Boot应用基本没有区别，只是resources目录中多了static静态资源目录以及templates页面模板目录。Spring Boot Web项目结构如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092219453.png" alt="image-20231009221907411"></p>
<h4 id="3-实现简单的Web请求"><a href="#3-实现简单的Web请求" class="headerlink" title="3. 实现简单的Web请求"></a>3. 实现简单的Web请求</h4><p>Spring Boot不像传统的MVC框架那样必须继承某个基础类才能处理HTTP请求，只需要在类上声明@Controller注解，标注这是一个控制器，然后使用@RequestMapping注解把HTTP请求映射到对应的方法即可。具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，@RequestMapping注解用于定义请求的路由地址，既可以作用在方法上，又可以作用在类上。</p>
<p>启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。">http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。</a></p>
<h3 id="4-1-2-Controller和-RestController"><a href="#4-1-2-Controller和-RestController" class="headerlink" title="4.1.2　@Controller和@RestController"></a>4.1.2　@Controller和@RestController</h3><p>Spring Boot提供了@Controller和@RestController两种注解来标识此类负责接收和处理HTTP请求。如果请求的是页面和数据，使用@Controller注解即可；如果只是请求数据，则可以使用@RestController注解。</p>
<h4 id="1-Controller的用法"><a href="#1-Controller的用法" class="headerlink" title="1. @Controller的用法"></a>1. @Controller的用法</h4><p>Spring Boot提供的@Controller注解主要用于页面和数据的返回。下面创建HelloController响应前台页面请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        map.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thymeleaf-index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;thymeleaf/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例用于请求/user/index地址，返回具体的index页面和name=thymeleaf-index的数据。在前端页面中可以通过${name}参数获取后台返回的数据并显示到页面中。</p>
<p>在@Controller类中，如果只返回数据到前台页面，需要使用@ResponseBody注解，否则会报错。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-RestController的用法"><a href="#2-RestController的用法" class="headerlink" title="2. @RestController的用法"></a>2. @RestController的用法</h4><p>Spring Boot提供的@RestController注解用于实现数据请求的处理。默认情况下，@RestController注解会将返回的对象数据转换为JSON格式。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义/user/getUser接口返回JSON格式的User数据。同时，@RequestMapping注解可以通过method参数指定请求的方式。如果请求方式不对，则会报错。</p>
<p>近几年前端框架越来越强大，前后端分离的RESTful架构成为主流。Spring Boot对RESTful也做了非常完善的支持，使用也特别简单，使用@RestController注解自动返回JSON格式的数据，同时使用@GetMapping、PostMapping等注解实现映射RESTful接口。</p>
<h4 id="3-RestController和-Controller的区别"><a href="#3-RestController和-Controller的区别" class="headerlink" title="3. @RestController和@Controller的区别"></a>3. @RestController和@Controller的区别</h4><p>@Controller和@RestController注解都是标识该类是否可以处理HTTP请求，可以说@RestController是@Controller和@ResponseBody的结合体，是这两个注解合并使用的效果。虽然二者的用法基本类似，但还是有一些区别，具体如下：</p>
<p>1）@Controller标识当前类是Spring MVC Controller处理器，而@RestController则只负责数据返回。</p>
<p>2）如果使用@RestController注解，则Controller中的方法无法返回Web页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return中的数据。</p>
<p>3）如果需要返回指定页面，则使用@Controller注解，并配合视图解析器返回页面和数据。如果需要返回JSON、XML或自定义内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p>
<p>4）使用@Controller注解时，在对应的方法上，视图解析器可以解析返回的JSP、HTML页面，并且跳转到相应页面。若返回JSON等内容到页面，则需要添加@ResponseBody注解。</p>
<p>5）@RestController注解相当于@Controller和@ResponseBody两个注解的结合，能直接将返回的数据转换成JSON数据格式，无须在方法前添加@ResponseBody注解，但是使用@RestController注解时不能返回JSP、HTML页面，因为视图解析器无法解析JSP、HTML页面。</p>
<p>总之，在Web系统中使用@Controller较多，而在Web API中基本使用@RestController注解。</p>
<h3 id="4-1-3-RequestMapping"><a href="#4-1-3-RequestMapping" class="headerlink" title="4.1.3　@RequestMapping"></a>4.1.3　@RequestMapping</h3><p>@RequestMapping注解主要负责URL的路由映射。它可以添加在Controller类或者具体的方法上，如果添加在Controller类上，则这个Controller中的所有路由映射都将会加上此映射规则，如果添加在方法上，则只对当前方法生效。@RequestMapping注解包含很多属性参数来定义HTTP的请求映射规则。常用的属性参数如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value：请求URL的路径，支持URL模板、正则表达式。</span><br><span class="line">method：HTTP请求的方法。</span><br><span class="line">consumes：允许的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Content-Type。produces：相应的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Accept字段。params：请求参数。</span><br><span class="line">headers：请求头的值。</span><br></pre></td></tr></table></figure>
<p>以上属性基本涵盖了一个HTTP请求的所有参数信息。其中，value和method属性比较常用。</p>
<h3 id="4-1-4-ResponseBody"><a href="#4-1-4-ResponseBody" class="headerlink" title="4.1.4　@ResponseBody"></a>4.1.4　@ResponseBody</h3><p>@ResponseBody注解主要用于定义数据的返回格式，作用在方法上，默认使用Jackson序列化成JSON字符串后返回给客户端，如果是字符串，则直接返回。</p>
<p>在Controller中有时需要返回JSON格式的数据，如果想直接返回数据体而不是视图名，则需要在方法上使用@ResponseBody。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，请求/user/getUser时，返回JSON格式的User数据。这与@RestController的作用类似。</p>
<p>需要注意的是，使用@ResponseBody注解时需要注意请求的类型和地址，如果期望返回JSON，但是请求URL以html结尾的页面，就会导致Spring Boot认为请求的是HTML类型的资源，而返回JSON类型的资源，与期望类型不一致，因此报出如下错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There was an unexpected <span class="title function_">error</span> <span class="params">(type=Not Acceptable, status=<span class="number">406</span>)</span>. Could not find acceptable representation</span><br></pre></td></tr></table></figure>
<p>根据RESTful规范的建议，在Spring Boot应用中，如果期望返回JSON类型的资源，URL请求资源后缀就使用json；如果期望返回视图，URL请求资源后缀就使用html。</p>
<h2 id="4-2-URL映射"><a href="#4-2-URL映射" class="headerlink" title="4.2　URL映射"></a>4.2　URL映射</h2><p>上一节介绍了Spring Boot对Web项目开发都做了哪些支持，还介绍了@Controller和@RestController等注解，那么Spring Boot是如何将HTTP请求映射到具体方法的呢？Spring Boot支持<strong>URL路径匹配、HTTP Method匹配、params和header匹配</strong>等URL映射。本节开始介绍Spring Boot的URL映射。</p>
<h3 id="4-2-1-URL路径匹配"><a href="#4-2-1-URL路径匹配" class="headerlink" title="4.2.1　URL路径匹配"></a>4.2.1　URL路径匹配</h3><h4 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1. 精确匹配"></a>1. 精确匹配</h4><p>@RequestMapping的value属性用于匹配URL映射，value支持简单表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@PathVariable注解作用在方法参数中，用于表示参数的值来自URL路径。如果URL中的参数名称与方法中的参数名称一致，则可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中访问/getDataById/1时，会自动映射到后台的getDataById方法，传入参数id的值为1。</p>
<h4 id="2-通配符匹配"><a href="#2-通配符匹配" class="headerlink" title="2. 通配符匹配"></a>2. 通配符匹配</h4><p>@RequestMapping支持使用通配符匹配URL，用于统一映射某些URL规则类似的请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getJson/*.json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;get json data&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中请求/getJson/a.json或者/getJson/b.json时都会匹配到后台的getJson方法。</p>
<p>@RequestMapping的通配符匹配非常简单实用，支持“<em>”“?”“*</em>”等通配符。使用时需要了解通配符的匹配规则，否则容易出错。通配符匹配规则如下：</p>
<p>1）符号“<em>”匹配任意字符，符号“**”匹配任意路径，符号“?”匹配单个字符。</em></p>
<p>2）有通配符的优先级低于没有通配符的，比如/user/add.json比/user/*.json优先匹配。</p>
<p>3）有“<em>*”通配符的优先级低于有“\</em>”通配符的。</p>
<h3 id="4-2-2-Method匹配"><a href="#4-2-2-Method匹配" class="headerlink" title="4.2.2　Method匹配"></a>4.2.2　Method匹配</h3><p>HTTP请求Method有GET、POST、PUT、DELETE等方式。HTTP支持的全部Method和说明如表4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092235704.png" alt="image-20231009223549957"></p>
<p>对于Web应用，GET和POST是经常使用的选项，而对于RESTful接口，则会使用PUT、DELETE等从语义上进一步区分操作。</p>
<p>@RequestMapping注解提供了method参数指定请求的Method类型，包括RequestMethod.GET、RequestMethod.POST、RequestMethod.DELETE、RequestMethod.PUT等值，分别对应HTTP请求的Method。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod GET&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">PostData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod POST&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例实现了GET和POST两种方式。当使用GET方式请求/data/getData接口时，会返回“RequestMethod GET”，使用POST方式请求/data/getData接口时，则返回“RequestMethod POST”，说明@RequestMapping通过HTTP请求Method映射不同的后台方法。</p>
<h3 id="4-2-3-consumes和produces匹配"><a href="#4-2-3-consumes和produces匹配" class="headerlink" title="4.2.3　consumes和produces匹配"></a>4.2.3　consumes和produces匹配</h3><p>@RequestMapping注解提供了consumes和produces参数用于验证HTTP请求的内容类型和返回类型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumes表示请求的HTTP头的Content-Type媒体类型与consumes的值匹配才可以调用方法。produces表示HTTP请求中的Accept字段只有匹配成功才可以调用。</span><br></pre></td></tr></table></figure>
<p>下面通过示例演示consumes和produces参数的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理request Content-Type为“application/json”类型的请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/Content&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">Consumes</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Consumes POST  Content-Type=application/json&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例只允许Content-Type=application/json的HTTP请求映射此方法，其他类型则返回“Unsupported Media Type”的错误。</p>
<h3 id="4-2-4-params和header匹配"><a href="#4-2-4-params和header匹配" class="headerlink" title="4.2.4　params和header匹配"></a>4.2.4　params和header匹配</h3><p>@RequestMapping注解提供了header参数和params参数，通过header参数可以根据HTTP请求中的消息头内容映射URL请求，通过params参数可以匹配HTTP中的请求参数实现URL映射。</p>
<h4 id="1-params"><a href="#1-params" class="headerlink" title="1. params"></a>1. params</h4><p>Spring Boot除了通过匹配URL和Method的方式实现映射HTTP请求之外，还可以通过匹配params的方式来实现。Spring Boot从请求参数或HTTP头中提取参数，通过判断参数，如params=”action=save”确定是否通过。同时还可以设置请求参数包含某个参数、不包含某个参数或者参数等于某个值时通过，具体如下：</p>
<p>1）params={“username”}，存在“username”参数时通过。</p>
<p>2）params={“!password”}，不存在“password”参数时通过。</p>
<p>3）params={“age=20”}，参数age等于20时通过。</p>
<p>通过@PostMapping设置的params参数来检查请求的params，实现HTTP的URL映射。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;paramsTest&quot;,params=&quot;action=save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paramsTest</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;params test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当请求的参数action=save时，映射此方法。</p>
<h4 id="2-header"><a href="#2-header" class="headerlink" title="2. header"></a>2. header</h4><p>header的使用和params类似，它检查HTTP的header头中是否有Host=localhost:8080的参数，如果有则匹配此方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;headerTest&quot;,headers=&#123;&quot;Host=localhost:8080&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headerTest</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;header test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-参数传递"><a href="#4-3-参数传递" class="headerlink" title="4.3　参数传递"></a>4.3　参数传递</h2><p>本节开始介绍Spring Boot是如何实现参数传递的。参数传递是Web开发的基础内容，前端页面和后端服务通过请求和返回的参数来判断所执行的业务逻辑，因此参数的传递和接收是Web开发中最基础却非常重要的功能。</p>
<p>本节开始介绍Spring Boot是如何实现参数传递的。参数传递是Web开发的基础内容，前端页面和后端服务通过请求和返回的参数来判断所执行的业务逻辑，因此参数的传递和接收是Web开发中最基础却非常重要的功能。</p>
<h3 id="4-3-1-PathVariable"><a href="#4-3-1-PathVariable" class="headerlink" title="4.3.1　@PathVariable"></a>4.3.1　@PathVariable</h3><p>在Web应用中，最常用的参数传递方式就是URL传参，也就是将参数放在请求的URL中。例如微博上不同用户的个人主页应该对应不同的URL：<a target="_blank" rel="noopener" href="http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。">http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。</a></p>
<h4 id="1-定义URL变量"><a href="#1-定义URL变量" class="headerlink" title="1. 定义URL变量"></a>1. 定义URL变量</h4><p>@RequestMapping注解使用{}来声明URL变量，例如@RequestMapping(“/user/{username}”)。其中，{username}是定义的变量规则，username是变量的名字。此URL路由可以匹配下列任意URL请求：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/user/tianmaying</span><br><span class="line">/user/ricky</span><br><span class="line">/user/tmy1234</span><br></pre></td></tr></table></figure>
<p>在@RequestMapping中定义变量规则后，Spring Boot提供的@PathVariable注解帮助我们获取URL中定义的变量参数，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userProfile</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span> + username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot会自动将URL中定义的变量传递给userProfile方法的username参数（同名赋值），例如当HTTP请求为/users/weiz时，URL变量username的值weiz会被赋给函数参数username，返回的数据为user：weiz。</p>
<p>需要注意的是，在默认情况下，<strong>变量参数不能包含URL的分隔符“/”</strong>，也就是说上面定义的URL路由不能匹配/users/weiz/zhang，即使weiz/zhang是一个存在的用户名。</p>
<h4 id="2-定义多个URL变量"><a href="#2-定义多个URL变量" class="headerlink" title="2. 定义多个URL变量"></a>2. 定义多个URL变量</h4><p>上面介绍了传递单个变量的例子，那么多个变量呢？同样，@RequestMapping支持定义包含多个URL变量的路由，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@RequestMapping(“/user/{username}/blog/{blogId}”)传入{username}和{blogId}两个参数，然后使用@PathVariable映射对应的变量参数。</p>
<p>在多变量参数的情况下，Spring Boot能够根据变量名自动赋值对应的函数参数值，也可以在@PathVariable中显式声明具体的URL变量名。</p>
<p>在默认情况下，@PathVariable注解的参数支持自动转换一些基本的数据类型，如int、long、date、string等，Spring Boot能够根据URL变量的具体值以及函数参数的数据类型来进行转换，例如/user/weiz/blog/1会将“weiz”的值赋给username，而1赋给int类型的变量blogId。</p>
<h4 id="3-匹配正则表达式"><a href="#3-匹配正则表达式" class="headerlink" title="3. 匹配正则表达式"></a>3. 匹配正则表达式</h4><p>虽然@RequestMapping路由支持URL变量，但是很多时候需要对URL变量进行更加精确的定义和限制，例如用户名只包含小写字母、数字、下划线：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user/fpc是一个合法的URL</span><br><span class="line">/user/#不是一个合法的URL</span><br></pre></td></tr></table></figure>
<p>这种情况下，简单定义{username}变量就无法满足需求了。没关系，@RequestMapping注解同样支持正则表达式匹配，可以通过定义正则表达式更精确地控制，定义语法是{变量名：正则表达式}，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username:[a-zA-Z0-9_]+&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用[a-zA-Z0-9_]+正则表达式来限定username参数值只能包含小写字母、大写字母、数字、下划线。如此设置URL变量规则后，不合法的URL不会被处理，直接返回404Not Found。</p>
<h3 id="4-3-2-使用Bean对象接收参数"><a href="#4-3-2-使用Bean对象接收参数" class="headerlink" title="4.3.2　使用Bean对象接收参数"></a>4.3.2　使用Bean对象接收参数</h3><p>针对参数较多的<strong>表单提交</strong>，Spring Boot可以通过创建一个JavaBean对象来接收HTTP传入的表单参数。需要注意的是，<strong>JavaBean对象中必须含有默认的构造函数</strong>，同时，需要设置属性字段必须有setter方法。</p>
<h4 id="1-增加Bean实体类"><a href="#1-增加Bean实体类" class="headerlink" title="1. 增加Bean实体类"></a>1. 增加Bean实体类</h4><p>首先，增加表单对应的实体类，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String firstName;</span><br><span class="line">    <span class="keyword">private</span>  String lastName;</span><br><span class="line">    <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例定义了Student数据实体类。</p>
<h4 id="2-增加后台方法"><a href="#2-增加后台方法" class="headerlink" title="2. 增加后台方法"></a>2. 增加后台方法</h4><p>在StudentController控制器中增加save()方法，接收前台传来的数据。定义save()方法的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器中提交表单数据时，Spring Boot会自动把提交的表单数据转为Student对象，然后传递给save()方法。</p>
<h3 id="4-3-3-RequsetBody接收JSON数据"><a href="#4-3-3-RequsetBody接收JSON数据" class="headerlink" title="4.3.3　@RequsetBody接收JSON数据"></a>4.3.3　@RequsetBody接收JSON数据</h3><p>@RequestBody主要是将前端传入的JSON数据对象映射成后端的实体对象。比如，前端传入JSON格式的数据后，@RequestBody注解会自动将JSON数据反序列化成Student对象。使用时需要注意以下两点：</p>
<p>1）前端传递的对象属性和类型必须与后端对应。比如后端定义的user属性为“int id，String name”，前端必须使用相同的数据类型和字段来定义。</p>
<p>2）要使用JSON数据集进行传递，也就是设置为contentType:”application/json”。</p>
<p>下面通过示例代码演示如何使用@RequsetBody接收JSON数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/save2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save2</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping注解包含consumes参数，默认为application/json，表示前台需要传入JSON格式的参数。另外，Spring Boot会根据名称一一对应，将数据转换成相应的数据类型。例如JSON数据中有int或date类型，前台传过来都是字符串，Spring Boot会自动将其转换成实体类中的数据类型。</p>
<h3 id="4-3-4-ModelAttribute"><a href="#4-3-4-ModelAttribute" class="headerlink" title="4.3.4　@ModelAttribute"></a>4.3.4　@ModelAttribute</h3><p>熟悉MVC的读者应该都知道，我们可以将@ModelAttribute注解放置在控制器（Controller）中的某个方法上。当请求这个控制器中的某个URL时，会<strong>首先</strong>调用这个被注解的方法并将该方法的结果作为公共模型的属性，然后调用对应URL的处理方法，前端页面通过模型获取返回的数据。</p>
<p>@ModelAttribute标注的方法会在Controller类的每个映射URL的控制执行方法之前执行。使用方法如下面的示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, userService.findUserById(userId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    System.out.println(model.containsAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当我们请求接口/user/1时，会先调用findUserById()方法，在方法内通过userId查询到对应的User对象放置到Model中。如果仅仅添加一个对象到Model中，上面的代码可以再精练一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findUserById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码返回的User对象会被自动添加到Model中，相当于手动调用了model.addAttribute(user)方法。</p>
<p>Model通过addAttribute()方法向页面传递参数。@ModelAttribute修饰的方法会先于login调用，它把请求的参数值赋给对应的变量。可以向方法中的Model添加对象，前提是在方法中加入一个Model类型的参数。</p>
<p>需要注意的是，被@ModelAttribute注释的方法会在此控制器的每个方法执行前被执行，因此对于一个控制器映射多个URL，要谨慎使用。</p>
<h3 id="4-3-5-ModelAndView对象"><a href="#4-3-5-ModelAndView对象" class="headerlink" title="4.3.5　ModelAndView对象"></a>4.3.5　ModelAndView对象</h3><p>ModelAndView也是Spring MVC中常用的数据返回对象。当控制器处理完请求时，通常会将包含视图对象和数据的ModelAndView对象一起返回前台。它的作用类似于request对象的setAttribute()方法。</p>
<p>ModelAndView对象有两个作用：</p>
<p>1）设置转向地址（这也是ModelAndView和ModelMap的主要区别）。</p>
<p>2）将后台数据传回到前台页面。</p>
<p>ModelAndView使用起来也特别简单，在控制器中把前台页面需要的数据放到ModelAndView对象中，然后返回mv对象。下面通过示例演示使用ModelAndView对象返回数据到前台页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/detail/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>userService.getUserById(id);</span><br><span class="line">   <span class="comment">// 设置user对象的username属性</span></span><br><span class="line">   mv.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">   <span class="comment">// 地址跳转，设置返回的视图名称</span></span><br><span class="line">   mv.setViewName(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，先获取用户数据，然后将数据和对象一起返回到前台detail页面。这样Spring MVC将使用包含的视图对模型数据进行渲染。</p>
<h2 id="4-4-数据验证"><a href="#4-4-数据验证" class="headerlink" title="4.4　数据验证"></a>4.4　数据验证</h2><p>对于应用系统而言，任何客户端传入的数据都不是绝对安全有效的，这就要求我们在服务端接收到数据时也对数据的有效性进行验证，以确保传入的数据安全正确。接下来介绍Spring Boot是如何实现数据验证的。</p>
<h3 id="4-4-1-Hibernate-Validator简介"><a href="#4-4-1-Hibernate-Validator简介" class="headerlink" title="4.4.1　Hibernate Validator简介"></a>4.4.1　Hibernate Validator简介</h3><p>数据校验是Web开发中的重要部分，也是必须要考虑和面对的事情。应用系统必须通过某种手段来确保输入的数据从语义上来讲是正确的。</p>
<p>目前数据校验的规范、组件非常多，有JSR-303/JSR-349、Hibernate Validator、Spring Validation。下面就来捋一捋它们之间的关系。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSR（Java Specification Request）规范是Java EE 6中的一项子规范，也叫作Bean Validation。它指定了一整套基于bean的验证API，通过标注给对象属性添加约束条件。</span><br><span class="line">Hibernate Validator是对JSR规范的实现，并增加了一些其他校验注解，如@Email、 @Length、@Range等。</span><br><span class="line">Spring Validation是Spring为了给开发者提供便捷，对Hibernate Validator进行了二次封装。同时，Spring Validation在SpringMVC模块中添加了自动校验，并将校验信息封装进了特定的类中。</span><br></pre></td></tr></table></figure>
<p>所以，JSR定义了数据验证规范，而Hibernate Validator则是基于JSR规范，实现了各种数据验证的注解以及一些附加的约束注解。Spring Validation则是对Hibernate Validator的封装整合。</p>
<p>JSR和Hibernate Validator中的常用注解如表4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092309365.png" alt="image-20231009230908286"></p>
<p>表4-2中包含了Hibernate Validator实现的JSR-303定义的验证注解和Hibernate Validator自己定义的验证注解，同时也支持自定义约束注解。所有的注解都包含code和message这两个属性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message定义数据校验不通过时的错误提示信息。</span><br><span class="line">code定义错误的类型。</span><br></pre></td></tr></table></figure>
<p>Spring Boot是从Spring发展而来的，所以自然支持Hibernate Validator和Spring Validation两种方式，<strong>默认使用的是Hibernate Validator组件。</strong></p>
<h3 id="4-4-2-数据校验"><a href="#4-4-2-数据校验" class="headerlink" title="4.4.2　数据校验"></a>4.4.2　数据校验</h3><p>使用Hibernate Validator校验数据需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。下面以User对象为例演示如何使用Hibernate Validator校验数据。</p>
<h4 id="1-JavaBean参数校验"><a href="#1-JavaBean参数校验" class="headerlink" title="1. JavaBean参数校验"></a>1. JavaBean参数校验</h4><p>Post请求参数较多时，可以在对应的数据模型（Java Bean）中进行数据校验，通过注解来指定字段校验的规则。下面以具体的实例来进行演示。</p>
<p>首先，创建Java Bean实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(message = &quot;年龄不能为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Min(18)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，每个注解中的属性message是数据校验不通过时要给出的提示信息，如@Email(message=”邮件格式错误”)，当邮件格式校验不通过时，提示邮件格式错误。</p>
<p>然后，添加数据校验方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> User user, BindingResult result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getName();</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123;</span><br><span class="line">        List&lt;ObjectError&gt; list = result.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : list) &#123;</span><br><span class="line">            System.out.println(error.getCode()+ <span class="string">&quot;-&quot;</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@RequestBody注解后面添加了@Valid注解，然后在后面添加了BindingResult返回验证结果，BindingResult是验证不通过时的结果集合。</p>
<p>注意，BindingResult必须跟在被校验参数之后，若被校验参数之后没有BindingResult对象，则会抛出BindException。</p>
<p>最后，运行验证。</p>
<p>启动项目，在postman中请求/user/check接口，后台输出了数据验证的结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length-密码长度错误，密码长度6-20！</span><br><span class="line">Min-最小不能小于18</span><br><span class="line">Length-姓名长度错误，姓名长度2-10！</span><br></pre></td></tr></table></figure>
<p>通过上面的输出可以看到，应用系统对传入的数据进行了校验，同时也返回了对应的数据校验结果。</p>
<h4 id="2-URL参数校验"><a href="#2-URL参数校验" class="headerlink" title="2. URL参数校验"></a>2. URL参数校验</h4><p>一般GET请求都是在URL中传入参数。对于这种情况，可以直接通过注解来指定参数的校验规则。下面通过实例进行演示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="meta">@Length(min = 2, max = 10, message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span></span><br><span class="line"><span class="params">                                                <span class="meta">@RequestParam(name = &quot;name&quot;, required = true)</span> String name,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Min(value = 1, message = &quot;年龄最小只能1&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@Max(value = 99, message = &quot;年龄最大只能99&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@RequestParam(name = &quot;age&quot;, required = true)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot;,&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Range、@Min、@Max等注解对URL中传入的参数进行校验。需要注意的是，使用@Valid注解是无效的，需要在方法所在的控制器上添加@Validated注解来使得验证生效。</p>
<h4 id="3-JavaBean对象级联校验"><a href="#3-JavaBean对象级联校验" class="headerlink" title="3. JavaBean对象级联校验"></a>3. JavaBean对象级联校验</h4><p>对于JavaBean对象中的普通属性字段，我们可以直接使用注解进行数据校验，那如果是关联对象呢？其实也很简单，在属性上添加@Valid注解就可以作为属性对象的内部属性进行验证（验证User对象，可以验证UserDetail的字段）。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Size(min = 3,max = 5,message = &quot;list的Size在[3,5]&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> UserDetail userDetail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetail</span> &#123;</span><br><span class="line">    <span class="meta">@Length(min = 5, max = 17, message = &quot;length长度在[5,17]之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String extField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在属性上添加@Valid就可以对User中的关联对象UserDetail的字段进行数据校验。</p>
<h4 id="4-分组校验"><a href="#4-分组校验" class="headerlink" title="4. 分组校验"></a>4. 分组校验</h4><p>在不同情况下，可能对JavaBean对象的数据校验规则有所不同，有时需要根据数据状态对JavaBean中的某些属性字段进行单独验证。这时就可以使用分组校验功能，即根据状态启用一组约束。Hibernate Validator的注解提供了groups参数，用于指定分组，如果没有指定groups参数，则默认属于javax.validation.groups.Default分组。</p>
<p>下面通过示例演示分组校验。</p>
<p>首先，创建分组GroupA和GroupB，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了GroupA和GroupB两个接口作为两个校验规则的分组。</p>
<p>然后，创建实体类Person，并在相关的字段中定义校验分组规则，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;userId不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length(min = 30,max = 40,message = &quot;必须在[30,40]&quot;,groups = &#123;GroupB.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 20,max = 30,message = &quot;必须在[20,30]&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户名*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，age字段定义了GroupA和GroupB两个分组校验规则。GroupA的校验规则为年龄在20～30，GroupB的校验规则为年龄在30～40。</p>
<p>最后，使用校验分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(&#123;GroupA.class,Default.class&#125;)</span> Person person, BindingResult result)</span>&#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(result.getAllErrors()));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@Validated注解中增加了{GroupA.class,Default.class}参数，表示对于定义了分组校验的字段使用GroupA校验规则，其他字段使用默认规则。</p>
<h3 id="4-4-3-自定义校验"><a href="#4-4-3-自定义校验" class="headerlink" title="4.4.3　自定义校验"></a>4.4.3　自定义校验</h3><p>Hibernate Validator支持自定义校验规则。通过自定义校验规则，可以实现一些复杂、特殊的数据验证功能。下面通过示例演示如何创建和使用自定义验证规则。</p>
<h4 id="1-声明一个自定义校验注解"><a href="#1-声明一个自定义校验注解" class="headerlink" title="1. 声明一个自定义校验注解"></a>1. 声明一个自定义校验注解</h4><p>首先，定义新的校验注解@CustomAgeValidator，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Min(value = 18,message = &quot;年龄最小不能小于18&quot;)</span></span><br><span class="line"><span class="meta">@Max(value = 120,message = &quot;年龄最大不能超过120&quot;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;&#125;)</span> <span class="comment">//不指定校验器</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAgeValidator &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;年龄大小必须大于18并且小于120&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了CustomAgeValidator自定义注解，用于自定义年龄的数据校验规则。</p>
<h4 id="2-使用自定义校验注解"><a href="#2-使用自定义校验注解" class="headerlink" title="2. 使用自定义校验注解"></a>2. 使用自定义校验注解</h4><p>创建自定义校验注解CustomAgeValidator之后，在User的age属性上使用自定义组合注解，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@CustomAgeValidator</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在需要做特殊校验的age字段上添加@CustomAgeValidator自定义注解，这样age字段就会使用我们自定义的校验规则。</p>
<h2 id="4-5-拦截器"><a href="#4-5-拦截器" class="headerlink" title="4.5　拦截器"></a>4.5　拦截器</h2><p>拦截器在Web系统中非常常见，一般用于拦截用户请求，实现访问权限控制、日志记录、敏感过滤等功能。本节首先介绍实际项目中拦截器的应用场景，然后介绍如何实现自定义拦截器的功能。</p>
<h3 id="4-5-1-应用场景"><a href="#4-5-1-应用场景" class="headerlink" title="4.5.1　应用场景"></a>4.5.1　应用场景</h3><p>拦截器在实际的应用开发中非常常见，对于某些全局统一的操作，我们可以把它提取到拦截器中实现。总结起来，拦截器大致有以下几种使用场景：</p>
<p>1）权限检查：如登录检测，进入处理程序检测是否登录，如果没有，则直接返回登录页面。</p>
<p>2）性能监控：有时系统在某段时间莫名其妙很慢，可以通过拦截器在进入处理程序之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如Apache，可以自动记录）。</p>
<p>3）通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有提取Locale、Theme信息等，只要是多个处理程序都需要的，即可使用拦截器实现。</p>
<p>4）OpenSessionInView：如Hibernate，在进入处理程序时打开Session（会话），在完成后关闭Session。</p>
<h3 id="4-5-2-HandlerInterceptor简介"><a href="#4-5-2-HandlerInterceptor简介" class="headerlink" title="4.5.2　HandlerInterceptor简介"></a>4.5.2　HandlerInterceptor简介</h3><p>Spring Boot定义了HandlerInterceptor接口来实现自定义拦截器的功能。HandlerInterceptor接口定义了preHandle、postHandle、afterCompletion三种方法，通过重写这三种方法实现请求前、请求后等操作。</p>
<p>1）preHandle：预处理回调方法实现处理程序的预处理（如登录检查），第三个参数为响应的处理程序（如第3章的控制器的实现）。</p>
<p>返回值：true表示继续流程（如调用下一个拦截器或处理程序）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理程序，此时需要通过response来产生响应。</p>
<p>2）postHandle：后处理回调方法，实现处理程序的后处理（但在渲染视图之前），此时可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</p>
<p>3）afterCompletion：整个请求处理完之后回调方法，即在视图渲染完毕时回调，如在性能监控中，可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但是只调用处理程序执行preHandle，返回true所对应的拦截器的afterCompletion。</p>
<p>有时我们只需要实现3种回调方法之一，如果实现HandlerInterceptor接口，则无论是否需要3种方法都必须实现，此时Spring提供了一个HandlerInterceptorAdapter适配器（一种适配器设计模式的实现），允许我们只实现需要的回调方法。</p>
<h3 id="4-5-3-使用HandlerInterceptor实现拦截器"><a href="#4-5-3-使用HandlerInterceptor实现拦截器" class="headerlink" title="4.5.3　使用HandlerInterceptor实现拦截器"></a>4.5.3　使用HandlerInterceptor实现拦截器</h3><p>我们在访问某些需要授权的页面，如订单详情、订单列表等需要用户登录后才能查看的功能时，需要对这些请求拦截，进行登录检测，符合规则的才允许请求通过。接下来通过登录状态检测的例子演示拦截器的使用。</p>
<p>首先，创建自定义登录拦截器，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/*注册拦截器*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;您没有权限这么做！&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，LoginInterceptor继承HandlerInterceptor接口，实现preHandle接口，验证用户的Session状态。如果当前用户有登录信息，则可以继续访问；如果当前用户没有登录信息，则返回无权限。</p>
<p>然后，将拦截器注入系统配置。</p>
<p>定义MyMvcConfig配置类，将上面定义的LoginInterceptor拦截器注入系统中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">        .addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;/asserts/**&quot;</span>,<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过WebMvcConfigurer类的addInterceptors方法将刚刚自定义的LoginInterceptor拦截器注入系统中。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPathPatterns定义拦截的请求地址。excludePathPatterns的作用是排除某些地址不被拦截，例如登录地址/user/login不需要进行登录验证。</span><br></pre></td></tr></table></figure>
<h2 id="4-6-过滤器"><a href="#4-6-过滤器" class="headerlink" title="4.6　过滤器"></a>4.6　过滤器</h2><p>本节介绍如何使用Spring Boot实现自定义过滤器，在开发Web项目时，经常需要过滤器（Filter）来处理一些请求，包括字符集转换、过滤敏感词汇等场景。</p>
<h3 id="4-6-1-过滤器简介"><a href="#4-6-1-过滤器简介" class="headerlink" title="4.6.1　过滤器简介"></a>4.6.1　过滤器简介</h3><p>过滤器是Java Servlet规范中定义的，<strong>能够在HTTP请求发送给Servlet之前对Request（请求）和Response（返回）进行检查和修改</strong>，从而起到过滤的作用。通过对Web服务器管理的所有Web资源（如JSP、Servlet、静态图片文件或静态HTML文件等）过滤，实现特殊的功能，例如，实现URL级别的权限访问控制、过滤敏感词汇、排除有XSS威胁的字符等。</p>
<p>Spring Boot内置了很多过滤器，比如处理编码的OrderedCharacterEncodingFilter和请求转化的HiddenHttpMethodFilter，也支持根据实际需求自定义过滤器。自定义过滤器有两种实现方式：第一种是使用@<strong>WebFilter</strong>，第二种是使用<strong>FilterRegistrationBean</strong>。经过实践之后，发现使用@WebFilter自定义的过滤器优先级顺序不能生效，因此推荐使用第二种方案。</p>
<p><strong>过滤器和拦截器的功能类似，但技术实现差距比较大</strong>，两者的区别包括以下几个方面：</p>
<p>1）过滤器依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</p>
<p>2）过滤器的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。</p>
<p>3）过滤器的生命周期由Servlet容器管理，而拦截器可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用更方便。</p>
<p>过滤器的生命周期由Servlet容器管理，而拦截器可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用更方便。</p>
<p>拦截器和过滤器的执行顺序是：先过滤器后拦截器。具体执行过程为：过滤前→拦截前→执行→拦截后→过滤后。</p>
<h3 id="4-6-2-使用FilterRegistrationBean实现过滤器"><a href="#4-6-2-使用FilterRegistrationBean实现过滤器" class="headerlink" title="4.6.2　使用FilterRegistrationBean实现过滤器"></a>4.6.2　使用FilterRegistrationBean实现过滤器</h3><p>Spring Boot提供了FilterRegistrationBean类实现过滤器注入，实现自定义过滤器的步骤如下：</p>
<p>1）添加自定义Filter类，实现Filter接口，并实现其中的doFilter()方法。</p>
<p>2）添加@Configuration注解，将自定义过滤器加入过滤链。</p>
<p>接下来以监控请求执行时间为例，通过自定义过滤器实现系统性能监控的功能。步骤如下：</p>
<p>步骤01 创建拦截器，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTimerFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;timer Filter begin&quot;</span>);</span><br><span class="line">         <span class="type">long</span> start=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="type">long</span> end=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">         System.out.println(<span class="string">&quot;timer Filter end,cost time:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Component注解确保被Spring Boot管理。上面的示例代码实现了doFilter()方法记录所有HTTP请求的时间。</p>
<p>步骤02 将过滤器注入系统配置中。</p>
<p>通过FilterRegistrationBean类将定义的ConsumerTimerFilter过滤器注入系统中，并配置过滤的地址和执行顺序，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">consumerLoginFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;ConsumerLoginFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        registration.setFilter(ConsumerTimerFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;consumerLoginFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用registration.setOrder(2)进行排序，数字越小越先执行。当有多个过滤器时，通过设置Order属性决定过滤器的执行顺序。</p>
<p>添加完后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/getUsers，就会看到控制台打印如下信息：">http://localhost:8080/getUsers，就会看到控制台打印如下信息：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer Filter begin</span><br><span class="line">timer Filter end,cost time:<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>如上所示，后台输出了请求的消耗时间，说明刚刚自定义的过滤器已经对所有的URL进行了过滤处理。</p>
<h2 id="4-7-Web配置"><a href="#4-7-Web配置" class="headerlink" title="4.7　Web配置"></a>4.7　Web配置</h2><p>本节介绍Spring Boot Web中非常重要的类：WebMvcConfigurer。有时我们需要自定义Handler、Interceptor、ViewResolver、MessageConverter实现特殊的Web配置功能，通过WebMvcConfigurer接口即可实现项目的自定义配置。</p>
<h3 id="4-7-1-WebMvcConfigurer简介"><a href="#4-7-1-WebMvcConfigurer简介" class="headerlink" title="4.7.1　WebMvcConfigurer简介"></a>4.7.1　WebMvcConfigurer简介</h3><p>在Spring Boot 1.5版本都是靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器、消息转换器等。Spring Boot 2.0以后，该类被标记为@Deprecated（弃用）。官方推荐直接实现WebMvcConfigurer接口或者直接继承WebMvcConfigurationSupport类。</p>
<p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的XML配置文件形式进行针对框架的个性化定制，可以自定义Handler、Interceptor、ViewResolver、MessageConverter。基于java-based方式的Spring MVC配置需要创建一个配置类并实现WebMvcConfigurer接口</p>
<h3 id="4-7-2-跨域访问"><a href="#4-7-2-跨域访问" class="headerlink" title="4.7.2　跨域访问"></a>4.7.2　跨域访问</h3><p>出于安全的考虑，浏览器会禁止Ajax访问不同域的地址，而在如今微服务横行的年代，跨域访问是非常常见的。这就需要应用系统既要保证系统安全，又要对前端跨域访问提供支持。所以W3C提出了CORS（Cross-Origin-Resource-Sharing）跨域访问规范，并被主流浏览器所支持。</p>
<p>Spring Boot可以基于CORS解决跨域问题，CORS是一种机制，告诉后台哪边（Origin）来的请求可以访问服务器的数据。WebMvcConfigurer配置类中的addCorsMappings()方法是专门为开发人员解决跨域而诞生的接口，其中构造参数为CorsRegistry，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addCorsMappings(registry);</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/cors/**&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;DELETE&quot;</span>,<span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，将pathPattern设置为/**，即整个系统支持跨域访问。当然也可以根据不同的项目路径定制访问行为。CorsRegistry提供了registrations属性，通过getCorsConfigurations()方法设置特定路径的跨域访问。</p>
<h3 id="4-7-3-数据转换配置"><a href="#4-7-3-数据转换配置" class="headerlink" title="4.7.3　数据转换配置"></a>4.7.3　数据转换配置</h3><p>Spring Boot支持对请求或返回的数据类型进行转换，常用到的是统一对返回的日期数据自动格式化。配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义时间格式转换器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title function_">jackson2HttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">    mapper.setDateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    converter.setObjectMapper(mapper);</span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加转换器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="comment">//将我们定义的时间格式转换器添加到转换器列表中</span></span><br><span class="line">    <span class="comment">//这样jackson格式化时但凡遇到Date类型就会转换成我们定义的格式</span></span><br><span class="line">    converters.add(jackson2HttpMessageConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先创建一个MessageConverter时间格式转换器，将设置时间的格式为”yyyy-MM-dd HH:mm:ss”，然后configureMessageConverters方法将转换器添加到系统中。这样JSON数据格式化时，统一将时间类型转换成我们定义的格式。</p>
<h3 id="4-7-4-静态资源"><a href="#4-7-4-静态资源" class="headerlink" title="4.7.4　静态资源"></a>4.7.4　静态资源</h3><p>在开发Web应用的过程中，需要引用大量的JS、CSS、图片等静态资源。Spring Boot默认提供静态资源的目录置于classpath下，目录名规则如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/static</span><br><span class="line">/public</span><br><span class="line">/resources</span><br><span class="line">/META-INF/resources</span><br></pre></td></tr></table></figure>
<p>比如，我们可以在src/main/resources/目录下创建static，在该位置放置一个文件名为xx.jpg的图片。启动程序后，访问<a target="_blank" rel="noopener" href="http://localhost:8080/xx.jpg即可访问该图片，无须其他额外配置。">http://localhost:8080/xx.jpg即可访问该图片，无须其他额外配置。</a></p>
<p>Spring Boot同样支持自定义静态资源目录，如果需要自定义静态资源映射目录，只需重写addResourceHandlers()方法即可，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理静态资源，例如图片、JS、CSS等</span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>).addResourceLocations</span><br><span class="line">(<span class="string">&quot;classpath:/images/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，创建的webconfig类继承自WebMvcConfigure类，重写了addResourceHandler()方法，通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addResourceLocations指的是文件放置的目录。</span><br><span class="line">addResoureHandler指的是对外暴露的访问路径。</span><br></pre></td></tr></table></figure>
<h3 id="4-7-5-跳转指定页面"><a href="#4-7-5-跳转指定页面" class="headerlink" title="4.7.5　跳转指定页面"></a>4.7.5　跳转指定页面</h3><p>以前编写Spring MVC的时候，如果需要访问一个页面，必须要在Controller类中编写一个页面跳转的方法。Spring Boot重写WebMvcConfigurer中的addViewControllers()方法即可达到同样的效果。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.addViewControllers(registry);</span><br><span class="line">     registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">     <span class="comment">// 实现一个请求到视图的映射，无须编写controller</span></span><br><span class="line">     registry.addViewController(<span class="string">&quot;/login&quot;</span>).setViewName</span><br><span class="line">(<span class="string">&quot;forward:/index.html&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>值得指出的是，在这里重写addViewControllers()方法并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是推荐添加自己的MVC配置的原因。</p>
<h2 id="4-8-实战：实现优雅的数据返回"><a href="#4-8-实战：实现优雅的数据返回" class="headerlink" title="4.8　实战：实现优雅的数据返回"></a>4.8　实战：实现优雅的数据返回</h2><p>本节介绍如何让前后台优雅地进行数据交互，正常的数据如何统一数据格式，以及异常情况如何统一处理并返回统一格式的数据。</p>
<h3 id="4-8-1-为什么要统一返回值"><a href="#4-8-1-为什么要统一返回值" class="headerlink" title="4.8.1　为什么要统一返回值"></a>4.8.1　为什么要统一返回值</h3><p>在项目开发过程中经常会涉及服务端、客户端接口数据传输或前后台分离的系统架构下的数据交互问题。如何确保数据完整、清晰易懂是考验开发者的大难题。定义统一的数据返回格式有利于提高开发效率、降低沟通成本，降低调用方的开发成本。目前比较流行的是基于JSON格式的数据交互。但是JSON只是消息的格式，其中的数据内容还需要重新设计和定义。无论是HTTP接口还是RPC接口，保持返回值格式统一很重要。</p>
<p>在项目中，我们会将响应封装成JSON返回，一般会统一所有接口的数据格式，使前端（iOS、Android、Web）对数据的操作一致、轻松。一般情况下，统一返回数据格式没有固定的规范，只要能描述清楚返回的数据状态以及要返回的具体数据即可，但是一般会包含状态码、消息提示语、具体数据这3部分内容。例如，一般的系统要求返回的基本数据格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weiz&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;备注&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上面的示例我们知道，定义的返回值包含4要素：响应结果、响应码、消息、返回数据。</p>
<h3 id="4-8-2-统一数据返回"><a href="#4-8-2-统一数据返回" class="headerlink" title="4.8.2　统一数据返回"></a>4.8.2　统一数据返回</h3><p>前面介绍了为什么要统一返回值以及如何实现统一JSON数据返回。接下来通过示例演示如何实现统一JSON数据返回。</p>
<h4 id="1-定义数据格式"><a href="#1-定义数据格式" class="headerlink" title="1. 定义数据格式"></a>1. 定义数据格式</h4><p>定义返回值的基本要素，确保后台执行无论成功还是失败都是返回这些字段，而不会出现其他的字段。定义的返回值包含如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer code：成功时返回0，失败时返回具体错误码。</span><br><span class="line">String message：成功时返回null，失败时返回具体错误消息。</span><br><span class="line">T data：成功时返回具体值，失败时为null。</span><br></pre></td></tr></table></figure>
<p>根据上面的返回数据格式的定义，实际返回的数据模板如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weiz&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;备注&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，data字段为泛型字段，根据实际的业务返回前端需要的数据类型。</p>
<h4 id="2-定义状态码"><a href="#2-定义状态码" class="headerlink" title="2. 定义状态码"></a>2. 定义状态码</h4><p>返回的数据中有一个非常重要的字段：状态码。状态码字段能够让服务端、客户端清楚知道操作的结果、业务是否处理成功，如果失败，失败的原因等信息。所以，定义清晰易懂的状态码非常重要。状态码定义如表4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310101858547.png" alt="image-20231010185842408"></p>
<p>以上定义的是通用状态码，其他的业务相关状态码需要根据实际业务定义。</p>
<h4 id="3-定义数据处理类"><a href="#3-定义数据处理类" class="headerlink" title="3. 定义数据处理类"></a>3. 定义数据处理类</h4><p>前面定义了返回数据的格式和处理结果的状态码，接下来定义通用的结果处理类。在实际使用时可以根据情况处理。本示例中简单定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: JSONResult.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.weiz.utils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义响应数据结构</span></span><br><span class="line"><span class="comment"> *                      200：表示成功</span></span><br><span class="line"><span class="comment"> *                      500：表示错误，错误信息在msg字段中</span></span><br><span class="line"><span class="comment"> *                      501：bean验证错误，无论多少个错误都以map形式返回</span></span><br><span class="line"><span class="comment"> *                      502：拦截器拦截到用户token出错</span></span><br><span class="line"><span class="comment"> *                      555：异常抛出信息</span></span><br><span class="line"><span class="comment"> * Copyright: Copyright (c) 2016</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年4月22日 下午8:33:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONResult</span> &#123;</span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="comment">// 响应业务状态</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 响应消息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">// 响应中的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">build</span><span class="params">(Integer status, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(status, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">500</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorMap</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">501</span>, <span class="string">&quot;error&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorTokenMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">502</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">555</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">(Integer status, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isOK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.status == <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 将json结果集转化为JSONResult对象</span></span><br><span class="line"><span class="comment">     *                          需要转换的对象是一个类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:34:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">formatToPojo</span><span class="params">(String jsonData, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MAPPER.readValue(jsonData, JSONResult.class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(jsonData);</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">data</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.isObject()) &#123;</span><br><span class="line">                    obj = MAPPER.readValue(data.traverse(), clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.isTextual()) &#123;</span><br><span class="line">                    obj = MAPPER.readValue(data.asText(), clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> build(jsonNode.get(<span class="string">&quot;status&quot;</span>).intValue(), jsonNode.get(<span class="string">&quot;msg&quot;</span>).asText(), obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 没有object对象的转化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:35:21</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">format</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAPPER.readValue(json, JSONResult.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Object是集合转化</span></span><br><span class="line"><span class="comment">     *                          需要转换的对象是一个list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:35:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">formatToList</span><span class="params">(String jsonData, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(jsonData);</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">data</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (data.isArray() &amp;&amp; data.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                obj = MAPPER.readValue(data.traverse(),</span><br><span class="line">                        MAPPER.getTypeFactory().constructCollectionType</span><br><span class="line">(List.class, clazz));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> build(jsonNode.get(<span class="string">&quot;status&quot;</span>).intValue(), jsonNode.get(<span class="string">&quot;msg&quot;</span>).asText(), obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getOk</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ok;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOk</span><span class="params">(String ok)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ok = ok;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了数据返回处理类，定义了响应数据结构，所有接口的数据返回统一通过此类处理，接收此类数据后，需要使用本类的方法转换成对应的数据类型格式（类或者list）。</p>
<h4 id="4-处理数据返回"><a href="#4-处理数据返回" class="headerlink" title="4. 处理数据返回"></a>4. 处理数据返回</h4><p>定义数据处理类后，在控制器中将返回的数据统一加上数据处理。调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">getUserJson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">    u.setAge(<span class="number">20</span>);</span><br><span class="line">    u.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><p>启动helloworld项目，浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/user/getUser，页面数据返回如下：">http://localhost:8080/user/getUser，页面数据返回如下：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;weiz222&quot;</span>,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">                <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-12-21 06:57:13&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的结果数据在正常的时候能够按照我们的预期结果格式返回。</p>
<h3 id="4-8-3-全局异常处理"><a href="#4-8-3-全局异常处理" class="headerlink" title="4.8.3　全局异常处理"></a>4.8.3　全局异常处理</h3><p>在项目开发的过程中肯定会碰到异常的情况，出现异常情况时如何处理，如何确保出现异常时程序也能正确地返回数据？总不能所有的方法都加上try catch吧？接下来介绍Spring Boot如何进行全局异常处理，捕获异常后如何按照统一格式返回数据。</p>
<h4 id="1-全局异常处理的实现方式"><a href="#1-全局异常处理的实现方式" class="headerlink" title="1. 全局异常处理的实现方式"></a>1. 全局异常处理的实现方式</h4><p>在介绍之前，我们需要先了解Spring中常见的异常处理方式有哪些。一般Spring Boot框架的异常处理有多种方式，从范围来说，包括全局异常捕获处理方式和局部异常捕获处理方式。下面介绍3种比较常用的异常处理解决方案。</p>
<p>（1）使用@ExceptionHandler处理局部异常</p>
<p>在控制器中通过加入@ExceptionHandler注解的方法来实现异常的处理。这种方式非常容易实现，但是只能处理使用@ExceptionHandler注解方法的控制器异常，而无法处理其他控制器的异常，所以不推荐使用。</p>
<p>（2）配置SimpleMappingExceptionResolver类来处理异常</p>
<p>通过配置SimpleMappingExceptionResolver类实现全局异常的处理，但是这种方式不能针对特定的异常进行特殊处理，所有的异常都按照统一的方式处理。</p>
<p>（3）使用ControllerAdvice注解处理全局异常</p>
<p>使用@ControllerAdvice、@ExceptionHandler注解实现全局异常处理，@ControllerAdvice定义全局异常处理类，@ExceptionHandler指定自定义错误处理方法拦截的异常类型。实现全局异常捕获，并针对特定的异常进行特殊处理。</p>
<p>以上三种解决方案，都能实现全局异常处理。但是，推荐使用@ControllerAdvice注解方式处理全局异常，这样可以针对不同的异常分开处理。</p>
<h4 id="2-使用-ControllerAdvice注解实现全局异常处理"><a href="#2-使用-ControllerAdvice注解实现全局异常处理" class="headerlink" title="2. 使用@ControllerAdvice注解实现全局异常处理"></a>2. 使用@ControllerAdvice注解实现全局异常处理</h4><p>下面通过示例演示@ControllerAdvice注解实现全局统一异常处理。</p>
<p>定义一个自定义的异常处理类GlobalExceptionHandler，具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ERROR_VIEW</span> <span class="operator">=</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ExceptionHandler(value = &#123;Exception.class &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">errorHandler</span><span class="params">(HttpServletRequest reqest,</span></span><br><span class="line"><span class="params">                HttpServletResponse response, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                    <span class="comment">// 记录日志</span></span><br><span class="line">                    logger.error(ExceptionUtils.getMessage(e));</span><br><span class="line">        <span class="comment">// 是否是Ajax请求</span></span><br><span class="line">        <span class="keyword">if</span> (isAjax(reqest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONResult.errorException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">              mav.addObject(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">              mav.addObject(<span class="string">&quot;url&quot;</span>, reqest.getRequestURL());</span><br><span class="line">              mav.setViewName(ERROR_VIEW);</span><br><span class="line">              <span class="keyword">return</span> mav;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Title</span>: GlobalExceptionHandler.java</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Package</span> com.weiz.exception</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Description</span>: 判断是否是Ajax请求</span></span><br><span class="line"><span class="comment">         * Copyright: Copyright (c) 2017</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2017年12月3日 下午1:40:39</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAjax</span><span class="params">(HttpServletRequest httpRequest)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  (httpRequest.getHeader(<span class="string">&quot;X-Requested-With&quot;</span>) != <span class="literal">null</span></span><br><span class="line">                                        &amp;&amp; <span class="string">&quot;XMLHttpRequest&quot;</span></span><br><span class="line"></span><br><span class="line">        .equals( httpRequest.getHeader(<span class="string">&quot;X-Requested-With&quot;</span>)) );</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例，处理全部Exception的异常，如果需要处理其他异常，例如NullPointerException异常，则只需要在GlobalException类中使用@ExceptionHandler(value = {NullPointerException.class})注解重新定义一个异常处理的方法即可。</p>
<p>启动项目，在浏览器中输入<a target="_blank" rel="noopener" href="http://localhost:8088/err/error，结果如图4-3所示。">http://localhost:8088/err/error，结果如图4-3所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310101951100.png" alt="image-20231010195138024"></p>
<p>如图4-3所示，处理异常之后页面自动调整到统一的错误页面，如果是Ajax请求出错，则会按照定义的JSON数据格式统一返回数据。</p>
<h1 id="第5章-Thymeleaf模板引擎"><a href="#第5章-Thymeleaf模板引擎" class="headerlink" title="第5章　Thymeleaf模板引擎"></a>第5章　Thymeleaf模板引擎</h1><p>本章主要介绍Web开发中的重要组成部分：模板引擎。Spring Boot支持的模板引擎有很多，Thymeleaf是流行的模板引擎之一。本章将介绍Thymeleaf模板引擎，包括Thymeleaf常用的语法、Thymeleaf的表达式等高级用法以及Thymeleaf页面的整体布局。</p>
<h2 id="5-1-Thymeleaf入门"><a href="#5-1-Thymeleaf入门" class="headerlink" title="5.1　Thymeleaf入门"></a>5.1　Thymeleaf入门</h2><p>本节介绍什么是Thymeleaf以及Spring Boot如何集成使用Thymeleaf模板，最后介绍Spring Boot支持的Thymeleaf的一些常用的配置参数。</p>
<h3 id="5-1-1-Thymeleaf简介"><a href="#5-1-1-Thymeleaf简介" class="headerlink" title="5.1.1　Thymeleaf简介"></a>5.1.1　Thymeleaf简介</h3><p>Thymeleaf是一款非常优秀的服务器端页面模板引擎，适用于Web和独立环境，具有丰富的标签语言和函数，能够处理HTML、XML、JavaScript甚至文</p>
<p>Thymeleaf相较于其他模板引擎更加优雅。它强调自然模板化（允许模板成为工作原型，而Velocity、FreeMarker模板不允许这样做），所以它的语法更干净，更符合当前Web开发的趋势。</p>
<h4 id="1-Thymeleaf的实现机制"><a href="#1-Thymeleaf的实现机制" class="headerlink" title="1. Thymeleaf的实现机制"></a>1. Thymeleaf的实现机制</h4><p>模板的诞生是为了将显示与数据分离，模板技术多种多样，本质是将模板文件和数据通过模板引擎生成最终的HTML代码。</p>
<p>Thymeleaf亦是如此。Thymeleaf将其逻辑注入模板控件中，而不会影响模板设计原型，所以可以在浏览器中正确显示HTML页面和数据，也可以在无后台时静态显示。由于Thymeleaf模板后缀为.html，可以直接在浏览器中打开，预览非常方便。这样改善了设计人员与开发人员的沟通，弥合了设计人员和开发团队之间的差距，从而可以在开发团队中实现更强大的协作。</p>
<h4 id="2-Thymeleaf的优点"><a href="#2-Thymeleaf的优点" class="headerlink" title="2. Thymeleaf的优点"></a>2. Thymeleaf的优点</h4><p>Thymeleaf与Velocity、FreeMarker等模板引擎类似，可以完全替代JSP。与其他的模板引擎相比，Thymeleaf具有如下优点：</p>
<p>1）动静结合：Thymeleaf页面采用模板+数据的展示方式，既可以展示静态页面，也可以展示数据返回到页面后的动态效果。这是因为Thymeleaf支持HTML原型，可以在HTML原型上添加额外的属性，浏览器在解释HTML时会忽视未定义的属性，当定义的属性带数据时就会动态替换静态内容，实现页面动态展示。</p>
<p>2）开箱即用：Thymeleaf提供标准方言和Spring方言，可以直接套用模板实现JSTL、OGNL表达式效果，避免套模板、改JSTL、改标签的困扰。同时，开发人员也可以扩展和创建自定义的方言。</p>
<p>3）多方言支持：Thymeleaf提供spring标准方言和一个与Spring MVC完美集成的可选模块，可以快速地实现表单绑定、属性编辑器、国际化等功能。</p>
<p>4）与Spring Boot完美整合：Spring Boot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，可以像操作JSP一样来操作Thymeleaf。代码几乎没有任何区别，仅在模板语法上有所区别。</p>
<p>Spring Boot官方推荐使用Thymeleaf作为前端页面模板，Spring Boot 2.0中默认使用Thymeleaf 3.0。同时Spring Boot也为Thymeleaf提供了spring-boot-starter-thymeleaf组件（集成了Thymeleaf模板引擎），还支持Thymeleaf自动装配，可以开箱即用。</p>
<h3 id="5-1-2-Spring-Boot使用Thymeleaf"><a href="#5-1-2-Spring-Boot使用Thymeleaf" class="headerlink" title="5.1.2　Spring Boot使用Thymeleaf"></a>5.1.2　Spring Boot使用Thymeleaf</h3><p>Spring Boot对Thymeleaf提供了非常完整的支持，使得我们使用Thymeleaf非常简单，只需要引入spring-boot-starter-thymeleaf依赖库即可。下面通过一个简单的例子来演示Spring Boot是如何集成Thymeleaf的。</p>
<p>步骤01 添加Thymeleaf依赖。</p>
<p>修改项目的pom.xml文件，添加spring-boot-starter-thymeleaf依赖配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在Spring Boot项目中除了需要引入spring-boot-starter-thymeleaf依赖库外，还需要引入spring-boot-starter-web和spring-boot-starter等组件。</p>
<p>步骤02 配置Thymeleaf参数</p>
<p>如果需要对默认的Thymeleaf配置参数进行自定义，可直接在application.properties中配置修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启缓存，开发时可以设置为false，默认为true</span></span><br><span class="line">spring.thymeleaf.cache=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 模板文件位置</span></span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"><span class="comment"># Content-Type配置</span></span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br><span class="line"><span class="comment"># 模板文件后缀</span></span><br><span class="line">spring.thymeleaf.suffix=.html</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主要是配置Thymeleaf模板页面的存放位置。当然，也可以通过application.properties灵活地配置Thymeleaf的其他各项特性。其中，spring.thymeleaf.cache=false用于关闭Thymeleaf的缓存，不然在开发过程中修改页面不会生效，需要重启，生产环境可配置为true。</p>
<p>步骤03 创建Thymeleaf页面。</p>
<p>Thymeleaf模板后缀为.html，在resource\templates模板存放目录下创建hello.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Thymeleaf模板引擎</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>Hello Thymeleaf<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了hello.html页面。此页面可直接双击来运行，页面会显示出“Hello Thymeleaf”。</p>
<p>步骤04 创建后台控制器（Controller）。</p>
<p>在Controller目录中创建HelloController控制器并实现测试方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">        map.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Hello Thymeleaf From Spring Boot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Controller注解返回页面和数据。返回具体的hello.html页面，需要与前端HTML的路径保持一致，同时返回数据name=Hello Thymeleaf。</p>
<p>步骤05 运行验证。</p>
<p>至此，准备工作已经完成。启动项目后，在浏览器中输入网址<a target="_blank" rel="noopener" href="http://localhost:8080/hello，验证Thymeleaf配置是否成功，如图5-1所示。">http://localhost:8080/hello，验证Thymeleaf配置是否成功，如图5-1所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102121535.png" alt="image-20231010212130425"></p>
<p>由图5-1可知，成功返回hello.html页面，并且通过th:text=”${name}”标签，页面的默认值已经成功地被后端传入的内容所替换。说明Thymeleaf已经成功整合到我们的Spring Boot项目中。</p>
<p>Thymeleaf使用非常简单，标签与Html基类似。但是，在使用Thymeleaf时还需要注意以下几个问题：</p>
<p>1）Thymeleaf模板页面必须在HTML标签中声明xmlns:th=”<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/，表明页面使用的是Thymeleaf的语法，否则Thymeleaf的自定义标签没有提示。">http://www.thymeleaf.org/，表明页面使用的是Thymeleaf的语法，否则Thymeleaf的自定义标签没有提示。</a></p>
<p>2）在application.properties文件中配置的模板路径为classpath:/templates/，模板的存放路径在resource/templates目录下。</p>
<p>3）Spring Boot默认存放模板页面的路径在src/main/resources/templates或者src/main/view/templates，无论使用什么模板语言都一样，当然默认路径是可以自定义的，不过一般不推荐这样做。</p>
<p>4）Thymeleaf默认的页面文件后缀是.html，也可以改成其他后缀。</p>
<h3 id="5-1-3-Thymeleaf常用的配置参数"><a href="#5-1-3-Thymeleaf常用的配置参数" class="headerlink" title="5.1.3　Thymeleaf常用的配置参数"></a>5.1.3　Thymeleaf常用的配置参数</h3><p>Thymeleaf提供了很多可自定义的配置参数，只是这些Spring Boot都已经默认配置，如果需要自定义修改这些配置，可以通过application.properties配置文件灵活地配置Thymeleaf的各项特性。以下为Thymeleaf的配置和默认参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># THYMELEAF (ThymeleafAutoConfiguration)</span></span><br><span class="line"><span class="comment"># 开启模板缓存（默认值：true）</span></span><br><span class="line">spring.thymeleaf.cache=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 检查模板是否存在，然后呈现</span></span><br><span class="line">spring.thymeleaf.check-template=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 检查模板位置是否正确（默认值:true）</span></span><br><span class="line">spring.thymeleaf.check-template-location=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Content-Type的值（默认值：text/html）</span></span><br><span class="line">spring.thymeleaf.content-type=text/html</span><br><span class="line"><span class="comment"># 开启MVC Thymeleaf视图解析（默认值：true）</span></span><br><span class="line">spring.thymeleaf.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 模板编码</span></span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line"><span class="comment"># 要被排除在解析之外的视图名称列表，用逗号分隔</span></span><br><span class="line">spring.thymeleaf.excluded-view-names=</span><br><span class="line"><span class="comment"># 定义模板的模式(默认值：HTML5)</span></span><br><span class="line">spring.thymeleaf.mode=HTML5</span><br><span class="line"><span class="comment"># 在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）</span></span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"><span class="comment"># 在构建URL时添加到视图名称后的后缀（默认值：.html）</span></span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line"><span class="comment"># Thymeleaf模板解析器在解析器链中的顺序，默认情况下，它排在第一位，顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性</span></span><br><span class="line">spring.thymeleaf.template-resolver-order=</span><br><span class="line"><span class="comment"># 可解析的视图名称列表，用逗号分隔</span></span><br><span class="line">spring.thymeleaf.view-names=</span><br></pre></td></tr></table></figure>
<p>上面的Thymeleaf的属性配置看起来很多，其实常用的就是之前介绍的配置项。其他的配置项在实际项目中可以根据实际使用情况来修改。</p>
<h2 id="5-2-Thymeleaf表达式"><a href="#5-2-Thymeleaf表达式" class="headerlink" title="5.2　Thymeleaf表达式"></a>5.2　Thymeleaf表达式</h2><p>既然Thymeleaf有着众多优点，又是Spring Boot官方推荐的模板引擎，接下来就让我们看看Thymeleaf有哪些实用的功能。本节介绍Thymeleaf的各种表达式，通过一些简单的例子来演示Thymeleaf的表达式及用法。</p>
<h3 id="5-2-1-变量表达式"><a href="#5-2-1-变量表达式" class="headerlink" title="5.2.1　变量表达式"></a>5.2.1　变量表达式</h3><p>变量表达式即获取后台变量的表达式。使用${}获取变量的值，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过${name}获取后台返回的model的属性。标签中的th:text属性用来填充该标签的内容。</p>
<p>如果后台返回的是对象，则使用变量名.属性名方式获取，这一点和EL表达式一样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.memo&#125;&quot;</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用${user. memo}可以获取model中的user对象的memo属性。</p>
<h3 id="5-2-2-选择或星号表达式"><a href="#5-2-2-选择或星号表达式" class="headerlink" title="5.2.2　选择或星号表达式"></a>5.2.2　选择或星号表达式</h3><p>选择表达式与变量表达式类似，不过它用一个预先选择的对象来代替上下文变量容器（map）执行*{name}。什么是预先选择的对象？就是父标签的值。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们用th:object预先定义了对象变量${session.user}，然后使用星号（*）获取了user变量中的各个属性。例如*{firstName}等价于${session.user.firstName}。这两种使用方式的区别如下：</p>
<p>1）在不考虑上下文的情况下，两者没有区别，只是星号语法评估在选定对象上表达，而不是整个上下文。</p>
<p>2）美元符号（$）和星号（*）语法可以混合使用。</p>
<h3 id="5-2-3-URL表达式"><a href="#5-2-3-URL表达式" class="headerlink" title="5.2.3　URL表达式"></a>5.2.3　URL表达式</h3><p>URL在Web应用中占据着十分重要的地位，如引用静态资源文件、处理URL链接等。Thymeleaf通过@{…}语法来处理URL表达式，主要使用th:href、th:src等属性引用CSS、JS等静态资源文件、下面通过示例演示URL表达式的使用。</p>
<h4 id="1-引入静态资源文件"><a href="#1-引入静态资源文件" class="headerlink" title="1. 引入静态资源文件"></a>1. 引入静态资源文件</h4><p>Thymeleaf页面使用th:href属性引入CSS资源文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/resources/css/bootstrap.min.css&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，默认访问resources下的css文件夹。</p>
<p>Thymeleaf页面使用th:src属性引入JS资源文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/resource/js/bootstrap.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认访问resources下的js文件夹。</p>
<h4 id="2-使用-…-设置背景图片"><a href="#2-使用-…-设置背景图片" class="headerlink" title="2. 使用 @{…} 设置背景图片"></a>2. 使用 @{…} 设置背景图片</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:style=<span class="string">&quot;&#x27;background:url(&#x27; + <span class="subst">@&#123;$&#123;imgurl&#125;&#125;</span> + &#x27;);&#x27;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面的路径使用@{${imgurl}指定图片的路径，Thymeleaf也通过th:background设置背景。</p>
<h4 id="3-URL链接"><a href="#3-URL链接" class="headerlink" title="3. URL链接"></a>3. URL链接</h4><p>Thymeleaf支持在<a>标签中使用th:href来处理URL链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.a.com/user/u2376052 &#125;&quot;</span>&gt;</span>绝对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order&#125;&quot;</span>&gt;</span>相对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，th:href属性修饰符将计算并替换使用href链接的URL值，并放入href属性中。</p>
<p>同样，th:href也支持URL参数传递，我们可以使用带参数的URL表达式，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order/details(orderId=$&#123;orderId&#125;)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@{…}表达式中通过{orderId}访问上下文中的orderId变量。最后的(orderId=${orderId})表示将括号内的内容作为URL参数处理，该语法避免使用“&amp;”拼接URL参数，大大提高了可读性。</p>
<p>如果需要多个参数，将用逗号分隔，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@{}表达式创建URL，同时传递execId和execType两个参数，比使用“&amp;”拼接更简单易读。</p>
<h3 id="5-2-4-文字国际化表达式"><a href="#5-2-4-文字国际化表达式" class="headerlink" title="5.2.4　文字国际化表达式"></a>5.2.4　文字国际化表达式</h3><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息，使用类似于#{login.tip}的表达式。下面通过示例演示Thymeleaf实现国际化。</p>
<p>步骤01 创建国际化资源。</p>
<p>Spring Boot支持国际化，我们在resources资源文件目录下新建i18n文件夹，在该文件夹下创建test_zh_CN.properties和test_en_US.properties两个文件（也可以直接创建Resource Bundle文件夹），然后增加测试属性，如图5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102139123.png" alt="image-20231010213943052"></p>
<p>我们创建了test的国际化资源配置文件，增加了login.tip属性并配置了对应的中英文。</p>
<p>步骤02 修改系统国际化配置。</p>
<p>在application.properties中加入上面定义的国际化配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n.test</span><br></pre></td></tr></table></figure>
<p>步骤03 在页面中引用国际化资源。</p>
<p>在resource/templates目录下创建i18n.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>国际化<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.tip&#125;&quot;</span>&gt;</span>Please log in<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过文字国际化表达式#{login.tip}获取属性配置。</p>
<p>步骤04 创建后台请求。</p>
<p>在之前的HelloController中加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/i18n&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">i18n</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;i18n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤05 运行测试。</p>
<p>配置完成之后启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/i18n来验证国际化配置是否生效，如图5-3所示。">http://localhost:8080/i18n来验证国际化配置是否生效，如图5-3所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102146822.png" alt="image-20231010214610670"></p>
<p>通过#{login.tip}表达式，获取到了国际化资源配置中的中文内容。</p>
<h2 id="5-3-表达式的语法"><a href="#5-3-表达式的语法" class="headerlink" title="5.3　表达式的语法"></a>5.3　表达式的语法</h2><p>我们知道，模板的主要作用是将后台返回的数据渲染到HTML中。那么Thymeleaf是如何解析后台数据的呢？接下来从变量、方法、条件判断、循环、运算（逻辑运算、布尔运算、比较运算、条件运算）方面学习Thymeleaf表达式支持的语法。</p>
<h3 id="5-3-1-赋值和拼接"><a href="#5-3-1-赋值和拼接" class="headerlink" title="5.3.1　赋值和拼接"></a>5.3.1　赋值和拼接</h3><h4 id="（1）文本赋值"><a href="#（1）文本赋值" class="headerlink" title="（1）文本赋值"></a>（1）文本赋值</h4><p>赋值就是通过${}标签将后台返回的数据替换到页面中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>hello spring boot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过${}标签将后台返回的name的值替换到页面的<p>标签中。当请求后台地址之后，Thymeleaf会将页面<p>标签中的hello spring boot替换成后台传回的name的值。</p>
<h4 id="（2）文本拼接"><a href="#（2）文本拼接" class="headerlink" title="（2）文本拼接"></a>（2）文本拼接</h4><p>Thymeleaf支持将后台返回的值和现有的内容进行拼接，然后替换到页面中。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome, &#x27; + $&#123;userName&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将后台返回的userName的值拼接到“Welcome,”之后，最后统一替换到页面的<span>中。文本文字可以用单引号来包含，如有特殊字符，需要用“\”转义。</p>
<p>除了上面这种写法外，字符串拼接还有另一种简洁的写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|Welcome, $&#123;userName&#125;!|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用两个竖杠“|”将后台返回的数据与页面中的内容合并，比前面的方式简单多了。</p>
<p>Thymeleaf标签和HTML的基本一致，在HTML的标签上加上“th：”即可替换HTML标签中原生属性的值。</p>
<h3 id="5-3-2-条件判断"><a href="#5-3-2-条件判断" class="headerlink" title="5.3.2　条件判断"></a>5.3.2　条件判断</h3><p>Thymeleaf中使用th:if和th:unless属性进行条件判断。在标签中使用th:if属性判断表达式是否成立，成立则显示该标签的内容，不成立则隐藏该标签的内容。th:unless与th:if恰好相反，只有表达式中的条件不成立才会显示其内容。</p>
<p>th:if和th:unless表达式的结果支持boolean、number、character、string及其他类型。下面通过例子演示Thymeleaf中如何使用th:if和th:unless属性进行条件判断。</p>
<p>步骤01 定义HTML页面。</p>
<p>在templates目录下创建if.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>条件判断<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;flag == &#x27;yes&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.a.com/&#125;&quot;</span>&gt;</span>a.home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;flag != &#x27;no&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.b.com/&#125;&quot;</span> &gt;</span>b.home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，通过th:if标签进行条件判断，如果flag==yes，就显示a.home的链接，否则显示b.home的链接。</p>
<p>步骤02 定义后端接口，返回数据结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/if&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">ifunless</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;if&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义请求的地址，返回if.html页面，并返回flag的值为yes。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/if，会出现如图5-4所示的结果。">http://localhost:8080/if，会出现如图5-4所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102215408.png" alt="image-20231010221534232"></p>
<p>由图5-4可知，后端返回的flag值为yes，th:if=”${flag == ‘yes’}”条件成立，所以显示a.home的链接。而th:unless=”${flag != ‘no’}” 条件也成立，所以隐藏b.home的链接。</p>
<h3 id="5-3-3-switch"><a href="#5-3-3-switch" class="headerlink" title="5.3.3　switch"></a>5.3.3　switch</h3><p>Thymeleaf中使用th:switch、th:case标签进行多条件判断，与Java中的switch语句等效，根据条件显示匹配的内容，如果有多个匹配结果，只选择第一个显示。th:case=”<em>“表示默认选项，即没有case的值为true时显示th:case=”</em>“的内容，对应Java中switch的default。下面以数据状态为例来演示th:switch的用法。</p>
<p>步骤01 创建前端页面。</p>
<p>在templates目录下创建switch.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example switch <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>switch<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;todo&#x27;&quot;</span>&gt;</span>未开始<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;doing&#x27;&quot;</span>&gt;</span>进行中<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;done&#x27;&quot;</span>&gt;</span>完成<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- *: case的默认选项 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>状态错误<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，使用th:switch、th:case标签根据后台返回的status的值显示匹配数据。</p>
<p>步骤02 添加后端程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/switch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">switchcase</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;doing&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;switch&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，后台返回switch.html页面，同时返回status值为doing。</p>
<p>步骤03 运行验证。</p>
<p>启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/switch，页面显示效果如图5-5所示。页面显示“进行中”的状态，可以在后台更改status的值来查看结果。">http://localhost:8080/switch，页面显示效果如图5-5所示。页面显示“进行中”的状态，可以在后台更改status的值来查看结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102220633.png" alt="image-20231010222013550"></p>
<p>由图5-5可知，switch.html页面通过后台返回的status的值来显示不同的内容。</p>
<h3 id="5-3-4-循环遍历"><a href="#5-3-4-循环遍历" class="headerlink" title="5.3.4　循环遍历"></a>5.3.4　循环遍历</h3><p>循环遍历在日常项目中比较常用，一般用于将后台返回的数据渲染到前端的表格中。Thymeleaf可以使用th:each标签进行数据的迭代循环，语法：th:each=”obj,iterStat:${objList}”，支持List、Map、数组数据类型等。下面通过简单的例子演示数据循环遍历的过程。</p>
<p>步骤01 定义后端数据。</p>
<p>首先在后端定义一个用户列表，然后传递到前端页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    User user1=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;spring&quot;</span>,<span class="number">12</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    User user2=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;boot&quot;</span>,<span class="number">6</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    User user3=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Thymeleaf&quot;</span>,<span class="number">66</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;users&quot;</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，后台返回list.html页面，同时返回ArrayList类型的用户列表数据。</p>
<p>步骤02 创建前台页面。</p>
<p>在templates目录下创建list.html页面，展示后台的数据，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example switch <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>each循环遍历<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：index<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：count<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：size<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：even<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：odd<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：first<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：last<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user,stat : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span>age<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.password&#125;&quot;</span>&gt;</span>password<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.index&#125;&quot;</span>&gt;</span>index<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.count&#125;&quot;</span>&gt;</span>count<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.size&#125;&quot;</span>&gt;</span>size<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.even&#125;&quot;</span>&gt;</span>even<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.odd&#125;&quot;</span>&gt;</span>odd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.first&#125;&quot;</span>&gt;</span>first<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.last&#125;&quot;</span>&gt;</span>last<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>循环遍历通过th:each实现，语法：th:each=”obj,stat:${objList}”。</p>
<p>1）${users}是从模板上下文中获取变量。</p>
<p>2）user是${users}变量遍历后的每一个对象。</p>
<p>3）${user.name}可以读取遍历中的变量。</p>
<p>在遍历的同时，也可以获取迭代对象的迭代状态变量stat，它包含如下属性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index：当前迭代对象的index（从0开始计算）。</span><br><span class="line">count：当前迭代对象的index（从1开始计算）。</span><br><span class="line">size：被迭代对象的大小。</span><br><span class="line">even/odd：布尔值，当前循环是不是偶数/奇数（从0开始计算）。</span><br><span class="line">first：布尔值，当前循环是不是第一个。</span><br><span class="line">ast：布尔值，当前循环是不是最后一个。</span><br></pre></td></tr></table></figure>
<p>步骤03 运行验证</p>
<p>启动项目，在浏览器中输入地址：<a target="_blank" rel="noopener" href="http://localhost:8080/list，页面显示效果如图5-6所示。">http://localhost:8080/list，页面显示效果如图5-6所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102240601.png" alt="image-20231010224024507"></p>
<p>由图5-6可知，后端返回的list数据被循环遍历并显示在页面中，同时th:each标签还提供了index、count等标签。</p>
<h3 id="5-3-5-运算符"><a href="#5-3-5-运算符" class="headerlink" title="5.3.5　运算符"></a>5.3.5　运算符</h3><p>Thymeleaf支持在表达式中使用算术运算、逻辑运算、布尔运算、三目运算等各类数据计算功能，实现前端页面根据后台返回数据动态显示页面信息。下面就来一一演示。</p>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h4><p>算术运算符包括+、-、*、/、%等简单的计算。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th:with=&quot;isEven=($&#123;prodStat.count&#125; / 2 == 0)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过除以2的算术运算判断奇偶。</p>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h4><p>关系运算符包括&gt;、&lt;、&gt;=、&lt;=、==、!=，对应的别名为gt、lt、ge、le、eq、ne，使用&gt;、&lt;时需要用它的HTML转义符，所以建议使用gt、lt等别名：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gt：great than（大于）。</span><br><span class="line">ge：great equal（大于等于）。</span><br><span class="line">eq：equal（等于）。</span><br><span class="line">lt：less than（小于）。</span><br><span class="line">le：less equal（小于等于）。</span><br><span class="line">ne：not equal（不等于）。</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th:if=&quot;$&#123;prodStat.count&#125; gt 1&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>使用gt比较count的值是否大于1。</p>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h4><p>通过逻辑运算符实现多个条件判断，包括&amp;&amp;（and）和||（or）。</p>
<p>&amp;&amp;（and）表示“并且”，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age gt 10 &amp;&amp; a lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;（$&#123;age gt 10&#125;） and $&#123;age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表示：如果age&gt;10且age &lt;19，实现年龄是否在10～19岁的判断。</p>
<p>|| or表示“或者”，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age gt 10 || age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;（$&#123;age gt 10&#125;） or $&#123;age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表示：如果age &gt; 10或age &lt; 19，实现年龄大于10岁或者年龄小于19岁的判断。</p>
<h4 id="4-三目运算符"><a href="#4-三目运算符" class="headerlink" title="4. 三目运算符"></a>4. 三目运算符</h4><p>三目运算符的语法与Java等语言类似，具体使用如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;row.even&#125;? &#x27;even&#x27; : &#x27;odd&#x27;&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在前端列表进行数据渲染，实现用颜色隔行显示的效果。</p>
<h2 id="5-4-Thymeleaf的高级用法"><a href="#5-4-Thymeleaf的高级用法" class="headerlink" title="5.4　Thymeleaf的高级用法"></a>5.4　Thymeleaf的高级用法</h2><p>上一节介绍了Thymeleaf的基本使用语法，包括常用的赋值、字符串拼接、条件判断、数据循环遍历等语法。接下来介绍Thymeleaf的<strong>内联、内置对象、内置变量</strong>等高级用法，让我们在实践中边学边用，从而更好地理解和吸收。</p>
<h3 id="5-4-1-内联"><a href="#5-4-1-内联" class="headerlink" title="5.4.1　内联"></a>5.4.1　内联</h3><p>虽然通过Thymeleaf中的标签属性已经几乎满足了开发中的所有需求，但是有些情况下需要在CSS或JS中访问后台返回的数据。所以Thymeleaf提供了th:inline=”text/javascript/none”标签，使用[[…]]内联表达式的方式在HTML、JavaScript、CSS代码块中轻松访问model对象数据。</p>
<h4 id="1-文本内联"><a href="#1-文本内联" class="headerlink" title="1. 文本内联"></a>1. 文本内联</h4><p>Thymeleaf内联表达式使用[[…]]或[(…)]语法表达。先在父级标签定义使用内联方式th:inline=”text”，然后在标签内使用[[…]]或[(…)]表达式操作数据对象。文本内联比th:text的代码更简洁。下面通过示例演示内联的使用方式。</p>
<p>首先，创建页面inline.html。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>内联<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, [[$&#123;userName&#125;]] !<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码等价于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>不使用内联<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Hello, &#x27; + $&#123;userName&#125; + &#x27; !&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过以上两个示例可以看出使用内联语法会更简洁一些。</p>
<p>1）th:inline=”text”表示使用文本内联方式。</p>
<p>2）任何父标签都可以加上th:inline。</p>
<p>3）[[…]] 等价于th:text结果将被HTML转义，[(…)]等价于th:utext结果不会被HTML转义。</p>
<p>然后，创建后台路由/inline，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/inline&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">inline</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;inline&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，后台返回inline.html页面，同时返回userName=admin。</p>
<p>最后，运行测试。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，则会出现如图5-7所示的结果。">http://localhost:8080/inline，则会出现如图5-7所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102255608.png" alt="image-20231010225512527"></p>
<p>页面显示后台返回的userName为admin，比之前介绍的th:text=${userName}的方式更加简单、清晰。</p>
<h4 id="2-脚本内联"><a href="#2-脚本内联" class="headerlink" title="2. 脚本内联"></a>2. 脚本内联</h4><p>脚本内联，顾名思义就是在JavaScript脚本中使用内联表达式。使用时只需要在<script>标签上加入th:inline=”javascript”属性，然后在JavaScript代码块中就能使用[[]]表达式。实现在JavaScript脚本中获取后台传过来的参数。</p>
<p>首先，修改inline.html页面，增加如下脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> name =<span class="string">&#x27;hello,&#x27;</span>+ [[$&#123;userName&#125;]] ;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(name);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在\<script>标签内加入th:inline=”javascript”，表示能在JavaScript中使用[ [] ]取值。在访问页面时，根据后端传值拼接name值，并以alert的方式弹框展示。</p>
<p>然后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，会出现如图5-8所示的结果。">http://localhost:8080/inline，会出现如图5-8所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102257904.png" alt="image-20231010225700826"></p>
<p>显示页面会先弹出一个alert提示框，显示“hello admin”，说明使用脚本内联绑定了后台传过来的数据。</p>
<h4 id="3-样式内联"><a href="#3-样式内联" class="headerlink" title="3. 样式内联"></a>3. 样式内联</h4><p>Thymeleaf还允许在\<style>标签中使用内联表达式动态生成CSS属性样式。下面通过示例演示内联CSS样式的用法。</p>
<p>首先，修改inline.html页面，加入如下样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">th:inline</span>=<span class="string">&quot;css&quot;</span> <span class="attr">th:with</span>=<span class="string">&quot;color=&#x27;yellow&#x27;, fontSize=&#x27;25px&#x27;&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="comment">/*[[$&#123;color&#125;]]*/</span> red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: [($&#123;fontSize&#125;) ];</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，与内联JavaScript一样，CSS内联也允许<style>标签静态和动态区分处理，当服务器动态打开时，字体颜色为黄色；当以原型静态打开时，显示的是红色，因为Thymeleaf会自动忽略掉CSS注释之后和分号之前的代码。需要注意的是，在获取变量赋值时，fontSize需要使用[(…)]表示不进行转义，如果使用[[…]]进行了转义，则会导致样式无效。</p>
<p>然后，修改/inline路由，返回fontSize和color，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/inline&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">inline</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;fontSize&quot;</span>, <span class="string">&quot;20px&quot;</span>);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;inline&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，增加了fontSize和color两个CSS的属性样式，设置fontSize为20px，color为yellow。</p>
<p>然后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，可以看到如图5-9所示的结果。">http://localhost:8080/inline，可以看到如图5-9所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102301299.png" alt="image-20231010230139225"></p>
<p>页面显示的字体大小和颜色根据后台返回的数据显示，说明CSS内联生效。</p>
<h4 id="4-禁用内联"><a href="#4-禁用内联" class="headerlink" title="4. 禁用内联"></a>4. 禁用内联</h4><p>Thymeleaf支持使用th:inline =“none”来禁止使用内联。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*禁用内联表达式*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;none&quot;</span>&gt;</span>[[$&#123;info&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*禁用内联表达式*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;none&quot;</span>&gt;</span>[[Info]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&lt;/body</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-内置对象"><a href="#5-4-2-内置对象" class="headerlink" title="5.4.2　内置对象"></a>5.4.2　内置对象</h3><p>Thymeleaf包含一些内置的基本对象，可以用于视图中获取上下文对象、请求参数、Session等信息。这些基本对象使用#开头，如表5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102305495.png" alt="image-20231010230522412"></p>
<p>如表5-1所示，Thymeleaf提供了有一系列的对象和属性用于访问请求参数、会话属性等应用属性。下面以其中两个常用的对象作为示例来演示。</p>
<p>步骤01 定义后台方法传值。</p>
<p>创建一个后台方法，后台传回request请求参数和session属性，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;spring boot&quot;</span>);</span><br><span class="line">    request.getSession().setAttribute(<span class="string">&quot;session&quot;</span>, <span class="string">&quot;admin session&quot;</span>);</span><br><span class="line">    request.getServletContext().setAttribute(<span class="string">&quot;servletContext&quot;</span>,<span class="string">&quot;Thymeleaf servletContext&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;baseobject&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们分别在request和session对象中写入了相关的测试，验证前台是否能获取到这些自定义的Web请求信息。</p>
<p>步骤02 前端页面接收参数</p>
<p>接下来看看前端页面如何通过Thymeleaf内置的基本对象获取后端传递的值，在/resources目录下新建一个前端页面baseobject.html，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>基本对象<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getAttribute(&#x27;request&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#session.getAttribute(&#x27;session&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#servletContext.getAttribute(&#x27;servletContext&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在HTML页面中通过#request、#session这些对象就能获取Web请求中的相关信息。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/object，则会出现如图5-10所示的结果。![image-20231010230911437](https://gitee.com/fjkf/images/raw/master/202310102309537.png">http://localhost:8080/object，则会出现如图5-10所示的结果。![image-20231010230911437](https://gitee.com/fjkf/images/raw/master/202310102309537.png</a>)</p>
<p>在HTML页面中，通过#request、#session这些对象成功获取了后台返回的Web请求信息。</p>
<h3 id="5-4-3-内嵌变量"><a href="#5-4-3-内嵌变量" class="headerlink" title="5.4.3　内嵌变量"></a>5.4.3　内嵌变量</h3><p>为了模板更加易用，Thymeleaf还提供了一系列公共的Utility对象（内置于Context中），可以通过#直接访问。具体的对象如表5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102310025.png" alt="image-20231010231034933"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102310174.png" alt="image-20231010231051090"></p>
<p>Thymeleaf除了定义上面这些常用的对象外，还有一些其他的utility对象，比如#ids，这里不再逐一列举。</p>
<h2 id="5-5-Thymeleaf页面布局"><a href="#5-5-Thymeleaf页面布局" class="headerlink" title="5.5　Thymeleaf页面布局"></a>5.5　Thymeleaf页面布局</h2><p>前面我们已经初步学会了Thymeleaf的基本语法以及内联、系统对象、内嵌变量、表达式等高级用法，俗话说“磨刀不误砍柴工”，熟悉Thymeleaf的语法和表达式后，后面开发起来会更加得心应手。接下来好好研究一下Thymeleaf如何实现完整的Web系统页面布局。</p>
<h3 id="5-5-1-引入代码片段"><a href="#5-5-1-引入代码片段" class="headerlink" title="5.5.1　引入代码片段"></a>5.5.1　引入代码片段</h3><p>在模板中经常希望包含来自其他模板页面的内容，如页脚、页眉、菜单等。为了做到这一点，Thymeleaf提供了th:fragment属性。下面通过在页面中添加标准的版权页脚的场景来演示如何引入代码片段。</p>
<p>步骤01 定义版权页脚代码片段。</p>
<p>在templates目录下创建版权模板页面footer.html，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2020 The Thymeleaf footer</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了版权页面footer.html，使用th:fragment属性定义了一个代码片段，名为copyright。</p>
<p>步骤02 引入代码片段模板。</p>
<p>创建一个普通的模板页面layout.html。使用th:insert或th:replace属性引入之前定义的copyright版权页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>页面布局<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;footer :: copyright&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在layout.html中通过th:insert引入先前定义的footer.html中的copyright代码片段，“～{footer :: copyright}”就是在当前模板页面引入的footer.html模板中的copyright片段。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/layout，验证主页是否能正常引入footer.html代码片段，如图5-11所示。">http://localhost:8080/layout，验证主页是否能正常引入footer.html代码片段，如图5-11所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102314965.png" alt="image-20231010231439878"></p>
<p>layout.html页面通过th:insert属性成功将footer页面的版权信息包含在主页中。</p>
<h3 id="5-5-2-片段表达式语法规范"><a href="#5-5-2-片段表达式语法规范" class="headerlink" title="5.5.2　片段表达式语法规范"></a>5.5.2　片段表达式语法规范</h3><p>Thymeleaf片段表达式非常实用，可以实现模板页面的复用，避免相同内容需要修改多个页面的情况。</p>
<h4 id="1-标记选择器"><a href="#1-标记选择器" class="headerlink" title="1. 标记选择器"></a>1. 标记选择器</h4><p>片段表达式的语法非常简单，其核心是标记选择器，由底层的AttoParser解析库定义，类似于XPath表达式或CSS选择器。片段表达式有以下3种不同的格式：</p>
<p>1）～{templatename::selector}：包含templatename和selector两个参数，其中templatename为页面模板的名称，selector为模板中定义的代码片段。例如上面示例中的“～{footer :: copyright}”就是在当前模板页面引入footer.html模板中的copyright片段。</p>
<p>2）～{templatename}：引入名为templatename的完整模板。</p>
<p>3）～{::selector}或～{this::selector}：Thymeleaf支持从同一个模板插入一个片段，如果在当前的模板上找不到，将向最初处理的模板遍历，直到选择器匹配上对应的模板。</p>
<p>此外，标记选择器的模板名和选择器还可以包含条件判断或三目运算等其他表达式语法，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;footer :: ($&#123;user.isAdmin&#125;? #&#123;footer.admin&#125; : #&#123;footer.normaluser&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过判断后台用户是否是管理员从而引入相应的代码片段，实现管理员和普通用户的页面区分。</p>
<h4 id="2-引用普通的模板"><a href="#2-引用普通的模板" class="headerlink" title="2. 引用普通的模板"></a>2. 引用普通的模板</h4><p>标记选择器非常强大，可以包含不使用任何th:fragment属性的片段，甚至可以是来自完全不了解Thymeleaf的不同应用程序的标记代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;copy-section&quot;</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用上面的片段，只需通过它的id属性引用，类似于CSS选择器：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;～&#123;footer :: #copy-section&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-th-insert、th-replace和th-include的区别"><a href="#3-th-insert、th-replace和th-include的区别" class="headerlink" title="3. th:insert、th:replace和th:include的区别"></a>3. th:insert、th:replace和th:include的区别</h4><p>th:insert、th:replace和th:include的功能基本类似，三者之间的差异如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">th:insert是最简单的，它简单地插入指定的片段作为其宿主标签的主体。</span><br><span class="line">th:replace实际上用指定的片段替换它的主机标签。</span><br><span class="line">th:include与th:insert类似，但它并不插入片段，只插入该片段的内容。</span><br></pre></td></tr></table></figure>
<h3 id="5-5-3-可参数化片段"><a href="#5-5-3-可参数化片段" class="headerlink" title="5.5.3　可参数化片段"></a>5.5.3　可参数化片段</h3><p>Thymeleaf支持在th:fragment定义的片段中指定一组参数，这使得模板片段更像一个可重复调用的函数。通过不同的参数控制模板的显示，从而达到模板共用的效果。</p>
<p>下面用th:fragment定义的片段指定一组参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;frag (onevar,twovar)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;onevar&#125; + &#x27; - &#x27; + $&#123;twovar&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义的frag片段包含两个参数，不需要定义参数的类型。</p>
<p>使用th:insert或th:replace调用此片段时，需要传入两个参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;::frag ($&#123;value1&#125;,$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>片段的参数传递与函数调用类似，通过传入的参数控制页面显示。</p>
<h1 id="第6章-构建RESTful服务"><a href="#第6章-构建RESTful服务" class="headerlink" title="第6章　构建RESTful服务"></a>第6章　构建RESTful服务</h1><h2 id="6-1-RESTful简介"><a href="#6-1-RESTful简介" class="headerlink" title="6.1　RESTful简介"></a>6.1　RESTful简介</h2><p>本节将从基础的概念开始介绍什么是RESTful、RESTful的特点、RESTful中的资源、HTTP Method、HTTP Status，还将介绍RESTful和SOAP到底有哪些区别。</p>
<h3 id="6-1-1-什么是RESTful"><a href="#6-1-1-什么是RESTful" class="headerlink" title="6.1.1　什么是RESTful"></a>6.1.1　什么是RESTful</h3><p>RESTful是目前流行的互联网软件服务架构设计风格。REST（Representational State Transfer，表述性状态转移）一词是由Roy Thomas Fielding在2000年的博士论文中提出的，它定义了互联网软件服务的架构原则，如果一个架构符合REST原则，则称之为RESTful架构。</p>
<p>REST并不是一个标准，它更像一组客户端和服务端交互时的架构理念和设计原则，基于这种架构理念和设计原则的Web API更加简洁，更有层次。</p>
<h4 id="1-RESTful的特点"><a href="#1-RESTful的特点" class="headerlink" title="1. RESTful的特点"></a>1. RESTful的特点</h4><p>1）每一个URI代表一种资源。</p>
<p>2）客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。3）通过操作资源的表现形式来实现服务端请求操作。</p>
<p>4）资源的表现形式是JSON或者HTML。</p>
<p>5）客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。</p>
<p>符合RESTful规范的Web API需要具备如下两个关键特性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安全性：安全的方法被期望不会产生任何副作用。当我们使用GET操作获取资源时，不会引起资源本身发生改变，也不会引起服务器状态的改变。</span><br><span class="line">幂等性：幂等的方法保证了重复进行一个请求和一次请求的效果相同（并不是指返回客户端的响应总是相同的，而是指服务器上资源的状态从第一次请求后就不再改变）。在数学中，幂等性是指N次变换和一次变换的结果相同。</span><br></pre></td></tr></table></figure>
<h4 id="2-REST的产生背景"><a href="#2-REST的产生背景" class="headerlink" title="2. REST的产生背景"></a>2. REST的产生背景</h4><p>随着互联网的发展，前端页面与后端的数据交互越来越频繁，数据结构越来越复杂，REST的出现极大地简化了前后端数据的交互逻辑。如果我们把前端页面看作一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。</p>
<p>假设，原本大家通过PC上的网上商城购物，当需要扩展到手机等移动端时，只需要开发针对iOS和Android的两个客户端，通过客户端访问系统公共的Web API就可以完成通过浏览器页面提供的功能，而后端代码基本无须改动，如图6-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111119898.png" alt="image-20231011111943737"></p>
<p>如图6-1所示，RESTful风格的Web API支持我们使用统一的接口规范对接iOS、Android、HTML5和PC等客户端。正是由于REST有着众多优点，因此REST一经提出就迅速取代了复杂而笨重的SOAP，成为Web API的标准。</p>
<h3 id="6-1-2-HTTP-Method"><a href="#6-1-2-HTTP-Method" class="headerlink" title="6.1.2　HTTP Method"></a>6.1.2　HTTP Method</h3><p>什么是HTTP Method（HTTP方法）呢？</p>
<p>HTTP提供了POST、GET、PUT、DELETE等操作类型对某个Web资源进行Create、Read、Update和Delete操作。一个HTTP请求除了利用URI标志目标资源之外，还需要通过HTTP Method指定针对该资源的操作类型。表6-1介绍一些常见的HTTP方法及其在RESTful风格下的使用。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111122063.png" alt="image-20231011112239956"></p>
<p>表6-1总结了主要的HTTP方法与资源URI结合使用的建议返回值。常见的HTTP Method（HTTP方法）有POST、GET、PUT、PATCH和DELETE，它们分别对应Create、Read、Update和Delete（或者CURD）操作。当然，还有许多其他方法，比如OPTIONS和HEAD等，但使用频率较低。</p>
<h3 id="6-1-3-HTTP状态码"><a href="#6-1-3-HTTP状态码" class="headerlink" title="6.1.3　HTTP状态码"></a>6.1.3　HTTP状态码</h3><p>HTTP状态码就是服务向用户返回的状态码和提示信息，客户端的每一次请求，服务都必须给出回应，回应包括HTTP状态码和数据两部分。</p>
<p>HTTP定义了40个标准状态码，可用于传达客户端请求的结果。状态码分为以下5个类别：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：信息，通信传输协议级信息。</span><br><span class="line">2xx：成功，表示客户端的请求已成功接受。</span><br><span class="line">3xx：重定向，表示客户端必须执行一些其他操作才能完成其请求。</span><br><span class="line">4xx：客户端错误，此类错误状态代码指向客户端。</span><br><span class="line">5xx：服务器错误，服务器负责这些错误状态代码。</span><br></pre></td></tr></table></figure>
<p>RESTful API中使用HTTP状态码来表示请求执行结果的状态，适用于REST API设计的代码以及对应的HTTP方法，如表6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111124766.png" alt="image-20231011112436442"></p>
<p>表6-2是HTTP协议提供的状态码和HTTP Method。通过RESTful API返回给客户端的状态码和提示信息可以判断出Web API的请求和执行情况。</p>
<p>除了以上基本的HTTP请求状态码外，Web API服务端还需要定义业务相关的状态，如1000订单提交成功、1002订单修改成功等。每种状态码都有标准的解释，客户端只需查看状态码字典就知道相应业务的执行结果，所以服务端应该返回尽可能精确的状态码。</p>
<h3 id="6-1-4-REST与SOAP的区别"><a href="#6-1-4-REST与SOAP的区别" class="headerlink" title="6.1.4　REST与SOAP的区别"></a>6.1.4　REST与SOAP的区别</h3><p>随着互联网的发展，RESTful越来越流行，那么RESTful和SOAP到底有哪些区别？我们在设计Web服务时，到底是应该选择目前最流行的RESTful还是选择老牌的WebService呢？</p>
<p>SOAP（Simple Object Access Protocol，简单对象访问协议）是一种标准化的通信规范，主要用于Web服务。它有着严格的规范和标准，包括安全、事务等各个方面的内容，同时SOAP强调操作方法和操作对象的分离，使用WSDL文件规范和XSD文件分别对其定义。</p>
<p>RESTful简化了WebService的设计，它不再需要WSDL，而是通过最简单的HTTP协议传输数据（包括XML或JSON）。既简化了设计，也减少了网络传输量（因为只传输代表数据的XML或JSON，没有额外的XML包装）。REST强制所有的操作都必须是无状态的，没有上下文的约束，不需要考虑上下文和会话保持的问题，极大地提高系统的可伸缩性。</p>
<p>RESTful相对于SOAP更加简单明了，它并没有一个明确的架构标准，更像是一种设计风格，其核心是面向资源；而WebService基于SOAP协议，主要核心是面向活动。</p>
<p>移动互联网飞速发展的今天，业务随时都在变化，天然拥抱变化的RESTful架构无疑是当前互联网行业Web服务架构开发的首选。</p>
<h2 id="6-2-构建RESTful应用接口"><a href="#6-2-构建RESTful应用接口" class="headerlink" title="6.2　构建RESTful应用接口"></a>6.2　构建RESTful应用接口</h2><p>RESTful架构是目前最流行的互联网软件架构规范，是Web API（应用编程接口）的大趋势和主流规范，了解了RESTful的众多优点之后，接下来一步一步地学习如何使用Spring Boot构建RESTful Web API。</p>
<h3 id="6-2-1-Spring-Boot对RESTful的支持"><a href="#6-2-1-Spring-Boot对RESTful的支持" class="headerlink" title="6.2.1　Spring Boot对RESTful的支持"></a>6.2.1　Spring Boot对RESTful的支持</h3><p>Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API，提供了与REST操作方式（GET、POST、PUT、DELETE）对应的注解：</p>
<p>1）@GetMapping：处理GET请求，获取资源。</p>
<p>2）@PostMapping：处理POST请求，新增资源。</p>
<p>3）@PutMapping：处理PUT请求，更新资源。</p>
<p>4）@DeleteMapping：处理DELETE请求，删除资源。</p>
<p>5）@PatchMapping：处理PATCH请求，用于部分更新资源。</p>
<p>通过这些注解就可以在Spring Boot项目中轻松构建RESTful接口。其中比较常用的是@GetMapping、@PostMapping、@PutMapping、@DeleteMapping四个注解。</p>
<p>使用Spring Boot开发RESTful接口非常简单，通过@RestController定义控制器，然后使用@GetMapping和@PostMapping等注解定义地址映射，实现相应的资源操作方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserByID</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserByID:&quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(value=&quot;/user &quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;save successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PutMapping(value=&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;update successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DeleteMapping(value=&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;delete id:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过Spring Boot提供的@GetMapping等注解简单实现了对用户（user）的操作。其实，这些注解就是@RequestMapping注解的简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserByID</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserByID:&quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;save successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;update successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;delete id:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前介绍的@RequestMapping注解通过method参数定义映射的HTTP请求方法，就相当于@RequestMapping+ RequestMethod的简化版。</p>
<p>我们看到，Get和Delete、Post和Put请求的URL是相同的，不同的Method（GET、PUT、POST、DELETE）会被映射到对应的处理方法上。这就是REST的魅力，简单明了的URL就能显示它的功能和作用。</p>
<h3 id="6-2-2-Spring-Boot实现RESTful-API"><a href="#6-2-2-Spring-Boot实现RESTful-API" class="headerlink" title="6.2.2　Spring Boot实现RESTful API"></a>6.2.2　Spring Boot实现RESTful API</h3><p>接下来根据之前介绍的RESTful设计风格，以用户管理模块为例演示Spring Boot如何实现RESTful API。</p>
<p>步骤01 设计API。</p>
<p>在RESTful架构中，每个网址代表一种资源，所以URI中建议不要包含动词，只包含名词即可，而且所用的名词往往与数据库的表格名对应。表6-3是用户管理模块的接口定义，实际项目的RESTful API文档要更详细，还会定义全部请求的数据结构体。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111135907.png" alt="image-20231011113552819"></p>
<p>表6-3定义了用户管理模块的接口，根据REST的定义，我们将用户定义为一种资源，通过POST、DELETE、PUT、GET等HTTP Method实现对用户的增、删、改、查。</p>
<p>可能大家会有疑问，为什么URI中没有我们习惯的getUser、saveUser这类路径？这正是RESTful优雅的地方，它将对资源的操作都定义在HTTP Method中，使得URL地址看起来更简洁。</p>
<p>除了设计URL接口之外，还需要定义服务端向客户端返回的状态码和提示信息。详细的状态码说明见表6-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111136875.png" alt="image-20231011113647789"></p>
<p>表6-4中除了定义用户管理相关的业务状态码之外，还需要定义通用的错误码，如400对应数据校验错误、401对应数据无权限等。</p>
<p>步骤02 实现用户管理接口。</p>
<p>上面定义了RESTful API以及接口返回的状态码，接下来根据之前的接口定义先创建UserController，再实现用户管理模块的用户新增、用户修改、用户删除、用户查询等接口。</p>
<p>1）用户新增：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户创建成功：&quot;</span>+user.getName());</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">201</span>,<span class="string">&quot;用户创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping注解表示此为POST接口。通过POST方法传入用户数据，然后调用Save方法保存用户数据。</p>
<p>2）用户修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户修改成功：&quot;</span>+user.getName());</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">203</span>,<span class="string">&quot;用户修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PutMapping注解表示此为PUT接口。PUT和POST的URL是相同的，只是通过PUT、POST方法加以区分。后端处理逻辑不同，所以使用时千万别搞混了。</p>
<p>3）用户删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户删除成功：&quot;</span>+userId);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">204</span>,<span class="string">&quot;用户删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@DeleteMapping注解表示此为删除接口。通过传入参数userId删除人员信息。</p>
<p>4）获取用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserId(userId);</span><br><span class="line">    user.setName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;获取用户成功：&quot;</span>+userId);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">200</span>,<span class="string">&quot;获取用户成功&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@GetMapping注解表示此为查询接口。@PathVariable注解用于参数映射，获取传入的参数。</p>
<p>步骤03 验证测试。</p>
<p>至此，用户管理的模块接口都实现了。接下来验证接口调用。我们可以使用单元测试或者Postman工具调用用户管理模块的相关接口，测试接口是否正常。这里就以Postman工具演示RESTful API的测试。</p>
<p>打开Postman，使用POST方法请求/user接口，验证新增人员的接口是否正常，如图6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111140998.png" alt="image-20231011114022905"></p>
<p>通过Postman发送POST请求，调用人员新增接口，后台接口处理成功后，返回人员信息保存成功。</p>
<p>接下来，使用GET方法请求/user/2001获取userId为2001的人员信息，从而验证获取人员的接口是否正常，如图6-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111140136.png" alt="image-20231011114043032"></p>
<p>通过Postman向后台接口发送GET方法请求/user/2001，RESTful API成功返回人员详细信息。</p>
<h2 id="6-3-使用Swagger生成Web-API文档"><a href="#6-3-使用Swagger生成Web-API文档" class="headerlink" title="6.3　使用Swagger生成Web API文档"></a>6.3　使用Swagger生成Web API文档</h2><p>高质量的API文档在系统开发的过程中非常重要。本节介绍什么是Swagger，如何在Spring Boot项目中集成Swagger构建RESTful API文档，以及为Swagger配置Token等通用参数。</p>
<h3 id="6-3-1-什么是Swagger"><a href="#6-3-1-什么是Swagger" class="headerlink" title="6.3.1　什么是Swagger"></a>6.3.1　什么是Swagger</h3><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务，是非常流行的API表达工具。</p>
<p>我们知道，RESTful API可能要面对多个开发人员或多个开发团队，涉及不同平台，包括iOS、Android或Web前端等。为了降低与其他团队频繁沟通的成本，一般我们会创建一份统一的API说明文档来记录所有接口的使用说明。然而，普通的API文档存在以下问题：</p>
<p>1）由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），创建这样一份高质量的文档是一件非常烦琐的工作。</p>
<p>2）随着需求的不断变化，接口文档必须同步修改，就很容易出现文档和业务不一致的情况。</p>
<p>为了解决这些问题，Swagger应运而生，它能够自动生成完善的RESTful API文档，并根据后台代码的修改同步更新。这样既可以减少维护接口文档的工作量，又能将说明内容集成到实现代码中，让维护文档和修改代码合为一体，实现代码逻辑与说明文档的同步更新。另外，Swagger也提供了完整的测试页面来调试API，让API测试变得轻松、简单。</p>
<h3 id="6-3-2-使用Swagger生成Web-API文档"><a href="#6-3-2-使用Swagger生成Web-API文档" class="headerlink" title="6.3.2　使用Swagger生成Web API文档"></a>6.3.2　使用Swagger生成Web API文档</h3><p>在Spring Boot项目中集成Swagger同样非常简单，只需在项目中引入springfox-swagger2和springfox-swagger-ui依赖即可。下面就以之前的用户管理模块接口为例来感受Swagger的魅力。</p>
<p>步骤01 配置Swagger的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger2 依赖配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在项目pom.xml配置文件中引入了springfox-swagger2和springfox-swagger-ui两个依赖包。其中swagger2是主要的文档生成组件，swagger-ui为页面显示组件。</p>
<p>步骤02 创建Swagger2配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.weiz.example01.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;Spring Boot相关文章请关注：https://www.cnblogs.com/zhangweizhong&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.cnblogs.com/zhangweizhong&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;架构师精进&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  swagger增加url映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;swagger-ui.html&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在SwaggerConfig的类上添加了@Configuration和@EnableSwagger2两个注解。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Configuration注解让Spring Boot来加载该类配置。</span><br><span class="line">@EnableSwagger2注解启用Swagger2，通过配置一个Docket Bean，来配置映射路径和要扫描的接口所在的位置。apiInfo主要配置Swagger2文档网站的信息，比如网站的标题、网站的描述、使用的协议等。</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<p>1）basePackage可以在SwaggerConfig中配置com.weiz.example01.controller，也可以在启动器ComponentScan中配置。</p>
<p>2）需要在SwaggerConfig中配置Swagger的URL映射地址：/swagger-ui.html。</p>
<p>步骤03 添加文档说明内容。</p>
<p>上面的配置完成之后，接下来需要在API上增加内容说明。我们直接在之前的用户管理模块的UserController中增加相应的接口内容说明，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &#123;&quot;用户接口&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户创建成功：&quot;</span>+user.getName());</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">201</span>,<span class="string">&quot;用户创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span></span><br><span class="line">    <span class="meta">@PutMapping(value = &quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户修改成功：&quot;</span>+user.getName());</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">203</span>,<span class="string">&quot;用户修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户删除成功：&quot;</span>+userId);</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">204</span>,<span class="string">&quot;用户删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;查询用户&quot;,notes = &quot;通过用户ID获取用户信息&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(userId);</span><br><span class="line">        user.setName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户成功：&quot;</span>+userId);</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">200</span>,<span class="string">&quot;获取用户成功&quot;</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主要为UserController中的接口增加了接口信息描述，包括接口的用途、请求参数说明等。</p>
<p>1）@Api注解：用来给整个控制器（Controller）增加说明。</p>
<p>2）@ApiOperation注解：用来给各个API方法增加说明。</p>
<p>3）@ApiImplicitParams、@ApiImplicitParam注解：用来给参数增加说明。</p>
<p>步骤04 查看生成的API文档。</p>
<p>完成上面的配置和代码修改之后，Swagger 2就集成到Spring Boot项目中了。接下来启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html，Swagger会自动构建接口说明文档，如图6-4所示。">http://localhost:8080/swagger-ui.html，Swagger会自动构建接口说明文档，如图6-4所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111218974.png" alt="image-20231011121801857"></p>
<p>Swagger自动将用户管理模块的全部接口信息展现出来，包括接口功能说明、调用方式、请求参数、返回数据结构等信息。</p>
<p>在Swagger页面上，我们发现每个接口描述右侧都有一个按钮try it out，单击try it out按钮即可调用该接口进行测试。如图6-5所示，在获取人员信息的接口上单击try it out按钮，输入userId的请求参数“2001”，单击Execute按钮就会将请求发送到后台，从而进行接口验证测试。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111219149.png" alt="image-20231011121926038"></p>
<h3 id="6-3-3-为Swagger添加token参数"><a href="#6-3-3-为Swagger添加token参数" class="headerlink" title="6.3.3　为Swagger添加token参数"></a>6.3.3　为Swagger添加token参数</h3><p>很多时候，客户端在调用API时需要在HTTP的请求头携带通用参数，比如权限验证的token参数等。但是Swagger是怎么描述此类参数的呢？接下来通过示例演示如何为Swagger添加固定的请求参数。</p>
<p>其实非常简单，修改Swagger2Config配置类，利用ParameterBuilder构成请求参数。具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 添加请求参数，这里把token作为请求头参数传入后端</span></span><br><span class="line">                <span class="type">ParameterBuilder</span> <span class="variable">parameterBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterBuilder</span>();</span><br><span class="line">                List&lt;Parameter&gt; parameters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Parameter&gt;();</span><br><span class="line">                parameterBuilder.name(<span class="string">&quot;token&quot;</span>).description(<span class="string">&quot;token令牌&quot;</span>)</span><br><span class="line">                                .modelRef(<span class="keyword">new</span> <span class="title class_">ModelRef</span>(<span class="string">&quot;string&quot;</span>)).parameterType(<span class="string">&quot;header&quot;</span>).required(<span class="literal">false</span>).build();</span><br><span class="line">                parameters.add(parameterBuilder.build());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                                .apiInfo(apiInfo())</span><br><span class="line">                                .select()</span><br><span class="line"></span><br><span class="line">                                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.weiz.example01.controller&quot;</span>))</span><br><span class="line">                                .paths(PathSelectors.any())</span><br><span class="line">                                .build()</span><br><span class="line">                                .globalOperationParameters(parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过ParameterBuilder类把token作为全局统一的参数添加到HTTP的请求头中。系统所有的API都会统一加上此参数。</p>
<p>完成之后重新启动应用，再次查看接口，如图6-6所示，我们可以看到接口参数中已经支持发送token请求参数。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111238129.png" alt="image-20231011123819035"></p>
<p>人员管理模块中的所有API都统一加上了token参数，调用时Swagger会将token参数自动加入HTTP的请求头。</p>
<h3 id="6-3-4-Swagger常用注解"><a href="#6-3-4-Swagger常用注解" class="headerlink" title="6.3.4　Swagger常用注解"></a>6.3.4　Swagger常用注解</h3><p>Swagger提供了一系列注解来描述接口信息，包括接口说明、请求方法、请求参数、返回信息等，常用注解如表6-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111241033.png" alt="image-20231011124137906"></p>
<p>在实际项目中，Swagger除了提供@ApiImplicitParams注解描述简单的参数之外，还提供了用于对象参数的@ApiModel和@ApiModelProperty两个注解，用于封装的对象作为传入参数或返回数据。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel负责描述对象的信息</span><br><span class="line">@ApiModelProperty负责描述对象中属性的相关内容</span><br></pre></td></tr></table></figure>
<p>以上是在项目中常用的一些注解，利用这些注解就可以构建出清晰的API文档</p>
<h1 id="第7章-JdbcTemplate数据连接模板"><a href="#第7章-JdbcTemplate数据连接模板" class="headerlink" title="第7章　JdbcTemplate数据连接模板"></a>第7章　JdbcTemplate数据连接模板</h1><p>本章主要介绍Spring Boot如何使用JdbcTemplate操作数据库、配置多数据源等技术。事实上，JdbcTemplate应该是最简单的数据持久化方案，其使用非常简单。接下来将学习JdbcTemplate数据连接模板的使用。</p>
<h2 id="7-1-JdbcTemplate入门"><a href="#7-1-JdbcTemplate入门" class="headerlink" title="7.1　JdbcTemplate入门"></a>7.1　JdbcTemplate入门</h2><p>本节从基础的部分开始介绍什么是JDBC、什么是JdbcTemplate，然后介绍Spring Boot项目如何使用JdbcTemplate操作数据库。</p>
<h3 id="7-1-1-JdbcTemplate简介"><a href="#7-1-1-JdbcTemplate简介" class="headerlink" title="7.1.1　JdbcTemplate简介"></a>7.1.1　JdbcTemplate简介</h3><h4 id="1-什么是JDBC"><a href="#1-什么是JDBC" class="headerlink" title="1. 什么是JDBC"></a>1. 什么是JDBC</h4><p>JDBC（Java Data Base Connectivity，Java数据库连接）是Java语言中用来规范应用程序如何访问数据库的API，为多种关系数据库提供统一访问方式，诸如查询和更新数据库中数据的方法。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
<h4 id="2-什么是JdbcTemplate"><a href="#2-什么是JdbcTemplate" class="headerlink" title="2. 什么是JdbcTemplate"></a>2. 什么是JdbcTemplate</h4><p>JDBC作为Java访问数据库的API规范，统一了各种数据库的访问方式，但是直接在Java程序中使用JDBC还是非常复杂和烦琐的，所以Spring对JDBC进行了更深层次的封装，而JdbcTemplate就是Spring提供的操作数据库的便捷工具。它主要实现数据库连接的管理，我们可以借助JdbcTemplate来执行所有数据库操作，例如查询、插入、更新、删除等操作，并且有效地避免了直接使用JDBC带来的烦琐编码。</p>
<p>Spring Boot作为Spring的集大成者，自然会将JdbcTemplate集成进去。Spring Boot针对JDBC的使用提供了对应的Starter：spring-boot-starter-jdbc，它其实就是在Spring JDBC上做进一步的封装，方便在Spring Boot项目中更好地使用JDBC。</p>
<h4 id="3-JdbcTemplate的特点"><a href="#3-JdbcTemplate的特点" class="headerlink" title="3. JdbcTemplate的特点"></a>3. JdbcTemplate的特点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">速度快，相对于ORM框架，JDBC的方式是最快的。</span><br><span class="line">配置简单，Spring封装的除了数据库连接之外，几乎没有额外的配置。</span><br><span class="line">使用方便，它更像DBUtils工具类，只需注入JdbcTemplate对象即可。</span><br></pre></td></tr></table></figure>
<h4 id="4-JdbcTemplate的几种类型的方法"><a href="#4-JdbcTemplate的几种类型的方法" class="headerlink" title="4. JdbcTemplate的几种类型的方法"></a>4. JdbcTemplate的几种类型的方法</h4><p>JdbcTemplate虽然简单，但是功能非常强大，它提供了非常丰富、实用的方法，归纳起来主要有以下几种类型的方法：</p>
<p>1）execute()方法：可以用于执行任何SQL语句，一般用于执行DDL语句。</p>
<p>2）update()、batchUpdate()方法：用于执行新增、修改与删除等语句。</p>
<p>3）query()和queryForXXX()方法：用于执行查询相关的语句。</p>
<p>4）call()方法：用于执行数据库存储过程和函数相关的语句。</p>
<p>总的来说，新增、删除与修改3种类型的操作主要使用update()和batchUpdate()方法来完成。query()和queryForObject()方法主要用来完成查询功能。execute()方法可以用来创建、修改、删除数据库表。call()方法则用来调用存储过程。</p>
<p>在大部分情况下，我们都会使用更加强大的持久化框架来访问数据库，比如MyBatis、Hibernate或者Spring Data JPA。之所以介绍JdbcTemplate这种基础的数据库框架，只是希望读者能从基础开始学习，只有掌握了这些基础的框架才能更好地学习其他复杂的ORM框架。</p>
<h3 id="7-1-2-Spring-Boot集成JdbcTemplate"><a href="#7-1-2-Spring-Boot集成JdbcTemplate" class="headerlink" title="7.1.2　Spring Boot集成JdbcTemplate"></a>7.1.2　Spring Boot集成JdbcTemplate</h3><p>Spring Boot集成JDBC很简单，只需要引入依赖并进行基础配置即可。接下来以一个具体的例子来学习如何利用Spring的JdbcTemplate进行数据库操作。</p>
<p>步骤01 添加依赖配置。</p>
<p>在pom.xml配置文件中增加JDBC等相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在pom.xml文件中引入spring-boot-starterjdbc依赖。同时，由于项目中使用MySQL作为数据库，因此项目中需要引入MySQL驱动包。spring-boot-starter-jdbc直接依赖于HikariCP和spring-jdbc。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HikariCP是Spring Boot 2.0默认使用的数据库连接池，也是传说中最快的数据库连接池。</span><br><span class="line">spring-jdbc是Spring框架对JDBC的简单封装，提供了一个简化JDBC操作的开发工具包。</span><br></pre></td></tr></table></figure>
<p>步骤02 创建数据库及表结构。</p>
<p>首先创建jdbctest测试数据库，然后创建student表，包括id、name、sex、age等字段，对应的SQL脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `student`;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">                `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">                `name` varchar(32) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">                `sex` int DEFAULT NULL,</span><br><span class="line">                `age` int DEFAULT NULL,</span><br><span class="line">                PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;;</span><br></pre></td></tr></table></figure>
<p>步骤03 配置数据源</p>
<p>在application.properties中配置MySQL数据库连接相关内容。具体配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，数据库连接配置非常简单，包括数据库连接地址、用户名、密码以及数据驱动，无须其他额外配置。在Spring Boot 2.0中，com.mysql.jdbc.Driver已经过期，推荐使用com.mysql.cj.jdbc.Driver。</p>
<p>步骤04 使用JdbcTemplate。</p>
<p>上面已经把JdbcTemplate集成到Spring Boot项目中，并创建了数据。接下来创建一个单元测试类JdbcTests，验证JdbcTemplate操作数据库。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdbcTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">querytest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(<span class="string">&quot;select * from student &quot;</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        Assert.assertNotNull(list);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是简单地使用JdbcTemplate的测试示例，Spring的JdbcTemplate是自动配置的。使用@Autowired将JdbcTemplate注入需要的Bean中即可直接调用。</p>
<p>单击Run Test或在方法上右击，选择Run ‘querytest’，运行测试方法，结果如图7-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111337679.png" alt="image-20231011133710531"></p>
<p>单元测试queryTest运行成功，并输出了相应的结果。这说明JdbcTemplate已经连接上数据库，并成功执行了数据查询操作。</p>
<p>以上就把JdbcTemplate集成到Spring Boot项目中了。</p>
<h2 id="7-2-使用JdbcTemplate操作数据库"><a href="#7-2-使用JdbcTemplate操作数据库" class="headerlink" title="7.2　使用JdbcTemplate操作数据库"></a>7.2　使用JdbcTemplate操作数据库</h2><p>成功在Spring Boot项目中集成JdbcTemplate后，如何使用JdbcTemplate数据库连接模板操作数据库呢？接下来以示例演示JdbcTemplate实现学生信息的增、删、改、查等操作，让我们在实践中边学边用，更好地理解和吸收。</p>
<h3 id="7-2-1-实现学生数据管理功能"><a href="#7-2-1-实现学生数据管理功能" class="headerlink" title="7.2.1　实现学生数据管理功能"></a>7.2.1　实现学生数据管理功能</h3><p>步骤01 创建实体类。</p>
<p>根据之前创建的Student表结构创建对应的实体类Student，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> sex, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，实体类的数据类型要和数据库字段一一对应。</p>
<p>步骤02 定义Repository接口。</p>
<p>首先，创建StudentRepository接口并定义常用的增、删、改、查接口方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在StudentRepository中定义了save()、update()、delete()和findById()方法。</p>
<p>然后，创建StudentRepositoryImpl类，继承StudentRepository接口，实现接口中的增、删、改、查等方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentRepository</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在StudentRepositoryImpl类上使用@Repository注解用于标注数据访问组件JdbcTemplate，同时在类中注入JdbcTemplate实例。</p>
<p>步骤03 实现增、删、改、查功能。</p>
<p>接下来逐个实现对应的增、删、改、查方法。</p>
<p>1）新增：</p>
<p>在StudentRepositoryImpl类中实现StudentRepository接口中的save()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(),student.getSex(),student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JdbcTemplate中，<strong>除了查询有几个API之外，新增、删除与修改操作统一都调用update()方法来完成</strong>，传入SQL即可。Update()方法的返回值就是SQL执行受影响的行数。</p>
<p>2）删除：</p>
<p>通过用户id删除用户信息，在StudentRepositoryImpl类中实现StudentRepository接口的update( )方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;DELETE FROM Student where id = ? &quot;</span>,id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里读者可能会有疑问：怎么新增、删除、修改都调用update()方法，这与其他的框架不一样？严格来说，新增、删除、修改都属于数据写入，通过update()执行对应的SQL语句即可实现对数据库中数据的变更。</p>
<p>3）修改：</p>
<p>修改和新增类似，在StudentRepositoryImpl类中实现StudentRepository接口的update()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;UPDATE Student SET name = ? , password = ? , age = ?  WHERE id=?&quot;</span>, student.getName(),student.getSex(),student.getAge(),student.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）查询：</p>
<p>根据用户id查询用户信息，同样在StudentRepositoryImpl类中实现StudentRepository接口的findById()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM Student WHERE id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; id &#125;, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Student&gt;(Student.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，JdbcTemplate执行查询相关的语句调用query()方法及queryForXXX()方法，查询对象调用queryForObject方法。JdbcTemplate支持将查询结果转换为实体对象，使用new BeanPropertyRowMapper\<Student>(Student.class)对返回的数据进行封装，它通过名称匹配的方式自动将数据列映射到指定类的实体类中。</p>
<p>在执行查询操作时，需要有一个RowMapper将查询出来的列和实体类中的属性一一对应起来：如果列名和属性名是相同的，那么可以直接使用BeanPropertyRowMapper；如果列名和属性名不同，就需要开发者自己实现RowMapper接口，将数据列与实体类属性字段映射。</p>
<p>步骤04 验证测试。</p>
<p>接下来对封装好的StudentRepository进行测试，测试StudentRepository中的各个方法是否正确。创建StudentRepositoryTests类，将studentRepository注入测试类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentRepositoryImplTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz&quot;</span>,<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">        studentRepository.save(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz&quot;</span>,<span class="number">1</span>,<span class="number">18</span>);</span><br><span class="line">        student.setId(<span class="number">1L</span>);</span><br><span class="line">        studentRepository.update(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        studentRepository.delete(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentRepository.findById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;student == &quot;</span> + student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，依次执行上面的单元测试方法，验证学生信息的增删改查功能是否正常，结果如图7-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111356123.png" alt="image-20231011135647015"></p>
<p>结果表明单元测试执行正常，说明StudentRepository中的方法执行成功，也可以查看数据库中的数据是否符合预期。</p>
<h3 id="7-2-2-复杂查询"><a href="#7-2-2-复杂查询" class="headerlink" title="7.2.2　复杂查询"></a>7.2.2　复杂查询</h3><p>JdbcTemplate除了封装update和query等这些常用的方法外，还可以实现数据的增删改查操作。实际上，JdbcTemplate还封装了execute()、queryForXXX()等许多非常实用的方法，比如需要返回List对象时可以调用queryForList()方法，创建数据库表结构时可以调用execute()方法生成数据库表。下面通过一些简单的示例来演示这些方法的调用。</p>
<h4 id="1-execute-方法"><a href="#1-execute-方法" class="headerlink" title="1. execute()方法"></a>1. execute()方法</h4><p>调用JdbcTemplate的execute()方法执行SQL语句，生成数据库表结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.execute(<span class="string">&quot;CREATE TABLE Student (id integer, name varchar(100))&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面这个示例就是通过调用execute()方法执行建表语句，生成数据库表结构。</p>
<h4 id="2-queryForXXX-方法"><a href="#2-queryForXXX-方法" class="headerlink" title="2. queryForXXX()方法"></a>2. queryForXXX()方法</h4><p>使用JdbcTemplate进行查询时，需要返回各种不同的数据类型，调用queryForXXX()等方法即可。比如需要返回int类型，调用queryForInt()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForInt(<span class="string">&quot;SELECT COUNT(*) FROM Student &quot;</span>);</span><br></pre></td></tr></table></figure>
<p>除了queryForInt()方法之外，还有像queryForList()等很多数据类型的方法可以直接返回需要的数据类型，无须额外的类型转换。</p>
<h4 id="3-数据对象转换"><a href="#3-数据对象转换" class="headerlink" title="3. 数据对象转换"></a>3. 数据对象转换</h4><p>前面提到可以使用BeanPropertyRowMapper类自动将查询到的数据转换为数据对象信息。针对数据库字段和实体属性不一致的情况，JdbcTemplate还提供了自定义RowMapper对象进行属性映射。</p>
<p>首先，创建一个属性映射类StudentRowMapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，自定义的StudentRowMapper类继承JdbcTemplate中的RowMapper类。重写mapRow()方法，将结果集中的数据转换为Student对象。</p>
<p>然后，创建单元测试，验证数据对象转换，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rowMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students = jdbcTemplate.query(<span class="string">&quot;SELECT * FROM student&quot;</span>, <span class="keyword">new</span> <span class="title class_">StudentRowMapper</span>());</span><br><span class="line">    <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+student.getId()+<span class="string">&quot;,name:&quot;</span>+student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，调用query()返回Student列表数据，传入StudentRowMapper参数，将查询结果转换为用户列表并返回。</p>
<h4 id="4-返回主键"><a href="#4-返回主键" class="headerlink" title="4. 返回主键"></a>4. 返回主键</h4><p>前面介绍了数据的新增，但是有些时候需要在数据插入的过程中返回主键，那么可以调用PreparedStatementCreator()，代码如下：``</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">KeyHolder</span> <span class="variable">keyHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedKeyHolder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> jdbcTemplate.update(<span class="keyword">new</span> <span class="title class_">PreparedStatementCreator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PreparedStatement <span class="title function_">createPreparedStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into student (name,sex,age) values (?,?,?);&quot;</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setString(<span class="number">1</span>, student.getName());</span><br><span class="line">            ps.setInt(<span class="number">2</span>, student.getSex());</span><br><span class="line">            ps.setInt(<span class="number">3</span>, student.getAge());</span><br><span class="line">            <span class="keyword">return</span> ps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, keyHolder);</span><br><span class="line">    student.setId(keyHolder.getKey().longValue());</span><br><span class="line">    System.out.println(keyHolder.getKey().longValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，实际上就相当于调用了JDBC中的方法，首先在构建PreparedStatement时传入Statement.RETURN_GENERATED_KEYS，然后传入KeyHolder，最终从KeyHolder中获取刚刚插入数据的id，保存到student对象的id属性中。</p>
<p>单击Run Test或在方法上右击，选择Run ‘save2’，运行测试方法，结果如图7-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111409769.png" alt="image-20231011140913667"></p>
<p>结果表明单元测试方法save2运行成功，并输出了相应的结果。这说明数据已经插入成功并返回了数据的主键id。</p>
<h4 id="5-存储过程"><a href="#5-存储过程" class="headerlink" title="5. 存储过程"></a>5. 存储过程</h4><p>由于各种ORM框架的流行，存储过程的使用场景已经不多见了。但是，JdbcTemplate对存储过程同样进行了良好的封装。下面通过一个示例来演示JdbcTemplate是如何调用存储过程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">resultList</span> <span class="operator">=</span> (List) jdbcTemplate.execute(</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">CallableStatementCreator</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> CallableStatement <span class="title function_">createCallableStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">storedProc</span> <span class="operator">=</span> <span class="string">&quot;&#123;call testpro(?,?)&#125;&quot;</span>;<span class="comment">// 调用的sql</span></span><br><span class="line">           <span class="type">CallableStatement</span> <span class="variable">cs</span> <span class="operator">=</span> con.prepareCall(storedProc);</span><br><span class="line">           cs.setString(<span class="number">1</span>, <span class="string">&quot;p1&quot;</span>);<span class="comment">// 设置输入参数的值</span></span><br><span class="line">           cs.registerOutParameter(<span class="number">2</span>, OracleTypes.CURSOR);<span class="comment">// 注册输出参数的类型</span></span><br><span class="line">           <span class="keyword">return</span> cs;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="keyword">new</span> <span class="title class_">CallableStatementCallback</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">doInCallableStatement</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException,DataAccessException &#123;</span><br><span class="line">           <span class="type">List</span> <span class="variable">resultsMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">           cs.execute();</span><br><span class="line">           <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> (ResultSet) cs.getObject(<span class="number">2</span>);<span class="comment">// 获取游标一行的值</span></span><br><span class="line">           <span class="keyword">while</span> (rs.next()) &#123;<span class="comment">// 转换每行的返回值到Map中</span></span><br><span class="line">              <span class="type">Map</span> <span class="variable">rowMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">              rowMap.put(<span class="string">&quot;id&quot;</span>, rs.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">              rowMap.put(<span class="string">&quot;name&quot;</span>, rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">              resultsMap.add(rowMap);</span><br><span class="line">           &#125;</span><br><span class="line">           rs.close();</span><br><span class="line">           <span class="keyword">return</span> resultsMap;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultList.size(); i++) &#123;</span><br><span class="line">     <span class="type">Map</span> <span class="variable">rowMap</span> <span class="operator">=</span> (Map) resultList.get(i);</span><br><span class="line">     <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> rowMap.get(<span class="string">&quot;id&quot;</span>).toString();</span><br><span class="line">     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rowMap.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">     System.out.println(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;;name=&quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码说明：</p>
<p>1）JdbcTemplete通过execute()方法执行存储过程并获得输出结果。</p>
<p>2）通过CallableStatement类的prepareCall()方法设置调用的存储过程名称和输入、输出参数。</p>
<p>3）通过CallableStatementCallback中的doInCallableStatement()方法执行对应的存储过程，并返回执行结果。</p>
<h2 id="7-3-实战：实现JdbcTemplate多数据源"><a href="#7-3-实战：实现JdbcTemplate多数据源" class="headerlink" title="7.3　实战：实现JdbcTemplate多数据源"></a>7.3　实战：实现JdbcTemplate多数据源</h2><p>上一节使用JdbcTemplate成功地实现了用户信息的增删改查功能，接下来好好研究一下如何配置多数据源。</p>
<h3 id="7-3-1-什么是多数据源"><a href="#7-3-1-什么是多数据源" class="headerlink" title="7.3.1　什么是多数据源"></a>7.3.1　什么是多数据源</h3><p>所谓多数据源，其实就是在一个项目中使用多个数据库实例中的数据库或者同一个数据库实例中多个不同的库。</p>
<p>在实际开发中可能会遇到需要配置多个数据源的情况，比如项目需要使用业务数据库和日志数据库等多个数据库，或者需要使用多种数据库（如MySQL、Oracle、SQL Server等）。</p>
<p>JdbcTemplate多数据源的配置比较简单，因为一个JdbcTemplate实例对应一个DataSource，开发者只需要手动提供多个DataSource，再手动配置相应的JdbcTemplate实例，需要操作哪个数据源就使用对应的JdbcTemplate实例即可。</p>
<h3 id="7-3-2-配置JdbcTemplate多数据源"><a href="#7-3-2-配置JdbcTemplate多数据源" class="headerlink" title="7.3.2　配置JdbcTemplate多数据源"></a>7.3.2　配置JdbcTemplate多数据源</h3><p>接下来在前面项目的基础上进行改造，演示JdbcTemplate是如何配置多数据源的。</p>
<p>步骤01 配置多数据源。</p>
<p>修改application.properties文件，配置数据源连接，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.primary.jdbc-url=jdbc:mysql://localhost:3306/jdbc_test</span><br><span class="line">spring.datasource.primary.username=root</span><br><span class="line">spring.datasource.primary.password=root</span><br><span class="line">spring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.secondary.jdbc-url=jdbc:mysql://localhost:3306/jdbc_test2</span><br><span class="line">spring.datasource.secondary.username=root</span><br><span class="line">spring.datasource.secondary.password=root</span><br><span class="line">spring.datasource.secondary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，先重新创建jdbc_test2数据库，再通过jdbc_test和jdbc_test2两个数据库演示多数据库的情况。我们可以看到上面的配置和原先单数据源的配置有些不同：</p>
<p>1）在application.properties配置文件中添加了两个数据源，通过primary和secondary来区分，分别对应的是jdbc_test和jdbc_test2数据库。</p>
<p>2）单数据源的数据库连接使用spring.datasource.url配置项，多数据源使用spring.datasource.*.jdbc-url配置项。</p>
<p>步骤02 配置JDBC初始化。</p>
<p>创建DataSourceConfig类，在项目启动时读取配置文件中的数据库信息，并对JDBC初始化，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;secondaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">secondaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;primaryJdbcTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">primaryJdbcTemplate</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;secondaryJdbcTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">secondaryJdbcTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，DataSourceConfig类的作用是在项目启动时根据特定的前缀加载不同的数据源，再根据构建好的数据源创建不同的JdbcTemplate。由于Spring容器中存在两个数据源，使用默认的类型查找时会报错，因此加上@Qualifier注解，表示按照名称查找。这里创建了两个JdbcTemplate实例，分别对应了两个数据源。</p>
<p>需要注意的是，使用多个数据源时需要添加@Primary注解，表示自动装配出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者。Primary表示“主要的”，类似于SQL语句中的“Primary Key”（主键），只能有唯一一个，否则会报错。</p>
<p>步骤03 使用多数据源。</p>
<p>配置完成之后如何使用呢？下面通过单元测试实例来演示使用多数据源。在测试列中注入了两个不同数据源的JdbcTemplate实例，测试使用不同的JdbcTemplate插入两条数据，查看两个数据库中是否全部保存成功。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate primaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate secondaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataSourceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz多数据源&quot;</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">    primaryJdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(), student.getSex(), student.getAge());</span><br><span class="line"></span><br><span class="line">    secondaryJdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(), student.getSex(), student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单击Run Test或在方法上右击，选择Run ‘save2’，运行测试方法，结果如图7-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111421980.png" alt="image-20231011142129862"></p>
<p>执行dataSourceTest()单元测试之后，我们看到系统自动创建了HikariPool-1和HikariPool-2两个数据库连接，查看数据库jdbc_test和jdbc_test2中的student表中是否有名为“weiz多数据源”的数据，有则说明多数据源配置成功。其他方法的测试与此大致相同。</p>
<p>这样多数据源就配置成功了。在实际开发的项目中，可以通过实现多数据源配置业务数据库与日志数据库分离。</p>
<h1 id="第8章-数据库持久层框架MyBatis"><a href="#第8章-数据库持久层框架MyBatis" class="headerlink" title="第8章　数据库持久层框架MyBatis"></a>第8章　数据库持久层框架MyBatis</h1><p>数据库是企业应用中非常重要的部分，而MyBatis是流行的数据库持久层框架之一，本章将主要介绍MyBatis的使用。MyBatis支持简单的XML或注解的方式配置与映射数据信息，支持定制化SQL、存储过程以及高级映射，从而避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/">https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java编程的逻辑</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div><div><a href="/2022/11/10/SpringMVC%E5%9F%BA%E7%A1%80/" title="SpringMVC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">SpringMVC基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86Spring-Boot"><span class="toc-number">1.</span> <span class="toc-text">第1章　初识Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Spring-Boot%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.1　Spring Boot是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Boot%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Spring Boot的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-Boot%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Spring Boot的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Spring Boot的核心组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Spring-Boot%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2　Spring Boot的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0Spring-Boot"><span class="toc-number">1.3.</span> <span class="toc-text">1.3　为什么学习Spring Boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE%E2%80%9D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4　什么是“约定优于配置”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Spring%E3%80%81Spring-Boot%E5%92%8CSpring-Cloud%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5　Spring、Spring Boot和Spring Cloud的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%A7%8BSpring-Boot%E4%B9%8B%E6%97%85"><span class="toc-number">2.</span> <span class="toc-text">第2章　开始Spring Boot之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AC%AC%E4%B8%80%E4%B8%AASpring-Boot%E9%A1%B9%E7%9B%AE%EF%BC%9Ahelloworld"><span class="toc-number">2.1.</span> <span class="toc-text">2.1　第一个Spring Boot项目：helloworld</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1　创建Spring Boot项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Spring%E5%AE%98%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9E%84%E5%BB%BA%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1. 使用Spring官网提供的构建页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8IDEA%E6%9E%84%E5%BB%BA"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2. 使用IDEA构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2　项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-pom-xml%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3　pom.xml详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1. 项目的描述信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2. 项目的依赖配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%85%AC%E5%85%B1%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3. 构建时需要的公共变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">4. 构建配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E7%AC%AC%E4%B8%80%E4%B8%AAhelloworld%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4　第一个helloworld程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2　单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Spring-Boot%E9%9B%86%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1　Spring Boot集成单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2. 创建单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">3. 运行单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%B5%8B%E8%AF%95Service%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2　测试Service方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAService%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1. 创建Service测试类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2. 实现单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%B5%8B%E8%AF%95Controller%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3　测试Controller接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4　常用的单元测试注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3　开发环境热部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-devtools%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1　devtools实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2　配置开发环境热部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Spring-Boot%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">第3章　Spring Boot的系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1　系统配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-application-properties"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1　application.properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2. 配置文件加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">3. 修改默认配置文件名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-application-yml"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2　application.yml</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2. 数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-Properties%E4%B8%8EYML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3　Properties与YML配置文件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4　实战：自定义系统的启动图案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.</span> <span class="toc-text">3.2　自定义配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-Value"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1　@Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-Environment"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2　Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ConfigurationProperties"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3　@ConfigurationProperties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. 创建自定义配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 创建实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3. 调用配置项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4　使用配置文件注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3　其他配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1　随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E9%85%8D%E7%BD%AE%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2　配置引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.</span> <span class="toc-text">3.4　日志配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Spring-Boot%E6%97%A5%E5%BF%97%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1　Spring Boot日志简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2　配置日志格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3　日志输出级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BF%9D%E5%AD%98%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4　保存日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">3.5　实战：实现系统多环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1　多环境的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">1. 创建多环境配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">2. 修改配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2　多环境的切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Web%E5%BC%80%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">第4章　Web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Web%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1　Web开发简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Web%E5%85%A5%E9%97%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1　Web入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-spring-boot-starter-web%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">1. spring-boot-starter-web介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">2. Web项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84Web%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">3. 实现简单的Web请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Controller%E5%92%8C-RestController"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2　@Controller和@RestController</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Controller%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1. @Controller的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RestController%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">2. @RestController的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RestController%E5%92%8C-Controller%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">3. @RestController和@Controller的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-RequestMapping"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3　@RequestMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-ResponseBody"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4　@ResponseBody</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-URL%E6%98%A0%E5%B0%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.2　URL映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-URL%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1　URL路径匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1. 精确匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">2. 通配符匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-Method%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2　Method匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-consumes%E5%92%8Cproduces%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3　consumes和produces匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-params%E5%92%8Cheader%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4　params和header匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-params"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">1. params</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-header"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">2. header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.3.</span> <span class="toc-text">4.3　参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-PathVariable"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1　@PathVariable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89URL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">1. 定义URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AAURL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">2. 定义多个URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">3. 匹配正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E4%BD%BF%E7%94%A8Bean%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2　使用Bean对象接收参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0Bean%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1. 增加Bean实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A2%9E%E5%8A%A0%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2. 增加后台方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-RequsetBody%E6%8E%A5%E6%94%B6JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3　@RequsetBody接收JSON数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-ModelAttribute"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4　@ModelAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-ModelAndView%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5　ModelAndView对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="toc-number">4.4.</span> <span class="toc-text">4.4　数据验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-Hibernate-Validator%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1　Hibernate Validator简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2　数据校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JavaBean%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">1. JavaBean参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-URL%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">2. URL参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JavaBean%E5%AF%B9%E8%B1%A1%E7%BA%A7%E8%81%94%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">3. JavaBean对象级联校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">4. 分组校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3　自定义校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">1. 声明一个自定义校验注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">2. 使用自定义校验注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.5　拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1　应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-HandlerInterceptor%E7%AE%80%E4%BB%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2　HandlerInterceptor简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E4%BD%BF%E7%94%A8HandlerInterceptor%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3　使用HandlerInterceptor实现拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">4.6　过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1　过滤器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E4%BD%BF%E7%94%A8FilterRegistrationBean%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2　使用FilterRegistrationBean实现过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Web%E9%85%8D%E7%BD%AE"><span class="toc-number">4.7.</span> <span class="toc-text">4.7　Web配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-WebMvcConfigurer%E7%AE%80%E4%BB%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1　WebMvcConfigurer简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE"><span class="toc-number">4.7.2.</span> <span class="toc-text">4.7.2　跨域访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E9%85%8D%E7%BD%AE"><span class="toc-number">4.7.3.</span> <span class="toc-text">4.7.3　数据转换配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">4.7.4.</span> <span class="toc-text">4.7.4　静态资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-%E8%B7%B3%E8%BD%AC%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.7.5.</span> <span class="toc-text">4.7.5　跳转指定页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.</span> <span class="toc-text">4.8　实战：实现优雅的数据返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.8.1.</span> <span class="toc-text">4.8.1　为什么要统一返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.2.</span> <span class="toc-text">4.8.2　统一数据返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">1. 定义数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">2. 定义状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">4.8.2.3.</span> <span class="toc-text">3. 定义数据处理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.2.4.</span> <span class="toc-text">4. 处理数据返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.8.2.5.</span> <span class="toc-text">5. 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.8.3.</span> <span class="toc-text">4.8.3　全局异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.8.3.1.</span> <span class="toc-text">1. 全局异常处理的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-ControllerAdvice%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.8.3.2.</span> <span class="toc-text">2. 使用@ControllerAdvice注解实现全局异常处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">第5章　Thymeleaf模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Thymeleaf%E5%85%A5%E9%97%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1　Thymeleaf入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-Thymeleaf%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1　Thymeleaf简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Thymeleaf%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1. Thymeleaf的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Thymeleaf%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">2. Thymeleaf的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-Spring-Boot%E4%BD%BF%E7%94%A8Thymeleaf"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2　Spring Boot使用Thymeleaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-Thymeleaf%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3　Thymeleaf常用的配置参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Thymeleaf%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2　Thymeleaf表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1　变量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%80%89%E6%8B%A9%E6%88%96%E6%98%9F%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2　选择或星号表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-URL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3　URL表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">1. 引入静态资源文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-%E2%80%A6-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">2. 使用 @{…} 设置背景图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-URL%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">3. URL链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E6%96%87%E5%AD%97%E5%9B%BD%E9%99%85%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4　文字国际化表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">5.3　表达式的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1　赋值和拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E8%B5%8B%E5%80%BC"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">（1）文本赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E6%9C%AC%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">（2）文本拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2　条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-switch"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3　switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4　循环遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.</span> <span class="toc-text">5.3.5　运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">1. 算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">2. 关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.3.</span> <span class="toc-text">3. 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.4.</span> <span class="toc-text">4. 三目运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Thymeleaf%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">5.4　Thymeleaf的高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1　内联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">1. 文本内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%9A%E6%9C%AC%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">2. 脚本内联</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程的逻辑"/></a><div class="content"><a class="title" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑">Java编程的逻辑</a><time datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript高级程序设计（第三版）"/></a><div class="content"><a class="title" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）">JavaScript高级程序设计（第三版）</a><time datetime="2023-10-05T14:44:18.000Z" title="发表于 2023-10-05 22:44:18">2023-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树的技巧"/></a><div class="content"><a class="title" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧">二叉树的技巧</a><time datetime="2023-08-15T04:23:33.000Z" title="发表于 2023-08-15 12:23:33">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表的技巧"/></a><div class="content"><a class="title" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧">链表的技巧</a><time datetime="2023-08-14T04:03:55.000Z" title="发表于 2023-08-14 12:03:55">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>