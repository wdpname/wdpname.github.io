<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring Boot从入门到实战 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot从入门到实战">
<meta property="og:url" content="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-09T07:04:53.000Z">
<meta property="article:modified_time" content="2023-10-09T15:30:12.979Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot从入门到实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-09 23:30:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Boot从入门到实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T15:30:12.979Z" title="更新于 2023-10-09 23:30:12">2023-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot从入门到实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第1章-初识Spring-Boot"><a href="#第1章-初识Spring-Boot" class="headerlink" title="第1章　初识Spring Boot"></a>第1章　初识Spring Boot</h1><h2 id="1-1-Spring-Boot是什么"><a href="#1-1-Spring-Boot是什么" class="headerlink" title="1.1　Spring Boot是什么"></a>1.1　Spring Boot是什么</h2><p>Spring Boot是由Pivotal团队提供的基于Spring的全新框架</p>
<p>Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。</p>
<p>Spring Boot的核心设计思想是“约定优于配置”</p>
<p>比如在使用Spring开发Web项目时，我们需要配置web.xml、Spring和MyBatis等，还需要将它们集成在一起。而使用Spring Boot一切将变得极其简单，它采用了大量的默认配置来简化这些文件的配置过程，只需引入对应的<strong>Starters</strong>（启动器）。</p>
<p>Spring Boot可以构建一切。设计它就是为了使用最少的配置，以最快的速度来启动和运行Spring项目。</p>
<h3 id="1-Spring-Boot的背景"><a href="#1-Spring-Boot的背景" class="headerlink" title="1. Spring Boot的背景"></a>1. Spring Boot的背景</h3><p>Spring Boot建立在Spring基础之上，遵循“约定优于配置”的原则，避免了创建项目或框架时必须做的繁杂配置，帮助开发者以最少的工作量，更加简单、方便地使用现有Spring中的所有功能组件。</p>
<h3 id="2-Spring-Boot的特性"><a href="#2-Spring-Boot的特性" class="headerlink" title="2. Spring Boot的特性"></a>2. Spring Boot的特性</h3><p>Spring Boot的一系列特性使得微服务架构的落地变得非常容易，对于目前众多的技术栈，Spring Boot是Java领域微服务架构的最优落地技术。图1-1所示为Spring Boot的一些特性。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091507170.png" alt="image-20231009150724075"></p>
<h3 id="3-Spring-Boot的核心组件"><a href="#3-Spring-Boot的核心组件" class="headerlink" title="3. Spring Boot的核心组件"></a>3. Spring Boot的核心组件</h3><p>Spring Boot官方提供了很多当前流行的基础功能组件的封装，命名一般以<strong>spring-boot-starter</strong>开头，比如spring-boot-starter-quartz定时任务组件和spring-boot-starter-thymeleaf页面模板引擎等</p>
<p>很多第三方中间件也按照Spring Boot的规范提供了针对Spring Boot项目的Starters（启动器），一般以组件名开头，比如MyBatis针对Spring Boot提供的组件包<strong>mybatis-spring-boot-starter</strong>。</p>
<h2 id="1-2-Spring-Boot的优点"><a href="#1-2-Spring-Boot的优点" class="headerlink" title="1.2　Spring Boot的优点"></a>1.2　Spring Boot的优点</h2><ol>
<li>遵循“约定优于配置”的原则</li>
<li>使用JavaConfig，避免使用XML的烦琐。</li>
<li>提供Starters（启动器），简化Maven配置，避免依赖冲突。</li>
<li>提供内嵌Servlet容器，可选择内嵌Tomcat、Jetty等容器，不需要单独的Web服务器。这意味着不再需要启动Tomcat或其他任何中间件。</li>
<li>提供了一系列项目中常见的非功能特性，如安全监控、应用监控、健康检测等。</li>
<li>与云计算、微服务的天然集成。</li>
</ol>
<p>Spring Boot就是尽可能地简化应用开发的门槛，让应用开发、测试、部署变得更加简单。</p>
<h2 id="1-3-为什么学习Spring-Boot"><a href="#1-3-为什么学习Spring-Boot" class="headerlink" title="1.3　为什么学习Spring Boot"></a>1.3　为什么学习Spring Boot</h2><p>最近几年，Spring生态圈最流行的技术框架莫过于Spring Boot和Spring Cloud。目前，各个企业都在推动微服务技术架构的落地，将一个复杂的应用拆分成多个小的独立模块，分开部署，互不干扰，从而达到松散耦合、提高开发效率和降低运维成本的目的。</p>
<p>Spring Boot作为微服务框架的基础被越来越多地应用于企业级开发中，它是Spring Cloud的基础。要学习Spring Cloud，就必须了解Spring Boot框架的架构和设计理念。</p>
<p>Spring Boot是Spring生态下的一个子项目，用于快速、敏捷地开发新一代基于Spring框架的应用程序。同时，它将目前各种比较成熟的服务框架和第三方组件组合起来（如Redis、MongoDB、JPA、RabbitMQ、Quartz等），按照“约定优于配置”的设计思想封装成Starters组件。这样，我们在Spring Boot应用中几乎可以零配置地使用这些组件，达到开箱即用的效果，从而从繁杂的配置中解放出来，更加专注于业务逻辑的开发。</p>
<p>Spring Boot让构建、编码、配置、部署、监控都变得非常简单</p>
<p>pring Boot不是新的语言、新的技术，它只是把现有的比较流行的框架集成在一起，遵循“约定优于配置”的原则，开箱即用，使得我们不需要再去关注那些烦琐的配置</p>
<h2 id="1-4-什么是“约定优于配置”"><a href="#1-4-什么是“约定优于配置”" class="headerlink" title="1.4　什么是“约定优于配置”"></a>1.4　什么是“约定优于配置”</h2><p>从本质上来说，系统、类库或框架应该约定合理的默认值，开发者仅需规定应用中不符合约定的部分。例如，如果模型中有一个名为Product的类，那么数据库中对应的表就会默认命名为product，只有在偏离这个约定时才需要定义有关这个名字的配置，例如将该表命名为product_info。</p>
<p>简单来说“约定优于配置”就是遵循约定。如果你所用工具的约定配置符合你的要求，那么就可以省去此配置；不符合，就通过修改相关的配置来达到你所期待的方式。</p>
<p>Spring Boot是Spring对“约定优于配置”的最佳实践产物。小到配置文件、中间件的默认配置，大到内置容器、Spring生态中的各种Starters，无不遵循“约定优于配置”的设计思想。</p>
<h2 id="1-5-Spring、Spring-Boot和Spring-Cloud的关系"><a href="#1-5-Spring、Spring-Boot和Spring-Cloud的关系" class="headerlink" title="1.5　Spring、Spring Boot和Spring Cloud的关系"></a>1.5　Spring、Spring Boot和Spring Cloud的关系</h2><p>Spring是一个开源生态体系，是集大成者。其核心是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）。正是IoC和AOP这两个核心功能成就了强大的Spring，Spring在这两大核心功能上不断地发展壮大，才有了Spring MVC等一系列成熟的产品，最终构建了功能强大的Spring生态帝国。</p>
<p>Spring Boot是在Spring的基础上发展而来的，它不是为了取代Spring，而是为了简化Spring应用的创建、运行、调试、部署，让开发者更容易地使用Spring。它将目前各种比较成熟的服务框架和第三方组件组合起来，按照“约定优于配置”的设计思想进行重新封装，屏蔽掉复杂的配置和实现，最终给开发者提供一套简单、易用、易部署、易维护的分布式系统开发工具包。</p>
<p>Spring Cloud是基于Spring Boot实现的分布式微服务框架，它利用Spring Boot简单、易用、便利的特性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、断路器、数据监控等基础组件都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>我们都知道，采用微服务架构，服务的数量会非常多，管理特别麻烦，而Spring Cloud就是一套分布式微服务治理框架，可以说是这些微服务的大管家。作为大管家Spring Cloud就需要提供各种组件和方案来治理与维护整个微服务系统，比如服务之间的通信、熔断、监控等。Spring Cloud利用Spring Boot的特性集成了开源行业中优秀的组件，在微服务架构中对外提供了一套服务治理的解决方案。</p>
<p>Spring Boot在Spring Cloud中起到了承上启下的作用，如果要学习Spring Cloud，则必须学习Spring Boot。三者之间的关系如图1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091515451.png" alt="image-20231009151526413"></p>
<h1 id="第2章-开始Spring-Boot之旅"><a href="#第2章-开始Spring-Boot之旅" class="headerlink" title="第2章　开始Spring Boot之旅"></a>第2章　开始Spring Boot之旅</h1><p>本章主要介绍如何开始Spring Boot项目，通过一个简单的helloworld程序演示Spring Boot的项目结构与启动流程，然后介绍Spring Boot是如何进行单元测试的，最后介绍非常实用的功能：配置开发环境热部署</p>
<h2 id="2-1-第一个Spring-Boot项目：helloworld"><a href="#2-1-第一个Spring-Boot项目：helloworld" class="headerlink" title="2.1　第一个Spring Boot项目：helloworld"></a>2.1　第一个Spring Boot项目：helloworld</h2><p>本节从简单的helloworld程序开始介绍创建Spring Boot项目的方法和流程，以及Spring Boot项目结构，最后介绍项目中非常重要的pom.xml文件。</p>
<h3 id="2-1-1-创建Spring-Boot项目"><a href="#2-1-1-创建Spring-Boot项目" class="headerlink" title="2.1.1　创建Spring Boot项目"></a>2.1.1　创建Spring Boot项目</h3><p>有两种方式来构建Spring Boot项目的基础框架：第一种是使用Spring官网提供的构建页面，第二种是使用IntelliJ IDEA中的Spring插件。</p>
<h4 id="1-使用Spring官网提供的构建页面"><a href="#1-使用Spring官网提供的构建页面" class="headerlink" title="1. 使用Spring官网提供的构建页面"></a>1. 使用Spring官网提供的构建页面</h4><p>步骤01 访问Spring官网。</p>
<p>步骤02 选择构建工具为Maven Project，编程语言选择Java，Spring Boot版本为2.3.7，填写项目基本信息，具体如图2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091519078.png" alt="image-20231009151910048"></p>
<p>步骤03 单击Generate创建并下载项目压缩包。</p>
<p>步骤04 解压后，使用IDEA引入项目，选择File→Open File or Project，选择解压后的文件夹，单击OK按钮，项目即可创建完成。</p>
<h4 id="2-使用IDEA构建"><a href="#2-使用IDEA构建" class="headerlink" title="2. 使用IDEA构建"></a>2. 使用IDEA构建</h4><p>步骤01 选择File→New→Project命令，弹出新建项目的对话框。</p>
<p>步骤02 选择Spring Initializr，单击Next按钮出现配置界面，IDEA已经帮助做了集成。如图2-2所示，IDEA界面中的Group、Artifact等输入框就对应着项目的pom.xml中的groupId、artifactId等配置项。</p>
<p>填完相关的信息之后，直接单击NEXT按钮来创建项目。</p>
<h3 id="2-1-2-项目结构"><a href="#2-1-2-项目结构" class="headerlink" title="2.1.2　项目结构"></a>2.1.2　项目结构</h3><p>Spring Boot的基础结构共有3个主要目录，具体如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/java：程序开发以及主程序目录。src/main/resources：配置文件和资源文件目录。src/test/java：测试程序目录。</span><br></pre></td></tr></table></figure>
<p>从上面我们可以了解到，新建的helloworld项目只有java、resources、test三个基础结构目录。通常，完整的项目包括前台页面、model实体、数据库访问、公共基础类等非常多的文件和目录，Spring Boot建议的目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">myproject</span><br><span class="line">        +-src</span><br><span class="line">                +- main</span><br><span class="line">                        +- java</span><br><span class="line">                                +- com.example.myproject</span><br><span class="line">                                        +- comm</span><br><span class="line">                                        +- model</span><br><span class="line">                                        +- repository</span><br><span class="line">                                        +- service</span><br><span class="line">                                        +- web</span><br><span class="line">                                        +- Application.java</span><br><span class="line">                        +- resources</span><br><span class="line">                                +- <span class="keyword">static</span></span><br><span class="line">                                +- templates</span><br><span class="line">                                +- application.properties</span><br><span class="line">                        +- test</span><br><span class="line">        +-pom.xml</span><br></pre></td></tr></table></figure>
<p>如上所示，其实就是把java、resources、test三大基础目录进行细化，定义每个子目录存放的文件和作用。</p>
<p>1）java目录下的com.example.myproject为后台java文件的根目录，包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application.java：建议放到根目录下，是项目的启动类，注意Spring Boot项目只能有一个main()方法入口。</span><br><span class="line">comm：建议放置公共的类，如全局的配置文件、工具类等。</span><br><span class="line">model：主要用于实体（Entity）。</span><br><span class="line">repository：主要是数据库访问层代码。</span><br><span class="line">service：主要是业务类代码。</span><br><span class="line">web：负责前台页面访问的Controller路由。</span><br></pre></td></tr></table></figure>
<p>2）resources目录下包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static：存放Web访问的静态资源，如JS、CSS、图片等。</span><br><span class="line">templates：存放页面模板。</span><br><span class="line">application.properties：存放项目的配置信息。</span><br></pre></td></tr></table></figure>
<p>3）test目录存放单元测试的代码，目录结构和java目录保持一致。</p>
<p>4）pom.xml用于配置项目依赖包以及其他配置。</p>
<p>采用Spring Boot推荐的默认配置可以省掉很多设置。当然，也可以根据技术规范进行调整。至此，我们的第一个Spring Boot项目就创建完成了。</p>
<h3 id="2-1-3-pom-xml详解"><a href="#2-1-3-pom-xml详解" class="headerlink" title="2.1.3　pom.xml详解"></a>2.1.3　pom.xml详解</h3><p>pom.xml配置文件主要分为四部分，下面就来一一介绍pom.xml文件的各个组成部分以及它们的作用。</p>
<h4 id="1-项目的描述信息"><a href="#1-项目的描述信息" class="headerlink" title="1. 项目的描述信息"></a>1. 项目的描述信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wei<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置内容基本是创建项目时定义的有关项目的基本描述信息，其中比较重要的是groupId、artifactId。各个属性说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupId：项目的包路径。</span><br><span class="line">artifactId：项目名称。</span><br><span class="line">version：项目版本号。</span><br><span class="line">packaging：一般有jar、war两个值，表示使用Maven打包时是构建成JAR包还是WAR包。</span><br><span class="line">name：项目名称。d</span><br><span class="line">escription：项目描述。</span><br></pre></td></tr></table></figure>
<h4 id="2-项目的依赖配置信息"><a href="#2-项目的依赖配置信息" class="headerlink" title="2. 项目的依赖配置信息"></a>2. 项目的依赖配置信息</h4><p>此部分为项目的依赖信息，主要包括Spring Boot的版本信息和第三方组件的版本信息。示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>项目的依赖信息主要分为parent和dependencies两部分。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent：配置父级项目的信息。Maven支持项目的父子结构，引入后会默认继承父级的配置。此项目		中引入spring-boot-starter-parent定义Spring Boot的基础版本。</span><br><span class="line">dependencies：配置项目所需要的依赖包，Spring Boot体系内的依赖组件不需要填写具体版本		号，spring-boot-starter-parent维护了体系内所有依赖包的版本信息。</span><br></pre></td></tr></table></figure>
<p>另外，<dependency>标签是Maven项目定义依赖库的重要标签，通过groupId、artifactId等“坐标”信息定义依赖库的路径信息。</p>
<h4 id="3-构建时需要的公共变量"><a href="#3-构建时需要的公共变量" class="headerlink" title="3. 构建时需要的公共变量"></a>3. 构建时需要的公共变量</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置了项目构建时所使用的编码、输出所使用的编码，最后指定了项目使用的JDK版本。</p>
<h4 id="4-构建配置"><a href="#4-构建配置" class="headerlink" title="4. 构建配置"></a>4. 构建配置</h4><p>此部分为构建配置信息，这里使用Maven构建Spring Boot项目，所以必须在<plugins>中添加spring-boot-maven-plugin插件，它能够以Maven的方式为应用提供Spring Boot的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置spring-boot-maven-plugin构建插件，将Spring Boot应用打包为可执行的JAR或WAR文件，然后以简单的方式运行Spring Boot应用。如果需要更改为Docker构建方式，则只要更改此部分即可。</p>
<h3 id="2-1-4-第一个helloworld程序"><a href="#2-1-4-第一个helloworld程序" class="headerlink" title="2.1.4　第一个helloworld程序"></a>2.1.4　第一个helloworld程序</h3><p>步骤01 在目录src\main\java\com\weiz\helloworld\controller下创建HelloController，然后添加/hello的路由地址和方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Hello @ Spring Boot!!! &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了HelloController并创建了一个hello()方法，最后使用@RestController和@RequestMapping注解实现HTTP路由。</p>
<p>1）@RestController表示HelloController为数据处理控制器。Spring Boot中有Controller和RestController两种控制器，都用来表示Spring中某个类是否可以接收HTTP请求，但不同的是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Controller：返回数据和页面，处理HTTP请求。</span><br><span class="line">@RestController：返回客户端数据请求，主要用于RESTful接口。</span><br></pre></td></tr></table></figure>
<p>可以说@RestController是@Controller与@ResponseBody的结合体，因而具有两个标注合并起来的作用。</p>
<p>2）@RequestMapping(“/hello”)提供路由映射，意思是”/hello”路径的HTTP请求都会被映射到hello()方法上进行处理。</p>
<p>步骤02 运行helloworld程序。</p>
<p>​    右击项目中的HelloApplication→run命令就可以启动项目，若出现如图2-4所示的内容则表    示启动成功。</p>
<p>​    通过系统的启动日志可以看到，系统运行在8080端口。如果需要切换到其他端口，可在        application.properties配置文件中自行定义。</p>
<p>步骤03 打开浏览器，访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。">http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091710024.png" alt="image-20231009171027923"></p>
<h2 id="2-2-单元测试"><a href="#2-2-单元测试" class="headerlink" title="2.2　单元测试"></a>2.2　单元测试</h2><p>单元测试在日常项目开发中必不可少，Spring Boot提供了完善的单元测试框架和工具用于测试开发的应用。接下来介绍Spring Boot为单元测试提供了哪些支持，以及如何在Spring Boot项目中进行单元测试。</p>
<h3 id="2-2-1-Spring-Boot集成单元测试"><a href="#2-2-1-Spring-Boot集成单元测试" class="headerlink" title="2.2.1　Spring Boot集成单元测试"></a>2.2.1　Spring Boot集成单元测试</h3><p>单元测试主要用于测试单个代码组件，以确保代码按预期方式工作。目前流行的有JUnit或TestNG等测试框架。Spring Boot封装了单元测试组件spring-boot-starter-test。下面通过示例演示Spring Boot是如何实现单元测试的。</p>
<h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><p>首先创建Spring Boot项目。在项目中引入spring-boot-starter-test组件，示例配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建单元测试"><a href="#2-创建单元测试" class="headerlink" title="2. 创建单元测试"></a>2. 创建单元测试</h4><p>在src/test目录下新建一个HelloTest测试类，如果只想输出一句“Hello Spring Boot Test”，只需要用一个@Test注解即可。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Spring Boot Test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的上面添加@SpringBootTest注解，系统会自动把这段程序加载到Spring Boot容器。@Test注解表示该方法为单元测试方法。</p>
<h4 id="3-运行单元测试"><a href="#3-运行单元测试" class="headerlink" title="3. 运行单元测试"></a>3. 运行单元测试</h4><p>单击Run Test或在方法上右击，再选择“Run ‘hello’”，运行测试方法，运行结果如图2-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091731926.png" alt="image-20231009173126887"></p>
<p>由图2-6可知，单元测试方法运行成功并输出相应的结果，同时IDEA也会显示运行的所有单元测试结果，包括测试是否通过、运行时间、测试总数和成功次数等。以上示例中的测试方法只是spring-boot-starter-test组件中的一部分功能，Spring Boot自带的spring-boot-starter-test框架对测试的支持非常完善，包括Web请求测试、Service方法测试等，后面会逐一介绍。</p>
<h3 id="2-2-2-测试Service方法"><a href="#2-2-2-测试Service方法" class="headerlink" title="2.2.2　测试Service方法"></a>2.2.2　测试Service方法</h3><p>一般使用Spring Boot进行单元测试主要是针对Service和API（Controller）进行。接下来通过示例演示Spring Boot如何测试Service方法。</p>
<h4 id="1-创建Service测试类"><a href="#1-创建Service测试类" class="headerlink" title="1. 创建Service测试类"></a>1. 创建Service测试类</h4><p>创建Service测试类非常简单，使用IDEA可以一键自动创建单元测试类。首先，选择需要测试的Service类或方法，然后在对应的Service类中右击，选择Go To→Test→Create New Test，打开如图2-7所示的创建测试类界面。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091732413.png" alt="image-20231009173236378"></p>
<p>单击OK按钮，IDEA会在Test目录下创建一个UserServiceTest测试类，并为勾选的测试类自动生成单元测试的方法。</p>
<h4 id="2-实现单元测试"><a href="#2-实现单元测试" class="headerlink" title="2. 实现单元测试"></a>2. 实现单元测试</h4><p>在上面创建好的UserServiceTest类中会自动创建对应的单元测试方法，我们只需要在测试方法中实现对应的测试代码即可，具体的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;1002&quot;</span>, userService.findOne());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如以上示例代码所示，在自动测试类上增加@SpringBootTest注解即可。首先注入需要测试的Service，然后在单元测试中调用该方法，最后通过Assert断句判断返回结果是否正确。</p>
<p>执行单元测试也非常简单，只需将鼠标放在对应的方法上，右击并选择Run执行该方法即可。</p>
<h3 id="2-2-3-测试Controller接口方法"><a href="#2-2-3-测试Controller接口方法" class="headerlink" title="2.2.3　测试Controller接口方法"></a>2.2.3　测试Controller接口方法</h3><p>上面是针对Service进行测试，但是有时需要对API（Controller）进行测试，这时需要用到MockMvc类。MockMvc能够模拟HTTP请求，使用网络的形式请求Controller中的方法，这样可以使得测试速度快、不依赖网络环境，而且它提供了一套完善的结果验证工具，测试和验证也非常简单、高效。</p>
<p>spring-boot-starter-test具备强大的Mock能力，使用@WebMvcTest等注解实现模拟HTTP请求测试。下面通过示例演示如何测试Controller接口。</p>
<p>步骤01 创建Controller的测试类HelloControllerTest，实现单元测试方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HelloController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/hello&quot;</span>)   <span class="comment">//执行一个请求</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))       <span class="comment">//接收的数据类型</span></span><br><span class="line">                .andExpect(status().isOk())  <span class="comment">//添加执行完成后的断句，请求的状态响应码//是否为200，如果不是则测试不通过</span></span><br><span class="line">                .andDo(print()); <span class="comment">//添加一个结果处理程序，表示要对结果进行处理，比如此处//使用print()输出整个响应结果信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过使用MockMvc构造一个post请求，MockMvcRequestBuilders可以支持post和get请求，调用print()方法将请求和相应的过程都打印出来。示例代码说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MockMvcRequestBuilders.post(&quot;/hello&quot;)：构造一个post请求。</span><br><span class="line">contentType (MediaType.APPLICATION<span class="emphasis">_JSON))：设置JSON返回编码，避免出现中文乱码的问题。</span></span><br><span class="line"><span class="emphasis">andExpect(status().isOk())：执行完成后的断句，请求的状态响应码是否为200，如果不是则测试不通过。</span></span><br><span class="line"><span class="emphasis">andDo(print())：添加一个结果处理程序，表示要对结果进行处理，比如此处调用print()输出整个响应结果信息。</span></span><br></pre></td></tr></table></figure>
<p>步骤02 执行单元测试。</p>
<p>完成测试方法之后，执行测试方法：将鼠标放在对应的方法上，右击并选择Run执行该方法即可。可以看到输出如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line"><span class="code">      HTTP Method = POST</span></span><br><span class="line"><span class="code">      Request URI = /hello</span></span><br><span class="line"><span class="code">       Parameters = &#123;&#125;</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;application/json;charset=UTF-8&quot;]</span></span><br><span class="line"><span class="code">             Body = null</span></span><br><span class="line"><span class="code">    Session Attrs = &#123;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Handler:</span><br><span class="line"><span class="code">             Type = com.weiz.helloworld.web.HelloController</span></span><br><span class="line"><span class="code">           Method = com.weiz.helloworld.web.HelloController#hello()</span></span><br><span class="line"><span class="code">Async:</span></span><br><span class="line"><span class="code">    Async started = false</span></span><br><span class="line"><span class="code">     Async result = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Resolved Exception:</span><br><span class="line"><span class="code">             Type = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">ModelAndView:</span><br><span class="line"><span class="code">        View name = null</span></span><br><span class="line"><span class="code">             View = null</span></span><br><span class="line"><span class="code">            Model = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">FlashMap:</span><br><span class="line"><span class="code">       Attributes = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line"><span class="code">           Status = 200</span></span><br><span class="line"><span class="code">    Error message = null</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;text/plain;charset=UTF-8&quot;, Content-Length:&quot;17&quot;]</span></span><br><span class="line"><span class="code">     Content type = text/plain;charset=UTF-8</span></span><br><span class="line"><span class="code">             Body = hello Spring Boot</span></span><br><span class="line"><span class="code">    Forwarded URL = null</span></span><br><span class="line"><span class="code">   Redirected URL = null</span></span><br><span class="line"><span class="code">          Cookies = []</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出中可以看到，返回完整的Http Response，包括Status=200、Body = hello Spring Boot，说明接口请求成功并成功返回。</p>
<p>如果接口有登录验证，则需要通过MockHttpSession注入用户登录信息，或者修改登录拦截器取消对单元测试的登录验证。</p>
<h3 id="2-2-4-常用的单元测试注解"><a href="#2-2-4-常用的单元测试注解" class="headerlink" title="2.2.4　常用的单元测试注解"></a>2.2.4　常用的单元测试注解</h3><p>在实际项目中，除了@SpringBootTest、@Test等注解之外，单元测试还有很多非常实用的注解，具体说明如表2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091815842.png" alt="image-20231009181555796"></p>
<h2 id="2-3-开发环境热部署"><a href="#2-3-开发环境热部署" class="headerlink" title="2.3　开发环境热部署"></a>2.3　开发环境热部署</h2><p>本节介绍Spring Boot非常实用的功能：开发环境热部署。在实际的项目开发调试过程中会频繁地修改后台类文件，导致需要重新编译、重新启动，整个过程非常麻烦，影响开发效率。下面介绍Spring Boot如何解决这个问题。</p>
<h3 id="2-3-1-devtools实现原理"><a href="#2-3-1-devtools实现原理" class="headerlink" title="2.3.1　devtools实现原理"></a>2.3.1　devtools实现原理</h3><p>我们在开发调试Spring Boot项目时，需要经历重新编译、重新启动程序的过程。由于系统启动时，需要加载一系列的组件和依赖包，因此整个过程非常耗时，大大影响开发效率。</p>
<p>Spring Boot在这方面做了很好的支持，提供了spring-boot-devtools组件，使得无须手动重启Spring Boot应用即可重新编译、启动项目，大大缩短编译、启动的时间，从而提高开发效率。</p>
<p>spring-boot-devtools的核心是两个类加载器（ClassLoader）：一个是Base类加载器（Base ClassLoader），负责加载那些不会改变的类，如第三方JAR包等；另一个是Restart类加载器（Restart ClassLoader），负责加载那些正在开发的会改变的类。这样如果只修改Java代码，devtools只会重新加载被修改的类文件，不会重新加载其他第三方的JAR包，所以重启较快，从而达到热部署的效果。</p>
<p>我们在项目中引入devtools组件之后，devtools会监听classpath下的文件变动，当文件被修改时会重新编译，重新生成类文件；devtools监听到类文件变动，触发Restart类加载器重新加载该类，从而实现类文件和属性文件的热部署。</p>
<p>需要注意的是，并不是所有的更改都需要重启应用（如静态资源、视图模板）。我们可以通过设置spring.devtools.restart.exclude属性来指定一些文件或目录的修改不用重启应用。例如，可以设置/static和/public下的所有文件更新都不触发应用重启。</p>
<h3 id="2-3-2-配置开发环境热部署"><a href="#2-3-2-配置开发环境热部署" class="headerlink" title="2.3.2　配置开发环境热部署"></a>2.3.2　配置开发环境热部署</h3><p>步骤01 在pom.xml配置文件中添加dev-tools依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    &lt;!— optional依赖是否传递，设置为true时，表示依赖不会传递 --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用optional=true表示依赖不会传递，即该项目依赖devtools；其他项目如果引入此项目生成的JAR包，则不会包含devtools，如果想要使用devtools，则需要重新引入。</p>
<p>步骤02 在application.properties中配置devtools。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 热部署生效</span><br><span class="line">spring.devtools.restart.enabled=true</span><br><span class="line"># 设置重启的目录</span><br><span class="line">spring.devtools.restart.additional-paths=src/main/java</span><br><span class="line"># classpath目录下的WEB-INF文件夹内容修改不重启</span><br><span class="line">spring.devtools.restart.exclude=WEB-INF/**</span><br></pre></td></tr></table></figure>
<p>上面的配置主要是打开devtools热部署，然后指定监控的后台文件目录，最后指明文件变更不需要重新编译部署的目录。配置完成之后，devtools会监听classpath下的文件变动，并且会立即重启应用。</p>
<p>需要注意的是，devtools也可以实现前台页面热部署，即页面修改后会立即生效，需要在application.properties文件中配置spring.thymeleaf.cache=false，以指定不缓存前端页面。</p>
<p>步骤03 验证配置是否生效。</p>
<p>配置完成后，需要验证热部署是否生效。首先启动项目，修改项目中的某个java文件，然后在IDEA后台可以看到devtools自动重启应用，后台日志输出如图2-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091834482.png" alt="image-20231009183402406"></p>
<p>我们手动修改java后台代码就会发现Spring Boot已经重新编译该文件，然后自动重新加载，无须手动重启。</p>
<h1 id="第3章-Spring-Boot的系统配置"><a href="#第3章-Spring-Boot的系统配置" class="headerlink" title="第3章　Spring Boot的系统配置"></a>第3章　Spring Boot的系统配置</h1><p>我们知道Spring Boot遵循“约定优于配置”的原则，绝大部分配置项都约定了默认值，Spring Boot甚至可以做到无须任何手动配置就能启动成功，这大大降低了系统配置的复杂程度。当然，Spring Boot也支持自定义修改系统配置，比如系统端口、启动图案、数据库连接等配置。下面介绍Spring Boot在实际项目中使用到的系统配置、如何自定义配置。</p>
<h2 id="3-1-系统配置文件"><a href="#3-1-系统配置文件" class="headerlink" title="3.1　系统配置文件"></a>3.1　系统配置文件</h2><p>本节讲述Spring Boot的系统配置文件，包括application.properties和application.yml配置文件的使用以及YML和Properties配置文件有什么区别，最后介绍如何更改Spring Boot的启动图案。</p>
<h3 id="3-1-1-application-properties"><a href="#3-1-1-application-properties" class="headerlink" title="3.1.1　application.properties"></a>3.1.1　application.properties</h3><p>Spring Boot支持两种不同格式的配置文件：一种是Properties，另一种是YML。Spring Boot默认使用application.properties作为系统配置文件，项目创建成功后会默认在resources目录下生成application.properties文件。该文件包含Spring Boot项目的<strong>全局配置</strong>。我们可以在application.properties文件中配置Spring Boot支持的所有配置项，比如端口号、数据库连接、日志、启动图案等。接下来将介绍在Spring Boot项目开发过程中与配置相关的一些知识。</p>
<h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>Spring Boot项目创建成功后会默认resources目录下会自动创建application.properties文件。使用也非常简单，配置格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<p>在上面的示例中配置了应用的启动端口。如果不配置此项，则默认使用8080端口；如果需要使用其他端口，则通过server.port=8081修改系统启动端口。</p>
<p>此外，Properties文件中的配置项可以是无序的，但是为了保证配置文件清晰易读，建议把相关的配置项放在一起，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># thymeleaf 模板</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">spring.thymeleaf.mode=HTML</span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br></pre></td></tr></table></figure>
<p>以上示例将thymeleaf模板相关的配置放在一起，这样看起来清晰明了，从而便于快速找到thymeleaf的所有配置。</p>
<h4 id="2-配置文件加载顺序"><a href="#2-配置文件加载顺序" class="headerlink" title="2. 配置文件加载顺序"></a>2. 配置文件加载顺序</h4><p>Spring Boot项目的配置文件默认存放在resources目录中。实际上，Spring Boot系统启动时会读取4个不同路径下的配置文件：</p>
<p>1）项目根目录下的config目录。</p>
<p>2）项目根目录。</p>
<p>3）classpath下的config目录。</p>
<p>4）classpath目录。</p>
<p>Spring Boot会从这4个位置全部加载主配置文件，这4个位置中的application.properties文件的优先级按照上面列出的顺序依次降低。如果同一个属性都出现在这4个文件中，则以优先级高的文件为准。</p>
<h4 id="3-修改默认配置文件名"><a href="#3-修改默认配置文件名" class="headerlink" title="3. 修改默认配置文件名"></a>3. 修改默认配置文件名</h4><p>可能有人会问，项目的配置文件必须命名为application.properties吗？当然不是，我们可以通过修改项目启动类，调用SpringApplicationBuilder类的properties()方法来实现自定义配置文件名称。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(ApplicationDemo.class)</span><br><span class="line">           .properties(<span class="string">&quot;spring.config.location=classpath:/ application.propertie&quot;</span>).run(args);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot项目启动加载时默认读取更改名称的配置文件，即可修改默认加载的application.yml文件名。</p>
<h3 id="3-1-2-application-yml"><a href="#3-1-2-application-yml" class="headerlink" title="3.1.2　application.yml"></a>3.1.2　application.yml</h3><p>application.yml是以yml为后缀，使用YAML（YAML Ain’t a Markup Language）的配置文件。与XML等标记语言相比，YMAL结构更清晰易读，更适合用作属性配置文件。</p>
<h4 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>YML基本语法为key:（空格）value的键值对形式，冒号后面必须加上空格。通过空格的缩进来控制属性的层级关系，只要是左对齐的一列数据，都是同一个层级的。具体格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">max-history:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">10MB</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，自定义配置了系统的日志级别、文件路径等属性。可以看到logging下包含level和file两个子配置项。</p>
<p>YML文件虽然格式简洁直观，但是对格式要求较高，使用YML配置文件时需要注意以下几点：</p>
<p>1）属性值和冒号中间必须有空格，如name: Weiz正确，使用name:Weiz就会报错。</p>
<p>2）需要注意各属性之间的缩进和对齐。</p>
<p>3）缩进不允许使用tab，只允许空格。</p>
<p>4）属性和值区分字母大小写。</p>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h4><p>YML文件以数据为中心，支持数组、JSON对象、Map等多种数据格式，因此更适合用作配置文件。</p>
<p>（1）普通的值（数字、字符串、布尔值）</p>
<p>普通的数据通过k:v的键值对形式直接编写，普通的值类型或字符串默认不用加上单引号或者双引号。</p>
<p>当然，也可以使用双引号（””）来转义字符串中的特殊字符，特殊字符转义后就表示它自身的意思，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;zhangsan \n lisi&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br></pre></td></tr></table></figure>
<p>使用单引号（’’）不会转义特殊字符，所有字符都按照普通字符处理，作为字符串数据，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&#x27;zhangsan \n lisi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：zhangsan \n lisi。“\n”字符作为普通的字符串，而不转义为换行。</p>
<p>（2）对象、Map（属性和值）</p>
<p>对象同样是以k:v的键值对方式展现的，只是对象的各个属性和值的关系通过换行和缩进方式来编写。示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>如果使用行内写法，可以将对象的属性和值写成JSON格式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（3）数组（List、Set）</p>
<p>数组是以- value的形式表示数组中的元素的，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">wangwu</span></span><br></pre></td></tr></table></figure>
<p>还可以采用行内写法，数组使用中括号的形式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span> [<span class="string">zhangsan</span>, <span class="string">lisi</span>, <span class="string">wangwu</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以看到，YML文件除了支持基本的数据类型之外，还支持对象、Map、JSON、数组等格式，这样可以在配置文件中直接定义想要的数据类型，无须额外转换。这也是程序员喜欢用application.yml的原因之一。</p>
<h3 id="3-1-3-Properties与YML配置文件的区别"><a href="#3-1-3-Properties与YML配置文件的区别" class="headerlink" title="3.1.3　Properties与YML配置文件的区别"></a>3.1.3　Properties与YML配置文件的区别</h3><p>Spring Boot中的配置文件有Properties或者YML两种格式。一般情况下，两者可以随意使用，我们可以根据自己的使用习惯选择适合的配置文件格式。这两者完全一样吗？肯定不是，YML和Properties配置文件的区别如下：</p>
<p>1）YML文件以数据为中心，对于数据的支持和展现非常友好。</p>
<p>2）Properties文件对格式的要求没那么严格，而YML文件以空格的缩进来控制层级关系，对格式的要求比较高，缩进格式不对时容易出错。</p>
<p>3）Properties文件支持@PropertySource注解，而YML文件不支持。</p>
<p>4）YML文件支持多文档块的使用方式，使用起来非常灵活。</p>
<p>5）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<h3 id="3-1-4-实战：自定义系统的启动图案"><a href="#3-1-4-实战：自定义系统的启动图案" class="headerlink" title="3.1.4　实战：自定义系统的启动图案"></a>3.1.4　实战：自定义系统的启动图案</h3><p>我们知道Spring Boot程序启动时，控制台会输出由一串字符组成的Spring符号的启动图案（Banner）以及版本信息（见图3-1）。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091848972.png" alt="image-20231009184827930"></p>
<p>Spring Boot自带的启动图案是否可以自定义呢？答案是肯定的。下面通过示例来演示如何自定义Spring Boot的启动图案。</p>
<p>步骤01 在项目的resources目录下新建banner.txt，示例代码如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">##     ## ###### ##       ##        #######</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">######## ######  ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ###### ####### #######  #######</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">Application Name: $&#123;application.title&#125;</span><br><span class="line">Application Version: $&#123;application.formatted-version&#125;</span><br><span class="line">Spring Boot Version: $&#123;spring-boot.formatted-version&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，通过${}获取application.properties配置文件中的相关配置信息，如Spring Boot版本、应用的版本、应用名称等信息。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;：设置控制台中输出内容的颜色，可以自定义，具体参考  			org.springframework.boot.ansi.AnsiColor。</span><br><span class="line">$&#123;application.version&#125;：用来获取MANIFEST.MF文件中的版本号，这就是在		  		Application.java中指定SpringVersion.class的原因。</span><br><span class="line">$&#123;application.formatted-version&#125;：格式化后的&#123;application.version&#125;版本信息。$&#123;spring-boot.version&#125;：Spring Boot的版本号。</span><br><span class="line">$&#123;spring-boot.formatted-version&#125;：格式化后的&#123;spring-boot.version&#125;版本信息。</span><br></pre></td></tr></table></figure>
<p>步骤02 在application.properties中配置banner.txt的路径等信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Banner 配置文件的位置</span></span><br><span class="line"><span class="string">spring.banner.location=/banner.txt</span></span><br><span class="line"><span class="comment"># 是否显示横幅图案</span></span><br><span class="line"><span class="comment"># 可选值有3个，一般不需要修改</span></span><br><span class="line"><span class="comment"># console:显示在控制台</span></span><br><span class="line"><span class="comment"># log:显示在文件</span></span><br><span class="line"><span class="comment"># off:不显示</span></span><br><span class="line"><span class="comment"># spring.main.banner-mode=console</span></span><br><span class="line"><span class="string">application.version=1.0.0.0</span></span><br><span class="line"><span class="string">application.formatted-version=v1.0.0.0</span></span><br><span class="line"><span class="string">spring-boot.version=2.1.2.RELEASE</span></span><br><span class="line"><span class="string">spring-boot.formatted-version=v2.1.2.RELEASE</span></span><br><span class="line"><span class="string">application.title=My</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>在上面的配置中，在application中设置banner.txt文件的路径、应用的版本、Spring Boot的版本等信息。</p>
<p>步骤03 启动项目，查看修改之后的启动横幅图案是否生效，如图3-2所示</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091850116.png" alt="image-20231009185040066"></p>
<p>通过系统输出的启动日志可以看到，系统的启动图案已经变成我们自定义的样子，也就是Spring Boot的默认启动图案已经更改成自定义的启动图案。</p>
<p>Spring Boot也支持使用GIF、JPG和PNG格式的图片文件来定义横幅图案。当然，并不会把图片直接输出在控制台上，而是将图片中的像素解析并转换成ASCII编码字符之后再输出到控制台上。</p>
<h2 id="3-2-自定义配置项"><a href="#3-2-自定义配置项" class="headerlink" title="3.2　自定义配置项"></a>3.2　自定义配置项</h2><p>本节将介绍Spring Boot实现自定义配置项（也称为配置属性）。在项目开发的过程中，经常需要自定义系统业务方面的配置文件及配置项，Spring Boot如何实现自定义属性配置呢？其实非常简单，Spring Boot提供了@Value注解、@ConfigurationProperties注解和Environment接口等3种方式自定义配置项。</p>
<h3 id="3-2-1-Value"><a href="#3-2-1-Value" class="headerlink" title="3.2.1　@Value"></a>3.2.1　@Value</h3><p>在实际项目中，经常需要在配置文件中定义一些简单的配置项，Spring Boot提供@Value注解来设置简单的配置项，默认读取application.properties文件中的配置属性。下面通过示例来演示使用@Value注解添加自定义配置项。</p>
<p>首先，在application.properties配置文件中添加自定义配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们添加了firstname和secondname两个自定义配置项。</p>
<p>然后，在使用的位置调用@Value注解来获取配置项的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.firstname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String firstName;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.secondname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String secondName;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过@Value注解获取了配置文件中对应的配置项的值。</p>
<p>需要注意的是：</p>
<p>1）使用@Value注解时，所在类必须被Spring容器管理，也就是使用@Component、@Controller、@Service等注解定义的类。</p>
<p>2）@Value需要传入完整的配置项的Key值。</p>
<p>3）@Value注解默认读取application.properties配置文件，如果需要使用其他的配置文件，可以通过@PropertySource注解指定对应的配置文件。</p>
<h3 id="3-2-2-Environment"><a href="#3-2-2-Environment" class="headerlink" title="3.2.2　Environment"></a>3.2.2　Environment</h3><p>Environment是Spring为运行环境提供的高度抽象的接口，它会自动获取系统加载的全部配置项，包括命令行参数，系统属性，系统环境，随机数，配置文件等。使用时无须其他的额外配置，只要在使用的类中注入Environment即可。下面通过示例演示Environment读取系统自定义的配置项。</p>
<p>首先，在application.properties配置文件中增加如下的配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在application.properties中配置了firstname和secondname两个自定义配置项。Environment读取的是系统中所有的配置。我们既可以在application.properties中设置自定义的配置项，又可以在自定义配置文件中添加配置项。</p>
<p>然后，创建单元测试方法，并注入Environment读取系统配置。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getEnv</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.firstname&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.secondname&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Environment使用的示例代码，非常简单。不过，使用Environment时还需要注意以下两点：</p>
<p>1）使用Environment无须指定配置文件，其获取的是系统加载的全部配置文件中的配置项。</p>
<p>2）需要注意配置文件的编码格式，默认为ISO8859-1。</p>
<h3 id="3-2-3-ConfigurationProperties"><a href="#3-2-3-ConfigurationProperties" class="headerlink" title="3.2.3　@ConfigurationProperties"></a>3.2.3　@ConfigurationProperties</h3><p>在实际项目开发中，需要注入的配置项非常多时，前面所讲的@value和Environment两种方法就会比较烦琐。这时可以使用注解@ConfigurationProperties将配置项和实体Bean关联起来，实现配置项和实体类字段的关联，读取配置文件数据。下面通过示例演示@ConfigurationProperties注解如何读取配置文件。</p>
<h4 id="1-创建自定义配置文件"><a href="#1-创建自定义配置文件" class="headerlink" title="1. 创建自定义配置文件"></a>1. 创建自定义配置文件</h4><p>在resources下创建自定义的website.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.resource.name</span>=<span class="string">weiz</span></span><br><span class="line"><span class="attr">com.weiz.resource.website</span>=<span class="string">www.weiz.com</span></span><br><span class="line"><span class="attr">com.weiz.resource.language</span>=<span class="string">java</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，创建了自定义的website.properties配置文件。增加了name、website、language等三个配置项，这些配置项的名称的前缀都是com.weiz.resource。</p>
<h4 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2. 创建实体类"></a>2. 创建实体类</h4><p>创建WebSiteProperties自定义配置对象类，然后使用@ConfigurationProperties注解将配置文件中的配置项注入到自定义配置对象类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.weiz.resource&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line">    <span class="keyword">private</span> String language;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getWebsite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWebsite</span><span class="params">(String website)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.website = website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getLanguage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> language;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLanguage</span><span class="params">(String language)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.language = language;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，我们使用了@Configuration注解、@ConfigurationProperties和@PropertySource三个注解来定义WebSiteProperties实体类：</p>
<p>1）@Configuration定义此类为配置类，用于构建bean定义并初始化到Spring容器。</p>
<p>2）@ConfigurationProperties(prefix = “com.weiz.resource”)绑定配置项，其中prefix表示所绑定的配置项名的前缀。</p>
<p>3）@PropertySource(value = “classpath:website.properties”)指定读取的配置文件及其路径。@PropertySource不支持引入YML文件。</p>
<p>通过上面的WebSiteProperties类即可读取全部对应的配置项。</p>
<h4 id="3-调用配置项"><a href="#3-调用配置项" class="headerlink" title="3. 调用配置项"></a>3. 调用配置项</h4><p>使用配置实体类中的方式也非常简单，只需将WebSiteProperties注入到需要使用的类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSiteProperties website;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(website.getName());</span><br><span class="line">    System.out.println(website.getWebsite());</span><br><span class="line">    System.out.println(website.getLanguage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-使用配置文件注意事项"><a href="#3-2-4-使用配置文件注意事项" class="headerlink" title="3.2.4　使用配置文件注意事项"></a>3.2.4　使用配置文件注意事项</h3><p>在实际项目中会碰到很多读取配置文件的应用场景，需要注意各种坑，否则会让你很惆怅。所以，我总结了一些使用配置文件时需要注意的事项：</p>
<p>1）使用YML文件时注意空格和格式缩进。</p>
<p>2）Properties文件默认使用的是ISO8859-1编码格式，容易出现乱码问题。如果含有中文，加入spring.http.encoding.charset=UTF-8配置即可。</p>
<p>3）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<p>4）@PropertySource注解默认只会加载Properties文件，YML文件不能使用此注解。</p>
<p>5）简单值推荐使用@Value，复杂对象推荐使用@ConfigurationProperties。</p>
<p>6）只有Spring容器中的组件才能使用容器提供的各类方法，所以，配置读取类需要增加@Component注解才能加入Spring容器中。</p>
<h2 id="3-3-其他配置"><a href="#3-3-其他配置" class="headerlink" title="3.3　其他配置"></a>3.3　其他配置</h2><p>上一节介绍了自定义的配置，根据项目的需要自定义配置属性。Spring Boot支持很多非常实用的参数配置功能。本节介绍Spring Boot配置生成随机数、配置引用等实际项目中的实用配置。</p>
<h3 id="3-3-1-随机数"><a href="#3-3-1-随机数" class="headerlink" title="3.3.1　随机数"></a>3.3.1　随机数</h3><p>在项目开发过程中，可能需要配置生成随机数，比如说随机配置的服务器端口、随机生成登录密钥等等。Spring Boot支持在系统加载时配置随机数，使用${random}可以生成各种不同类型的随机值，从而简化代码生成的麻烦，例如生成int值、long值、string字符串。</p>
<p>Spring Boot提供的RandomValuePropertySource配置类可以很方便地生成随机数，可以生成integer、long、uuids和string类型的数据。下面通过示例来演示如何配置生成随机数。</p>
<p>首先，在application.properties中添加随机数的配置项。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机字符串</span></span><br><span class="line"><span class="attr">cfg.random.value</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="comment"># uuid</span></span><br><span class="line"><span class="attr">cfg.random.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="comment"># 随机int</span></span><br><span class="line"><span class="attr">cfg.random.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="comment"># 随机long</span></span><br><span class="line"><span class="attr">cfg.random.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="comment"># 10以内的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test1</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="comment"># 10-20的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test2</span>=<span class="string">$&#123;random.int[10,20]&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，在application.properties配置文件中增加配置项以使用${radom.xxx}的形式实现生成随机数。</p>
<p>然后，创建配置映射类ConfigRandomValue获取随机数配置项，读取配置项的方式和读取普通配置项的方式一样：通过@Value或者@ConfigurationProperties注解来读取。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigRandomValue</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.number&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.bignumber&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> bigNumber;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.uuid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number2;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，验证随机数配置是否生效。创建单元测试，验证随机数是否生成成功。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigRandomValue randomValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(randomValue.getSecret());</span><br><span class="line">    System.out.println(randomValue.getUuid());</span><br><span class="line">    System.out.println(randomValue.getBigNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber2());</span><br><span class="line">    System.out.println(randomValue.getNumber3());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先注入了自定义的随机数生成配置类，然后调用了相关的配置项来验证随机数规则是否生效。</p>
<h3 id="3-3-2-配置引用"><a href="#3-3-2-配置引用" class="headerlink" title="3.3.2　配置引用"></a>3.3.2　配置引用</h3><p>Spring Boot支持使用占位符获取之前的属性配置，也就是在后一个配置的值中直接引用先前定义过的配置项，直接解析其中的值。这样做的好处是：在多个具有相互关联的配置项中，只需要对其中一处配置项预先设置，其他地方都可以引用，省去了后续多处修改的麻烦。</p>
<p>使用格式为：${name}，name表示先前在配置文件中已经设置过的配置项名。下面通过示例演示如何在配置文件中实现参数引用。</p>
<p>我们修改application.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.name</span>=<span class="string">ZhangSan</span></span><br><span class="line"><span class="attr">my.sex</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name&#125;.</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先设置了my.name=ZhangSan；接着在my.des配置项中使用${my.name}来引用my.name配置项的值。my.des获取到的是：My name is ZhangSan。</p>
<p>${my.name}还可以使用“:”指定默认值，避免没有配置参数导致程序异常，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name:weiz&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过冒号“:”设置配置项的默认值为：weiz，如果配置项为空或者未找到该配置项，系统也不会出错，my.des获取到的是：My name is weiz。</p>
<p>随机数和配置引用非常简单，在项目开发过程中非常实用。</p>
<h2 id="3-4-日志配置"><a href="#3-4-日志配置" class="headerlink" title="3.4　日志配置"></a>3.4　日志配置</h2><p>我们知道日志对于系统监控、故障定位非常重要，比如当生产系统发生问题时，完整清晰的日志记录有助于快速定位问题。接下来介绍Spring Boot对日志的支持。</p>
<h3 id="3-4-1-Spring-Boot日志简介"><a href="#3-4-1-Spring-Boot日志简介" class="headerlink" title="3.4.1　Spring Boot日志简介"></a>3.4.1　Spring Boot日志简介</h3><p>Spring Boot自带spring-boot-starter-logging库实现系统日志功能，spring-boot-starter-logging组件默认使用LogBack日志记录工具。系统运行日志默认输出到控制台，也能输出到文件中。下面通过示例来演示Spring Boot项目配置日志的功能。</p>
<p>修改pom.xml文件，添加spring-boot-starter-logging依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动项目，查看控制台的日志输出情况，如图3-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092018150.png" alt="image-20231009201809999"></p>
<p>在默认情况下，Spring Boot会用LogBack来记录日志，并用INFO级别输出到控制台。运行应用程序，可以看到很多INFO级别的日志。</p>
<h3 id="3-4-2-配置日志格式"><a href="#3-4-2-配置日志格式" class="headerlink" title="3.4.2　配置日志格式"></a>3.4.2　配置日志格式</h3><p>在Spring Boot项目中配置日志功能之后，如何定制自己的日志格式、自定义记录的信息呢？Spring Boot提供了logging.pattern.console和logging.pattern.file配置项来定制日志输出格式，只需在application.properties文件中添加logging.pattern.console的配置项即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</span><br></pre></td></tr></table></figure>
<p>上述配置的示例中，对应符号的含义如下：</p>
<p>%d{HH:mm:ss.SSS}：日志输出时间。</p>
<p>%thread：输出日志的进程名，这在Web应用以及异步任务处理中很有用。</p>
<p>%-5level：日志级别，使用5个字符靠左对齐。</p>
<p>%logger-：日志输出者的名称。</p>
<p>%msg：日志消息。</p>
<p>%n：平台的换行符。</p>
<p>修改完配置项再重启项目，查看控制台的日志输出情况，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092035331.png" alt="image-20231009203539284"></p>
<p>Spring Boot控制台启动日志的格式已经改成配置的格式。</p>
<h3 id="3-4-3-日志输出级别"><a href="#3-4-3-日志输出级别" class="headerlink" title="3.4.3　日志输出级别"></a>3.4.3　日志输出级别</h3><p>一般而言，系统的日志级别为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt;FATAL，级别逐渐提高。如果日志级别设置为INFO，则意味着TRACE和DEBUG级别的日志都不会输出。</p>
<p>Spring Boot通过logging.level配置项来设置日志输出级别，下面通过示例演示Spring Boot日志输出级别。</p>
<p>首先，添加Log级别测试类LogDemo，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">logMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从trace到error日志级别由低到高</span></span><br><span class="line">        <span class="comment">// 可以调整输出的日志级别，日志就只会在这个级别后的高级别生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;LogDemo trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;LogDemo debug日志...&quot;</span>);</span><br><span class="line">        <span class="comment">// Spring Boot默认使用的是info级别，没有指定级别就用Spring Boot默认规定的级别，即root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;LogDemo info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;LogDemo warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;LogDemoerror日志...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello log&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，针对每个日志级别输出了一行日志。我们可以调整输出的日志级别，让其只在该级别以后的高级别生效。</p>
<p>然后，配置日志输出级别，在application.properties中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=warn</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用logging.level.root指定整个项目的日志级别为WARN。当然，我们也可以对某个包指定单独的日志级别，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=INFO</span><br><span class="line">logging.level.com.weiz.example01.log=WARN</span><br></pre></td></tr></table></figure>
<p>在上面的配置示例，我们将整个项目的日志级别设置为INFO，同时将指定包com.weiz.example01下的日志级别设置为WARN。</p>
<p>最后，启动项目验证日志的输出情况，如图3-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092037071.png" alt="image-20231009203750022"></p>
<p>如图3-5所示，Spring Boot控制台输出的系统启动日志为INFO级别，而com.weiz.example01.log下LogDemo的日志级别设置为WARN，输出了WARN、INFO和ERROR的日志。</p>
<h3 id="3-4-4-保存日志文件"><a href="#3-4-4-保存日志文件" class="headerlink" title="3.4.4　保存日志文件"></a>3.4.4　保存日志文件</h3><p>一般情况下，在开发环境中习惯通过控制台查看日志，但是生产环境中需要将日志信息保存到磁盘上，以便于日后的日志查询。应该如何配置才能将日志信息保存到日志文件内呢？下面演示保存日志文件的过程。</p>
<p>在resources目录下的application.properties配置文件中添加如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.file.name=D:/var/log/spring_log.log</span><br></pre></td></tr></table></figure>
<p>重新启动项目，可以看到在D:/var/log目录下生成了spring_log.log文件，该文件的内容和控制台打印输出的内容一致，如图3-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092043631.png" alt="image-20231009204300583"></p>
<h2 id="3-5-实战：实现系统多环境配置"><a href="#3-5-实战：实现系统多环境配置" class="headerlink" title="3.5　实战：实现系统多环境配置"></a>3.5　实战：实现系统多环境配置</h2><p>在实际项目开发的过程中，需要面对不同的运行环境，比如开发环境、测试环境、生产环境等，每个运行环境的数据库、Redis服务器等配置都不相同，每次发布测试、更新生产都需要手动修改相关系统配置。这种方式特别麻烦，费时费力，而且出错的概率极大。庆幸的是，Spring Boot为我们提供了更加简单方便的配置方案来解决多环境的配置问题，下面就来演示Spring Boot系统如何实现多环境配置。</p>
<h3 id="3-5-1-多环境的配置"><a href="#3-5-1-多环境的配置" class="headerlink" title="3.5.1　多环境的配置"></a>3.5.1　多环境的配置</h3><p>通常应用系统可能在开发环境（dev）、测试环境（test）、生产环境（prod）中运行，那么如何做到多个运行环境配置灵活、快速切换呢？Spring Boot提供了极简的解决方案，只需要简单的配置，应用系统就能灵活切换运行环境配置。</p>
<h4 id="1-创建多环境配置文件"><a href="#1-创建多环境配置文件" class="headerlink" title="1. 创建多环境配置文件"></a>1. 创建多环境配置文件</h4><p>创建多环境配置文件时，需要遵循Spring Boot允许的命名约定来命名，格式为application-{profile}.properties，其中{profile}为对应的环境标识。在项目resources目录下分别创建application-dev.properties、application-test.properties和application-prod.properties三个配置文件，对应开发环境、测试环境和生产环境，如图3-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092045861.png" alt="image-20231009204506816"></p>
<p>如图3-7所示，根据应用系统中常见的三个运行环境拆分成了多个不同的配置文件，分别独立配置上面各运行环境的配置项。具体如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties为项目主配置文件，包含项目所需的所有公共配置。</span><br><span class="line">application-dev.properties为开发环境配置文件，包含项目所需的单独配置。</span><br><span class="line">application-test.properties为测试环境配置文件。</span><br><span class="line">application-prod.properties为生产环境配置文件。</span><br></pre></td></tr></table></figure>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>通常情况下，开发环境、测试环境和生产环境使用的数据库是不一样的，所以接下来以不同环境配置不同数据库为例来演示多环境的配置。</p>
<p>首先，修改application.properties，配置系统的启动端口：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8088</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，application.properties包含项目所需的所有公共配置，这里配置系统的启动端口，所有环境的启动端口都是8088。</p>
<p>然后，修改application-dev.properties开发环境的配置，增加数据库的连接配置，代码示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 指定数据库驱动</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"># 数据库jdbc连接url地址</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/myapp_dev</span><br><span class="line"># 数据库账号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></table></figure>
<p>配置数据库连接的相关属性，我们看到开发环境配置的数据库是myapp_dev。</p>
<p>其他环境的配置文件修改对应的配置连接即可，以上项目的多环境配置就完成了。接下来演示切换项目运行环境。</p>
<h3 id="3-5-2-多环境的切换"><a href="#3-5-2-多环境的切换" class="headerlink" title="3.5.2　多环境的切换"></a>3.5.2　多环境的切换</h3><p>前面讲了如何配置多环境，那么，在实际测试、运行过程中如何切换系统运行环境呢？这个也非常简单，通过修改application.properties配置文件中的spring.profiles.active配置项来激活相应的运行环境。如果没有指定任何profile的配置文件，Spring Boot默认会启动application-default.properties（默认环境）。</p>
<p>指定项目的启动环境有以下3种方式：</p>
<p>（1）配置文件指定项目启动环境</p>
<p>Spring Boot支持通过spring.profiles.active配置项目启动环境，在application.properties配置文件中增加如下配置项指定对应的环境目录：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 系统运行环境</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过在application.properties配置文件中设置spring.profiles.active的配置项来配置系统的运行环境。这里配置的是dev开发环境。</p>
<p>（2）IDEA编译器指定项目启动环境</p>
<p>一般在IDEA启动时，直接在IDEA的Run/debug Configuration页面配置项目启动环境，如图3-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092048033.png" alt="image-20231009204827985"></p>
<p>如图3-8所示，项目调试运行时，IDEA编译器可以通过VM options、Program arguments、Active profiles三个参数设置启动方式。</p>
<p>（3）命令行启动指定项目环境</p>
<p>在命令行通过java -jar命令启动项目时，需要如下指定启动环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.<span class="property">jar</span> --spring.<span class="property">profiles</span>.<span class="property">active</span>=dev</span><br></pre></td></tr></table></figure>
<p>如上所示，程序打包之后，可以在命令行使用java -jar的方式启动，并设置启动参数spring.profiles.active=dev，以开发环境为默认配置。在application-{profile}.properties中配置完成后，启动项目时，在系统启动日志中可以看到加载的是哪个环境的配置文件，如图3-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092051552.png" alt="image-20231009205139509"></p>
<p>在上面的启动日志中可以看到系统目前启动的是dev开发环境。如果实现相关的数据库测试方法，可以验证相应的数据库操作是否生效。</p>
<h1 id="第4章-Web开发"><a href="#第4章-Web开发" class="headerlink" title="第4章　Web开发"></a>第4章　Web开发</h1><p>本章主要讲解Spring Boot开发Web应用的相关技术点，包括使用spring-boot-starter-web组件来实现Web应用开发、URL地址映射、参数传递、数据校验规则等，然后介绍统一数据返回和统一异常处理，最后介绍如何根据项目需求配置Web项目，包括拦截器、跨域访问、视图解析、数据格式化等。</p>
<h2 id="4-1-Web开发简介"><a href="#4-1-Web开发简介" class="headerlink" title="4.1　Web开发简介"></a>4.1　Web开发简介</h2><p>本节主要介绍Spring Boot对Web应用开发提供了哪些支持，首先介绍Spring Boot 提供的Web组件spring-boot-starter-web，然后介绍@Controller和@RestController注解，以及控制数据返回的@ResponseBody注解，最后介绍Web配置，以便让读者对使用Spring Boot开发Web系统有初步的了解。</p>
<h3 id="4-1-1-Web入门"><a href="#4-1-1-Web入门" class="headerlink" title="4.1.1　Web入门"></a>4.1.1　Web入门</h3><p>当前，Spring毫无疑问已经成为Java企业应用开发的标准框架之一，它提供了众多的可配置功能模块和第三方组件，几乎可以解决企业开发中的所有问题。不过，Spring也带来了复杂的配置项，这对初学者而言简直就是灾难，于是Spring Boot应运而生。Spring Boot将传统Web开发的mvc、json、validation、tomcat等框架整合，提供了spring-boot-starter-web组件，简化了Web应用配置、开发的难度，将初学者从繁杂的配置项中解放出来，专注于业务逻辑的实现。</p>
<h4 id="1-spring-boot-starter-web介绍"><a href="#1-spring-boot-starter-web介绍" class="headerlink" title="1. spring-boot-starter-web介绍"></a>1. spring-boot-starter-web介绍</h4><p>Spring Boot自带的spring-boot-starter-web组件为Web应用开发提供支持，它内嵌的Tomcat以及Spring MVC的依赖使用起来非常方便。</p>
<p>Spring Boot创建Web应用非常简单，先创建一个普通的Spring Boot项目，然后修改pom.xml文件将spring-boot-starter-web组件加入项目就可以创建Web应用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们使用IDEA编辑器打开新创建的Web项目。打开Maven中的Dependencies，查看spring-boot-starter-web启动器（Starters）会引入哪些依赖JAR包，如图4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092217758.png" alt="image-20231009221716617"></p>
<p>由图4-1可见，spring-boot-starter-web启动器主要包括web、webmvc、json、tomcat等基础依赖组件，作用是提供Web开发场景所需的所有底层依赖。其中webmvc为Web开发的基础框架，json为JSON数据解析组件，tomcat为自带的容器依赖。所以，只需引入spring-boot-starter-web启动器即可实现Web应用开发，而无须额外引入Tomcat以及其他Web依赖文件。</p>
<p>另外，开发Web应用可能还会用到模板引擎，Spring Boot提供了大量的模板引擎，包括FreeMarker、Groovy、Thymeleaf、Velocity和Mustache等。Spring Boot官方推荐使用Thymeleaf。</p>
<h4 id="2-Web项目结构"><a href="#2-Web项目结构" class="headerlink" title="2. Web项目结构"></a>2. Web项目结构</h4><p>Spring Boot的Web应用与其他的Spring Boot应用基本没有区别，只是resources目录中多了static静态资源目录以及templates页面模板目录。Spring Boot Web项目结构如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092219453.png" alt="image-20231009221907411"></p>
<h4 id="3-实现简单的Web请求"><a href="#3-实现简单的Web请求" class="headerlink" title="3. 实现简单的Web请求"></a>3. 实现简单的Web请求</h4><p>Spring Boot不像传统的MVC框架那样必须继承某个基础类才能处理HTTP请求，只需要在类上声明@Controller注解，标注这是一个控制器，然后使用@RequestMapping注解把HTTP请求映射到对应的方法即可。具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，@RequestMapping注解用于定义请求的路由地址，既可以作用在方法上，又可以作用在类上。</p>
<p>启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。">http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。</a></p>
<h3 id="4-1-2-Controller和-RestController"><a href="#4-1-2-Controller和-RestController" class="headerlink" title="4.1.2　@Controller和@RestController"></a>4.1.2　@Controller和@RestController</h3><p>Spring Boot提供了@Controller和@RestController两种注解来标识此类负责接收和处理HTTP请求。如果请求的是页面和数据，使用@Controller注解即可；如果只是请求数据，则可以使用@RestController注解。</p>
<h4 id="1-Controller的用法"><a href="#1-Controller的用法" class="headerlink" title="1. @Controller的用法"></a>1. @Controller的用法</h4><p>Spring Boot提供的@Controller注解主要用于页面和数据的返回。下面创建HelloController响应前台页面请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        map.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thymeleaf-index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;thymeleaf/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例用于请求/user/index地址，返回具体的index页面和name=thymeleaf-index的数据。在前端页面中可以通过${name}参数获取后台返回的数据并显示到页面中。</p>
<p>在@Controller类中，如果只返回数据到前台页面，需要使用@ResponseBody注解，否则会报错。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-RestController的用法"><a href="#2-RestController的用法" class="headerlink" title="2. @RestController的用法"></a>2. @RestController的用法</h4><p>Spring Boot提供的@RestController注解用于实现数据请求的处理。默认情况下，@RestController注解会将返回的对象数据转换为JSON格式。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义/user/getUser接口返回JSON格式的User数据。同时，@RequestMapping注解可以通过method参数指定请求的方式。如果请求方式不对，则会报错。</p>
<p>近几年前端框架越来越强大，前后端分离的RESTful架构成为主流。Spring Boot对RESTful也做了非常完善的支持，使用也特别简单，使用@RestController注解自动返回JSON格式的数据，同时使用@GetMapping、PostMapping等注解实现映射RESTful接口。</p>
<h4 id="3-RestController和-Controller的区别"><a href="#3-RestController和-Controller的区别" class="headerlink" title="3. @RestController和@Controller的区别"></a>3. @RestController和@Controller的区别</h4><p>@Controller和@RestController注解都是标识该类是否可以处理HTTP请求，可以说@RestController是@Controller和@ResponseBody的结合体，是这两个注解合并使用的效果。虽然二者的用法基本类似，但还是有一些区别，具体如下：</p>
<p>1）@Controller标识当前类是Spring MVC Controller处理器，而@RestController则只负责数据返回。</p>
<p>2）如果使用@RestController注解，则Controller中的方法无法返回Web页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return中的数据。</p>
<p>3）如果需要返回指定页面，则使用@Controller注解，并配合视图解析器返回页面和数据。如果需要返回JSON、XML或自定义内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p>
<p>4）使用@Controller注解时，在对应的方法上，视图解析器可以解析返回的JSP、HTML页面，并且跳转到相应页面。若返回JSON等内容到页面，则需要添加@ResponseBody注解。</p>
<p>5）@RestController注解相当于@Controller和@ResponseBody两个注解的结合，能直接将返回的数据转换成JSON数据格式，无须在方法前添加@ResponseBody注解，但是使用@RestController注解时不能返回JSP、HTML页面，因为视图解析器无法解析JSP、HTML页面。</p>
<p>总之，在Web系统中使用@Controller较多，而在Web API中基本使用@RestController注解。</p>
<h3 id="4-1-3-RequestMapping"><a href="#4-1-3-RequestMapping" class="headerlink" title="4.1.3　@RequestMapping"></a>4.1.3　@RequestMapping</h3><p>@RequestMapping注解主要负责URL的路由映射。它可以添加在Controller类或者具体的方法上，如果添加在Controller类上，则这个Controller中的所有路由映射都将会加上此映射规则，如果添加在方法上，则只对当前方法生效。@RequestMapping注解包含很多属性参数来定义HTTP的请求映射规则。常用的属性参数如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value：请求URL的路径，支持URL模板、正则表达式。</span><br><span class="line">method：HTTP请求的方法。</span><br><span class="line">consumes：允许的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Content-Type。produces：相应的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Accept字段。params：请求参数。</span><br><span class="line">headers：请求头的值。</span><br></pre></td></tr></table></figure>
<p>以上属性基本涵盖了一个HTTP请求的所有参数信息。其中，value和method属性比较常用。</p>
<h3 id="4-1-4-ResponseBody"><a href="#4-1-4-ResponseBody" class="headerlink" title="4.1.4　@ResponseBody"></a>4.1.4　@ResponseBody</h3><p>@ResponseBody注解主要用于定义数据的返回格式，作用在方法上，默认使用Jackson序列化成JSON字符串后返回给客户端，如果是字符串，则直接返回。</p>
<p>在Controller中有时需要返回JSON格式的数据，如果想直接返回数据体而不是视图名，则需要在方法上使用@ResponseBody。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，请求/user/getUser时，返回JSON格式的User数据。这与@RestController的作用类似。</p>
<p>需要注意的是，使用@ResponseBody注解时需要注意请求的类型和地址，如果期望返回JSON，但是请求URL以html结尾的页面，就会导致Spring Boot认为请求的是HTML类型的资源，而返回JSON类型的资源，与期望类型不一致，因此报出如下错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There was an unexpected <span class="title function_">error</span> <span class="params">(type=Not Acceptable, status=<span class="number">406</span>)</span>. Could not find acceptable representation</span><br></pre></td></tr></table></figure>
<p>根据RESTful规范的建议，在Spring Boot应用中，如果期望返回JSON类型的资源，URL请求资源后缀就使用json；如果期望返回视图，URL请求资源后缀就使用html。</p>
<h2 id="4-2-URL映射"><a href="#4-2-URL映射" class="headerlink" title="4.2　URL映射"></a>4.2　URL映射</h2><p>上一节介绍了Spring Boot对Web项目开发都做了哪些支持，还介绍了@Controller和@RestController等注解，那么Spring Boot是如何将HTTP请求映射到具体方法的呢？Spring Boot支持<strong>URL路径匹配、HTTP Method匹配、params和header匹配</strong>等URL映射。本节开始介绍Spring Boot的URL映射。</p>
<h3 id="4-2-1-URL路径匹配"><a href="#4-2-1-URL路径匹配" class="headerlink" title="4.2.1　URL路径匹配"></a>4.2.1　URL路径匹配</h3><h4 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1. 精确匹配"></a>1. 精确匹配</h4><p>@RequestMapping的value属性用于匹配URL映射，value支持简单表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@PathVariable注解作用在方法参数中，用于表示参数的值来自URL路径。如果URL中的参数名称与方法中的参数名称一致，则可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中访问/getDataById/1时，会自动映射到后台的getDataById方法，传入参数id的值为1。</p>
<h4 id="2-通配符匹配"><a href="#2-通配符匹配" class="headerlink" title="2. 通配符匹配"></a>2. 通配符匹配</h4><p>@RequestMapping支持使用通配符匹配URL，用于统一映射某些URL规则类似的请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getJson/*.json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;get json data&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中请求/getJson/a.json或者/getJson/b.json时都会匹配到后台的getJson方法。</p>
<p>@RequestMapping的通配符匹配非常简单实用，支持“<em>”“?”“*</em>”等通配符。使用时需要了解通配符的匹配规则，否则容易出错。通配符匹配规则如下：</p>
<p>1）符号“<em>”匹配任意字符，符号“**”匹配任意路径，符号“?”匹配单个字符。</em></p>
<p>2）有通配符的优先级低于没有通配符的，比如/user/add.json比/user/*.json优先匹配。</p>
<p>3）有“<em>*”通配符的优先级低于有“\</em>”通配符的。</p>
<h3 id="4-2-2-Method匹配"><a href="#4-2-2-Method匹配" class="headerlink" title="4.2.2　Method匹配"></a>4.2.2　Method匹配</h3><p>HTTP请求Method有GET、POST、PUT、DELETE等方式。HTTP支持的全部Method和说明如表4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092235704.png" alt="image-20231009223549957"></p>
<p>对于Web应用，GET和POST是经常使用的选项，而对于RESTful接口，则会使用PUT、DELETE等从语义上进一步区分操作。</p>
<p>@RequestMapping注解提供了method参数指定请求的Method类型，包括RequestMethod.GET、RequestMethod.POST、RequestMethod.DELETE、RequestMethod.PUT等值，分别对应HTTP请求的Method。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod GET&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">PostData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod POST&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例实现了GET和POST两种方式。当使用GET方式请求/data/getData接口时，会返回“RequestMethod GET”，使用POST方式请求/data/getData接口时，则返回“RequestMethod POST”，说明@RequestMapping通过HTTP请求Method映射不同的后台方法。</p>
<h3 id="4-2-3-consumes和produces匹配"><a href="#4-2-3-consumes和produces匹配" class="headerlink" title="4.2.3　consumes和produces匹配"></a>4.2.3　consumes和produces匹配</h3><p>@RequestMapping注解提供了consumes和produces参数用于验证HTTP请求的内容类型和返回类型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumes表示请求的HTTP头的Content-Type媒体类型与consumes的值匹配才可以调用方法。produces表示HTTP请求中的Accept字段只有匹配成功才可以调用。</span><br></pre></td></tr></table></figure>
<p>下面通过示例演示consumes和produces参数的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理request Content-Type为“application/json”类型的请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/Content&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">Consumes</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Consumes POST  Content-Type=application/json&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例只允许Content-Type=application/json的HTTP请求映射此方法，其他类型则返回“Unsupported Media Type”的错误。</p>
<h3 id="4-2-4-params和header匹配"><a href="#4-2-4-params和header匹配" class="headerlink" title="4.2.4　params和header匹配"></a>4.2.4　params和header匹配</h3><p>@RequestMapping注解提供了header参数和params参数，通过header参数可以根据HTTP请求中的消息头内容映射URL请求，通过params参数可以匹配HTTP中的请求参数实现URL映射。</p>
<h4 id="1-params"><a href="#1-params" class="headerlink" title="1. params"></a>1. params</h4><p>Spring Boot除了通过匹配URL和Method的方式实现映射HTTP请求之外，还可以通过匹配params的方式来实现。Spring Boot从请求参数或HTTP头中提取参数，通过判断参数，如params=”action=save”确定是否通过。同时还可以设置请求参数包含某个参数、不包含某个参数或者参数等于某个值时通过，具体如下：</p>
<p>1）params={“username”}，存在“username”参数时通过。</p>
<p>2）params={“!password”}，不存在“password”参数时通过。</p>
<p>3）params={“age=20”}，参数age等于20时通过。</p>
<p>通过@PostMapping设置的params参数来检查请求的params，实现HTTP的URL映射。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;paramsTest&quot;,params=&quot;action=save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paramsTest</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;params test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当请求的参数action=save时，映射此方法。</p>
<h4 id="2-header"><a href="#2-header" class="headerlink" title="2. header"></a>2. header</h4><p>header的使用和params类似，它检查HTTP的header头中是否有Host=localhost:8080的参数，如果有则匹配此方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;headerTest&quot;,headers=&#123;&quot;Host=localhost:8080&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headerTest</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;header test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-参数传递"><a href="#4-3-参数传递" class="headerlink" title="4.3　参数传递"></a>4.3　参数传递</h2><p>本节开始介绍Spring Boot是如何实现参数传递的。参数传递是Web开发的基础内容，前端页面和后端服务通过请求和返回的参数来判断所执行的业务逻辑，因此参数的传递和接收是Web开发中最基础却非常重要的功能。</p>
<p>本节开始介绍Spring Boot是如何实现参数传递的。参数传递是Web开发的基础内容，前端页面和后端服务通过请求和返回的参数来判断所执行的业务逻辑，因此参数的传递和接收是Web开发中最基础却非常重要的功能。</p>
<h3 id="4-3-1-PathVariable"><a href="#4-3-1-PathVariable" class="headerlink" title="4.3.1　@PathVariable"></a>4.3.1　@PathVariable</h3><p>在Web应用中，最常用的参数传递方式就是URL传参，也就是将参数放在请求的URL中。例如微博上不同用户的个人主页应该对应不同的URL：<a target="_blank" rel="noopener" href="http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。">http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。</a></p>
<h4 id="1-定义URL变量"><a href="#1-定义URL变量" class="headerlink" title="1. 定义URL变量"></a>1. 定义URL变量</h4><p>@RequestMapping注解使用{}来声明URL变量，例如@RequestMapping(“/user/{username}”)。其中，{username}是定义的变量规则，username是变量的名字。此URL路由可以匹配下列任意URL请求：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/user/tianmaying</span><br><span class="line">/user/ricky</span><br><span class="line">/user/tmy1234</span><br></pre></td></tr></table></figure>
<p>在@RequestMapping中定义变量规则后，Spring Boot提供的@PathVariable注解帮助我们获取URL中定义的变量参数，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userProfile</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span> + username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot会自动将URL中定义的变量传递给userProfile方法的username参数（同名赋值），例如当HTTP请求为/users/weiz时，URL变量username的值weiz会被赋给函数参数username，返回的数据为user：weiz。</p>
<p>需要注意的是，在默认情况下，<strong>变量参数不能包含URL的分隔符“/”</strong>，也就是说上面定义的URL路由不能匹配/users/weiz/zhang，即使weiz/zhang是一个存在的用户名。</p>
<h4 id="2-定义多个URL变量"><a href="#2-定义多个URL变量" class="headerlink" title="2. 定义多个URL变量"></a>2. 定义多个URL变量</h4><p>上面介绍了传递单个变量的例子，那么多个变量呢？同样，@RequestMapping支持定义包含多个URL变量的路由，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@RequestMapping(“/user/{username}/blog/{blogId}”)传入{username}和{blogId}两个参数，然后使用@PathVariable映射对应的变量参数。</p>
<p>在多变量参数的情况下，Spring Boot能够根据变量名自动赋值对应的函数参数值，也可以在@PathVariable中显式声明具体的URL变量名。</p>
<p>在默认情况下，@PathVariable注解的参数支持自动转换一些基本的数据类型，如int、long、date、string等，Spring Boot能够根据URL变量的具体值以及函数参数的数据类型来进行转换，例如/user/weiz/blog/1会将“weiz”的值赋给username，而1赋给int类型的变量blogId。</p>
<h4 id="3-匹配正则表达式"><a href="#3-匹配正则表达式" class="headerlink" title="3. 匹配正则表达式"></a>3. 匹配正则表达式</h4><p>虽然@RequestMapping路由支持URL变量，但是很多时候需要对URL变量进行更加精确的定义和限制，例如用户名只包含小写字母、数字、下划线：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user/fpc是一个合法的URL</span><br><span class="line">/user/#不是一个合法的URL</span><br></pre></td></tr></table></figure>
<p>这种情况下，简单定义{username}变量就无法满足需求了。没关系，@RequestMapping注解同样支持正则表达式匹配，可以通过定义正则表达式更精确地控制，定义语法是{变量名：正则表达式}，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username:[a-zA-Z0-9_]+&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用[a-zA-Z0-9_]+正则表达式来限定username参数值只能包含小写字母、大写字母、数字、下划线。如此设置URL变量规则后，不合法的URL不会被处理，直接返回404Not Found。</p>
<h3 id="4-3-2-使用Bean对象接收参数"><a href="#4-3-2-使用Bean对象接收参数" class="headerlink" title="4.3.2　使用Bean对象接收参数"></a>4.3.2　使用Bean对象接收参数</h3><p>针对参数较多的<strong>表单提交</strong>，Spring Boot可以通过创建一个JavaBean对象来接收HTTP传入的表单参数。需要注意的是，<strong>JavaBean对象中必须含有默认的构造函数</strong>，同时，需要设置属性字段必须有setter方法。</p>
<h4 id="1-增加Bean实体类"><a href="#1-增加Bean实体类" class="headerlink" title="1. 增加Bean实体类"></a>1. 增加Bean实体类</h4><p>首先，增加表单对应的实体类，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String firstName;</span><br><span class="line">    <span class="keyword">private</span>  String lastName;</span><br><span class="line">    <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例定义了Student数据实体类。</p>
<h4 id="2-增加后台方法"><a href="#2-增加后台方法" class="headerlink" title="2. 增加后台方法"></a>2. 增加后台方法</h4><p>在StudentController控制器中增加save()方法，接收前台传来的数据。定义save()方法的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器中提交表单数据时，Spring Boot会自动把提交的表单数据转为Student对象，然后传递给save()方法。</p>
<h3 id="4-3-3-RequsetBody接收JSON数据"><a href="#4-3-3-RequsetBody接收JSON数据" class="headerlink" title="4.3.3　@RequsetBody接收JSON数据"></a>4.3.3　@RequsetBody接收JSON数据</h3><p>@RequestBody主要是将前端传入的JSON数据对象映射成后端的实体对象。比如，前端传入JSON格式的数据后，@RequestBody注解会自动将JSON数据反序列化成Student对象。使用时需要注意以下两点：</p>
<p>1）前端传递的对象属性和类型必须与后端对应。比如后端定义的user属性为“int id，String name”，前端必须使用相同的数据类型和字段来定义。</p>
<p>2）要使用JSON数据集进行传递，也就是设置为contentType:”application/json”。</p>
<p>下面通过示例代码演示如何使用@RequsetBody接收JSON数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/save2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save2</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping注解包含consumes参数，默认为application/json，表示前台需要传入JSON格式的参数。另外，Spring Boot会根据名称一一对应，将数据转换成相应的数据类型。例如JSON数据中有int或date类型，前台传过来都是字符串，Spring Boot会自动将其转换成实体类中的数据类型。</p>
<h3 id="4-3-4-ModelAttribute"><a href="#4-3-4-ModelAttribute" class="headerlink" title="4.3.4　@ModelAttribute"></a>4.3.4　@ModelAttribute</h3><p>熟悉MVC的读者应该都知道，我们可以将@ModelAttribute注解放置在控制器（Controller）中的某个方法上。当请求这个控制器中的某个URL时，会<strong>首先</strong>调用这个被注解的方法并将该方法的结果作为公共模型的属性，然后调用对应URL的处理方法，前端页面通过模型获取返回的数据。</p>
<p>@ModelAttribute标注的方法会在Controller类的每个映射URL的控制执行方法之前执行。使用方法如下面的示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, userService.findUserById(userId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    System.out.println(model.containsAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当我们请求接口/user/1时，会先调用findUserById()方法，在方法内通过userId查询到对应的User对象放置到Model中。如果仅仅添加一个对象到Model中，上面的代码可以再精练一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findUserById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码返回的User对象会被自动添加到Model中，相当于手动调用了model.addAttribute(user)方法。</p>
<p>Model通过addAttribute()方法向页面传递参数。@ModelAttribute修饰的方法会先于login调用，它把请求的参数值赋给对应的变量。可以向方法中的Model添加对象，前提是在方法中加入一个Model类型的参数。</p>
<p>需要注意的是，被@ModelAttribute注释的方法会在此控制器的每个方法执行前被执行，因此对于一个控制器映射多个URL，要谨慎使用。</p>
<h3 id="4-3-5-ModelAndView对象"><a href="#4-3-5-ModelAndView对象" class="headerlink" title="4.3.5　ModelAndView对象"></a>4.3.5　ModelAndView对象</h3><p>ModelAndView也是Spring MVC中常用的数据返回对象。当控制器处理完请求时，通常会将包含视图对象和数据的ModelAndView对象一起返回前台。它的作用类似于request对象的setAttribute()方法。</p>
<p>ModelAndView对象有两个作用：</p>
<p>1）设置转向地址（这也是ModelAndView和ModelMap的主要区别）。</p>
<p>2）将后台数据传回到前台页面。</p>
<p>ModelAndView使用起来也特别简单，在控制器中把前台页面需要的数据放到ModelAndView对象中，然后返回mv对象。下面通过示例演示使用ModelAndView对象返回数据到前台页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/detail/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>userService.getUserById(id);</span><br><span class="line">   <span class="comment">// 设置user对象的username属性</span></span><br><span class="line">   mv.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">   <span class="comment">// 地址跳转，设置返回的视图名称</span></span><br><span class="line">   mv.setViewName(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，先获取用户数据，然后将数据和对象一起返回到前台detail页面。这样Spring MVC将使用包含的视图对模型数据进行渲染。</p>
<h2 id="4-4-数据验证"><a href="#4-4-数据验证" class="headerlink" title="4.4　数据验证"></a>4.4　数据验证</h2><p>对于应用系统而言，任何客户端传入的数据都不是绝对安全有效的，这就要求我们在服务端接收到数据时也对数据的有效性进行验证，以确保传入的数据安全正确。接下来介绍Spring Boot是如何实现数据验证的。</p>
<h3 id="4-4-1-Hibernate-Validator简介"><a href="#4-4-1-Hibernate-Validator简介" class="headerlink" title="4.4.1　Hibernate Validator简介"></a>4.4.1　Hibernate Validator简介</h3><p>数据校验是Web开发中的重要部分，也是必须要考虑和面对的事情。应用系统必须通过某种手段来确保输入的数据从语义上来讲是正确的。</p>
<p>目前数据校验的规范、组件非常多，有JSR-303/JSR-349、Hibernate Validator、Spring Validation。下面就来捋一捋它们之间的关系。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSR（Java Specification Request）规范是Java EE 6中的一项子规范，也叫作Bean Validation。它指定了一整套基于bean的验证API，通过标注给对象属性添加约束条件。</span><br><span class="line">Hibernate Validator是对JSR规范的实现，并增加了一些其他校验注解，如@Email、 @Length、@Range等。</span><br><span class="line">Spring Validation是Spring为了给开发者提供便捷，对Hibernate Validator进行了二次封装。同时，Spring Validation在SpringMVC模块中添加了自动校验，并将校验信息封装进了特定的类中。</span><br></pre></td></tr></table></figure>
<p>所以，JSR定义了数据验证规范，而Hibernate Validator则是基于JSR规范，实现了各种数据验证的注解以及一些附加的约束注解。Spring Validation则是对Hibernate Validator的封装整合。</p>
<p>JSR和Hibernate Validator中的常用注解如表4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092309365.png" alt="image-20231009230908286"></p>
<p>表4-2中包含了Hibernate Validator实现的JSR-303定义的验证注解和Hibernate Validator自己定义的验证注解，同时也支持自定义约束注解。所有的注解都包含code和message这两个属性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message定义数据校验不通过时的错误提示信息。</span><br><span class="line">code定义错误的类型。</span><br></pre></td></tr></table></figure>
<p>Spring Boot是从Spring发展而来的，所以自然支持Hibernate Validator和Spring Validation两种方式，<strong>默认使用的是Hibernate Validator组件。</strong></p>
<h3 id="4-4-2-数据校验"><a href="#4-4-2-数据校验" class="headerlink" title="4.4.2　数据校验"></a>4.4.2　数据校验</h3><p>使用Hibernate Validator校验数据需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。下面以User对象为例演示如何使用Hibernate Validator校验数据。</p>
<h4 id="1-JavaBean参数校验"><a href="#1-JavaBean参数校验" class="headerlink" title="1. JavaBean参数校验"></a>1. JavaBean参数校验</h4><p>Post请求参数较多时，可以在对应的数据模型（Java Bean）中进行数据校验，通过注解来指定字段校验的规则。下面以具体的实例来进行演示。</p>
<p>首先，创建Java Bean实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(message = &quot;年龄不能为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Min(18)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，每个注解中的属性message是数据校验不通过时要给出的提示信息，如@Email(message=”邮件格式错误”)，当邮件格式校验不通过时，提示邮件格式错误。</p>
<p>然后，添加数据校验方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> User user, BindingResult result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getName();</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123;</span><br><span class="line">        List&lt;ObjectError&gt; list = result.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : list) &#123;</span><br><span class="line">            System.out.println(error.getCode()+ <span class="string">&quot;-&quot;</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@RequestBody注解后面添加了@Valid注解，然后在后面添加了BindingResult返回验证结果，BindingResult是验证不通过时的结果集合。</p>
<p>注意，BindingResult必须跟在被校验参数之后，若被校验参数之后没有BindingResult对象，则会抛出BindException。</p>
<p>最后，运行验证。</p>
<p>启动项目，在postman中请求/user/check接口，后台输出了数据验证的结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length-密码长度错误，密码长度6-20！</span><br><span class="line">Min-最小不能小于18</span><br><span class="line">Length-姓名长度错误，姓名长度2-10！</span><br></pre></td></tr></table></figure>
<p>通过上面的输出可以看到，应用系统对传入的数据进行了校验，同时也返回了对应的数据校验结果。</p>
<h4 id="2-URL参数校验"><a href="#2-URL参数校验" class="headerlink" title="2. URL参数校验"></a>2. URL参数校验</h4><p>一般GET请求都是在URL中传入参数。对于这种情况，可以直接通过注解来指定参数的校验规则。下面通过实例进行演示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="meta">@Length(min = 2, max = 10, message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span></span><br><span class="line"><span class="params">                                                <span class="meta">@RequestParam(name = &quot;name&quot;, required = true)</span> String name,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Min(value = 1, message = &quot;年龄最小只能1&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@Max(value = 99, message = &quot;年龄最大只能99&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@RequestParam(name = &quot;age&quot;, required = true)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot;,&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Range、@Min、@Max等注解对URL中传入的参数进行校验。需要注意的是，使用@Valid注解是无效的，需要在方法所在的控制器上添加@Validated注解来使得验证生效。</p>
<h4 id="3-JavaBean对象级联校验"><a href="#3-JavaBean对象级联校验" class="headerlink" title="3. JavaBean对象级联校验"></a>3. JavaBean对象级联校验</h4><p>对于JavaBean对象中的普通属性字段，我们可以直接使用注解进行数据校验，那如果是关联对象呢？其实也很简单，在属性上添加@Valid注解就可以作为属性对象的内部属性进行验证（验证User对象，可以验证UserDetail的字段）。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Size(min = 3,max = 5,message = &quot;list的Size在[3,5]&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> UserDetail userDetail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetail</span> &#123;</span><br><span class="line">    <span class="meta">@Length(min = 5, max = 17, message = &quot;length长度在[5,17]之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String extField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在属性上添加@Valid就可以对User中的关联对象UserDetail的字段进行数据校验。</p>
<h4 id="4-分组校验"><a href="#4-分组校验" class="headerlink" title="4. 分组校验"></a>4. 分组校验</h4><p>在不同情况下，可能对JavaBean对象的数据校验规则有所不同，有时需要根据数据状态对JavaBean中的某些属性字段进行单独验证。这时就可以使用分组校验功能，即根据状态启用一组约束。Hibernate Validator的注解提供了groups参数，用于指定分组，如果没有指定groups参数，则默认属于javax.validation.groups.Default分组。</p>
<p>下面通过示例演示分组校验。</p>
<p>首先，创建分组GroupA和GroupB，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了GroupA和GroupB两个接口作为两个校验规则的分组。</p>
<p>然后，创建实体类Person，并在相关的字段中定义校验分组规则，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;userId不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length(min = 30,max = 40,message = &quot;必须在[30,40]&quot;,groups = &#123;GroupB.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 20,max = 30,message = &quot;必须在[20,30]&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户名*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，age字段定义了GroupA和GroupB两个分组校验规则。GroupA的校验规则为年龄在20～30，GroupB的校验规则为年龄在30～40。</p>
<p>最后，使用校验分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(&#123;GroupA.class,Default.class&#125;)</span> Person person, BindingResult result)</span>&#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(result.getAllErrors()));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@Validated注解中增加了{GroupA.class,Default.class}参数，表示对于定义了分组校验的字段使用GroupA校验规则，其他字段使用默认规则。</p>
<h3 id="4-4-3-自定义校验"><a href="#4-4-3-自定义校验" class="headerlink" title="4.4.3　自定义校验"></a>4.4.3　自定义校验</h3><p>Hibernate Validator支持自定义校验规则。通过自定义校验规则，可以实现一些复杂、特殊的数据验证功能。下面通过示例演示如何创建和使用自定义验证规则。</p>
<h4 id="1-声明一个自定义校验注解"><a href="#1-声明一个自定义校验注解" class="headerlink" title="1. 声明一个自定义校验注解"></a>1. 声明一个自定义校验注解</h4><p>首先，定义新的校验注解@CustomAgeValidator，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Min(value = 18,message = &quot;年龄最小不能小于18&quot;)</span></span><br><span class="line"><span class="meta">@Max(value = 120,message = &quot;年龄最大不能超过120&quot;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;&#125;)</span> <span class="comment">//不指定校验器</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAgeValidator &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;年龄大小必须大于18并且小于120&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了CustomAgeValidator自定义注解，用于自定义年龄的数据校验规则。</p>
<h4 id="2-使用自定义校验注解"><a href="#2-使用自定义校验注解" class="headerlink" title="2. 使用自定义校验注解"></a>2. 使用自定义校验注解</h4><p>创建自定义校验注解CustomAgeValidator之后，在User的age属性上使用自定义组合注解，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@CustomAgeValidator</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在需要做特殊校验的age字段上添加@CustomAgeValidator自定义注解，这样age字段就会使用我们自定义的校验规则。</p>
<h2 id="4-5-拦截器"><a href="#4-5-拦截器" class="headerlink" title="4.5　拦截器"></a>4.5　拦截器</h2><p>拦截器在Web系统中非常常见，一般用于拦截用户请求，实现访问权限控制、日志记录、敏感过滤等功能。本节首先介绍实际项目中拦截器的应用场景，然后介绍如何实现自定义拦截器的功能。</p>
<h3 id="4-5-1-应用场景"><a href="#4-5-1-应用场景" class="headerlink" title="4.5.1　应用场景"></a>4.5.1　应用场景</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/">https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java编程的逻辑</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86Spring-Boot"><span class="toc-number">1.</span> <span class="toc-text">第1章　初识Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Spring-Boot%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.1　Spring Boot是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Boot%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Spring Boot的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-Boot%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Spring Boot的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Spring Boot的核心组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Spring-Boot%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2　Spring Boot的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0Spring-Boot"><span class="toc-number">1.3.</span> <span class="toc-text">1.3　为什么学习Spring Boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE%E2%80%9D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4　什么是“约定优于配置”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Spring%E3%80%81Spring-Boot%E5%92%8CSpring-Cloud%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5　Spring、Spring Boot和Spring Cloud的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%A7%8BSpring-Boot%E4%B9%8B%E6%97%85"><span class="toc-number">2.</span> <span class="toc-text">第2章　开始Spring Boot之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AC%AC%E4%B8%80%E4%B8%AASpring-Boot%E9%A1%B9%E7%9B%AE%EF%BC%9Ahelloworld"><span class="toc-number">2.1.</span> <span class="toc-text">2.1　第一个Spring Boot项目：helloworld</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1　创建Spring Boot项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Spring%E5%AE%98%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9E%84%E5%BB%BA%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1. 使用Spring官网提供的构建页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8IDEA%E6%9E%84%E5%BB%BA"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2. 使用IDEA构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2　项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-pom-xml%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3　pom.xml详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1. 项目的描述信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2. 项目的依赖配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%85%AC%E5%85%B1%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3. 构建时需要的公共变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">4. 构建配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E7%AC%AC%E4%B8%80%E4%B8%AAhelloworld%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4　第一个helloworld程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2　单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Spring-Boot%E9%9B%86%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1　Spring Boot集成单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2. 创建单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">3. 运行单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%B5%8B%E8%AF%95Service%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2　测试Service方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAService%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1. 创建Service测试类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2. 实现单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%B5%8B%E8%AF%95Controller%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3　测试Controller接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4　常用的单元测试注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3　开发环境热部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-devtools%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1　devtools实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2　配置开发环境热部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Spring-Boot%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">第3章　Spring Boot的系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1　系统配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-application-properties"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1　application.properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2. 配置文件加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">3. 修改默认配置文件名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-application-yml"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2　application.yml</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2. 数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-Properties%E4%B8%8EYML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3　Properties与YML配置文件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4　实战：自定义系统的启动图案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.</span> <span class="toc-text">3.2　自定义配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-Value"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1　@Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-Environment"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2　Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ConfigurationProperties"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3　@ConfigurationProperties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. 创建自定义配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 创建实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3. 调用配置项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4　使用配置文件注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3　其他配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1　随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E9%85%8D%E7%BD%AE%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2　配置引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.</span> <span class="toc-text">3.4　日志配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Spring-Boot%E6%97%A5%E5%BF%97%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1　Spring Boot日志简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2　配置日志格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3　日志输出级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BF%9D%E5%AD%98%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4　保存日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">3.5　实战：实现系统多环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1　多环境的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">1. 创建多环境配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">2. 修改配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2　多环境的切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Web%E5%BC%80%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">第4章　Web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Web%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1　Web开发简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Web%E5%85%A5%E9%97%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1　Web入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-spring-boot-starter-web%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">1. spring-boot-starter-web介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">2. Web项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84Web%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">3. 实现简单的Web请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Controller%E5%92%8C-RestController"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2　@Controller和@RestController</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Controller%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1. @Controller的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RestController%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">2. @RestController的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RestController%E5%92%8C-Controller%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">3. @RestController和@Controller的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-RequestMapping"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3　@RequestMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-ResponseBody"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4　@ResponseBody</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-URL%E6%98%A0%E5%B0%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.2　URL映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-URL%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1　URL路径匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1. 精确匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">2. 通配符匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-Method%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2　Method匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-consumes%E5%92%8Cproduces%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3　consumes和produces匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-params%E5%92%8Cheader%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4　params和header匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-params"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">1. params</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-header"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">2. header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.3.</span> <span class="toc-text">4.3　参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-PathVariable"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1　@PathVariable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89URL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">1. 定义URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AAURL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">2. 定义多个URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">3. 匹配正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E4%BD%BF%E7%94%A8Bean%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2　使用Bean对象接收参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0Bean%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1. 增加Bean实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A2%9E%E5%8A%A0%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2. 增加后台方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-RequsetBody%E6%8E%A5%E6%94%B6JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3　@RequsetBody接收JSON数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-ModelAttribute"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4　@ModelAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-ModelAndView%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5　ModelAndView对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="toc-number">4.4.</span> <span class="toc-text">4.4　数据验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-Hibernate-Validator%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1　Hibernate Validator简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2　数据校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JavaBean%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">1. JavaBean参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-URL%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">2. URL参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JavaBean%E5%AF%B9%E8%B1%A1%E7%BA%A7%E8%81%94%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">3. JavaBean对象级联校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">4. 分组校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3　自定义校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">1. 声明一个自定义校验注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">2. 使用自定义校验注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.5　拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1　应用场景</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程的逻辑"/></a><div class="content"><a class="title" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑">Java编程的逻辑</a><time datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript高级程序设计（第三版）"/></a><div class="content"><a class="title" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）">JavaScript高级程序设计（第三版）</a><time datetime="2023-10-05T14:44:18.000Z" title="发表于 2023-10-05 22:44:18">2023-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树的技巧"/></a><div class="content"><a class="title" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧">二叉树的技巧</a><time datetime="2023-08-15T04:23:33.000Z" title="发表于 2023-08-15 12:23:33">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表的技巧"/></a><div class="content"><a class="title" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧">链表的技巧</a><time datetime="2023-08-14T04:03:55.000Z" title="发表于 2023-08-14 12:03:55">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>