<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring Boot从入门到实战 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot从入门到实战">
<meta property="og:url" content="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第1章　初识Spring Boot1.1　Spring Boot是什么Spring Boot是由Pivotal团队提供的基于Spring的全新框架 Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。 Spring Boot的核心设计思想是“约定优于配置” 比如在使用Spring开发Web项目时，我们需要配置w">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-09T07:04:53.000Z">
<meta property="article:modified_time" content="2023-12-08T08:00:22.947Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot从入门到实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-08 16:00:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Boot从入门到实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-08T08:00:22.947Z" title="更新于 2023-12-08 16:00:22">2023-12-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot从入门到实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第1章-初识Spring-Boot"><a href="#第1章-初识Spring-Boot" class="headerlink" title="第1章　初识Spring Boot"></a>第1章　初识Spring Boot</h1><h2 id="1-1-Spring-Boot是什么"><a href="#1-1-Spring-Boot是什么" class="headerlink" title="1.1　Spring Boot是什么"></a>1.1　Spring Boot是什么</h2><p>Spring Boot是由Pivotal团队提供的基于Spring的全新框架</p>
<p>Spring Boot集成了绝大部分目前流行的开发框架，就像Maven集成了所有的JAR包一样，Spring Boot集成了几乎所有的框架。</p>
<p>Spring Boot的核心设计思想是“约定优于配置”</p>
<p>比如在使用Spring开发Web项目时，我们需要配置web.xml、Spring和MyBatis等，还需要将它们集成在一起。而使用Spring Boot一切将变得极其简单，它采用了大量的默认配置来简化这些文件的配置过程，只需引入对应的<strong>Starters</strong>（启动器）。</p>
<p>Spring Boot可以构建一切。设计它就是为了使用最少的配置，以最快的速度来启动和运行Spring项目。</p>
<h3 id="1-Spring-Boot的背景"><a href="#1-Spring-Boot的背景" class="headerlink" title="1. Spring Boot的背景"></a>1. Spring Boot的背景</h3><p>Spring Boot建立在Spring基础之上，遵循“约定优于配置”的原则，避免了创建项目或框架时必须做的繁杂配置，帮助开发者以最少的工作量，更加简单、方便地使用现有Spring中的所有功能组件。</p>
<h3 id="2-Spring-Boot的特性"><a href="#2-Spring-Boot的特性" class="headerlink" title="2. Spring Boot的特性"></a>2. Spring Boot的特性</h3><p>Spring Boot的一系列特性使得微服务架构的落地变得非常容易，对于目前众多的技术栈，Spring Boot是Java领域微服务架构的最优落地技术。图1-1所示为Spring Boot的一些特性。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091507170.png" alt="image-20231009150724075"></p>
<h3 id="3-Spring-Boot的核心组件"><a href="#3-Spring-Boot的核心组件" class="headerlink" title="3. Spring Boot的核心组件"></a>3. Spring Boot的核心组件</h3><p>Spring Boot官方提供了很多当前流行的基础功能组件的封装，命名一般以<strong>spring-boot-starter</strong>开头，比如spring-boot-starter-quartz定时任务组件和spring-boot-starter-thymeleaf页面模板引擎等</p>
<p>很多第三方中间件也按照Spring Boot的规范提供了针对Spring Boot项目的Starters（启动器），一般以组件名开头，比如MyBatis针对Spring Boot提供的组件包<strong>mybatis-spring-boot-starter</strong>。</p>
<h2 id="1-2-Spring-Boot的优点"><a href="#1-2-Spring-Boot的优点" class="headerlink" title="1.2　Spring Boot的优点"></a>1.2　Spring Boot的优点</h2><ol>
<li>遵循“约定优于配置”的原则</li>
<li>使用JavaConfig，避免使用XML的烦琐。</li>
<li>提供Starters（启动器），简化Maven配置，避免依赖冲突。</li>
<li>提供内嵌Servlet容器，可选择内嵌Tomcat、Jetty等容器，不需要单独的Web服务器。这意味着不再需要启动Tomcat或其他任何中间件。</li>
<li>提供了一系列项目中常见的非功能特性，如安全监控、应用监控、健康检测等。</li>
<li>与云计算、微服务的天然集成。</li>
</ol>
<p>Spring Boot就是尽可能地简化应用开发的门槛，让应用开发、测试、部署变得更加简单。</p>
<h2 id="1-3-为什么学习Spring-Boot"><a href="#1-3-为什么学习Spring-Boot" class="headerlink" title="1.3　为什么学习Spring Boot"></a>1.3　为什么学习Spring Boot</h2><p>最近几年，Spring生态圈最流行的技术框架莫过于Spring Boot和Spring Cloud。目前，各个企业都在推动微服务技术架构的落地，将一个复杂的应用拆分成多个小的独立模块，分开部署，互不干扰，从而达到松散耦合、提高开发效率和降低运维成本的目的。</p>
<p>Spring Boot作为微服务框架的基础被越来越多地应用于企业级开发中，它是Spring Cloud的基础。要学习Spring Cloud，就必须了解Spring Boot框架的架构和设计理念。</p>
<p>Spring Boot是Spring生态下的一个子项目，用于快速、敏捷地开发新一代基于Spring框架的应用程序。同时，它将目前各种比较成熟的服务框架和第三方组件组合起来（如Redis、MongoDB、JPA、RabbitMQ、Quartz等），按照“约定优于配置”的设计思想封装成Starters组件。这样，我们在Spring Boot应用中几乎可以零配置地使用这些组件，达到开箱即用的效果，从而从繁杂的配置中解放出来，更加专注于业务逻辑的开发。</p>
<p>Spring Boot让构建、编码、配置、部署、监控都变得非常简单</p>
<p>pring Boot不是新的语言、新的技术，它只是把现有的比较流行的框架集成在一起，遵循“约定优于配置”的原则，开箱即用，使得我们不需要再去关注那些烦琐的配置</p>
<h2 id="1-4-什么是“约定优于配置”"><a href="#1-4-什么是“约定优于配置”" class="headerlink" title="1.4　什么是“约定优于配置”"></a>1.4　什么是“约定优于配置”</h2><p>从本质上来说，系统、类库或框架应该约定合理的默认值，开发者仅需规定应用中不符合约定的部分。例如，如果模型中有一个名为Product的类，那么数据库中对应的表就会默认命名为product，只有在偏离这个约定时才需要定义有关这个名字的配置，例如将该表命名为product_info。</p>
<p>简单来说“约定优于配置”就是遵循约定。如果你所用工具的约定配置符合你的要求，那么就可以省去此配置；不符合，就通过修改相关的配置来达到你所期待的方式。</p>
<p>Spring Boot是Spring对“约定优于配置”的最佳实践产物。小到配置文件、中间件的默认配置，大到内置容器、Spring生态中的各种Starters，无不遵循“约定优于配置”的设计思想。</p>
<h2 id="1-5-Spring、Spring-Boot和Spring-Cloud的关系"><a href="#1-5-Spring、Spring-Boot和Spring-Cloud的关系" class="headerlink" title="1.5　Spring、Spring Boot和Spring Cloud的关系"></a>1.5　Spring、Spring Boot和Spring Cloud的关系</h2><p>Spring是一个开源生态体系，是集大成者。其核心是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）。正是IoC和AOP这两个核心功能成就了强大的Spring，Spring在这两大核心功能上不断地发展壮大，才有了Spring MVC等一系列成熟的产品，最终构建了功能强大的Spring生态帝国。</p>
<p>Spring Boot是在Spring的基础上发展而来的，它不是为了取代Spring，而是为了简化Spring应用的创建、运行、调试、部署，让开发者更容易地使用Spring。它将目前各种比较成熟的服务框架和第三方组件组合起来，按照“约定优于配置”的设计思想进行重新封装，屏蔽掉复杂的配置和实现，最终给开发者提供一套简单、易用、易部署、易维护的分布式系统开发工具包。</p>
<p>Spring Cloud是基于Spring Boot实现的分布式微服务框架，它利用Spring Boot简单、易用、便利的特性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、断路器、数据监控等基础组件都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>我们都知道，采用微服务架构，服务的数量会非常多，管理特别麻烦，而Spring Cloud就是一套分布式微服务治理框架，可以说是这些微服务的大管家。作为大管家Spring Cloud就需要提供各种组件和方案来治理与维护整个微服务系统，比如服务之间的通信、熔断、监控等。Spring Cloud利用Spring Boot的特性集成了开源行业中优秀的组件，在微服务架构中对外提供了一套服务治理的解决方案。</p>
<p>Spring Boot在Spring Cloud中起到了承上启下的作用，如果要学习Spring Cloud，则必须学习Spring Boot。三者之间的关系如图1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091515451.png" alt="image-20231009151526413"></p>
<h1 id="第2章-开始Spring-Boot之旅"><a href="#第2章-开始Spring-Boot之旅" class="headerlink" title="第2章　开始Spring Boot之旅"></a>第2章　开始Spring Boot之旅</h1><p>本章主要介绍如何开始Spring Boot项目，通过一个简单的helloworld程序演示Spring Boot的项目结构与启动流程，然后介绍Spring Boot是如何进行单元测试的，最后介绍非常实用的功能：配置开发环境热部署</p>
<h2 id="2-1-第一个Spring-Boot项目：helloworld"><a href="#2-1-第一个Spring-Boot项目：helloworld" class="headerlink" title="2.1　第一个Spring Boot项目：helloworld"></a>2.1　第一个Spring Boot项目：helloworld</h2><p>本节从简单的helloworld程序开始介绍创建Spring Boot项目的方法和流程，以及Spring Boot项目结构，最后介绍项目中非常重要的pom.xml文件。</p>
<h3 id="2-1-1-创建Spring-Boot项目"><a href="#2-1-1-创建Spring-Boot项目" class="headerlink" title="2.1.1　创建Spring Boot项目"></a>2.1.1　创建Spring Boot项目</h3><p>有两种方式来构建Spring Boot项目的基础框架：第一种是使用Spring官网提供的构建页面，第二种是使用IntelliJ IDEA中的Spring插件。</p>
<h4 id="1-使用Spring官网提供的构建页面"><a href="#1-使用Spring官网提供的构建页面" class="headerlink" title="1. 使用Spring官网提供的构建页面"></a>1. 使用Spring官网提供的构建页面</h4><p>步骤01 访问Spring官网。</p>
<p>步骤02 选择构建工具为Maven Project，编程语言选择Java，Spring Boot版本为2.3.7，填写项目基本信息，具体如图2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091519078.png" alt="image-20231009151910048"></p>
<p>步骤03 单击Generate创建并下载项目压缩包。</p>
<p>步骤04 解压后，使用IDEA引入项目，选择File→Open File or Project，选择解压后的文件夹，单击OK按钮，项目即可创建完成。</p>
<h4 id="2-使用IDEA构建"><a href="#2-使用IDEA构建" class="headerlink" title="2. 使用IDEA构建"></a>2. 使用IDEA构建</h4><p>步骤01 选择File→New→Project命令，弹出新建项目的对话框。</p>
<p>步骤02 选择Spring Initializr，单击Next按钮出现配置界面，IDEA已经帮助做了集成。如图2-2所示，IDEA界面中的Group、Artifact等输入框就对应着项目的pom.xml中的groupId、artifactId等配置项。</p>
<p>填完相关的信息之后，直接单击NEXT按钮来创建项目。</p>
<h3 id="2-1-2-项目结构"><a href="#2-1-2-项目结构" class="headerlink" title="2.1.2　项目结构"></a>2.1.2　项目结构</h3><p>Spring Boot的基础结构共有3个主要目录，具体如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/java：程序开发以及主程序目录。src/main/resources：配置文件和资源文件目录。src/test/java：测试程序目录。</span><br></pre></td></tr></table></figure>
<p>从上面我们可以了解到，新建的helloworld项目只有java、resources、test三个基础结构目录。通常，完整的项目包括前台页面、model实体、数据库访问、公共基础类等非常多的文件和目录，Spring Boot建议的目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">myproject</span><br><span class="line">        +-src</span><br><span class="line">                +- main</span><br><span class="line">                        +- java</span><br><span class="line">                                +- com.example.myproject</span><br><span class="line">                                        +- comm</span><br><span class="line">                                        +- model</span><br><span class="line">                                        +- repository</span><br><span class="line">                                        +- service</span><br><span class="line">                                        +- web</span><br><span class="line">                                        +- Application.java</span><br><span class="line">                        +- resources</span><br><span class="line">                                +- <span class="keyword">static</span></span><br><span class="line">                                +- templates</span><br><span class="line">                                +- application.properties</span><br><span class="line">                        +- test</span><br><span class="line">        +-pom.xml</span><br></pre></td></tr></table></figure>
<p>如上所示，其实就是把java、resources、test三大基础目录进行细化，定义每个子目录存放的文件和作用。</p>
<p>1）java目录下的com.example.myproject为后台java文件的根目录，包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application.java：建议放到根目录下，是项目的启动类，注意Spring Boot项目只能有一个main()方法入口。</span><br><span class="line">comm：建议放置公共的类，如全局的配置文件、工具类等。</span><br><span class="line">model：主要用于实体（Entity）。</span><br><span class="line">repository：主要是数据库访问层代码。</span><br><span class="line">service：主要是业务类代码。</span><br><span class="line">web：负责前台页面访问的Controller路由。</span><br></pre></td></tr></table></figure>
<p>2）resources目录下包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static：存放Web访问的静态资源，如JS、CSS、图片等。</span><br><span class="line">templates：存放页面模板。</span><br><span class="line">application.properties：存放项目的配置信息。</span><br></pre></td></tr></table></figure>
<p>3）test目录存放单元测试的代码，目录结构和java目录保持一致。</p>
<p>4）pom.xml用于配置项目依赖包以及其他配置。</p>
<p>采用Spring Boot推荐的默认配置可以省掉很多设置。当然，也可以根据技术规范进行调整。至此，我们的第一个Spring Boot项目就创建完成了。</p>
<h3 id="2-1-3-pom-xml详解"><a href="#2-1-3-pom-xml详解" class="headerlink" title="2.1.3　pom.xml详解"></a>2.1.3　pom.xml详解</h3><p>pom.xml配置文件主要分为四部分，下面就来一一介绍pom.xml文件的各个组成部分以及它们的作用。</p>
<h4 id="1-项目的描述信息"><a href="#1-项目的描述信息" class="headerlink" title="1. 项目的描述信息"></a>1. 项目的描述信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wei<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置内容基本是创建项目时定义的有关项目的基本描述信息，其中比较重要的是groupId、artifactId。各个属性说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupId：项目的包路径。</span><br><span class="line">artifactId：项目名称。</span><br><span class="line">version：项目版本号。</span><br><span class="line">packaging：一般有jar、war两个值，表示使用Maven打包时是构建成JAR包还是WAR包。</span><br><span class="line">name：项目名称。d</span><br><span class="line">description：项目描述。</span><br></pre></td></tr></table></figure>
<h4 id="2-项目的依赖配置信息"><a href="#2-项目的依赖配置信息" class="headerlink" title="2. 项目的依赖配置信息"></a>2. 项目的依赖配置信息</h4><p>此部分为项目的依赖信息，主要包括Spring Boot的版本信息和第三方组件的版本信息。示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>项目的依赖信息主要分为parent和dependencies两部分。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent：配置父级项目的信息。Maven支持项目的父子结构，引入后会默认继承父级的配置。此项目		中引入spring-boot-starter-parent定义Spring Boot的基础版本。</span><br><span class="line">dependencies：配置项目所需要的依赖包，Spring Boot体系内的依赖组件不需要填写具体版本		号，spring-boot-starter-parent维护了体系内所有依赖包的版本信息。</span><br></pre></td></tr></table></figure>
<p>另外，\<dependency>标签是Maven项目定义依赖库的重要标签，通过groupId、artifactId等“坐标”信息定义依赖库的路径信息。</p>
<h4 id="3-构建时需要的公共变量"><a href="#3-构建时需要的公共变量" class="headerlink" title="3. 构建时需要的公共变量"></a>3. 构建时需要的公共变量</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置了项目构建时所使用的编码、输出所使用的编码，最后指定了项目使用的JDK版本。</p>
<h4 id="4-构建配置"><a href="#4-构建配置" class="headerlink" title="4. 构建配置"></a>4. 构建配置</h4><p>此部分为构建配置信息，这里使用Maven构建Spring Boot项目，所以必须在\<plugins>中添加spring-boot-maven-plugin插件，它能够以Maven的方式为应用提供Spring Boot的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面配置spring-boot-maven-plugin构建插件，将Spring Boot应用打包为可执行的JAR或WAR文件，然后以简单的方式运行Spring Boot应用。如果需要更改为Docker构建方式，则只要更改此部分即可。</p>
<h3 id="2-1-4-第一个helloworld程序"><a href="#2-1-4-第一个helloworld程序" class="headerlink" title="2.1.4　第一个helloworld程序"></a>2.1.4　第一个helloworld程序</h3><p>步骤01 在目录src\main\java\com\weiz\helloworld\controller下创建HelloController，然后添加/hello的路由地址和方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Hello @ Spring Boot!!! &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了HelloController并创建了一个hello()方法，最后使用@RestController和@RequestMapping注解实现HTTP路由。</p>
<p>1）@RestController表示HelloController为数据处理控制器。Spring Boot中有Controller和RestController两种控制器，都用来表示Spring中某个类是否可以接收HTTP请求，但不同的是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Controller：返回数据和页面，处理HTTP请求。</span><br><span class="line">@RestController：返回客户端数据请求，主要用于RESTful接口。</span><br></pre></td></tr></table></figure>
<p>可以说@RestController是@Controller与@ResponseBody的结合体，因而具有两个标注合并起来的作用。</p>
<p>2）@RequestMapping(“/hello”)提供路由映射，意思是”/hello”路径的HTTP请求都会被映射到hello()方法上进行处理。</p>
<p>步骤02 运行helloworld程序。</p>
<p>​    右击项目中的HelloApplication→run命令就可以启动项目，若出现如图2-4所示的内容则表    示启动成功。</p>
<p>​    通过系统的启动日志可以看到，系统运行在8080端口。如果需要切换到其他端口，可在        application.properties配置文件中自行定义。</p>
<p>步骤03 打开浏览器，访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。">http://localhost:8080/hello地址，查看页面返回的结果，如图2-5所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091710024.png" alt="image-20231009171027923"></p>
<h2 id="2-2-单元测试"><a href="#2-2-单元测试" class="headerlink" title="2.2　单元测试"></a>2.2　单元测试</h2><p>单元测试在日常项目开发中必不可少，Spring Boot提供了完善的单元测试框架和工具用于测试开发的应用。接下来介绍Spring Boot为单元测试提供了哪些支持，以及如何在Spring Boot项目中进行单元测试。</p>
<h3 id="2-2-1-Spring-Boot集成单元测试"><a href="#2-2-1-Spring-Boot集成单元测试" class="headerlink" title="2.2.1　Spring Boot集成单元测试"></a>2.2.1　Spring Boot集成单元测试</h3><p>单元测试主要用于测试单个代码组件，以确保代码按预期方式工作。目前流行的有JUnit或TestNG等测试框架。Spring Boot封装了单元测试组件spring-boot-starter-test。下面通过示例演示Spring Boot是如何实现单元测试的。</p>
<h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><p>首先创建Spring Boot项目。在项目中引入spring-boot-starter-test组件，示例配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建单元测试"><a href="#2-创建单元测试" class="headerlink" title="2. 创建单元测试"></a>2. 创建单元测试</h4><p>在src/test目录下新建一个HelloTest测试类，如果只想输出一句“Hello Spring Boot Test”，只需要用一个@Test注解即可。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Spring Boot Test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的上面添加@SpringBootTest注解，系统会自动把这段程序加载到Spring Boot容器。@Test注解表示该方法为单元测试方法。</p>
<h4 id="3-运行单元测试"><a href="#3-运行单元测试" class="headerlink" title="3. 运行单元测试"></a>3. 运行单元测试</h4><p>单击Run Test或在方法上右击，再选择“Run ‘hello’”，运行测试方法，运行结果如图2-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091731926.png" alt="image-20231009173126887"></p>
<p>由图2-6可知，单元测试方法运行成功并输出相应的结果，同时IDEA也会显示运行的所有单元测试结果，包括测试是否通过、运行时间、测试总数和成功次数等。以上示例中的测试方法只是spring-boot-starter-test组件中的一部分功能，Spring Boot自带的spring-boot-starter-test框架对测试的支持非常完善，包括Web请求测试、Service方法测试等，后面会逐一介绍。</p>
<h3 id="2-2-2-测试Service方法"><a href="#2-2-2-测试Service方法" class="headerlink" title="2.2.2　测试Service方法"></a>2.2.2　测试Service方法</h3><p>一般使用Spring Boot进行单元测试主要是针对Service和API（Controller）进行。接下来通过示例演示Spring Boot如何测试Service方法。</p>
<h4 id="1-创建Service测试类"><a href="#1-创建Service测试类" class="headerlink" title="1. 创建Service测试类"></a>1. 创建Service测试类</h4><p>创建Service测试类非常简单，使用IDEA可以一键自动创建单元测试类。首先，选择需要测试的Service类或方法，然后在对应的Service类中右击，选择Go To→Test→Create New Test，打开如图2-7所示的创建测试类界面。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091732413.png" alt="image-20231009173236378"></p>
<p>单击OK按钮，IDEA会在Test目录下创建一个UserServiceTest测试类，并为勾选的测试类自动生成单元测试的方法。</p>
<h4 id="2-实现单元测试"><a href="#2-实现单元测试" class="headerlink" title="2. 实现单元测试"></a>2. 实现单元测试</h4><p>在上面创建好的UserServiceTest类中会自动创建对应的单元测试方法，我们只需要在测试方法中实现对应的测试代码即可，具体的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;1002&quot;</span>, userService.findOne());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如以上示例代码所示，在自动测试类上增加@SpringBootTest注解即可。首先注入需要测试的Service，然后在单元测试中调用该方法，最后通过Assert断句判断返回结果是否正确。</p>
<p>执行单元测试也非常简单，只需将鼠标放在对应的方法上，右击并选择Run执行该方法即可。</p>
<h3 id="2-2-3-测试Controller接口方法"><a href="#2-2-3-测试Controller接口方法" class="headerlink" title="2.2.3　测试Controller接口方法"></a>2.2.3　测试Controller接口方法</h3><p>上面是针对Service进行测试，但是有时需要对API（Controller）进行测试，这时需要用到MockMvc类。MockMvc能够模拟HTTP请求，使用网络的形式请求Controller中的方法，这样可以使得测试速度快、不依赖网络环境，而且它提供了一套完善的结果验证工具，测试和验证也非常简单、高效。</p>
<p>spring-boot-starter-test具备强大的Mock能力，使用@WebMvcTest等注解实现模拟HTTP请求测试。下面通过示例演示如何测试Controller接口。</p>
<p>步骤01 创建Controller的测试类HelloControllerTest，实现单元测试方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HelloController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/hello&quot;</span>)   <span class="comment">//执行一个请求</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))       <span class="comment">//接收的数据类型</span></span><br><span class="line">                .andExpect(status().isOk())  <span class="comment">//添加执行完成后的断句，请求的状态响应码//是否为200，如果不是则测试不通过</span></span><br><span class="line">                .andDo(print()); <span class="comment">//添加一个结果处理程序，表示要对结果进行处理，比如此处//使用print()输出整个响应结果信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过使用MockMvc构造一个post请求，MockMvcRequestBuilders可以支持post和get请求，调用print()方法将请求和相应的过程都打印出来。示例代码说明如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MockMvcRequestBuilders.post(&quot;/hello&quot;)：构造一个post请求。</span><br><span class="line">contentType (MediaType.APPLICATION<span class="emphasis">_JSON))：设置JSON返回编码，避免出现中文乱码的问题。</span></span><br><span class="line"><span class="emphasis">andExpect(status().isOk())：执行完成后的断句，请求的状态响应码是否为200，如果不是则测试不通过。</span></span><br><span class="line"><span class="emphasis">andDo(print())：添加一个结果处理程序，表示要对结果进行处理，比如此处调用print()输出整个响应结果信息。</span></span><br></pre></td></tr></table></figure>
<p>步骤02 执行单元测试。</p>
<p>完成测试方法之后，执行测试方法：将鼠标放在对应的方法上，右击并选择Run执行该方法即可。可以看到输出如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line"><span class="code">      HTTP Method = POST</span></span><br><span class="line"><span class="code">      Request URI = /hello</span></span><br><span class="line"><span class="code">       Parameters = &#123;&#125;</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;application/json;charset=UTF-8&quot;]</span></span><br><span class="line"><span class="code">             Body = null</span></span><br><span class="line"><span class="code">    Session Attrs = &#123;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Handler:</span><br><span class="line"><span class="code">             Type = com.weiz.helloworld.web.HelloController</span></span><br><span class="line"><span class="code">           Method = com.weiz.helloworld.web.HelloController#hello()</span></span><br><span class="line"><span class="code">Async:</span></span><br><span class="line"><span class="code">    Async started = false</span></span><br><span class="line"><span class="code">     Async result = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Resolved Exception:</span><br><span class="line"><span class="code">             Type = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">ModelAndView:</span><br><span class="line"><span class="code">        View name = null</span></span><br><span class="line"><span class="code">             View = null</span></span><br><span class="line"><span class="code">            Model = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">FlashMap:</span><br><span class="line"><span class="code">       Attributes = null</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line"><span class="code">           Status = 200</span></span><br><span class="line"><span class="code">    Error message = null</span></span><br><span class="line"><span class="code">          Headers = [Content-Type:&quot;text/plain;charset=UTF-8&quot;, Content-Length:&quot;17&quot;]</span></span><br><span class="line"><span class="code">     Content type = text/plain;charset=UTF-8</span></span><br><span class="line"><span class="code">             Body = hello Spring Boot</span></span><br><span class="line"><span class="code">    Forwarded URL = null</span></span><br><span class="line"><span class="code">   Redirected URL = null</span></span><br><span class="line"><span class="code">          Cookies = []</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出中可以看到，返回完整的Http Response，包括Status=200、Body = hello Spring Boot，说明接口请求成功并成功返回。</p>
<p>如果接口有登录验证，则需要通过MockHttpSession注入用户登录信息，或者修改登录拦截器取消对单元测试的登录验证。</p>
<h3 id="2-2-4-常用的单元测试注解"><a href="#2-2-4-常用的单元测试注解" class="headerlink" title="2.2.4　常用的单元测试注解"></a>2.2.4　常用的单元测试注解</h3><p>在实际项目中，除了@SpringBootTest、@Test等注解之外，单元测试还有很多非常实用的注解，具体说明如表2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091815842.png" alt="image-20231009181555796"></p>
<h2 id="2-3-开发环境热部署"><a href="#2-3-开发环境热部署" class="headerlink" title="2.3　开发环境热部署"></a>2.3　开发环境热部署</h2><p>本节介绍Spring Boot非常实用的功能：开发环境热部署。在实际的项目开发调试过程中会频繁地修改后台类文件，导致需要重新编译、重新启动，整个过程非常麻烦，影响开发效率。下面介绍Spring Boot如何解决这个问题。</p>
<h3 id="2-3-1-devtools实现原理"><a href="#2-3-1-devtools实现原理" class="headerlink" title="2.3.1　devtools实现原理"></a>2.3.1　devtools实现原理</h3><p>我们在开发调试Spring Boot项目时，需要经历重新编译、重新启动程序的过程。由于系统启动时，需要加载一系列的组件和依赖包，因此整个过程非常耗时，大大影响开发效率。</p>
<p>Spring Boot在这方面做了很好的支持，提供了spring-boot-devtools组件，使得无须手动重启Spring Boot应用即可重新编译、启动项目，大大缩短编译、启动的时间，从而提高开发效率。</p>
<p>spring-boot-devtools的核心是两个类加载器（ClassLoader）：一个是Base类加载器（Base ClassLoader），负责加载那些不会改变的类，如第三方JAR包等；另一个是Restart类加载器（Restart ClassLoader），负责加载那些正在开发的会改变的类。这样如果只修改Java代码，devtools只会重新加载被修改的类文件，不会重新加载其他第三方的JAR包，所以重启较快，从而达到热部署的效果。</p>
<p>我们在项目中引入devtools组件之后，devtools会监听classpath下的文件变动，当文件被修改时会重新编译，重新生成类文件；devtools监听到类文件变动，触发Restart类加载器重新加载该类，从而实现类文件和属性文件的热部署。</p>
<p>需要注意的是，并不是所有的更改都需要重启应用（如静态资源、视图模板）。我们可以通过设置spring.devtools.restart.exclude属性来指定一些文件或目录的修改不用重启应用。例如，可以设置/static和/public下的所有文件更新都不触发应用重启。</p>
<h3 id="2-3-2-配置开发环境热部署"><a href="#2-3-2-配置开发环境热部署" class="headerlink" title="2.3.2　配置开发环境热部署"></a>2.3.2　配置开发环境热部署</h3><p>步骤01 在pom.xml配置文件中添加dev-tools依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    &lt;!— optional依赖是否传递，设置为true时，表示依赖不会传递 --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用optional=true表示依赖不会传递，即该项目依赖devtools；其他项目如果引入此项目生成的JAR包，则不会包含devtools，如果想要使用devtools，则需要重新引入。</p>
<p>步骤02 在application.properties中配置devtools。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 热部署生效</span><br><span class="line">spring.devtools.restart.enabled=true</span><br><span class="line"># 设置重启的目录</span><br><span class="line">spring.devtools.restart.additional-paths=src/main/java</span><br><span class="line"># classpath目录下的WEB-INF文件夹内容修改不重启</span><br><span class="line">spring.devtools.restart.exclude=WEB-INF/**</span><br></pre></td></tr></table></figure>
<p>上面的配置主要是打开devtools热部署，然后指定监控的后台文件目录，最后指明文件变更不需要重新编译部署的目录。配置完成之后，devtools会监听classpath下的文件变动，并且会立即重启应用。</p>
<p>需要注意的是，devtools也可以实现前台页面热部署，即页面修改后会立即生效，需要在application.properties文件中配置spring.thymeleaf.cache=false，以指定不缓存前端页面。</p>
<p>步骤03 验证配置是否生效。</p>
<p>配置完成后，需要验证热部署是否生效。首先启动项目，修改项目中的某个java文件，然后在IDEA后台可以看到devtools自动重启应用，后台日志输出如图2-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091834482.png" alt="image-20231009183402406"></p>
<p>我们手动修改java后台代码就会发现Spring Boot已经重新编译该文件，然后自动重新加载，无须手动重启。</p>
<p>个人感觉 就是引入包 devtools 然后再项目配置页面中<img src="https://gitee.com/fjkf/images/raw/master/202311030921147.png" alt="image-20231103092132850"></p>
<p>然后再spring配置文件中加入</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 热部署生效</span></span><br><span class="line"><span class="string">spring.devtools.restart.enabled=true</span></span><br></pre></td></tr></table></figure>
<p>即可热部署生效。</p>
<h1 id="第3章-Spring-Boot的系统配置"><a href="#第3章-Spring-Boot的系统配置" class="headerlink" title="第3章　Spring Boot的系统配置"></a>第3章　Spring Boot的系统配置</h1><p>我们知道Spring Boot遵循“约定优于配置”的原则，绝大部分配置项都约定了默认值，Spring Boot甚至可以做到无须任何手动配置就能启动成功，这大大降低了系统配置的复杂程度。当然，Spring Boot也支持自定义修改系统配置，比如系统端口、启动图案、数据库连接等配置。下面介绍Spring Boot在实际项目中使用到的系统配置、如何自定义配置。</p>
<h2 id="3-1-系统配置文件"><a href="#3-1-系统配置文件" class="headerlink" title="3.1　系统配置文件"></a>3.1　系统配置文件</h2><p>本节讲述Spring Boot的系统配置文件，包括application.properties和application.yml配置文件的使用以及YML和Properties配置文件有什么区别，最后介绍如何更改Spring Boot的启动图案。</p>
<h3 id="3-1-1-application-properties"><a href="#3-1-1-application-properties" class="headerlink" title="3.1.1　application.properties"></a>3.1.1　application.properties</h3><p>Spring Boot支持两种不同格式的配置文件：一种是Properties，另一种是YML。Spring Boot默认使用application.properties作为系统配置文件，项目创建成功后会默认在resources目录下生成application.properties文件。该文件包含Spring Boot项目的<strong>全局配置</strong>。我们可以在application.properties文件中配置Spring Boot支持的所有配置项，比如端口号、数据库连接、日志、启动图案等。接下来将介绍在Spring Boot项目开发过程中与配置相关的一些知识。</p>
<h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>Spring Boot项目创建成功后会默认resources目录下会自动创建application.properties文件。使用也非常简单，配置格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<p>在上面的示例中配置了应用的启动端口。如果不配置此项，则默认使用8080端口；如果需要使用其他端口，则通过server.port=8081修改系统启动端口。</p>
<p>此外，Properties文件中的配置项可以是无序的，但是为了保证配置文件清晰易读，建议把相关的配置项放在一起，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># thymeleaf 模板</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">spring.thymeleaf.mode=HTML</span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br></pre></td></tr></table></figure>
<p>以上示例将thymeleaf模板相关的配置放在一起，这样看起来清晰明了，从而便于快速找到thymeleaf的所有配置。</p>
<h4 id="2-配置文件加载顺序"><a href="#2-配置文件加载顺序" class="headerlink" title="2. 配置文件加载顺序"></a>2. 配置文件加载顺序</h4><p>Spring Boot项目的配置文件默认存放在resources目录中。实际上，Spring Boot系统启动时会读取4个不同路径下的配置文件：</p>
<p>1）项目根目录下的config目录。</p>
<p>2）项目根目录。</p>
<p>3）classpath下的config目录。</p>
<p>4）classpath目录。</p>
<p>Spring Boot会从这4个位置全部加载主配置文件，这4个位置中的application.properties文件的优先级按照上面列出的顺序依次降低。如果同一个属性都出现在这4个文件中，则以优先级高的文件为准。</p>
<h4 id="3-修改默认配置文件名"><a href="#3-修改默认配置文件名" class="headerlink" title="3. 修改默认配置文件名"></a>3. 修改默认配置文件名</h4><p>可能有人会问，项目的配置文件必须命名为application.properties吗？当然不是，我们可以通过修改项目启动类，调用SpringApplicationBuilder类的properties()方法来实现自定义配置文件名称。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(ApplicationDemo.class)</span><br><span class="line">           .properties(<span class="string">&quot;spring.config.location=classpath:/ application.propertie&quot;</span>).run(args);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot项目启动加载时默认读取更改名称的配置文件，即可修改默认加载的application.yml文件名。</p>
<h3 id="3-1-2-application-yml"><a href="#3-1-2-application-yml" class="headerlink" title="3.1.2　application.yml"></a>3.1.2　application.yml</h3><p>application.yml是以yml为后缀，使用YAML（YAML Ain’t a Markup Language）的配置文件。与XML等标记语言相比，YMAL结构更清晰易读，更适合用作属性配置文件。</p>
<h4 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>YML基本语法为key:（空格）value的键值对形式，冒号后面必须加上空格。通过空格的缩进来控制属性的层级关系，只要是左对齐的一列数据，都是同一个层级的。具体格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">max-history:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">10MB</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，自定义配置了系统的日志级别、文件路径等属性。可以看到logging下包含level和file两个子配置项。</p>
<p>YML文件虽然格式简洁直观，但是对格式要求较高，使用YML配置文件时需要注意以下几点：</p>
<p>1）属性值和冒号中间必须有空格，如name: Weiz正确，使用name:Weiz就会报错。</p>
<p>2）需要注意各属性之间的缩进和对齐。</p>
<p>3）缩进不允许使用tab，只允许空格。</p>
<p>4）属性和值区分字母大小写。</p>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h4><p>YML文件以数据为中心，支持数组、JSON对象、Map等多种数据格式，因此更适合用作配置文件。</p>
<p>（1）普通的值（数字、字符串、布尔值）</p>
<p>普通的数据通过k:v的键值对形式直接编写，普通的值类型或字符串默认不用加上单引号或者双引号。</p>
<p>当然，也可以使用双引号（””）来转义字符串中的特殊字符，特殊字符转义后就表示它自身的意思，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;zhangsan \n lisi&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br></pre></td></tr></table></figure>
<p>使用单引号（’’）不会转义特殊字符，所有字符都按照普通字符处理，作为字符串数据，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&#x27;zhangsan \n lisi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例会输出：zhangsan \n lisi。“\n”字符作为普通的字符串，而不转义为换行。</p>
<p>（2）对象、Map（属性和值）</p>
<p>对象同样是以k:v的键值对方式展现的，只是对象的各个属性和值的关系通过换行和缩进方式来编写。示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>如果使用行内写法，可以将对象的属性和值写成JSON格式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（3）数组（List、Set）</p>
<p>数组是以- value的形式表示数组中的元素的，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">wangwu</span></span><br></pre></td></tr></table></figure>
<p>还可以采用行内写法，数组使用中括号的形式，具体写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">persons:</span> [<span class="string">zhangsan</span>, <span class="string">lisi</span>, <span class="string">wangwu</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以看到，YML文件除了支持基本的数据类型之外，还支持对象、Map、JSON、数组等格式，这样可以在配置文件中直接定义想要的数据类型，无须额外转换。这也是程序员喜欢用application.yml的原因之一。</p>
<h3 id="3-1-3-Properties与YML配置文件的区别"><a href="#3-1-3-Properties与YML配置文件的区别" class="headerlink" title="3.1.3　Properties与YML配置文件的区别"></a>3.1.3　Properties与YML配置文件的区别</h3><p>Spring Boot中的配置文件有Properties或者YML两种格式。一般情况下，两者可以随意使用，我们可以根据自己的使用习惯选择适合的配置文件格式。这两者完全一样吗？肯定不是，YML和Properties配置文件的区别如下：</p>
<p>1）YML文件以数据为中心，对于数据的支持和展现非常友好。</p>
<p>2）Properties文件对格式的要求没那么严格，而YML文件以空格的缩进来控制层级关系，对格式的要求比较高，缩进格式不对时容易出错。</p>
<p>3）Properties文件支持@PropertySource注解，而YML文件不支持。</p>
<p>4）YML文件支持多文档块的使用方式，使用起来非常灵活。</p>
<p>5）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<h3 id="3-1-4-实战：自定义系统的启动图案"><a href="#3-1-4-实战：自定义系统的启动图案" class="headerlink" title="3.1.4　实战：自定义系统的启动图案"></a>3.1.4　实战：自定义系统的启动图案</h3><p>我们知道Spring Boot程序启动时，控制台会输出由一串字符组成的Spring符号的启动图案（Banner）以及版本信息（见图3-1）。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091848972.png" alt="image-20231009184827930"></p>
<p>Spring Boot自带的启动图案是否可以自定义呢？答案是肯定的。下面通过示例来演示如何自定义Spring Boot的启动图案。</p>
<p>步骤01 在项目的resources目录下新建banner.txt，示例代码如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">##     ## ###### ##       ##        #######</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">######## ######  ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ##     ##       ##       ##     ##</span><br><span class="line">##     ## ###### ####### #######  #######</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">Application Name: $&#123;application.title&#125;</span><br><span class="line">Application Version: $&#123;application.formatted-version&#125;</span><br><span class="line">Spring Boot Version: $&#123;spring-boot.formatted-version&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，通过${}获取application.properties配置文件中的相关配置信息，如Spring Boot版本、应用的版本、应用名称等信息。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;：设置控制台中输出内容的颜色，可以自定义，具体参考  			org.springframework.boot.ansi.AnsiColor。</span><br><span class="line">$&#123;application.version&#125;：用来获取MANIFEST.MF文件中的版本号，这就是在		  		Application.java中指定SpringVersion.class的原因。</span><br><span class="line">$&#123;application.formatted-version&#125;：格式化后的&#123;application.version&#125;版本信息。$&#123;spring-boot.version&#125;：Spring Boot的版本号。</span><br><span class="line">$&#123;spring-boot.formatted-version&#125;：格式化后的&#123;spring-boot.version&#125;版本信息。</span><br></pre></td></tr></table></figure>
<p>步骤02 在application.properties中配置banner.txt的路径等信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Banner 配置文件的位置</span></span><br><span class="line"><span class="string">spring.banner.location=/banner.txt</span></span><br><span class="line"><span class="comment"># 是否显示横幅图案</span></span><br><span class="line"><span class="comment"># 可选值有3个，一般不需要修改</span></span><br><span class="line"><span class="comment"># console:显示在控制台</span></span><br><span class="line"><span class="comment"># log:显示在文件</span></span><br><span class="line"><span class="comment"># off:不显示</span></span><br><span class="line"><span class="comment"># spring.main.banner-mode=console</span></span><br><span class="line"><span class="string">application.version=1.0.0.0</span></span><br><span class="line"><span class="string">application.formatted-version=v1.0.0.0</span></span><br><span class="line"><span class="string">spring-boot.version=2.1.2.RELEASE</span></span><br><span class="line"><span class="string">spring-boot.formatted-version=v2.1.2.RELEASE</span></span><br><span class="line"><span class="string">application.title=My</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>在上面的配置中，在application中设置banner.txt文件的路径、应用的版本、Spring Boot的版本等信息。</p>
<p>步骤03 启动项目，查看修改之后的启动横幅图案是否生效，如图3-2所示</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310091850116.png" alt="image-20231009185040066"></p>
<p>通过系统输出的启动日志可以看到，系统的启动图案已经变成我们自定义的样子，也就是Spring Boot的默认启动图案已经更改成自定义的启动图案。</p>
<p>Spring Boot也支持使用GIF、JPG和PNG格式的图片文件来定义横幅图案。当然，并不会把图片直接输出在控制台上，而是将图片中的像素解析并转换成ASCII编码字符之后再输出到控制台上。</p>
<h2 id="3-2-自定义配置项"><a href="#3-2-自定义配置项" class="headerlink" title="3.2　自定义配置项"></a>3.2　自定义配置项</h2><p>本节将介绍Spring Boot实现自定义配置项（也称为配置属性）。在项目开发的过程中，经常需要自定义系统业务方面的配置文件及配置项，Spring Boot如何实现自定义属性配置呢？其实非常简单，Spring Boot提供了@Value注解、@ConfigurationProperties注解和Environment接口等3种方式自定义配置项。</p>
<h3 id="3-2-1-Value"><a href="#3-2-1-Value" class="headerlink" title="3.2.1　@Value"></a>3.2.1　@Value</h3><p>在实际项目中，经常需要在配置文件中定义一些简单的配置项，Spring Boot提供@Value注解来设置简单的配置项，默认读取application.properties文件中的配置属性。下面通过示例来演示使用@Value注解添加自定义配置项。</p>
<p>首先，在application.properties配置文件中添加自定义配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们添加了firstname和secondname两个自定义配置项。</p>
<p>然后，在使用的位置调用@Value注解来获取配置项的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.firstname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String firstName;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;com.weiz.costum.secondname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String secondName;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过@Value注解获取了配置文件中对应的配置项的值。</p>
<p>需要注意的是：</p>
<p>1）使用@Value注解时，所在类必须被Spring容器管理，也就是使用@Component、@Controller、@Service等注解定义的类。</p>
<p>2）@Value需要传入完整的配置项的Key值。</p>
<p>3）@Value注解默认读取application.properties配置文件，如果需要使用其他的配置文件，可以通过@PropertySource注解指定对应的配置文件。</p>
<h3 id="3-2-2-Environment"><a href="#3-2-2-Environment" class="headerlink" title="3.2.2　Environment"></a>3.2.2　Environment</h3><p>Environment是Spring为运行环境提供的高度抽象的接口，它会自动获取系统加载的全部配置项，包括命令行参数，系统属性，系统环境，随机数，配置文件等。使用时无须其他的额外配置，只要在使用的类中注入Environment即可。下面通过示例演示Environment读取系统自定义的配置项。</p>
<p>首先，在application.properties配置文件中增加如下的配置项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.costum.firstname</span>=<span class="string">Zhang</span></span><br><span class="line"><span class="attr">com.weiz.costum.secondname</span>=<span class="string">Weiz</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在application.properties中配置了firstname和secondname两个自定义配置项。Environment读取的是系统中所有的配置。我们既可以在application.properties中设置自定义的配置项，又可以在自定义配置文件中添加配置项。</p>
<p>然后，创建单元测试方法，并注入Environment读取系统配置。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getEnv</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.firstname&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;com.weiz.costum.secondname&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Environment使用的示例代码，非常简单。不过，使用Environment时还需要注意以下两点：</p>
<p>1）使用Environment无须指定配置文件，其获取的是系统加载的全部配置文件中的配置项。</p>
<p>2）需要注意配置文件的编码格式，默认为ISO8859-1。</p>
<h3 id="3-2-3-ConfigurationProperties"><a href="#3-2-3-ConfigurationProperties" class="headerlink" title="3.2.3　@ConfigurationProperties"></a>3.2.3　@ConfigurationProperties</h3><p>在实际项目开发中，需要注入的配置项非常多时，前面所讲的@value和Environment两种方法就会比较烦琐。这时可以使用注解@ConfigurationProperties将配置项和实体Bean关联起来，实现配置项和实体类字段的关联，读取配置文件数据。下面通过示例演示@ConfigurationProperties注解如何读取配置文件。</p>
<h4 id="1-创建自定义配置文件"><a href="#1-创建自定义配置文件" class="headerlink" title="1. 创建自定义配置文件"></a>1. 创建自定义配置文件</h4><p>在resources下创建自定义的website.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.weiz.resource.name</span>=<span class="string">weiz</span></span><br><span class="line"><span class="attr">com.weiz.resource.website</span>=<span class="string">www.weiz.com</span></span><br><span class="line"><span class="attr">com.weiz.resource.language</span>=<span class="string">java</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，创建了自定义的website.properties配置文件。增加了name、website、language等三个配置项，这些配置项的名称的前缀都是com.weiz.resource。</p>
<h4 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2. 创建实体类"></a>2. 创建实体类</h4><p>创建WebSiteProperties自定义配置对象类，然后使用@ConfigurationProperties注解将配置文件中的配置项注入到自定义配置对象类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.weiz.resource&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line">    <span class="keyword">private</span> String language;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getWebsite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWebsite</span><span class="params">(String website)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.website = website;</span><br><span class="line">    &#125;    <span class="keyword">public</span> String <span class="title function_">getLanguage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> language;</span><br><span class="line">    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLanguage</span><span class="params">(String language)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.language = language;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，我们使用了@Configuration注解、@ConfigurationProperties和@PropertySource三个注解来定义WebSiteProperties实体类：</p>
<p>1）@Configuration定义此类为配置类，用于构建bean定义并初始化到Spring容器。</p>
<p>2）@ConfigurationProperties(prefix = “com.weiz.resource”)绑定配置项，其中prefix表示所绑定的配置项名的前缀。</p>
<p>3）@PropertySource(value = “classpath:website.properties”)指定读取的配置文件及其路径。@PropertySource不支持引入YML文件。</p>
<p>通过上面的WebSiteProperties类即可读取全部对应的配置项。</p>
<h4 id="3-调用配置项"><a href="#3-调用配置项" class="headerlink" title="3. 调用配置项"></a>3. 调用配置项</h4><p>使用配置实体类中的方式也非常简单，只需将WebSiteProperties注入到需要使用的类中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSiteProperties website;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(website.getName());</span><br><span class="line">    System.out.println(website.getWebsite());</span><br><span class="line">    System.out.println(website.getLanguage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-使用配置文件注意事项"><a href="#3-2-4-使用配置文件注意事项" class="headerlink" title="3.2.4　使用配置文件注意事项"></a>3.2.4　使用配置文件注意事项</h3><p>在实际项目中会碰到很多读取配置文件的应用场景，需要注意各种坑，否则会让你很惆怅。所以，我总结了一些使用配置文件时需要注意的事项：</p>
<p>1）使用YML文件时注意空格和格式缩进。</p>
<p>2）Properties文件默认使用的是ISO8859-1编码格式，容易出现乱码问题。如果含有中文，加入spring.http.encoding.charset=UTF-8配置即可。</p>
<p>3）Properties配置的优先级高于YML文件。因为YML文件的加载顺序先于Properties文件，如果两个文件存在相同的配置，后面加载的Properties中的配置会覆盖前面YML中的配置。</p>
<p>4）@PropertySource注解默认只会加载Properties文件，YML文件不能使用此注解。</p>
<p>5）简单值推荐使用@Value，复杂对象推荐使用@ConfigurationProperties。</p>
<p>6）只有Spring容器中的组件才能使用容器提供的各类方法，所以，配置读取类需要增加@Component注解才能加入Spring容器中。</p>
<h2 id="3-3-其他配置"><a href="#3-3-其他配置" class="headerlink" title="3.3　其他配置"></a>3.3　其他配置</h2><p>上一节介绍了自定义的配置，根据项目的需要自定义配置属性。Spring Boot支持很多非常实用的参数配置功能。本节介绍Spring Boot配置生成随机数、配置引用等实际项目中的实用配置。</p>
<h3 id="3-3-1-随机数"><a href="#3-3-1-随机数" class="headerlink" title="3.3.1　随机数"></a>3.3.1　随机数</h3><p>在项目开发过程中，可能需要配置生成随机数，比如说随机配置的服务器端口、随机生成登录密钥等等。Spring Boot支持在系统加载时配置随机数，使用${random}可以生成各种不同类型的随机值，从而简化代码生成的麻烦，例如生成int值、long值、string字符串。</p>
<p>Spring Boot提供的RandomValuePropertySource配置类可以很方便地生成随机数，可以生成integer、long、uuids和string类型的数据。下面通过示例来演示如何配置生成随机数。</p>
<p>首先，在application.properties中添加随机数的配置项。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机字符串</span></span><br><span class="line"><span class="attr">cfg.random.value</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="comment"># uuid</span></span><br><span class="line"><span class="attr">cfg.random.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="comment"># 随机int</span></span><br><span class="line"><span class="attr">cfg.random.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="comment"># 随机long</span></span><br><span class="line"><span class="attr">cfg.random.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="comment"># 10以内的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test1</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="comment"># 10-20的随机数</span></span><br><span class="line"><span class="attr">cfg.random.test2</span>=<span class="string">$&#123;random.int[10,20]&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，在application.properties配置文件中增加配置项以使用${radom.xxx}的形式实现生成随机数。</p>
<p>然后，创建配置映射类ConfigRandomValue获取随机数配置项，读取配置项的方式和读取普通配置项的方式一样：通过@Value或者@ConfigurationProperties注解来读取。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigRandomValue</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.number&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.bignumber&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> bigNumber;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.uuid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number2;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;cfg.random.test2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，验证随机数配置是否生效。创建单元测试，验证随机数是否生成成功。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigRandomValue randomValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(randomValue.getSecret());</span><br><span class="line">    System.out.println(randomValue.getUuid());</span><br><span class="line">    System.out.println(randomValue.getBigNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber());</span><br><span class="line">    System.out.println(randomValue.getNumber2());</span><br><span class="line">    System.out.println(randomValue.getNumber3());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先注入了自定义的随机数生成配置类，然后调用了相关的配置项来验证随机数规则是否生效。</p>
<h3 id="3-3-2-配置引用"><a href="#3-3-2-配置引用" class="headerlink" title="3.3.2　配置引用"></a>3.3.2　配置引用</h3><p>Spring Boot支持使用占位符获取之前的属性配置，也就是在后一个配置的值中直接引用先前定义过的配置项，直接解析其中的值。这样做的好处是：在多个具有相互关联的配置项中，只需要对其中一处配置项预先设置，其他地方都可以引用，省去了后续多处修改的麻烦。</p>
<p>使用格式为：${name}，name表示先前在配置文件中已经设置过的配置项名。下面通过示例演示如何在配置文件中实现参数引用。</p>
<p>我们修改application.properties配置文件，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.name</span>=<span class="string">ZhangSan</span></span><br><span class="line"><span class="attr">my.sex</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name&#125;.</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先设置了my.name=ZhangSan；接着在my.des配置项中使用${my.name}来引用my.name配置项的值。my.des获取到的是：My name is ZhangSan。</p>
<p>${my.name}还可以使用“:”指定默认值，避免没有配置参数导致程序异常，示例代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.des</span>=<span class="string">My name is $&#123;my.name:weiz&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过冒号“:”设置配置项的默认值为：weiz，如果配置项为空或者未找到该配置项，系统也不会出错，my.des获取到的是：My name is weiz。</p>
<p>随机数和配置引用非常简单，在项目开发过程中非常实用。</p>
<h2 id="3-4-日志配置"><a href="#3-4-日志配置" class="headerlink" title="3.4　日志配置"></a>3.4　日志配置</h2><p>我们知道日志对于系统监控、故障定位非常重要，比如当生产系统发生问题时，完整清晰的日志记录有助于快速定位问题。接下来介绍Spring Boot对日志的支持。</p>
<h3 id="3-4-1-Spring-Boot日志简介"><a href="#3-4-1-Spring-Boot日志简介" class="headerlink" title="3.4.1　Spring Boot日志简介"></a>3.4.1　Spring Boot日志简介</h3><p>Spring Boot自带spring-boot-starter-logging库实现系统日志功能，spring-boot-starter-logging组件默认使用LogBack日志记录工具。系统运行日志默认输出到控制台，也能输出到文件中。下面通过示例来演示Spring Boot项目配置日志的功能。</p>
<p>修改pom.xml文件，添加spring-boot-starter-logging依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动项目，查看控制台的日志输出情况，如图3-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092018150.png" alt="image-20231009201809999"></p>
<p>在默认情况下，Spring Boot会用LogBack来记录日志，并用INFO级别输出到控制台。运行应用程序，可以看到很多INFO级别的日志。</p>
<h3 id="3-4-2-配置日志格式"><a href="#3-4-2-配置日志格式" class="headerlink" title="3.4.2　配置日志格式"></a>3.4.2　配置日志格式</h3><p>在Spring Boot项目中配置日志功能之后，如何定制自己的日志格式、自定义记录的信息呢？Spring Boot提供了logging.pattern.console和logging.pattern.file配置项来定制日志输出格式，只需在application.properties文件中添加logging.pattern.console的配置项即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</span><br></pre></td></tr></table></figure>
<p>上述配置的示例中，对应符号的含义如下：</p>
<p>%d{HH:mm:ss.SSS}：日志输出时间。</p>
<p>%thread：输出日志的进程名，这在Web应用以及异步任务处理中很有用。</p>
<p>%-5level：日志级别，使用5个字符靠左对齐。</p>
<p>%logger-：日志输出者的名称。</p>
<p>%msg：日志消息。</p>
<p>%n：平台的换行符。</p>
<p>修改完配置项再重启项目，查看控制台的日志输出情况，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092035331.png" alt="image-20231009203539284"></p>
<p>Spring Boot控制台启动日志的格式已经改成配置的格式。</p>
<h3 id="3-4-3-日志输出级别"><a href="#3-4-3-日志输出级别" class="headerlink" title="3.4.3　日志输出级别"></a>3.4.3　日志输出级别</h3><p>一般而言，系统的日志级别为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt;FATAL，级别逐渐提高。如果日志级别设置为INFO，则意味着TRACE和DEBUG级别的日志都不会输出。</p>
<p>Spring Boot通过logging.level配置项来设置日志输出级别，下面通过示例演示Spring Boot日志输出级别。</p>
<p>首先，添加Log级别测试类LogDemo，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">logMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从trace到error日志级别由低到高</span></span><br><span class="line">        <span class="comment">// 可以调整输出的日志级别，日志就只会在这个级别后的高级别生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;LogDemo trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;LogDemo debug日志...&quot;</span>);</span><br><span class="line">        <span class="comment">// Spring Boot默认使用的是info级别，没有指定级别就用Spring Boot默认规定的级别，即root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;LogDemo info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;LogDemo warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;LogDemoerror日志...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello log&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，针对每个日志级别输出了一行日志。我们可以调整输出的日志级别，让其只在该级别以后的高级别生效。</p>
<p>然后，配置日志输出级别，在application.properties中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=warn</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用logging.level.root指定整个项目的日志级别为WARN。当然，我们也可以对某个包指定单独的日志级别，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=INFO</span><br><span class="line">logging.level.com.weiz.example01.log=WARN</span><br></pre></td></tr></table></figure>
<p>在上面的配置示例，我们将整个项目的日志级别设置为INFO，同时将指定包com.weiz.example01下的日志级别设置为WARN。</p>
<p>最后，启动项目验证日志的输出情况，如图3-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092037071.png" alt="image-20231009203750022"></p>
<p>如图3-5所示，Spring Boot控制台输出的系统启动日志为INFO级别，而com.weiz.example01.log下LogDemo的日志级别设置为WARN，输出了WARN、INFO和ERROR的日志。</p>
<h3 id="3-4-4-保存日志文件"><a href="#3-4-4-保存日志文件" class="headerlink" title="3.4.4　保存日志文件"></a>3.4.4　保存日志文件</h3><p>一般情况下，在开发环境中习惯通过控制台查看日志，但是生产环境中需要将日志信息保存到磁盘上，以便于日后的日志查询。应该如何配置才能将日志信息保存到日志文件内呢？下面演示保存日志文件的过程。</p>
<p>在resources目录下的application.properties配置文件中添加如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.file.name=D:/var/log/spring_log.log</span><br></pre></td></tr></table></figure>
<p>重新启动项目，可以看到在D:/var/log目录下生成了spring_log.log文件，该文件的内容和控制台打印输出的内容一致，如图3-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092043631.png" alt="image-20231009204300583"></p>
<h2 id="3-5-实战：实现系统多环境配置"><a href="#3-5-实战：实现系统多环境配置" class="headerlink" title="3.5　实战：实现系统多环境配置"></a>3.5　实战：实现系统多环境配置</h2><p>在实际项目开发的过程中，需要面对不同的运行环境，比如开发环境、测试环境、生产环境等，每个运行环境的数据库、Redis服务器等配置都不相同，每次发布测试、更新生产都需要手动修改相关系统配置。这种方式特别麻烦，费时费力，而且出错的概率极大。庆幸的是，Spring Boot为我们提供了更加简单方便的配置方案来解决多环境的配置问题，下面就来演示Spring Boot系统如何实现多环境配置。</p>
<h3 id="3-5-1-多环境的配置"><a href="#3-5-1-多环境的配置" class="headerlink" title="3.5.1　多环境的配置"></a>3.5.1　多环境的配置</h3><p>通常应用系统可能在开发环境（dev）、测试环境（test）、生产环境（prod）中运行，那么如何做到多个运行环境配置灵活、快速切换呢？Spring Boot提供了极简的解决方案，只需要简单的配置，应用系统就能灵活切换运行环境配置。</p>
<h4 id="1-创建多环境配置文件"><a href="#1-创建多环境配置文件" class="headerlink" title="1. 创建多环境配置文件"></a>1. 创建多环境配置文件</h4><p>创建多环境配置文件时，需要遵循Spring Boot允许的命名约定来命名，格式为application-{profile}.properties，其中{profile}为对应的环境标识。在项目resources目录下分别创建application-dev.properties、application-test.properties和application-prod.properties三个配置文件，对应开发环境、测试环境和生产环境，如图3-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092045861.png" alt="image-20231009204506816"></p>
<p>如图3-7所示，根据应用系统中常见的三个运行环境拆分成了多个不同的配置文件，分别独立配置上面各运行环境的配置项。具体如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application.properties为项目主配置文件，包含项目所需的所有公共配置。</span><br><span class="line">application-dev.properties为开发环境配置文件，包含项目所需的单独配置。</span><br><span class="line">application-test.properties为测试环境配置文件。</span><br><span class="line">application-prod.properties为生产环境配置文件。</span><br></pre></td></tr></table></figure>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>通常情况下，开发环境、测试环境和生产环境使用的数据库是不一样的，所以接下来以不同环境配置不同数据库为例来演示多环境的配置。</p>
<p>首先，修改application.properties，配置系统的启动端口：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端口配置</span><br><span class="line">server.port=8088</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，application.properties包含项目所需的所有公共配置，这里配置系统的启动端口，所有环境的启动端口都是8088。</p>
<p>然后，修改application-dev.properties开发环境的配置，增加数据库的连接配置，代码示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 指定数据库驱动</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"># 数据库jdbc连接url地址</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/myapp_dev</span><br><span class="line"># 数据库账号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></table></figure>
<p>配置数据库连接的相关属性，我们看到开发环境配置的数据库是myapp_dev。</p>
<p>其他环境的配置文件修改对应的配置连接即可，以上项目的多环境配置就完成了。接下来演示切换项目运行环境。</p>
<h3 id="3-5-2-多环境的切换"><a href="#3-5-2-多环境的切换" class="headerlink" title="3.5.2　多环境的切换"></a>3.5.2　多环境的切换</h3><p>前面讲了如何配置多环境，那么，在实际测试、运行过程中如何切换系统运行环境呢？这个也非常简单，通过修改application.properties配置文件中的spring.profiles.active配置项来激活相应的运行环境。如果没有指定任何profile的配置文件，Spring Boot默认会启动application-default.properties（默认环境）。</p>
<p>指定项目的启动环境有以下3种方式：</p>
<p>（1）配置文件指定项目启动环境</p>
<p>Spring Boot支持通过spring.profiles.active配置项目启动环境，在application.properties配置文件中增加如下配置项指定对应的环境目录：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 系统运行环境</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过在application.properties配置文件中设置spring.profiles.active的配置项来配置系统的运行环境。这里配置的是dev开发环境。</p>
<p>（2）IDEA编译器指定项目启动环境</p>
<p>一般在IDEA启动时，直接在IDEA的Run/debug Configuration页面配置项目启动环境，如图3-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092048033.png" alt="image-20231009204827985"></p>
<p>如图3-8所示，项目调试运行时，IDEA编译器可以通过VM options、Program arguments、Active profiles三个参数设置启动方式。</p>
<p>（3）命令行启动指定项目环境</p>
<p>在命令行通过java -jar命令启动项目时，需要如下指定启动环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.<span class="property">jar</span> --spring.<span class="property">profiles</span>.<span class="property">active</span>=dev</span><br></pre></td></tr></table></figure>
<p>如上所示，程序打包之后，可以在命令行使用java -jar的方式启动，并设置启动参数spring.profiles.active=dev，以开发环境为默认配置。在application-{profile}.properties中配置完成后，启动项目时，在系统启动日志中可以看到加载的是哪个环境的配置文件，如图3-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092051552.png" alt="image-20231009205139509"></p>
<p>在上面的启动日志中可以看到系统目前启动的是dev开发环境。如果实现相关的数据库测试方法，可以验证相应的数据库操作是否生效。</p>
<h1 id="第4章-Web开发"><a href="#第4章-Web开发" class="headerlink" title="第4章　Web开发"></a>第4章　Web开发</h1><p>本章主要讲解Spring Boot开发Web应用的相关技术点，包括使用spring-boot-starter-web组件来实现Web应用开发、URL地址映射、参数传递、数据校验规则等，然后介绍统一数据返回和统一异常处理，最后介绍如何根据项目需求配置Web项目，包括拦截器、跨域访问、视图解析、数据格式化等。</p>
<h2 id="4-1-Web开发简介"><a href="#4-1-Web开发简介" class="headerlink" title="4.1　Web开发简介"></a>4.1　Web开发简介</h2><p>本节主要介绍Spring Boot对Web应用开发提供了哪些支持，首先介绍Spring Boot 提供的Web组件spring-boot-starter-web，然后介绍@Controller和@RestController注解，以及控制数据返回的@ResponseBody注解，最后介绍Web配置，以便让读者对使用Spring Boot开发Web系统有初步的了解。</p>
<h3 id="4-1-1-Web入门"><a href="#4-1-1-Web入门" class="headerlink" title="4.1.1　Web入门"></a>4.1.1　Web入门</h3><p>当前，Spring毫无疑问已经成为Java企业应用开发的标准框架之一，它提供了众多的可配置功能模块和第三方组件，几乎可以解决企业开发中的所有问题。不过，Spring也带来了复杂的配置项，这对初学者而言简直就是灾难，于是Spring Boot应运而生。Spring Boot将传统Web开发的mvc、json、validation、tomcat等框架整合，提供了spring-boot-starter-web组件，简化了Web应用配置、开发的难度，将初学者从繁杂的配置项中解放出来，专注于业务逻辑的实现。</p>
<h4 id="1-spring-boot-starter-web介绍"><a href="#1-spring-boot-starter-web介绍" class="headerlink" title="1. spring-boot-starter-web介绍"></a>1. spring-boot-starter-web介绍</h4><p>Spring Boot自带的spring-boot-starter-web组件为Web应用开发提供支持，它内嵌的Tomcat以及Spring MVC的依赖使用起来非常方便。</p>
<p>Spring Boot创建Web应用非常简单，先创建一个普通的Spring Boot项目，然后修改pom.xml文件将spring-boot-starter-web组件加入项目就可以创建Web应用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们使用IDEA编辑器打开新创建的Web项目。打开Maven中的Dependencies，查看spring-boot-starter-web启动器（Starters）会引入哪些依赖JAR包，如图4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092217758.png" alt="image-20231009221716617"></p>
<p>由图4-1可见，spring-boot-starter-web启动器主要包括web、webmvc、json、tomcat等基础依赖组件，作用是提供Web开发场景所需的所有底层依赖。其中webmvc为Web开发的基础框架，json为JSON数据解析组件，tomcat为自带的容器依赖。所以，只需引入spring-boot-starter-web启动器即可实现Web应用开发，而无须额外引入Tomcat以及其他Web依赖文件。</p>
<p>另外，开发Web应用可能还会用到模板引擎，Spring Boot提供了大量的模板引擎，包括FreeMarker、Groovy、Thymeleaf、Velocity和Mustache等。Spring Boot官方推荐使用Thymeleaf。</p>
<h4 id="2-Web项目结构"><a href="#2-Web项目结构" class="headerlink" title="2. Web项目结构"></a>2. Web项目结构</h4><p>Spring Boot的Web应用与其他的Spring Boot应用基本没有区别，只是resources目录中多了static静态资源目录以及templates页面模板目录。Spring Boot Web项目结构如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092219453.png" alt="image-20231009221907411"></p>
<h4 id="3-实现简单的Web请求"><a href="#3-实现简单的Web请求" class="headerlink" title="3. 实现简单的Web请求"></a>3. 实现简单的Web请求</h4><p>Spring Boot不像传统的MVC框架那样必须继承某个基础类才能处理HTTP请求，只需要在类上声明@Controller注解，标注这是一个控制器，然后使用@RequestMapping注解把HTTP请求映射到对应的方法即可。具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，@RequestMapping注解用于定义请求的路由地址，既可以作用在方法上，又可以作用在类上。</p>
<p>启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。">http://localhost:8080/hello地址，就可以看到页面返回“hello，world”。这说明一个简单的Web项目创建成功了。</a></p>
<h3 id="4-1-2-Controller和-RestController"><a href="#4-1-2-Controller和-RestController" class="headerlink" title="4.1.2　@Controller和@RestController"></a>4.1.2　@Controller和@RestController</h3><p>Spring Boot提供了@Controller和@RestController两种注解来标识此类负责接收和处理HTTP请求。如果请求的是页面和数据，使用@Controller注解即可；如果只是请求数据，则可以使用@RestController注解。</p>
<h4 id="1-Controller的用法"><a href="#1-Controller的用法" class="headerlink" title="1. @Controller的用法"></a>1. @Controller的用法</h4><p>Spring Boot提供的@Controller注解主要用于页面和数据的返回。下面创建HelloController响应前台页面请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        map.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thymeleaf-index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;thymeleaf/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例用于请求/user/index地址，返回具体的index页面和name=thymeleaf-index的数据。在前端页面中可以通过${name}参数获取后台返回的数据并显示到页面中。</p>
<p>在@Controller类中，如果只返回数据到前台页面，需要使用@ResponseBody注解，否则会报错。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-RestController的用法"><a href="#2-RestController的用法" class="headerlink" title="2. @RestController的用法"></a>2. @RestController的用法</h4><p>Spring Boot提供的@RestController注解用于实现数据请求的处理。默认情况下，@RestController注解会将返回的对象数据转换为JSON格式。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义/user/getUser接口返回JSON格式的User数据。同时，@RequestMapping注解可以通过method参数指定请求的方式。如果请求方式不对，则会报错。</p>
<p>近几年前端框架越来越强大，前后端分离的RESTful架构成为主流。Spring Boot对RESTful也做了非常完善的支持，使用也特别简单，使用@RestController注解自动返回JSON格式的数据，同时使用@GetMapping、PostMapping等注解实现映射RESTful接口。</p>
<h4 id="3-RestController和-Controller的区别"><a href="#3-RestController和-Controller的区别" class="headerlink" title="3. @RestController和@Controller的区别"></a>3. @RestController和@Controller的区别</h4><p>@Controller和@RestController注解都是标识该类是否可以处理HTTP请求，可以说@RestController是@Controller和@ResponseBody的结合体，是这两个注解合并使用的效果。虽然二者的用法基本类似，但还是有一些区别，具体如下：</p>
<p>1）@Controller标识当前类是Spring MVC Controller处理器，而@RestController则只负责数据返回。</p>
<p>2）如果使用@RestController注解，则Controller中的方法无法返回Web页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return中的数据。</p>
<p>3）如果需要返回指定页面，则使用@Controller注解，并配合视图解析器返回页面和数据。如果需要返回JSON、XML或自定义内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p>
<p>4）使用@Controller注解时，在对应的方法上，视图解析器可以解析返回的JSP、HTML页面，并且跳转到相应页面。若返回JSON等内容到页面，则需要添加@ResponseBody注解。</p>
<p>5）@RestController注解相当于@Controller和@ResponseBody两个注解的结合，能直接将返回的数据转换成JSON数据格式，无须在方法前添加@ResponseBody注解，但是使用@RestController注解时不能返回JSP、HTML页面，因为视图解析器无法解析JSP、HTML页面。</p>
<p>总之，在Web系统中使用@Controller较多，而在Web API中基本使用@RestController注解。</p>
<h3 id="4-1-3-RequestMapping"><a href="#4-1-3-RequestMapping" class="headerlink" title="4.1.3　@RequestMapping"></a>4.1.3　@RequestMapping</h3><p>@RequestMapping注解主要负责URL的路由映射。它可以添加在Controller类或者具体的方法上，如果添加在Controller类上，则这个Controller中的所有路由映射都将会加上此映射规则，如果添加在方法上，则只对当前方法生效。@RequestMapping注解包含很多属性参数来定义HTTP的请求映射规则。常用的属性参数如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value：请求URL的路径，支持URL模板、正则表达式。</span><br><span class="line">method：HTTP请求的方法。</span><br><span class="line">consumes：允许的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Content-Type。</span><br><span class="line">produces：相应的媒体类型，如consumes=&quot;application/json&quot;为HTTP的Accept字段。params：请求参数。</span><br><span class="line">headers：请求头的值。</span><br></pre></td></tr></table></figure>
<p>以上属性基本涵盖了一个HTTP请求的所有参数信息。其中，value和method属性比较常用。</p>
<h3 id="4-1-4-ResponseBody"><a href="#4-1-4-ResponseBody" class="headerlink" title="4.1.4　@ResponseBody"></a>4.1.4　@ResponseBody</h3><p>@ResponseBody注解主要用于定义数据的返回格式，作用在方法上，默认使用Jackson序列化成JSON字符串后返回给客户端，如果是字符串，则直接返回。</p>
<p>在Controller中有时需要返回JSON格式的数据，如果想直接返回数据体而不是视图名，则需要在方法上使用@ResponseBody。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，请求/user/getUser时，返回JSON格式的User数据。这与@RestController的作用类似。</p>
<p>需要注意的是，使用@ResponseBody注解时需要注意请求的类型和地址，如果期望返回JSON，但是请求URL以html结尾的页面，就会导致Spring Boot认为请求的是HTML类型的资源，而返回JSON类型的资源，与期望类型不一致，因此报出如下错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There was an unexpected <span class="title function_">error</span> <span class="params">(type=Not Acceptable, status=<span class="number">406</span>)</span>. Could not find acceptable representation</span><br></pre></td></tr></table></figure>
<p>根据RESTful规范的建议，在Spring Boot应用中，如果期望返回JSON类型的资源，URL请求资源后缀就使用json；如果期望返回视图，URL请求资源后缀就使用html。</p>
<h2 id="4-2-URL映射"><a href="#4-2-URL映射" class="headerlink" title="4.2　URL映射"></a>4.2　URL映射</h2><p>上一节介绍了Spring Boot对Web项目开发都做了哪些支持，还介绍了@Controller和@RestController等注解，那么Spring Boot是如何将HTTP请求映射到具体方法的呢？Spring Boot支持<strong>URL路径匹配、HTTP Method匹配、params和header匹配</strong>等URL映射。本节开始介绍Spring Boot的URL映射。</p>
<h3 id="4-2-1-URL路径匹配"><a href="#4-2-1-URL路径匹配" class="headerlink" title="4.2.1　URL路径匹配"></a>4.2.1　URL路径匹配</h3><h4 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1. 精确匹配"></a>1. 精确匹配</h4><p>@RequestMapping的value属性用于匹配URL映射，value支持简单表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@PathVariable注解作用在方法参数中，用于表示参数的值来自URL路径。如果URL中的参数名称与方法中的参数名称一致，则可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getDataById/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getDataById:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中访问/getDataById/1时，会自动映射到后台的getDataById方法，传入参数id的值为1。</p>
<h4 id="2-通配符匹配"><a href="#2-通配符匹配" class="headerlink" title="2. 通配符匹配"></a>2. 通配符匹配</h4><p>@RequestMapping支持使用通配符匹配URL，用于统一映射某些URL规则类似的请求，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getJson/*.json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;get json data&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当在浏览器中请求/getJson/a.json或者/getJson/b.json时都会匹配到后台的getJson方法。</p>
<p>@RequestMapping的通配符匹配非常简单实用，支持“<em>”“?”“*</em>”等通配符。使用时需要了解通配符的匹配规则，否则容易出错。通配符匹配规则如下：</p>
<p>1）符号“*”匹配任意字符，符号**匹配任意路径，符号“?”匹配单个字符。*</p>
<p>2）有通配符的优先级低于没有通配符的，比如/user/add.json比/user/*.json优先匹配。</p>
<p>3）有“<em>*”通配符的优先级低于有“\</em>”通配符的。</p>
<h3 id="4-2-2-Method匹配"><a href="#4-2-2-Method匹配" class="headerlink" title="4.2.2　Method匹配"></a>4.2.2　Method匹配</h3><p>HTTP请求Method有GET、POST、PUT、DELETE等方式。HTTP支持的全部Method和说明如表4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092235704.png" alt="image-20231009223549957"></p>
<p>对于Web应用，GET和POST是经常使用的选项，而对于RESTful接口，则会使用PUT、DELETE等从语义上进一步区分操作。</p>
<p>@RequestMapping注解提供了method参数指定请求的Method类型，包括RequestMethod.GET、RequestMethod.POST、RequestMethod.DELETE、RequestMethod.PUT等值，分别对应HTTP请求的Method。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod GET&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/getData&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">PostData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;RequestMethod POST&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例实现了GET和POST两种方式。当使用GET方式请求/data/getData接口时，会返回“RequestMethod GET”，使用POST方式请求/data/getData接口时，则返回“RequestMethod POST”，说明@RequestMapping通过HTTP请求Method映射不同的后台方法。</p>
<h3 id="4-2-3-consumes和produces匹配"><a href="#4-2-3-consumes和produces匹配" class="headerlink" title="4.2.3　consumes和produces匹配"></a>4.2.3　consumes和produces匹配</h3><p>@RequestMapping注解提供了consumes和produces参数用于验证HTTP请求的内容类型和返回类型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumes表示请求的HTTP头的Content-Type媒体类型与consumes的值匹配才可以调用方法。produces表示HTTP请求中的Accept字段只有匹配成功才可以调用。</span><br></pre></td></tr></table></figure>
<p>下面通过示例演示consumes和produces参数的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理request Content-Type为“application/json”类型的请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/Content&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">Consumes</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Consumes POST  Content-Type=application/json&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例只允许Content-Type=application/json的HTTP请求映射此方法，其他类型则返回“Unsupported Media Type”的错误。</p>
<h3 id="4-2-4-params和header匹配"><a href="#4-2-4-params和header匹配" class="headerlink" title="4.2.4　params和header匹配"></a>4.2.4　params和header匹配</h3><p>@RequestMapping注解提供了header参数和params参数，通过header参数可以根据HTTP请求中的消息头内容映射URL请求，通过params参数可以匹配HTTP中的请求参数实现URL映射。</p>
<h4 id="1-params"><a href="#1-params" class="headerlink" title="1. params"></a>1. params</h4><p>Spring Boot除了通过匹配URL和Method的方式实现映射HTTP请求之外，还可以通过匹配params的方式来实现。Spring Boot从请求参数或HTTP头中提取参数，通过判断参数，如params=”action=save”确定是否通过。同时还可以设置请求参数包含某个参数、不包含某个参数或者参数等于某个值时通过，具体如下：</p>
<p>1）params={“username”}，存在“username”参数时通过。</p>
<p>2）params={“!password”}，不存在“password”参数时通过。</p>
<p>3）params={“age=20”}，参数age等于20时通过。</p>
<p>通过@PostMapping设置的params参数来检查请求的params，实现HTTP的URL映射。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;paramsTest&quot;,params=&quot;action=save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paramsTest</span><span class="params">(<span class="meta">@RequestBody</span> Map param)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;params test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当请求的参数action=save时，映射此方法。</p>
<h4 id="2-header"><a href="#2-header" class="headerlink" title="2. header"></a>2. header</h4><p>header的使用和params类似，它检查HTTP的header头中是否有Host=localhost:8080的参数，如果有则匹配此方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;headerTest&quot;,headers=&#123;&quot;Host=localhost:8080&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headerTest</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;header test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-参数传递"><a href="#4-3-参数传递" class="headerlink" title="4.3　参数传递"></a>4.3　参数传递</h2><p>本节开始介绍Spring Boot是如何实现参数传递的。参数传递是Web开发的基础内容，前端页面和后端服务通过请求和返回的参数来判断所执行的业务逻辑，因此参数的传递和接收是Web开发中最基础却非常重要的功能。</p>
<h3 id="4-3-1-PathVariable"><a href="#4-3-1-PathVariable" class="headerlink" title="4.3.1　@PathVariable"></a>4.3.1　@PathVariable</h3><p>在Web应用中，最常用的参数传递方式就是URL传参，也就是将参数放在请求的URL中。例如微博上不同用户的个人主页应该对应不同的URL：<a target="_blank" rel="noopener" href="http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。">http://weibo.com/user/1、http://weibo.com/user/2。我们不可能对每个用户都定义一个@RequestMapping注解的方法来映射URL请求。对于相同模式的URL，可以采用同一种规则进行处理。</a></p>
<h4 id="1-定义URL变量"><a href="#1-定义URL变量" class="headerlink" title="1. 定义URL变量"></a>1. 定义URL变量</h4><p>@RequestMapping注解使用{}来声明URL变量，例如@RequestMapping(“/user/{username}”)。其中，{username}是定义的变量规则，username是变量的名字。此URL路由可以匹配下列任意URL请求：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/user/tianmaying</span><br><span class="line">/user/ricky</span><br><span class="line">/user/tmy1234</span><br></pre></td></tr></table></figure>
<p>在@RequestMapping中定义变量规则后，Spring Boot提供的@PathVariable注解帮助我们获取URL中定义的变量参数，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userProfile</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user：&quot;</span> + username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Spring Boot会自动将URL中定义的变量传递给userProfile方法的username参数（同名赋值），例如当HTTP请求为/users/weiz时，URL变量username的值weiz会被赋给函数参数username，返回的数据为user：weiz。</p>
<p>需要注意的是，在默认情况下，<strong>变量参数不能包含URL的分隔符“/”</strong>，也就是说上面定义的URL路由不能匹配/users/weiz/zhang，即使weiz/zhang是一个存在的用户名。</p>
<h4 id="2-定义多个URL变量"><a href="#2-定义多个URL变量" class="headerlink" title="2. 定义多个URL变量"></a>2. 定义多个URL变量</h4><p>上面介绍了传递单个变量的例子，那么多个变量呢？同样，@RequestMapping支持定义包含多个URL变量的路由，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@RequestMapping(“/user/{username}/blog/{blogId}”)传入{username}和{blogId}两个参数，然后使用@PathVariable映射对应的变量参数。</p>
<p>在多变量参数的情况下，Spring Boot能够根据变量名自动赋值对应的函数参数值，也可以在@PathVariable中显式声明具体的URL变量名。</p>
<p>在默认情况下，@PathVariable注解的参数支持自动转换一些基本的数据类型，如int、long、date、string等，Spring Boot能够根据URL变量的具体值以及函数参数的数据类型来进行转换，例如/user/weiz/blog/1会将“weiz”的值赋给username，而1赋给int类型的变量blogId。</p>
<h4 id="3-匹配正则表达式"><a href="#3-匹配正则表达式" class="headerlink" title="3. 匹配正则表达式"></a>3. 匹配正则表达式</h4><p>虽然@RequestMapping路由支持URL变量，但是很多时候需要对URL变量进行更加精确的定义和限制，例如用户名只包含小写字母、数字、下划线：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user/fpc是一个合法的URL</span><br><span class="line">/user/#不是一个合法的URL</span><br></pre></td></tr></table></figure>
<p>这种情况下，简单定义{username}变量就无法满足需求了。没关系，@RequestMapping注解同样支持正则表达式匹配，可以通过定义正则表达式更精确地控制，定义语法是{变量名：正则表达式}，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;username:[a-zA-Z0-9_]+&#125;/blog/&#123;blogId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUerBlog</span><span class="params">(<span class="meta">@PathVariable</span> String username , <span class="meta">@PathVariable</span> <span class="type">int</span> blogId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user: &quot;</span> + username + <span class="string">&quot;blog：&quot;</span> + blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用[a-zA-Z0-9_]+正则表达式来限定username参数值只能包含小写字母、大写字母、数字、下划线。如此设置URL变量规则后，不合法的URL不会被处理，直接返回404Not Found。</p>
<h3 id="4-3-2-使用Bean对象接收参数"><a href="#4-3-2-使用Bean对象接收参数" class="headerlink" title="4.3.2　使用Bean对象接收参数"></a>4.3.2　使用Bean对象接收参数</h3><p>针对参数较多的<strong>表单提交</strong>，Spring Boot可以通过创建一个JavaBean对象来接收HTTP传入的表单参数。需要注意的是，<strong>JavaBean对象中必须含有默认的构造函数</strong>，同时，需要设置属性字段必须有setter方法。</p>
<h4 id="1-增加Bean实体类"><a href="#1-增加Bean实体类" class="headerlink" title="1. 增加Bean实体类"></a>1. 增加Bean实体类</h4><p>首先，增加表单对应的实体类，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String firstName;</span><br><span class="line">    <span class="keyword">private</span>  String lastName;</span><br><span class="line">    <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例定义了Student数据实体类。</p>
<h4 id="2-增加后台方法"><a href="#2-增加后台方法" class="headerlink" title="2. 增加后台方法"></a>2. 增加后台方法</h4><p>在StudentController控制器中增加save()方法，接收前台传来的数据。定义save()方法的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器中提交表单数据时，Spring Boot会自动把提交的表单数据转为Student对象，然后传递给save()方法。</p>
<h3 id="4-3-3-RequsetBody接收JSON数据"><a href="#4-3-3-RequsetBody接收JSON数据" class="headerlink" title="4.3.3　@RequsetBody接收JSON数据"></a>4.3.3　@RequsetBody接收JSON数据</h3><p>@RequestBody主要是将前端传入的JSON数据对象映射成后端的实体对象。比如，前端传入JSON格式的数据后，@RequestBody注解会自动将JSON数据反序列化成Student对象。使用时需要注意以下两点：</p>
<p>1）前端传递的对象属性和类型必须与后端对应。比如后端定义的user属性为“int id，String name”，前端必须使用相同的数据类型和字段来定义。</p>
<p>2）要使用JSON数据集进行传递，也就是设置为contentType:”application/json”。</p>
<p>下面通过示例代码演示如何使用@RequsetBody接收JSON数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/save2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save2</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> student.getFirstName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> student.getLastName();</span><br><span class="line">    <span class="keyword">return</span> firstName +<span class="string">&quot; &quot;</span>+ lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping注解包含consumes参数，默认为application/json，表示前台需要传入JSON格式的参数。另外，Spring Boot会根据名称一一对应，将数据转换成相应的数据类型。例如JSON数据中有int或date类型，前台传过来都是字符串，Spring Boot会自动将其转换成实体类中的数据类型。</p>
<h3 id="4-3-4-ModelAttribute"><a href="#4-3-4-ModelAttribute" class="headerlink" title="4.3.4　@ModelAttribute"></a>4.3.4　@ModelAttribute</h3><p>熟悉MVC的读者应该都知道，我们可以将@ModelAttribute注解放置在控制器（Controller）中的某个方法上。当请求这个控制器中的某个URL时，会<strong>首先</strong>调用这个被注解的方法并将该方法的结果作为公共模型的属性，然后调用对应URL的处理方法，前端页面通过模型获取返回的数据。</p>
<p>@ModelAttribute标注的方法会在Controller类的每个映射URL的控制执行方法之前执行。使用方法如下面的示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, userService.findUserById(userId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    System.out.println(model.containsAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当我们请求接口/user/1时，会先调用findUserById()方法，在方法内通过userId查询到对应的User对象放置到Model中。如果仅仅添加一个对象到Model中，上面的代码可以再精练一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findUserById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码返回的User对象会被自动添加到Model中，相当于手动调用了model.addAttribute(user)方法。</p>
<p>Model通过addAttribute()方法向页面传递参数。@ModelAttribute修饰的方法会先于login调用，它把请求的参数值赋给对应的变量。可以向方法中的Model添加对象，前提是在方法中加入一个Model类型的参数。</p>
<p>需要注意的是，被@ModelAttribute注释的方法会在此控制器的每个方法执行前被执行，因此对于一个控制器映射多个URL，要谨慎使用。</p>
<h3 id="4-3-5-ModelAndView对象"><a href="#4-3-5-ModelAndView对象" class="headerlink" title="4.3.5　ModelAndView对象"></a>4.3.5　ModelAndView对象</h3><p>ModelAndView也是Spring MVC中常用的数据返回对象。当控制器处理完请求时，通常会将包含视图对象和数据的ModelAndView对象一起返回前台。它的作用类似于request对象的setAttribute()方法。</p>
<p>ModelAndView对象有两个作用：</p>
<p>1）设置转向地址（这也是ModelAndView和ModelMap的主要区别）。</p>
<p>2）将后台数据传回到前台页面。</p>
<p>ModelAndView使用起来也特别简单，在控制器中把前台页面需要的数据放到ModelAndView对象中，然后返回mv对象。下面通过示例演示使用ModelAndView对象返回数据到前台页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/detail/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>userService.getUserById(id);</span><br><span class="line">   <span class="comment">// 设置user对象的username属性</span></span><br><span class="line">   mv.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">   <span class="comment">// 地址跳转，设置返回的视图名称</span></span><br><span class="line">   mv.setViewName(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，先获取用户数据，然后将数据和对象一起返回到前台detail页面。这样Spring MVC将使用包含的视图对模型数据进行渲染。</p>
<h2 id="4-4-数据验证"><a href="#4-4-数据验证" class="headerlink" title="4.4　数据验证"></a>4.4　数据验证</h2><p>对于应用系统而言，任何客户端传入的数据都不是绝对安全有效的，这就要求我们在服务端接收到数据时也对数据的有效性进行验证，以确保传入的数据安全正确。接下来介绍Spring Boot是如何实现数据验证的。</p>
<h3 id="4-4-1-Hibernate-Validator简介"><a href="#4-4-1-Hibernate-Validator简介" class="headerlink" title="4.4.1　Hibernate Validator简介"></a>4.4.1　Hibernate Validator简介</h3><p>数据校验是Web开发中的重要部分，也是必须要考虑和面对的事情。应用系统必须通过某种手段来确保输入的数据从语义上来讲是正确的。</p>
<p>目前数据校验的规范、组件非常多，有JSR-303/JSR-349、Hibernate Validator、Spring Validation。下面就来捋一捋它们之间的关系。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSR（Java Specification Request）规范是Java EE 6中的一项子规范，也叫作Bean Validation。它指定了一整套基于bean的验证API，通过标注给对象属性添加约束条件。</span><br><span class="line">Hibernate Validator是对JSR规范的实现，并增加了一些其他校验注解，如@Email、 @Length、@Range等。</span><br><span class="line">Spring Validation是Spring为了给开发者提供便捷，对Hibernate Validator进行了二次封装。同时，Spring Validation在SpringMVC模块中添加了自动校验，并将校验信息封装进了特定的类中。</span><br></pre></td></tr></table></figure>
<p>所以，JSR定义了数据验证规范，而Hibernate Validator则是基于JSR规范，实现了各种数据验证的注解以及一些附加的约束注解。Spring Validation则是对Hibernate Validator的封装整合。</p>
<p>JSR和Hibernate Validator中的常用注解如表4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310092309365.png" alt="image-20231009230908286"></p>
<p>表4-2中包含了Hibernate Validator实现的JSR-303定义的验证注解和Hibernate Validator自己定义的验证注解，同时也支持自定义约束注解。所有的注解都包含code和message这两个属性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message定义数据校验不通过时的错误提示信息。</span><br><span class="line">code定义错误的类型。</span><br></pre></td></tr></table></figure>
<p>Spring Boot是从Spring发展而来的，所以自然支持Hibernate Validator和Spring Validation两种方式，<strong>默认使用的是Hibernate Validator组件。</strong></p>
<h3 id="4-4-2-数据校验"><a href="#4-4-2-数据校验" class="headerlink" title="4.4.2　数据校验"></a>4.4.2　数据校验</h3><p>使用Hibernate Validator校验数据需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。下面以User对象为例演示如何使用Hibernate Validator校验数据。</p>
<h4 id="1-JavaBean参数校验"><a href="#1-JavaBean参数校验" class="headerlink" title="1. JavaBean参数校验"></a>1. JavaBean参数校验</h4><p>Post请求参数较多时，可以在对应的数据模型（Java Bean）中进行数据校验，通过注解来指定字段校验的规则。下面以具体的实例来进行演示。</p>
<p>首先，创建Java Bean实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(message = &quot;年龄不能为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Min(18)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，每个注解中的属性message是数据校验不通过时要给出的提示信息，如@Email(message=”邮件格式错误”)，当邮件格式校验不通过时，提示邮件格式错误。</p>
<p>然后，添加数据校验方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> User user, BindingResult result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getName();</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123;</span><br><span class="line">        List&lt;ObjectError&gt; list = result.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : list) &#123;</span><br><span class="line">            System.out.println(error.getCode()+ <span class="string">&quot;-&quot;</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@RequestBody注解后面添加了@Valid注解，然后在后面添加了BindingResult返回验证结果，BindingResult是验证不通过时的结果集合。</p>
<p>注意，BindingResult必须跟在被校验参数之后，若被校验参数之后没有BindingResult对象，则会抛出BindException。</p>
<p>最后，运行验证。</p>
<p>启动项目，在postman中请求/user/check接口，后台输出了数据验证的结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length-密码长度错误，密码长度6-20！</span><br><span class="line">Min-最小不能小于18</span><br><span class="line">Length-姓名长度错误，姓名长度2-10！</span><br></pre></td></tr></table></figure>
<p>通过上面的输出可以看到，应用系统对传入的数据进行了校验，同时也返回了对应的数据校验结果。</p>
<h4 id="2-URL参数校验"><a href="#2-URL参数校验" class="headerlink" title="2. URL参数校验"></a>2. URL参数校验</h4><p>一般GET请求都是在URL中传入参数。对于这种情况，可以直接通过注解来指定参数的校验规则。下面通过实例进行演示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="meta">@Length(min = 2, max = 10, message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span></span><br><span class="line"><span class="params">                                                <span class="meta">@RequestParam(name = &quot;name&quot;, required = true)</span> String name,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Min(value = 1, message = &quot;年龄最小只能1&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@Max(value = 99, message = &quot;年龄最大只能99&quot;)</span></span></span><br><span class="line"><span class="params">                                        <span class="meta">@RequestParam(name = &quot;age&quot;, required = true)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot;,&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Range、@Min、@Max等注解对URL中传入的参数进行校验。需要注意的是，使用@Valid注解是无效的，需要在方法所在的控制器上添加@Validated注解来使得验证生效。</p>
<h4 id="3-JavaBean对象级联校验"><a href="#3-JavaBean对象级联校验" class="headerlink" title="3. JavaBean对象级联校验"></a>3. JavaBean对象级联校验</h4><p>对于JavaBean对象中的普通属性字段，我们可以直接使用注解进行数据校验，那如果是关联对象呢？其实也很简单，在属性上添加@Valid注解就可以作为属性对象的内部属性进行验证（验证User对象，可以验证UserDetail的字段）。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Size(min = 3,max = 5,message = &quot;list的Size在[3,5]&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> UserDetail userDetail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetail</span> &#123;</span><br><span class="line">    <span class="meta">@Length(min = 5, max = 17, message = &quot;length长度在[5,17]之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String extField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在属性上添加@Valid就可以对User中的关联对象UserDetail的字段进行数据校验。</p>
<h4 id="4-分组校验"><a href="#4-分组校验" class="headerlink" title="4. 分组校验"></a>4. 分组校验</h4><p>在不同情况下，可能对JavaBean对象的数据校验规则有所不同，有时需要根据数据状态对JavaBean中的某些属性字段进行单独验证。这时就可以使用分组校验功能，即根据状态启用一组约束。Hibernate Validator的注解提供了groups参数，用于指定分组，如果没有指定groups参数，则默认属于javax.validation.groups.Default分组。</p>
<p>下面通过示例演示分组校验。</p>
<p>首先，创建分组GroupA和GroupB，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了GroupA和GroupB两个接口作为两个校验规则的分组。</p>
<p>然后，创建实体类Person，并在相关的字段中定义校验分组规则，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;userId不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户id*/</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length(min = 30,max = 40,message = &quot;必须在[30,40]&quot;,groups = &#123;GroupB.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 20,max = 30,message = &quot;必须在[20,30]&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="comment">/**用户名*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，age字段定义了GroupA和GroupB两个分组校验规则。GroupA的校验规则为年龄在20～30，GroupB的校验规则为年龄在30～40。</p>
<p>最后，使用校验分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(&#123;GroupA.class,Default.class&#125;)</span> Person person, BindingResult result)</span>&#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(result.getAllErrors()));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在@Validated注解中增加了{GroupA.class,Default.class}参数，表示对于定义了分组校验的字段使用GroupA校验规则，其他字段使用默认规则。</p>
<h3 id="4-4-3-自定义校验"><a href="#4-4-3-自定义校验" class="headerlink" title="4.4.3　自定义校验"></a>4.4.3　自定义校验</h3><p>Hibernate Validator支持自定义校验规则。通过自定义校验规则，可以实现一些复杂、特殊的数据验证功能。下面通过示例演示如何创建和使用自定义验证规则。</p>
<h4 id="1-声明一个自定义校验注解"><a href="#1-声明一个自定义校验注解" class="headerlink" title="1. 声明一个自定义校验注解"></a>1. 声明一个自定义校验注解</h4><p>首先，定义新的校验注解@CustomAgeValidator，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Min(value = 18,message = &quot;年龄最小不能小于18&quot;)</span></span><br><span class="line"><span class="meta">@Max(value = 120,message = &quot;年龄最大不能超过120&quot;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;&#125;)</span> <span class="comment">//不指定校验器</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAgeValidator &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;年龄大小必须大于18并且小于120&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了CustomAgeValidator自定义注解，用于自定义年龄的数据校验规则。</p>
<h4 id="2-使用自定义校验注解"><a href="#2-使用自定义校验注解" class="headerlink" title="2. 使用自定义校验注解"></a>2. 使用自定义校验注解</h4><p>创建自定义校验注解CustomAgeValidator之后，在User的age属性上使用自定义组合注解，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;姓名不允许为空！&quot;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2,max = 10,message = &quot;姓名长度错误，姓名长度2-10！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@CustomAgeValidator</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="meta">@NotBlank(message = &quot;地址不能为空！&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">        <span class="meta">@Pattern(regexp = &quot;^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d&#123;8&#125;$&quot;, message = &quot;手机号格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="comment">// 省略get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在需要做特殊校验的age字段上添加@CustomAgeValidator自定义注解，这样age字段就会使用我们自定义的校验规则。</p>
<h2 id="4-5-拦截器"><a href="#4-5-拦截器" class="headerlink" title="4.5　拦截器"></a>4.5　拦截器</h2><p>拦截器在Web系统中非常常见，一般用于拦截用户请求，实现访问权限控制、日志记录、敏感过滤等功能。本节首先介绍实际项目中拦截器的应用场景，然后介绍如何实现自定义拦截器的功能。</p>
<h3 id="4-5-1-应用场景"><a href="#4-5-1-应用场景" class="headerlink" title="4.5.1　应用场景"></a>4.5.1　应用场景</h3><p>拦截器在实际的应用开发中非常常见，对于某些全局统一的操作，我们可以把它提取到拦截器中实现。总结起来，拦截器大致有以下几种使用场景：</p>
<p>1）权限检查：如登录检测，进入处理程序检测是否登录，如果没有，则直接返回登录页面。</p>
<p>2）性能监控：有时系统在某段时间莫名其妙很慢，可以通过拦截器在进入处理程序之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如Apache，可以自动记录）。</p>
<p>3）通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有提取Locale、Theme信息等，只要是多个处理程序都需要的，即可使用拦截器实现。</p>
<p>4）OpenSessionInView：如Hibernate，在进入处理程序时打开Session（会话），在完成后关闭Session。</p>
<h3 id="4-5-2-HandlerInterceptor简介"><a href="#4-5-2-HandlerInterceptor简介" class="headerlink" title="4.5.2　HandlerInterceptor简介"></a>4.5.2　HandlerInterceptor简介</h3><p>Spring Boot定义了HandlerInterceptor接口来实现自定义拦截器的功能。HandlerInterceptor接口定义了preHandle、postHandle、afterCompletion三种方法，通过重写这三种方法实现请求前、请求后等操作。</p>
<p>1）preHandle：预处理回调方法实现处理程序的预处理（如登录检查），第三个参数为响应的处理程序（如第3章的控制器的实现）。</p>
<p>返回值：true表示继续流程（如调用下一个拦截器或处理程序）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理程序，此时需要通过response来产生响应。</p>
<p>2）postHandle：后处理回调方法，实现处理程序的后处理（但在渲染视图之前），此时可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</p>
<p>3）afterCompletion：整个请求处理完之后回调方法，即在视图渲染完毕时回调，如在性能监控中，可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但是只调用处理程序执行preHandle，返回true所对应的拦截器的afterCompletion。</p>
<p>有时我们只需要实现3种回调方法之一，如果实现HandlerInterceptor接口，则无论是否需要3种方法都必须实现，此时Spring提供了一个HandlerInterceptorAdapter适配器（一种适配器设计模式的实现），允许我们只实现需要的回调方法。</p>
<h3 id="4-5-3-使用HandlerInterceptor实现拦截器"><a href="#4-5-3-使用HandlerInterceptor实现拦截器" class="headerlink" title="4.5.3　使用HandlerInterceptor实现拦截器"></a>4.5.3　使用HandlerInterceptor实现拦截器</h3><p>我们在访问某些需要授权的页面，如订单详情、订单列表等需要用户登录后才能查看的功能时，需要对这些请求拦截，进行登录检测，符合规则的才允许请求通过。接下来通过登录状态检测的例子演示拦截器的使用。</p>
<p>首先，创建自定义登录拦截器，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/*注册拦截器*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;您没有权限这么做！&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，LoginInterceptor继承HandlerInterceptor接口，实现preHandle接口，验证用户的Session状态。如果当前用户有登录信息，则可以继续访问；如果当前用户没有登录信息，则返回无权限。</p>
<p>然后，将拦截器注入系统配置。</p>
<p>定义MyMvcConfig配置类，将上面定义的LoginInterceptor拦截器注入系统中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">        .addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;/asserts/**&quot;</span>,<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过WebMvcConfigurer类的addInterceptors方法将刚刚自定义的LoginInterceptor拦截器注入系统中。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPathPatterns定义拦截的请求地址。excludePathPatterns的作用是排除某些地址不被拦截，例如登录地址/user/login不需要进行登录验证。</span><br></pre></td></tr></table></figure>
<h2 id="4-6-过滤器"><a href="#4-6-过滤器" class="headerlink" title="4.6　过滤器"></a>4.6　过滤器</h2><p>本节介绍如何使用Spring Boot实现自定义过滤器，在开发Web项目时，经常需要过滤器（Filter）来处理一些请求，包括字符集转换、过滤敏感词汇等场景。</p>
<h3 id="4-6-1-过滤器简介"><a href="#4-6-1-过滤器简介" class="headerlink" title="4.6.1　过滤器简介"></a>4.6.1　过滤器简介</h3><p>再启动类中加上@ServletComponentScan，并且自定义过滤器类，再过滤器类上加上@WebFilter。</p>
<p>过滤器优先级是根据过滤器类名按照a-z，不区分大小写进行优先级排序的，a优先级最高！！！</p>
<p>过滤器是Java Servlet规范中定义的，<strong>能够在HTTP请求发送给Servlet之前对Request（请求）和Response（返回）进行检查和修改</strong>，从而起到过滤的作用。通过对Web服务器管理的所有Web资源（如JSP、Servlet、静态图片文件或静态HTML文件等）过滤，实现特殊的功能，例如，实现URL级别的权限访问控制、过滤敏感词汇、排除有XSS威胁的字符等。</p>
<p>Spring Boot内置了很多过滤器，比如处理编码的OrderedCharacterEncodingFilter和请求转化的HiddenHttpMethodFilter，也支持根据实际需求自定义过滤器。自定义过滤器有两种实现方式：第一种是使用@<strong>WebFilter</strong>，第二种是使用<strong>FilterRegistrationBean</strong>。经过实践之后，发现使用@WebFilter自定义的过滤器优先级顺序不能生效，因此推荐使用第二种方案。</p>
<p><strong>过滤器和拦截器的功能类似，但技术实现差距比较大</strong>，两者的区别包括以下几个方面：</p>
<p>1）过滤器依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</p>
<p>2）过滤器的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。</p>
<p>3）过滤器的生命周期由Servlet容器管理，而拦截器可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用更方便。</p>
<p>拦截器和过滤器的执行顺序是：先过滤器后拦截器。具体执行过程为：过滤前→拦截前→执行→拦截后→过滤后。</p>
<h3 id="4-6-2-使用FilterRegistrationBean实现过滤器"><a href="#4-6-2-使用FilterRegistrationBean实现过滤器" class="headerlink" title="4.6.2　使用FilterRegistrationBean实现过滤器"></a>4.6.2　使用FilterRegistrationBean实现过滤器</h3><p>Spring Boot提供了FilterRegistrationBean类实现过滤器注入，实现自定义过滤器的步骤如下：</p>
<p>1）添加自定义Filter类，实现Filter接口，并实现其中的doFilter()方法。</p>
<p>2）添加@Configuration注解，将自定义过滤器加入过滤链。</p>
<p>接下来以监控请求执行时间为例，通过自定义过滤器实现系统性能监控的功能。步骤如下：</p>
<p>步骤01 创建拦截器，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTimerFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;timer Filter begin&quot;</span>);</span><br><span class="line">         <span class="type">long</span> start=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="type">long</span> end=<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">         System.out.println(<span class="string">&quot;timer Filter end,cost time:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Component注解确保被Spring Boot管理。上面的示例代码实现了doFilter()方法记录所有HTTP请求的时间。</p>
<p>步骤02 将过滤器注入系统配置中。</p>
<p>通过FilterRegistrationBean类将定义的ConsumerTimerFilter过滤器注入系统中，并配置过滤的地址和执行顺序，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">consumerLoginFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;ConsumerTimerFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> <span class="title class_">ConsumerTimerFilter</span>());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;consumerLoginFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用registration.setOrder(2)进行排序，数字越小越先执行。当有多个过滤器时，通过设置Order属性决定过滤器的执行顺序。</p>
<p>添加完后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/getUsers，就会看到控制台打印如下信息：">http://localhost:8080/getUsers，就会看到控制台打印如下信息：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer Filter begin</span><br><span class="line">timer Filter end,cost time:<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>如上所示，后台输出了请求的消耗时间，说明刚刚自定义的过滤器已经对所有的URL进行了过滤处理。</p>
<h2 id="4-7-Web配置"><a href="#4-7-Web配置" class="headerlink" title="4.7　Web配置"></a>4.7　Web配置</h2><p>本节介绍Spring Boot Web中非常重要的类：WebMvcConfigurer。有时我们需要自定义Handler、Interceptor、ViewResolver、MessageConverter实现特殊的Web配置功能，通过WebMvcConfigurer接口即可实现项目的自定义配置。</p>
<h3 id="4-7-1-WebMvcConfigurer简介"><a href="#4-7-1-WebMvcConfigurer简介" class="headerlink" title="4.7.1　WebMvcConfigurer简介"></a>4.7.1　WebMvcConfigurer简介</h3><p>在Spring Boot 1.5版本都是靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器、消息转换器等。Spring Boot 2.0以后，该类被标记为@Deprecated（弃用）。官方推荐直接实现WebMvcConfigurer接口或者直接继承WebMvcConfigurationSupport类。</p>
<p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的XML配置文件形式进行针对框架的个性化定制，可以自定义Handler、Interceptor、ViewResolver、MessageConverter。基于java-based方式的Spring MVC配置需要创建一个配置类并实现WebMvcConfigurer接口</p>
<h3 id="4-7-2-跨域访问"><a href="#4-7-2-跨域访问" class="headerlink" title="4.7.2　跨域访问"></a>4.7.2　跨域访问</h3><p>出于安全的考虑，浏览器会禁止Ajax访问不同域的地址，而在如今微服务横行的年代，跨域访问是非常常见的。这就需要应用系统既要保证系统安全，又要对前端跨域访问提供支持。所以W3C提出了CORS（Cross-Origin-Resource-Sharing）跨域访问规范，并被主流浏览器所支持。</p>
<p>Spring Boot可以基于CORS解决跨域问题，CORS是一种机制，告诉后台哪边（Origin）来的请求可以访问服务器的数据。WebMvcConfigurer配置类中的addCorsMappings()方法是专门为开发人员解决跨域而诞生的接口，其中构造参数为CorsRegistry，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addCorsMappings(registry);</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/cors/**&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;DELETE&quot;</span>,<span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，将pathPattern设置为/**，即整个系统支持跨域访问。当然也可以根据不同的项目路径定制访问行为。CorsRegistry提供了registrations属性，通过getCorsConfigurations()方法设置特定路径的跨域访问。</p>
<h3 id="4-7-3-数据转换配置"><a href="#4-7-3-数据转换配置" class="headerlink" title="4.7.3　数据转换配置"></a>4.7.3　数据转换配置</h3><p>Spring Boot支持对请求或返回的数据类型进行转换，常用到的是统一对返回的日期数据自动格式化。配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义时间格式转换器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title function_">jackson2HttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">    mapper.setDateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    converter.setObjectMapper(mapper);</span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加转换器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="comment">//将我们定义的时间格式转换器添加到转换器列表中</span></span><br><span class="line">    <span class="comment">//这样jackson格式化时但凡遇到Date类型就会转换成我们定义的格式</span></span><br><span class="line">    converters.add(jackson2HttpMessageConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先创建一个MessageConverter时间格式转换器，将设置时间的格式为”yyyy-MM-dd HH:mm:ss”，然后configureMessageConverters方法将转换器添加到系统中。这样JSON数据格式化时，统一将时间类型转换成我们定义的格式。</p>
<h3 id="4-7-4-静态资源"><a href="#4-7-4-静态资源" class="headerlink" title="4.7.4　静态资源"></a>4.7.4　静态资源</h3><p>在开发Web应用的过程中，需要引用大量的JS、CSS、图片等静态资源。Spring Boot默认提供静态资源的目录置于classpath下，目录名规则如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/static</span><br><span class="line">/public</span><br><span class="line">/resources</span><br><span class="line">/META-INF/resources</span><br></pre></td></tr></table></figure>
<p>比如，我们可以在src/main/resources/目录下创建static，在该位置放置一个文件名为xx.jpg的图片。启动程序后，访问<a target="_blank" rel="noopener" href="http://localhost:8080/xx.jpg即可访问该图片，无须其他额外配置。">http://localhost:8080/xx.jpg即可访问该图片，无须其他额外配置。</a></p>
<p>Spring Boot同样支持自定义静态资源目录，如果需要自定义静态资源映射目录，只需重写addResourceHandlers()方法即可，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理静态资源，例如图片、JS、CSS等</span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>).addResourceLocations</span><br><span class="line">(<span class="string">&quot;classpath:/images/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，创建的webconfig类继承自WebMvcConfigure类，重写了addResourceHandler()方法，通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addResourceLocations指的是文件放置的目录。</span><br><span class="line">addResoureHandler指的是对外暴露的访问路径。</span><br></pre></td></tr></table></figure>
<h3 id="4-7-5-跳转指定页面"><a href="#4-7-5-跳转指定页面" class="headerlink" title="4.7.5　跳转指定页面"></a>4.7.5　跳转指定页面</h3><p>以前编写Spring MVC的时候，如果需要访问一个页面，必须要在Controller类中编写一个页面跳转的方法。Spring Boot重写WebMvcConfigurer中的addViewControllers()方法即可达到同样的效果。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.addViewControllers(registry);</span><br><span class="line">     registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">     <span class="comment">// 实现一个请求到视图的映射，无须编写controller</span></span><br><span class="line">     registry.addViewController(<span class="string">&quot;/login&quot;</span>).setViewName</span><br><span class="line">(<span class="string">&quot;forward:/index.html&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>值得指出的是，在这里重写addViewControllers()方法并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是推荐添加自己的MVC配置的原因。</p>
<h2 id="4-8-实战：实现优雅的数据返回"><a href="#4-8-实战：实现优雅的数据返回" class="headerlink" title="4.8　实战：实现优雅的数据返回"></a>4.8　实战：实现优雅的数据返回</h2><p>本节介绍如何让前后台优雅地进行数据交互，正常的数据如何统一数据格式，以及异常情况如何统一处理并返回统一格式的数据。</p>
<h3 id="4-8-1-为什么要统一返回值"><a href="#4-8-1-为什么要统一返回值" class="headerlink" title="4.8.1　为什么要统一返回值"></a>4.8.1　为什么要统一返回值</h3><p>在项目开发过程中经常会涉及服务端、客户端接口数据传输或前后台分离的系统架构下的数据交互问题。如何确保数据完整、清晰易懂是考验开发者的大难题。定义统一的数据返回格式有利于提高开发效率、降低沟通成本，降低调用方的开发成本。目前比较流行的是基于JSON格式的数据交互。但是JSON只是消息的格式，其中的数据内容还需要重新设计和定义。无论是HTTP接口还是RPC接口，保持返回值格式统一很重要。</p>
<p>在项目中，我们会将响应封装成JSON返回，一般会统一所有接口的数据格式，使前端（iOS、Android、Web）对数据的操作一致、轻松。一般情况下，统一返回数据格式没有固定的规范，只要能描述清楚返回的数据状态以及要返回的具体数据即可，但是一般会包含状态码、消息提示语、具体数据这3部分内容。例如，一般的系统要求返回的基本数据格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weiz&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;备注&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上面的示例我们知道，定义的返回值包含4要素：响应结果、响应码、消息、返回数据。</p>
<h3 id="4-8-2-统一数据返回"><a href="#4-8-2-统一数据返回" class="headerlink" title="4.8.2　统一数据返回"></a>4.8.2　统一数据返回</h3><p>前面介绍了为什么要统一返回值以及如何实现统一JSON数据返回。接下来通过示例演示如何实现统一JSON数据返回。</p>
<h4 id="1-定义数据格式"><a href="#1-定义数据格式" class="headerlink" title="1. 定义数据格式"></a>1. 定义数据格式</h4><p>定义返回值的基本要素，确保后台执行无论成功还是失败都是返回这些字段，而不会出现其他的字段。定义的返回值包含如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer code：成功时返回0，失败时返回具体错误码。</span><br><span class="line">String message：成功时返回null，失败时返回具体错误消息。</span><br><span class="line">T data：成功时返回具体值，失败时为null。</span><br></pre></td></tr></table></figure>
<p>根据上面的返回数据格式的定义，实际返回的数据模板如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weiz&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;备注&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，data字段为泛型字段，根据实际的业务返回前端需要的数据类型。</p>
<h4 id="2-定义状态码"><a href="#2-定义状态码" class="headerlink" title="2. 定义状态码"></a>2. 定义状态码</h4><p>返回的数据中有一个非常重要的字段：状态码。状态码字段能够让服务端、客户端清楚知道操作的结果、业务是否处理成功，如果失败，失败的原因等信息。所以，定义清晰易懂的状态码非常重要。状态码定义如表4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310101858547.png" alt="image-20231010185842408"></p>
<p>以上定义的是通用状态码，其他的业务相关状态码需要根据实际业务定义。</p>
<h4 id="3-定义数据处理类"><a href="#3-定义数据处理类" class="headerlink" title="3. 定义数据处理类"></a>3. 定义数据处理类</h4><p>前面定义了返回数据的格式和处理结果的状态码，接下来定义通用的结果处理类。在实际使用时可以根据情况处理。本示例中简单定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: JSONResult.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.weiz.utils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义响应数据结构</span></span><br><span class="line"><span class="comment"> *                      200：表示成功</span></span><br><span class="line"><span class="comment"> *                      500：表示错误，错误信息在msg字段中</span></span><br><span class="line"><span class="comment"> *                      501：bean验证错误，无论多少个错误都以map形式返回</span></span><br><span class="line"><span class="comment"> *                      502：拦截器拦截到用户token出错</span></span><br><span class="line"><span class="comment"> *                      555：异常抛出信息</span></span><br><span class="line"><span class="comment"> * Copyright: Copyright (c) 2016</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年4月22日 下午8:33:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONResult</span> &#123;</span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="comment">// 响应业务状态</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 响应消息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">// 响应中的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">build</span><span class="params">(Integer status, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(status, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">500</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorMap</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">501</span>, <span class="string">&quot;error&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorTokenMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">502</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">errorException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONResult</span>(<span class="number">555</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">(Integer status, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JSONResult</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">this</span>.msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isOK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.status == <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 将json结果集转化为JSONResult对象</span></span><br><span class="line"><span class="comment">     *                          需要转换的对象是一个类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:34:58</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">formatToPojo</span><span class="params">(String jsonData, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MAPPER.readValue(jsonData, JSONResult.class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(jsonData);</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">data</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.isObject()) &#123;</span><br><span class="line">                    obj = MAPPER.readValue(data.traverse(), clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.isTextual()) &#123;</span><br><span class="line">                    obj = MAPPER.readValue(data.asText(), clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> build(jsonNode.get(<span class="string">&quot;status&quot;</span>).intValue(), jsonNode.get(<span class="string">&quot;msg&quot;</span>).asText(), obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 没有object对象的转化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:35:21</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">format</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAPPER.readValue(json, JSONResult.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Object是集合转化</span></span><br><span class="line"><span class="comment">     *                          需要转换的对象是一个list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年4月22日 下午8:35:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JSONResult <span class="title function_">formatToList</span><span class="params">(String jsonData, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> MAPPER.readTree(jsonData);</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">data</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (data.isArray() &amp;&amp; data.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                obj = MAPPER.readValue(data.traverse(),</span><br><span class="line">                        MAPPER.getTypeFactory().constructCollectionType</span><br><span class="line">(List.class, clazz));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> build(jsonNode.get(<span class="string">&quot;status&quot;</span>).intValue(), jsonNode.get(<span class="string">&quot;msg&quot;</span>).asText(), obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getOk</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ok;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOk</span><span class="params">(String ok)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ok = ok;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了数据返回处理类，定义了响应数据结构，所有接口的数据返回统一通过此类处理，接收此类数据后，需要使用本类的方法转换成对应的数据类型格式（类或者list）。</p>
<h4 id="4-处理数据返回"><a href="#4-处理数据返回" class="headerlink" title="4. 处理数据返回"></a>4. 处理数据返回</h4><p>定义数据处理类后，在控制器中将返回的数据统一加上数据处理。调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">getUserJson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    u.setName(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">    u.setAge(<span class="number">20</span>);</span><br><span class="line">    u.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    u.setPassword(<span class="string">&quot;weiz222&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><p>启动helloworld项目，浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/user/getUser，页面数据返回如下：">http://localhost:8080/user/getUser，页面数据返回如下：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;weiz222&quot;</span>,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">                <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-12-21 06:57:13&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的结果数据在正常的时候能够按照我们的预期结果格式返回。</p>
<h3 id="4-8-3-全局异常处理"><a href="#4-8-3-全局异常处理" class="headerlink" title="4.8.3　全局异常处理"></a>4.8.3　全局异常处理</h3><p>在项目开发的过程中肯定会碰到异常的情况，出现异常情况时如何处理，如何确保出现异常时程序也能正确地返回数据？总不能所有的方法都加上try catch吧？接下来介绍Spring Boot如何进行全局异常处理，捕获异常后如何按照统一格式返回数据。</p>
<h4 id="1-全局异常处理的实现方式"><a href="#1-全局异常处理的实现方式" class="headerlink" title="1. 全局异常处理的实现方式"></a>1. 全局异常处理的实现方式</h4><p>在介绍之前，我们需要先了解Spring中常见的异常处理方式有哪些。一般Spring Boot框架的异常处理有多种方式，从范围来说，包括全局异常捕获处理方式和局部异常捕获处理方式。下面介绍3种比较常用的异常处理解决方案。</p>
<p>（1）使用@ExceptionHandler处理局部异常</p>
<p>在控制器中通过加入@ExceptionHandler注解的方法来实现异常的处理。这种方式非常容易实现，但是只能处理使用@ExceptionHandler注解方法的控制器异常，而无法处理其他控制器的异常，所以不推荐使用。</p>
<p>（2）配置SimpleMappingExceptionResolver类来处理异常</p>
<p>通过配置SimpleMappingExceptionResolver类实现全局异常的处理，但是这种方式不能针对特定的异常进行特殊处理，所有的异常都按照统一的方式处理。</p>
<p>（3）使用ControllerAdvice注解处理全局异常</p>
<p>使用<strong>@ControllerAdvice</strong>、<strong>@ExceptionHandler</strong>注解实现全局异常处理，@ControllerAdvice定义全局异常处理类，@ExceptionHandler指定自定义错误处理方法拦截的异常类型。实现全局异常捕获，并针对特定的异常进行特殊处理。</p>
<p>以上三种解决方案，都能实现全局异常处理。但是，推荐使用@ControllerAdvice注解方式处理全局异常，这样可以针对不同的异常分开处理。</p>
<h4 id="2-使用-ControllerAdvice注解实现全局异常处理"><a href="#2-使用-ControllerAdvice注解实现全局异常处理" class="headerlink" title="2. 使用@ControllerAdvice注解实现全局异常处理"></a>2. 使用@ControllerAdvice注解实现全局异常处理</h4><p>下面通过示例演示@ControllerAdvice注解实现全局统一异常处理。</p>
<p>定义一个自定义的异常处理类GlobalExceptionHandler，具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ERROR_VIEW</span> <span class="operator">=</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ExceptionHandler(value = &#123;Exception.class &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">errorHandler</span><span class="params">(HttpServletRequest reqest,</span></span><br><span class="line"><span class="params">                HttpServletResponse response, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                    <span class="comment">// 记录日志</span></span><br><span class="line">                    logger.error(ExceptionUtils.getMessage(e));</span><br><span class="line">        <span class="comment">// 是否是Ajax请求</span></span><br><span class="line">        <span class="keyword">if</span> (isAjax(reqest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONResult.errorException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">              mav.addObject(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">              mav.addObject(<span class="string">&quot;url&quot;</span>, reqest.getRequestURL());</span><br><span class="line">              mav.setViewName(ERROR_VIEW);</span><br><span class="line">              <span class="keyword">return</span> mav;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Title</span>: GlobalExceptionHandler.java</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Package</span> com.weiz.exception</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Description</span>: 判断是否是Ajax请求</span></span><br><span class="line"><span class="comment">         * Copyright: Copyright (c) 2017</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> weiz</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2017年12月3日 下午1:40:39</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAjax</span><span class="params">(HttpServletRequest httpRequest)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  (httpRequest.getHeader(<span class="string">&quot;X-Requested-With&quot;</span>) != <span class="literal">null</span></span><br><span class="line">                                        &amp;&amp; <span class="string">&quot;XMLHttpRequest&quot;</span></span><br><span class="line"></span><br><span class="line">        .equals( httpRequest.getHeader(<span class="string">&quot;X-Requested-With&quot;</span>)) );</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例，处理全部Exception的异常，如果需要处理其他异常，例如NullPointerException异常，则只需要在GlobalException类中使用@ExceptionHandler(value = {NullPointerException.class})注解重新定义一个异常处理的方法即可。</p>
<p>启动项目，在浏览器中输入<a target="_blank" rel="noopener" href="http://localhost:8088/err/error，结果如图4-3所示。">http://localhost:8088/err/error，结果如图4-3所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310101951100.png" alt="image-20231010195138024"></p>
<p>如图4-3所示，处理异常之后页面自动调整到统一的错误页面，如果是Ajax请求出错，则会按照定义的JSON数据格式统一返回数据。</p>
<h1 id="第5章-Thymeleaf模板引擎"><a href="#第5章-Thymeleaf模板引擎" class="headerlink" title="第5章　Thymeleaf模板引擎"></a>第5章　Thymeleaf模板引擎</h1><p>本章主要介绍Web开发中的重要组成部分：模板引擎。Spring Boot支持的模板引擎有很多，Thymeleaf是流行的模板引擎之一。本章将介绍Thymeleaf模板引擎，包括Thymeleaf常用的语法、Thymeleaf的表达式等高级用法以及Thymeleaf页面的整体布局。</p>
<h2 id="5-1-Thymeleaf入门"><a href="#5-1-Thymeleaf入门" class="headerlink" title="5.1　Thymeleaf入门"></a>5.1　Thymeleaf入门</h2><p>本节介绍什么是Thymeleaf以及Spring Boot如何集成使用Thymeleaf模板，最后介绍Spring Boot支持的Thymeleaf的一些常用的配置参数。</p>
<h3 id="5-1-1-Thymeleaf简介"><a href="#5-1-1-Thymeleaf简介" class="headerlink" title="5.1.1　Thymeleaf简介"></a>5.1.1　Thymeleaf简介</h3><p>Thymeleaf是一款非常优秀的服务器端页面模板引擎，适用于Web和独立环境，具有丰富的标签语言和函数，能够处理HTML、XML、JavaScript甚至文</p>
<p>Thymeleaf相较于其他模板引擎更加优雅。它强调自然模板化（允许模板成为工作原型，而Velocity、FreeMarker模板不允许这样做），所以它的语法更干净，更符合当前Web开发的趋势。</p>
<h4 id="1-Thymeleaf的实现机制"><a href="#1-Thymeleaf的实现机制" class="headerlink" title="1. Thymeleaf的实现机制"></a>1. Thymeleaf的实现机制</h4><p>模板的诞生是为了将显示与数据分离，模板技术多种多样，本质是将模板文件和数据通过模板引擎生成最终的HTML代码。</p>
<p>Thymeleaf亦是如此。Thymeleaf将其逻辑注入模板控件中，而不会影响模板设计原型，所以可以在浏览器中正确显示HTML页面和数据，也可以在无后台时静态显示。由于Thymeleaf模板后缀为.html，可以直接在浏览器中打开，预览非常方便。这样改善了设计人员与开发人员的沟通，弥合了设计人员和开发团队之间的差距，从而可以在开发团队中实现更强大的协作。</p>
<h4 id="2-Thymeleaf的优点"><a href="#2-Thymeleaf的优点" class="headerlink" title="2. Thymeleaf的优点"></a>2. Thymeleaf的优点</h4><p>Thymeleaf与Velocity、FreeMarker等模板引擎类似，可以完全替代JSP。与其他的模板引擎相比，Thymeleaf具有如下优点：</p>
<p>1）动静结合：Thymeleaf页面采用模板+数据的展示方式，既可以展示静态页面，也可以展示数据返回到页面后的动态效果。这是因为Thymeleaf支持HTML原型，可以在HTML原型上添加额外的属性，浏览器在解释HTML时会忽视未定义的属性，当定义的属性带数据时就会动态替换静态内容，实现页面动态展示。</p>
<p>2）开箱即用：Thymeleaf提供标准方言和Spring方言，可以直接套用模板实现JSTL、OGNL表达式效果，避免套模板、改JSTL、改标签的困扰。同时，开发人员也可以扩展和创建自定义的方言。</p>
<p>3）多方言支持：Thymeleaf提供spring标准方言和一个与Spring MVC完美集成的可选模块，可以快速地实现表单绑定、属性编辑器、国际化等功能。</p>
<p>4）与Spring Boot完美整合：Spring Boot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，可以像操作JSP一样来操作Thymeleaf。代码几乎没有任何区别，仅在模板语法上有所区别。</p>
<p>Spring Boot官方推荐使用Thymeleaf作为前端页面模板，Spring Boot 2.0中默认使用Thymeleaf 3.0。同时Spring Boot也为Thymeleaf提供了spring-boot-starter-thymeleaf组件（集成了Thymeleaf模板引擎），还支持Thymeleaf自动装配，可以开箱即用。</p>
<h3 id="5-1-2-Spring-Boot使用Thymeleaf"><a href="#5-1-2-Spring-Boot使用Thymeleaf" class="headerlink" title="5.1.2　Spring Boot使用Thymeleaf"></a>5.1.2　Spring Boot使用Thymeleaf</h3><p>Spring Boot对Thymeleaf提供了非常完整的支持，使得我们使用Thymeleaf非常简单，只需要引入spring-boot-starter-thymeleaf依赖库即可。下面通过一个简单的例子来演示Spring Boot是如何集成Thymeleaf的。</p>
<p>步骤01 添加Thymeleaf依赖。</p>
<p>修改项目的pom.xml文件，添加spring-boot-starter-thymeleaf依赖配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在Spring Boot项目中除了需要引入spring-boot-starter-thymeleaf依赖库外，还需要引入spring-boot-starter-web和spring-boot-starter等组件。</p>
<p>步骤02 配置Thymeleaf参数</p>
<p>如果需要对默认的Thymeleaf配置参数进行自定义，可直接在application.properties中配置修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启缓存，开发时可以设置为false，默认为true</span></span><br><span class="line">spring.thymeleaf.cache=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 模板文件位置</span></span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"><span class="comment"># Content-Type配置</span></span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br><span class="line"><span class="comment"># 模板文件后缀</span></span><br><span class="line">spring.thymeleaf.suffix=.html</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主要是配置Thymeleaf模板页面的存放位置。当然，也可以通过application.properties灵活地配置Thymeleaf的其他各项特性。其中，spring.thymeleaf.cache=false用于关闭Thymeleaf的缓存，不然在开发过程中修改页面不会生效，需要重启，生产环境可配置为true。</p>
<p>步骤03 创建Thymeleaf页面。</p>
<p>Thymeleaf模板后缀为.html，在resource\templates模板存放目录下创建hello.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Thymeleaf模板引擎</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>Hello Thymeleaf<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了hello.html页面。此页面可直接双击来运行，页面会显示出“Hello Thymeleaf”。</p>
<p>步骤04 创建后台控制器（Controller）。</p>
<p>在Controller目录中创建HelloController控制器并实现测试方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">        map.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Hello Thymeleaf From Spring Boot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Controller注解返回页面和数据。返回具体的hello.html页面，需要与前端HTML的路径保持一致，同时返回数据name=Hello Thymeleaf。</p>
<p>步骤05 运行验证。</p>
<p>至此，准备工作已经完成。启动项目后，在浏览器中输入网址<a target="_blank" rel="noopener" href="http://localhost:8080/hello，验证Thymeleaf配置是否成功，如图5-1所示。">http://localhost:8080/hello，验证Thymeleaf配置是否成功，如图5-1所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102121535.png" alt="image-20231010212130425"></p>
<p>由图5-1可知，成功返回hello.html页面，并且通过th:text=”${name}”标签，页面的默认值已经成功地被后端传入的内容所替换。说明Thymeleaf已经成功整合到我们的Spring Boot项目中。</p>
<p>Thymeleaf使用非常简单，标签与Html基类似。但是，在使用Thymeleaf时还需要注意以下几个问题：</p>
<p>1）Thymeleaf模板页面必须在HTML标签中声明xmlns:th=”<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/，表明页面使用的是Thymeleaf的语法，否则Thymeleaf的自定义标签没有提示。">http://www.thymeleaf.org/，表明页面使用的是Thymeleaf的语法，否则Thymeleaf的自定义标签没有提示。</a></p>
<p>2）在application.properties文件中配置的模板路径为classpath:/templates/，模板的存放路径在resource/templates目录下。</p>
<p>3）Spring Boot默认存放模板页面的路径在src/main/resources/templates或者src/main/view/templates，无论使用什么模板语言都一样，当然默认路径是可以自定义的，不过一般不推荐这样做。</p>
<p>4）Thymeleaf默认的页面文件后缀是.html，也可以改成其他后缀。</p>
<h3 id="5-1-3-Thymeleaf常用的配置参数"><a href="#5-1-3-Thymeleaf常用的配置参数" class="headerlink" title="5.1.3　Thymeleaf常用的配置参数"></a>5.1.3　Thymeleaf常用的配置参数</h3><p>Thymeleaf提供了很多可自定义的配置参数，只是这些Spring Boot都已经默认配置，如果需要自定义修改这些配置，可以通过application.properties配置文件灵活地配置Thymeleaf的各项特性。以下为Thymeleaf的配置和默认参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># THYMELEAF (ThymeleafAutoConfiguration)</span></span><br><span class="line"><span class="comment"># 开启模板缓存（默认值：true）</span></span><br><span class="line">spring.thymeleaf.cache=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 检查模板是否存在，然后呈现</span></span><br><span class="line">spring.thymeleaf.check-template=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 检查模板位置是否正确（默认值:true）</span></span><br><span class="line">spring.thymeleaf.check-template-location=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Content-Type的值（默认值：text/html）</span></span><br><span class="line">spring.thymeleaf.content-type=text/html</span><br><span class="line"><span class="comment"># 开启MVC Thymeleaf视图解析（默认值：true）</span></span><br><span class="line">spring.thymeleaf.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 模板编码</span></span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line"><span class="comment"># 要被排除在解析之外的视图名称列表，用逗号分隔</span></span><br><span class="line">spring.thymeleaf.excluded-view-names=</span><br><span class="line"><span class="comment"># 定义模板的模式(默认值：HTML5)</span></span><br><span class="line">spring.thymeleaf.mode=HTML5</span><br><span class="line"><span class="comment"># 在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）</span></span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"><span class="comment"># 在构建URL时添加到视图名称后的后缀（默认值：.html）</span></span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line"><span class="comment"># Thymeleaf模板解析器在解析器链中的顺序，默认情况下，它排在第一位，顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性</span></span><br><span class="line">spring.thymeleaf.template-resolver-order=</span><br><span class="line"><span class="comment"># 可解析的视图名称列表，用逗号分隔</span></span><br><span class="line">spring.thymeleaf.view-names=</span><br></pre></td></tr></table></figure>
<p>上面的Thymeleaf的属性配置看起来很多，其实常用的就是之前介绍的配置项。其他的配置项在实际项目中可以根据实际使用情况来修改。</p>
<h2 id="5-2-Thymeleaf表达式"><a href="#5-2-Thymeleaf表达式" class="headerlink" title="5.2　Thymeleaf表达式"></a>5.2　Thymeleaf表达式</h2><p>既然Thymeleaf有着众多优点，又是Spring Boot官方推荐的模板引擎，接下来就让我们看看Thymeleaf有哪些实用的功能。本节介绍Thymeleaf的各种表达式，通过一些简单的例子来演示Thymeleaf的表达式及用法。</p>
<h3 id="5-2-1-变量表达式"><a href="#5-2-1-变量表达式" class="headerlink" title="5.2.1　变量表达式"></a>5.2.1　变量表达式</h3><p>变量表达式即获取后台变量的表达式。使用${}获取变量的值，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过${name}获取后台返回的model的属性。标签中的th:text属性用来填充该标签的内容。</p>
<p>如果后台返回的是对象，则使用变量名.属性名方式获取，这一点和EL表达式一样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.memo&#125;&quot;</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用${user. memo}可以获取model中的user对象的memo属性。</p>
<h3 id="5-2-2-选择或星号表达式"><a href="#5-2-2-选择或星号表达式" class="headerlink" title="5.2.2　选择或星号表达式"></a>5.2.2　选择或星号表达式</h3><p>选择表达式与变量表达式类似，不过它用一个预先选择的对象来代替上下文变量容器（map）执行*{name}。什么是预先选择的对象？就是父标签的值。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们用th:object预先定义了对象变量${session.user}，然后使用星号（*）获取了user变量中的各个属性。例如*{firstName}等价于${session.user.firstName}。这两种使用方式的区别如下：</p>
<p>1）在不考虑上下文的情况下，两者没有区别，只是星号语法评估在选定对象上表达，而不是整个上下文。</p>
<p>2）美元符号（$）和星号（*）语法可以混合使用。</p>
<h3 id="5-2-3-URL表达式"><a href="#5-2-3-URL表达式" class="headerlink" title="5.2.3　URL表达式"></a>5.2.3　URL表达式</h3><p>URL在Web应用中占据着十分重要的地位，如引用静态资源文件、处理URL链接等。Thymeleaf通过@{…}语法来处理URL表达式，主要使用th:href、th:src等属性引用CSS、JS等静态资源文件、下面通过示例演示URL表达式的使用。</p>
<h4 id="1-引入静态资源文件"><a href="#1-引入静态资源文件" class="headerlink" title="1. 引入静态资源文件"></a>1. 引入静态资源文件</h4><p>Thymeleaf页面使用th:href属性引入CSS资源文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/resources/css/bootstrap.min.css&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，默认访问resources下的css文件夹。</p>
<p>Thymeleaf页面使用th:src属性引入JS资源文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/resource/js/bootstrap.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认访问resources下的js文件夹。</p>
<h4 id="2-使用-…-设置背景图片"><a href="#2-使用-…-设置背景图片" class="headerlink" title="2. 使用 @{…} 设置背景图片"></a>2. 使用 @{…} 设置背景图片</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:style=<span class="string">&quot;&#x27;background:url(&#x27; + <span class="subst">@&#123;$&#123;imgurl&#125;&#125;</span> + &#x27;);&#x27;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面的路径使用@{${imgurl}指定图片的路径，Thymeleaf也通过th:background设置背景。</p>
<h4 id="3-URL链接"><a href="#3-URL链接" class="headerlink" title="3. URL链接"></a>3. URL链接</h4><p>Thymeleaf支持在\<a>标签中使用th:href来处理URL链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.a.com/user/u2376052 &#125;&quot;</span>&gt;</span>绝对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order&#125;&quot;</span>&gt;</span>相对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，th:href属性修饰符将计算并替换使用href链接的URL值，并放入href属性中。</p>
<p>同样，th:href也支持URL参数传递，我们可以使用带参数的URL表达式，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order/details(orderId=$&#123;orderId&#125;)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，@{…}表达式中通过{orderId}访问上下文中的orderId变量。最后的(orderId=${orderId})表示将括号内的内容作为URL参数处理，该语法避免使用“&amp;”拼接URL参数，大大提高了可读性。</p>
<p>如果需要多个参数，将用逗号分隔，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@{}表达式创建URL，同时传递execId和execType两个参数，比使用“&amp;”拼接更简单易读。</p>
<h3 id="5-2-4-文字国际化表达式"><a href="#5-2-4-文字国际化表达式" class="headerlink" title="5.2.4　文字国际化表达式"></a>5.2.4　文字国际化表达式</h3><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息，使用类似于#{login.tip}的表达式。下面通过示例演示Thymeleaf实现国际化。</p>
<p>步骤01 创建国际化资源。</p>
<p>Spring Boot支持国际化，我们在resources资源文件目录下新建i18n文件夹，在该文件夹下创建test_zh_CN.properties和test_en_US.properties两个文件（也可以直接创建Resource Bundle文件夹），然后增加测试属性，如图5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102139123.png" alt="image-20231010213943052"></p>
<p>我们创建了test的国际化资源配置文件，增加了login.tip属性并配置了对应的中英文。</p>
<p>步骤02 修改系统国际化配置。</p>
<p>在application.properties中加入上面定义的国际化配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n.test</span><br></pre></td></tr></table></figure>
<p>步骤03 在页面中引用国际化资源。</p>
<p>在resource/templates目录下创建i18n.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>国际化<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.tip&#125;&quot;</span>&gt;</span>Please log in<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过文字国际化表达式#{login.tip}获取属性配置。</p>
<p>步骤04 创建后台请求。</p>
<p>在之前的HelloController中加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/i18n&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">i18n</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;i18n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤05 运行测试。</p>
<p>配置完成之后启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/i18n来验证国际化配置是否生效，如图5-3所示。">http://localhost:8080/i18n来验证国际化配置是否生效，如图5-3所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102146822.png" alt="image-20231010214610670"></p>
<p>通过#{login.tip}表达式，获取到了国际化资源配置中的中文内容。</p>
<h2 id="5-3-表达式的语法"><a href="#5-3-表达式的语法" class="headerlink" title="5.3　表达式的语法"></a>5.3　表达式的语法</h2><p>我们知道，模板的主要作用是将后台返回的数据渲染到HTML中。那么Thymeleaf是如何解析后台数据的呢？接下来从变量、方法、条件判断、循环、运算（逻辑运算、布尔运算、比较运算、条件运算）方面学习Thymeleaf表达式支持的语法。</p>
<h3 id="5-3-1-赋值和拼接"><a href="#5-3-1-赋值和拼接" class="headerlink" title="5.3.1　赋值和拼接"></a>5.3.1　赋值和拼接</h3><h4 id="（1）文本赋值"><a href="#（1）文本赋值" class="headerlink" title="（1）文本赋值"></a>（1）文本赋值</h4><p>赋值就是通过${}标签将后台返回的数据替换到页面中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>hello spring boot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过${}标签将后台返回的name的值替换到页面的\<p>标签中。当请求后台地址之后，Thymeleaf会将页面\<p>标签中的hello spring boot替换成后台传回的name的值。</p>
<h4 id="（2）文本拼接"><a href="#（2）文本拼接" class="headerlink" title="（2）文本拼接"></a>（2）文本拼接</h4><p>Thymeleaf支持将后台返回的值和现有的内容进行拼接，然后替换到页面中。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome, &#x27; + $&#123;userName&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将后台返回的userName的值拼接到“Welcome,”之后，最后统一替换到页面的<span>中。文本文字可以用单引号来包含，如有特殊字符，需要用“\”转义。</p>
<p>除了上面这种写法外，字符串拼接还有另一种简洁的写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|Welcome, $&#123;userName&#125;!|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用两个竖杠“|”将后台返回的数据与页面中的内容合并，比前面的方式简单多了。</p>
<p>Thymeleaf标签和HTML的基本一致，在HTML的标签上加上“th：”即可替换HTML标签中原生属性的值。</p>
<h3 id="5-3-2-条件判断"><a href="#5-3-2-条件判断" class="headerlink" title="5.3.2　条件判断"></a>5.3.2　条件判断</h3><p>Thymeleaf中使用th:if和th:unless属性进行条件判断。在标签中使用th:if属性判断表达式是否成立，成立则显示该标签的内容，不成立则隐藏该标签的内容。th:unless与th:if恰好相反，只有表达式中的条件不成立才会显示其内容。</p>
<p>th:if和th:unless表达式的结果支持boolean、number、character、string及其他类型。下面通过例子演示Thymeleaf中如何使用th:if和th:unless属性进行条件判断。</p>
<p>步骤01 定义HTML页面。</p>
<p>在templates目录下创建if.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>条件判断<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;flag == &#x27;yes&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.a.com/&#125;&quot;</span>&gt;</span>a.home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;flag != &#x27;no&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.b.com/&#125;&quot;</span> &gt;</span>b.home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，通过th:if标签进行条件判断，如果flag==yes，就显示a.home的链接，否则显示b.home的链接。</p>
<p>步骤02 定义后端接口，返回数据结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/if&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">ifunless</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;if&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义请求的地址，返回if.html页面，并返回flag的值为yes。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/if，会出现如图5-4所示的结果。">http://localhost:8080/if，会出现如图5-4所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102215408.png" alt="image-20231010221534232"></p>
<p>由图5-4可知，后端返回的flag值为yes，th:if=”${flag == ‘yes’}”条件成立，所以显示a.home的链接。而th:unless=”${flag != ‘no’}” 条件也成立，所以隐藏b.home的链接。</p>
<h3 id="5-3-3-switch"><a href="#5-3-3-switch" class="headerlink" title="5.3.3　switch"></a>5.3.3　switch</h3><p>Thymeleaf中使用th:switch、th:case标签进行多条件判断，与Java中的switch语句等效，根据条件显示匹配的内容，如果有多个匹配结果，只选择第一个显示。th:case=”<em>“表示默认选项，即没有case的值为true时显示th:case=”</em>“的内容，对应Java中switch的default。下面以数据状态为例来演示th:switch的用法。</p>
<p>步骤01 创建前端页面。</p>
<p>在templates目录下创建switch.html页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example switch <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>switch<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;todo&#x27;&quot;</span>&gt;</span>未开始<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;doing&#x27;&quot;</span>&gt;</span>进行中<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;done&#x27;&quot;</span>&gt;</span>完成<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- *: case的默认选项 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>状态错误<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，使用th:switch、th:case标签根据后台返回的status的值显示匹配数据。</p>
<p>步骤02 添加后端程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/switch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">switchcase</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;doing&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;switch&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，后台返回switch.html页面，同时返回status值为doing。</p>
<p>步骤03 运行验证。</p>
<p>启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/switch，页面显示效果如图5-5所示。页面显示“进行中”的状态，可以在后台更改status的值来查看结果。">http://localhost:8080/switch，页面显示效果如图5-5所示。页面显示“进行中”的状态，可以在后台更改status的值来查看结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102220633.png" alt="image-20231010222013550"></p>
<p>由图5-5可知，switch.html页面通过后台返回的status的值来显示不同的内容。</p>
<h3 id="5-3-4-循环遍历"><a href="#5-3-4-循环遍历" class="headerlink" title="5.3.4　循环遍历"></a>5.3.4　循环遍历</h3><p>循环遍历在日常项目中比较常用，一般用于将后台返回的数据渲染到前端的表格中。Thymeleaf可以使用th:each标签进行数据的迭代循环，语法：th:each=”obj,iterStat:${objList}”，支持List、Map、数组数据类型等。下面通过简单的例子演示数据循环遍历的过程。</p>
<p>步骤01 定义后端数据。</p>
<p>首先在后端定义一个用户列表，然后传递到前端页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    User user1=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;spring&quot;</span>,<span class="number">12</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    User user2=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;boot&quot;</span>,<span class="number">6</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    User user3=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Thymeleaf&quot;</span>,<span class="number">66</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;users&quot;</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，后台返回list.html页面，同时返回ArrayList类型的用户列表数据。</p>
<p>步骤02 创建前台页面。</p>
<p>在templates目录下创建list.html页面，展示后台的数据，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example switch <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>each循环遍历<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：index<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：count<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：size<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：even<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：odd<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：first<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>变量：last<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user,stat : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span>age<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.password&#125;&quot;</span>&gt;</span>password<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.index&#125;&quot;</span>&gt;</span>index<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.count&#125;&quot;</span>&gt;</span>count<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.size&#125;&quot;</span>&gt;</span>size<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.even&#125;&quot;</span>&gt;</span>even<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.odd&#125;&quot;</span>&gt;</span>odd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.first&#125;&quot;</span>&gt;</span>first<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;iterStat.last&#125;&quot;</span>&gt;</span>last<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>循环遍历通过th:each实现，语法：th:each=”obj,stat:${objList}”。</p>
<p>1）${users}是从模板上下文中获取变量。</p>
<p>2）user是${users}变量遍历后的每一个对象。</p>
<p>3）${user.name}可以读取遍历中的变量。</p>
<p>在遍历的同时，也可以获取迭代对象的迭代状态变量stat，它包含如下属性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index：当前迭代对象的index（从0开始计算）。</span><br><span class="line">count：当前迭代对象的index（从1开始计算）。</span><br><span class="line">size：被迭代对象的大小。</span><br><span class="line">even/odd：布尔值，当前循环是不是偶数/奇数（从0开始计算）。</span><br><span class="line">first：布尔值，当前循环是不是第一个。</span><br><span class="line">ast：布尔值，当前循环是不是最后一个。</span><br></pre></td></tr></table></figure>
<p>步骤03 运行验证</p>
<p>启动项目，在浏览器中输入地址：<a target="_blank" rel="noopener" href="http://localhost:8080/list，页面显示效果如图5-6所示。">http://localhost:8080/list，页面显示效果如图5-6所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102240601.png" alt="image-20231010224024507"></p>
<p>由图5-6可知，后端返回的list数据被循环遍历并显示在页面中，同时th:each标签还提供了index、count等标签。</p>
<h3 id="5-3-5-运算符"><a href="#5-3-5-运算符" class="headerlink" title="5.3.5　运算符"></a>5.3.5　运算符</h3><p>Thymeleaf支持在表达式中使用算术运算、逻辑运算、布尔运算、三目运算等各类数据计算功能，实现前端页面根据后台返回数据动态显示页面信息。下面就来一一演示。</p>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h4><p>算术运算符包括+、-、*、/、%等简单的计算。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th:with=&quot;isEven=($&#123;prodStat.count&#125; / 2 == 0)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过除以2的算术运算判断奇偶。</p>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h4><p>关系运算符包括&gt;、&lt;、&gt;=、&lt;=、==、!=，对应的别名为gt、lt、ge、le、eq、ne，使用&gt;、&lt;时需要用它的HTML转义符，所以建议使用gt、lt等别名：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gt：great than（大于）。</span><br><span class="line">ge：great equal（大于等于）。</span><br><span class="line">eq：equal（等于）。</span><br><span class="line">lt：less than（小于）。</span><br><span class="line">le：less equal（小于等于）。</span><br><span class="line">ne：not equal（不等于）。</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th:if=&quot;$&#123;prodStat.count&#125; gt 1&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>使用gt比较count的值是否大于1。</p>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h4><p>通过逻辑运算符实现多个条件判断，包括&amp;&amp;（and）和||（or）。</p>
<p>&amp;&amp;（and）表示“并且”，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age gt 10 &amp;&amp; a lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;（$&#123;age gt 10&#125;） and $&#123;age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表示：如果age&gt;10且age &lt;19，实现年龄是否在10～19岁的判断。</p>
<p>|| or表示“或者”，示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age gt 10 || age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;（$&#123;age gt 10&#125;） or $&#123;age lt 19&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表示：如果age &gt; 10或age &lt; 19，实现年龄大于10岁或者年龄小于19岁的判断。</p>
<h4 id="4-三目运算符"><a href="#4-三目运算符" class="headerlink" title="4. 三目运算符"></a>4. 三目运算符</h4><p>三目运算符的语法与Java等语言类似，具体使用如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;row.even&#125;? &#x27;even&#x27; : &#x27;odd&#x27;&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在前端列表进行数据渲染，实现用颜色隔行显示的效果。</p>
<h2 id="5-4-Thymeleaf的高级用法"><a href="#5-4-Thymeleaf的高级用法" class="headerlink" title="5.4　Thymeleaf的高级用法"></a>5.4　Thymeleaf的高级用法</h2><p>上一节介绍了Thymeleaf的基本使用语法，包括常用的赋值、字符串拼接、条件判断、数据循环遍历等语法。接下来介绍Thymeleaf的<strong>内联、内置对象、内置变量</strong>等高级用法，让我们在实践中边学边用，从而更好地理解和吸收。</p>
<h3 id="5-4-1-内联"><a href="#5-4-1-内联" class="headerlink" title="5.4.1　内联"></a>5.4.1　内联</h3><p>虽然通过Thymeleaf中的标签属性已经几乎满足了开发中的所有需求，但是有些情况下需要在CSS或JS中访问后台返回的数据。所以Thymeleaf提供了th:inline=”text/javascript/none”标签，使用[[…]]内联表达式的方式在HTML、JavaScript、CSS代码块中轻松访问model对象数据。</p>
<h4 id="1-文本内联"><a href="#1-文本内联" class="headerlink" title="1. 文本内联"></a>1. 文本内联</h4><p>Thymeleaf内联表达式使用[[…]]或[(…)]语法表达。先在父级标签定义使用内联方式th:inline=”text”，然后在标签内使用[[…]]或[(…)]表达式操作数据对象。文本内联比th:text的代码更简洁。下面通过示例演示内联的使用方式。</p>
<p>首先，创建页面inline.html。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>内联<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, [[$&#123;userName&#125;]] !<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码等价于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>不使用内联<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Hello, &#x27; + $&#123;userName&#125; + &#x27; !&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过以上两个示例可以看出使用内联语法会更简洁一些。</p>
<p>1）th:inline=”text”表示使用文本内联方式。</p>
<p>2）任何父标签都可以加上th:inline。</p>
<p>3）[[…]] 等价于th:text结果将被HTML转义，[(…)]等价于th:utext结果不会被HTML转义。</p>
<p>然后，创建后台路由/inline，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/inline&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">inline</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;inline&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，后台返回inline.html页面，同时返回userName=admin。</p>
<p>最后，运行测试。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，则会出现如图5-7所示的结果。">http://localhost:8080/inline，则会出现如图5-7所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102255608.png" alt="image-20231010225512527"></p>
<p>页面显示后台返回的userName为admin，比之前介绍的th:text=${userName}的方式更加简单、清晰。</p>
<h4 id="2-脚本内联"><a href="#2-脚本内联" class="headerlink" title="2. 脚本内联"></a>2. 脚本内联</h4><p>脚本内联，顾名思义就是在JavaScript脚本中使用内联表达式。使用时只需要在\<script>标签上加入th:inline=”javascript”属性，然后在JavaScript代码块中就能使用[[]]表达式。实现在JavaScript脚本中获取后台传过来的参数。</p>
<p>首先，修改inline.html页面，增加如下脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> name =<span class="string">&#x27;hello,&#x27;</span>+ [[$&#123;userName&#125;]] ;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(name);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在\<script>标签内加入th:inline=”javascript”，表示能在JavaScript中使用[ [] ]取值。在访问页面时，根据后端传值拼接name值，并以alert的方式弹框展示。</p>
<p>然后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，会出现如图5-8所示的结果。">http://localhost:8080/inline，会出现如图5-8所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102257904.png" alt="image-20231010225700826"></p>
<p>显示页面会先弹出一个alert提示框，显示“hello admin”，说明使用脚本内联绑定了后台传过来的数据。</p>
<h4 id="3-样式内联"><a href="#3-样式内联" class="headerlink" title="3. 样式内联"></a>3. 样式内联</h4><p>Thymeleaf还允许在\<style>标签中使用内联表达式动态生成CSS属性样式。下面通过示例演示内联CSS样式的用法。</p>
<p>首先，修改inline.html页面，加入如下样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">th:inline</span>=<span class="string">&quot;css&quot;</span> <span class="attr">th:with</span>=<span class="string">&quot;color=&#x27;yellow&#x27;, fontSize=&#x27;25px&#x27;&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="comment">/*[[$&#123;color&#125;]]*/</span> red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: [($&#123;fontSize&#125;) ];</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，与内联JavaScript一样，CSS内联也允许<style>标签静态和动态区分处理，当服务器动态打开时，字体颜色为黄色；当以原型静态打开时，显示的是红色，因为Thymeleaf会自动忽略掉CSS注释之后和分号之前的代码。需要注意的是，在获取变量赋值时，fontSize需要使用[(…)]表示不进行转义，如果使用[[…]]进行了转义，则会导致样式无效。</p>
<p>然后，修改/inline路由，返回fontSize和color，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/inline&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">inline</span><span class="params">(ModelMap map)</span> &#123;</span><br><span class="line">    map.addAttribute(<span class="string">&quot;fontSize&quot;</span>, <span class="string">&quot;20px&quot;</span>);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    map.addAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;inline&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，增加了fontSize和color两个CSS的属性样式，设置fontSize为20px，color为yellow。</p>
<p>然后启动项目，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/inline，可以看到如图5-9所示的结果。">http://localhost:8080/inline，可以看到如图5-9所示的结果。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102301299.png" alt="image-20231010230139225"></p>
<p>页面显示的字体大小和颜色根据后台返回的数据显示，说明CSS内联生效。</p>
<h4 id="4-禁用内联"><a href="#4-禁用内联" class="headerlink" title="4. 禁用内联"></a>4. 禁用内联</h4><p>Thymeleaf支持使用th:inline =“none”来禁止使用内联。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*禁用内联表达式*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;none&quot;</span>&gt;</span>[[$&#123;info&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*禁用内联表达式*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;none&quot;</span>&gt;</span>[[Info]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&lt;/body</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-内置对象"><a href="#5-4-2-内置对象" class="headerlink" title="5.4.2　内置对象"></a>5.4.2　内置对象</h3><p>Thymeleaf包含一些内置的基本对象，可以用于视图中获取上下文对象、请求参数、Session等信息。这些基本对象使用#开头，如表5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102305495.png" alt="image-20231010230522412"></p>
<p>如表5-1所示，Thymeleaf提供了有一系列的对象和属性用于访问请求参数、会话属性等应用属性。下面以其中两个常用的对象作为示例来演示。</p>
<p>步骤01 定义后台方法传值。</p>
<p>创建一个后台方法，后台传回request请求参数和session属性，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;spring boot&quot;</span>);</span><br><span class="line">    request.getSession().setAttribute(<span class="string">&quot;session&quot;</span>, <span class="string">&quot;admin session&quot;</span>);</span><br><span class="line">    request.getServletContext().setAttribute(<span class="string">&quot;servletContext&quot;</span>,<span class="string">&quot;Thymeleaf servletContext&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;baseobject&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们分别在request和session对象中写入了相关的测试，验证前台是否能获取到这些自定义的Web请求信息。</p>
<p>步骤02 前端页面接收参数</p>
<p>接下来看看前端页面如何通过Thymeleaf内置的基本对象获取后端传递的值，在/resources目录下新建一个前端页面baseobject.html，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>基本对象<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getAttribute(&#x27;request&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#session.getAttribute(&#x27;session&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#servletContext.getAttribute(&#x27;servletContext&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在HTML页面中通过#request、#session这些对象就能获取Web请求中的相关信息。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/object，则会出现如图5-10所示的结果。![image-20231010230911437](https://gitee.com/fjkf/images/raw/master/202310102309537.png">http://localhost:8080/object，则会出现如图5-10所示的结果。![image-20231010230911437](https://gitee.com/fjkf/images/raw/master/202310102309537.png</a>)</p>
<p>在HTML页面中，通过#request、#session这些对象成功获取了后台返回的Web请求信息。</p>
<h3 id="5-4-3-内嵌变量"><a href="#5-4-3-内嵌变量" class="headerlink" title="5.4.3　内嵌变量"></a>5.4.3　内嵌变量</h3><p>为了模板更加易用，Thymeleaf还提供了一系列公共的Utility对象（内置于Context中），可以通过#直接访问。具体的对象如表5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102310025.png" alt="image-20231010231034933"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102310174.png" alt="image-20231010231051090"></p>
<p>Thymeleaf除了定义上面这些常用的对象外，还有一些其他的utility对象，比如#ids，这里不再逐一列举。</p>
<h2 id="5-5-Thymeleaf页面布局"><a href="#5-5-Thymeleaf页面布局" class="headerlink" title="5.5　Thymeleaf页面布局"></a>5.5　Thymeleaf页面布局</h2><p>前面我们已经初步学会了Thymeleaf的基本语法以及内联、系统对象、内嵌变量、表达式等高级用法，俗话说“磨刀不误砍柴工”，熟悉Thymeleaf的语法和表达式后，后面开发起来会更加得心应手。接下来好好研究一下Thymeleaf如何实现完整的Web系统页面布局。</p>
<h3 id="5-5-1-引入代码片段"><a href="#5-5-1-引入代码片段" class="headerlink" title="5.5.1　引入代码片段"></a>5.5.1　引入代码片段</h3><p>在模板中经常希望包含来自其他模板页面的内容，如页脚、页眉、菜单等。为了做到这一点，Thymeleaf提供了th:fragment属性。下面通过在页面中添加标准的版权页脚的场景来演示如何引入代码片段。</p>
<p>步骤01 定义版权页脚代码片段。</p>
<p>在templates目录下创建版权模板页面footer.html，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2020 The Thymeleaf footer</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了版权页面footer.html，使用th:fragment属性定义了一个代码片段，名为copyright。</p>
<p>步骤02 引入代码片段模板。</p>
<p>创建一个普通的模板页面layout.html。使用th:insert或th:replace属性引入之前定义的copyright版权页面，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Thymeleaf模板引擎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>页面布局<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;footer :: copyright&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在layout.html中通过th:insert引入先前定义的footer.html中的copyright代码片段，“～{footer :: copyright}”就是在当前模板页面引入的footer.html模板中的copyright片段。</p>
<p>步骤03 启动验证。</p>
<p>启动项目后，在浏览器中输入地址<a target="_blank" rel="noopener" href="http://localhost:8080/layout，验证主页是否能正常引入footer.html代码片段，如图5-11所示。">http://localhost:8080/layout，验证主页是否能正常引入footer.html代码片段，如图5-11所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310102314965.png" alt="image-20231010231439878"></p>
<p>layout.html页面通过th:insert属性成功将footer页面的版权信息包含在主页中。</p>
<h3 id="5-5-2-片段表达式语法规范"><a href="#5-5-2-片段表达式语法规范" class="headerlink" title="5.5.2　片段表达式语法规范"></a>5.5.2　片段表达式语法规范</h3><p>Thymeleaf片段表达式非常实用，可以实现模板页面的复用，避免相同内容需要修改多个页面的情况。</p>
<h4 id="1-标记选择器"><a href="#1-标记选择器" class="headerlink" title="1. 标记选择器"></a>1. 标记选择器</h4><p>片段表达式的语法非常简单，其核心是标记选择器，由底层的AttoParser解析库定义，类似于XPath表达式或CSS选择器。片段表达式有以下3种不同的格式：</p>
<p>1）～{templatename::selector}：包含templatename和selector两个参数，其中templatename为页面模板的名称，selector为模板中定义的代码片段。例如上面示例中的“～{footer :: copyright}”就是在当前模板页面引入footer.html模板中的copyright片段。</p>
<p>2）～{templatename}：引入名为templatename的完整模板。</p>
<p>3）～{::selector}或～{this::selector}：Thymeleaf支持从同一个模板插入一个片段，如果在当前的模板上找不到，将向最初处理的模板遍历，直到选择器匹配上对应的模板。</p>
<p>此外，标记选择器的模板名和选择器还可以包含条件判断或三目运算等其他表达式语法，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;footer :: ($&#123;user.isAdmin&#125;? #&#123;footer.admin&#125; : #&#123;footer.normaluser&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过判断后台用户是否是管理员从而引入相应的代码片段，实现管理员和普通用户的页面区分。</p>
<h4 id="2-引用普通的模板"><a href="#2-引用普通的模板" class="headerlink" title="2. 引用普通的模板"></a>2. 引用普通的模板</h4><p>标记选择器非常强大，可以包含不使用任何th:fragment属性的片段，甚至可以是来自完全不了解Thymeleaf的不同应用程序的标记代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;copy-section&quot;</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用上面的片段，只需通过它的id属性引用，类似于CSS选择器：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;～&#123;footer :: #copy-section&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-th-insert、th-replace和th-include的区别"><a href="#3-th-insert、th-replace和th-include的区别" class="headerlink" title="3. th:insert、th:replace和th:include的区别"></a>3. th:insert、th:replace和th:include的区别</h4><p>th:insert、th:replace和th:include的功能基本类似，三者之间的差异如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">th:insert是最简单的，它简单地插入指定的片段作为其宿主标签的主体。</span><br><span class="line">th:replace实际上用指定的片段替换它的主机标签。</span><br><span class="line">th:include与th:insert类似，但它并不插入片段，只插入该片段的内容。</span><br></pre></td></tr></table></figure>
<h3 id="5-5-3-可参数化片段"><a href="#5-5-3-可参数化片段" class="headerlink" title="5.5.3　可参数化片段"></a>5.5.3　可参数化片段</h3><p>Thymeleaf支持在th:fragment定义的片段中指定一组参数，这使得模板片段更像一个可重复调用的函数。通过不同的参数控制模板的显示，从而达到模板共用的效果。</p>
<p>下面用th:fragment定义的片段指定一组参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;frag (onevar,twovar)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;onevar&#125; + &#x27; - &#x27; + $&#123;twovar&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义的frag片段包含两个参数，不需要定义参数的类型。</p>
<p>使用th:insert或th:replace调用此片段时，需要传入两个参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;::frag ($&#123;value1&#125;,$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>片段的参数传递与函数调用类似，通过传入的参数控制页面显示。</p>
<h1 id="第6章-构建RESTful服务"><a href="#第6章-构建RESTful服务" class="headerlink" title="第6章　构建RESTful服务"></a>第6章　构建RESTful服务</h1><h2 id="6-1-RESTful简介"><a href="#6-1-RESTful简介" class="headerlink" title="6.1　RESTful简介"></a>6.1　RESTful简介</h2><p>本节将从基础的概念开始介绍什么是RESTful、RESTful的特点、RESTful中的资源、HTTP Method、HTTP Status，还将介绍RESTful和SOAP到底有哪些区别。</p>
<h3 id="6-1-1-什么是RESTful"><a href="#6-1-1-什么是RESTful" class="headerlink" title="6.1.1　什么是RESTful"></a>6.1.1　什么是RESTful</h3><p>RESTful是目前流行的互联网软件服务架构设计风格。REST（Representational State Transfer，表述性状态转移）一词是由Roy Thomas Fielding在2000年的博士论文中提出的，它定义了互联网软件服务的架构原则，如果一个架构符合REST原则，则称之为RESTful架构。</p>
<p>REST并不是一个标准，它更像一组客户端和服务端交互时的架构理念和设计原则，基于这种架构理念和设计原则的Web API更加简洁，更有层次。</p>
<h4 id="1-RESTful的特点"><a href="#1-RESTful的特点" class="headerlink" title="1. RESTful的特点"></a>1. RESTful的特点</h4><p>1）每一个URI代表一种资源。</p>
<p>2）客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。3）通过操作资源的表现形式来实现服务端请求操作。</p>
<p>4）资源的表现形式是JSON或者HTML。</p>
<p>5）客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。</p>
<p>符合RESTful规范的Web API需要具备如下两个关键特性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安全性：安全的方法被期望不会产生任何副作用。当我们使用GET操作获取资源时，不会引起资源本身发生改变，也不会引起服务器状态的改变。</span><br><span class="line">幂等性：幂等的方法保证了重复进行一个请求和一次请求的效果相同（并不是指返回客户端的响应总是相同的，而是指服务器上资源的状态从第一次请求后就不再改变）。在数学中，幂等性是指N次变换和一次变换的结果相同。</span><br></pre></td></tr></table></figure>
<h4 id="2-REST的产生背景"><a href="#2-REST的产生背景" class="headerlink" title="2. REST的产生背景"></a>2. REST的产生背景</h4><p>随着互联网的发展，前端页面与后端的数据交互越来越频繁，数据结构越来越复杂，REST的出现极大地简化了前后端数据的交互逻辑。如果我们把前端页面看作一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。</p>
<p>假设，原本大家通过PC上的网上商城购物，当需要扩展到手机等移动端时，只需要开发针对iOS和Android的两个客户端，通过客户端访问系统公共的Web API就可以完成通过浏览器页面提供的功能，而后端代码基本无须改动，如图6-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111119898.png" alt="image-20231011111943737"></p>
<p>如图6-1所示，RESTful风格的Web API支持我们使用统一的接口规范对接iOS、Android、HTML5和PC等客户端。正是由于REST有着众多优点，因此REST一经提出就迅速取代了复杂而笨重的SOAP，成为Web API的标准。</p>
<h3 id="6-1-2-HTTP-Method"><a href="#6-1-2-HTTP-Method" class="headerlink" title="6.1.2　HTTP Method"></a>6.1.2　HTTP Method</h3><p>什么是HTTP Method（HTTP方法）呢？</p>
<p>HTTP提供了POST、GET、PUT、DELETE等操作类型对某个Web资源进行Create、Read、Update和Delete操作。一个HTTP请求除了利用URI标志目标资源之外，还需要通过HTTP Method指定针对该资源的操作类型。表6-1介绍一些常见的HTTP方法及其在RESTful风格下的使用。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111122063.png" alt="image-20231011112239956"></p>
<p>表6-1总结了主要的HTTP方法与资源URI结合使用的建议返回值。常见的HTTP Method（HTTP方法）有POST、GET、PUT、PATCH和DELETE，它们分别对应Create、Read、Update和Delete（或者CURD）操作。当然，还有许多其他方法，比如OPTIONS和HEAD等，但使用频率较低。</p>
<h3 id="6-1-3-HTTP状态码"><a href="#6-1-3-HTTP状态码" class="headerlink" title="6.1.3　HTTP状态码"></a>6.1.3　HTTP状态码</h3><p>HTTP状态码就是服务向用户返回的状态码和提示信息，客户端的每一次请求，服务都必须给出回应，回应包括HTTP状态码和数据两部分。</p>
<p>HTTP定义了40个标准状态码，可用于传达客户端请求的结果。状态码分为以下5个类别：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：信息，通信传输协议级信息。</span><br><span class="line">2xx：成功，表示客户端的请求已成功接受。</span><br><span class="line">3xx：重定向，表示客户端必须执行一些其他操作才能完成其请求。</span><br><span class="line">4xx：客户端错误，此类错误状态代码指向客户端。</span><br><span class="line">5xx：服务器错误，服务器负责这些错误状态代码。</span><br></pre></td></tr></table></figure>
<p>RESTful API中使用HTTP状态码来表示请求执行结果的状态，适用于REST API设计的代码以及对应的HTTP方法，如表6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111124766.png" alt="image-20231011112436442"></p>
<p>表6-2是HTTP协议提供的状态码和HTTP Method。通过RESTful API返回给客户端的状态码和提示信息可以判断出Web API的请求和执行情况。</p>
<p>除了以上基本的HTTP请求状态码外，Web API服务端还需要定义业务相关的状态，如1000订单提交成功、1002订单修改成功等。每种状态码都有标准的解释，客户端只需查看状态码字典就知道相应业务的执行结果，所以服务端应该返回尽可能精确的状态码。</p>
<h3 id="6-1-4-REST与SOAP的区别"><a href="#6-1-4-REST与SOAP的区别" class="headerlink" title="6.1.4　REST与SOAP的区别"></a>6.1.4　REST与SOAP的区别</h3><p>随着互联网的发展，RESTful越来越流行，那么RESTful和SOAP到底有哪些区别？我们在设计Web服务时，到底是应该选择目前最流行的RESTful还是选择老牌的WebService呢？</p>
<p>SOAP（Simple Object Access Protocol，简单对象访问协议）是一种标准化的通信规范，主要用于Web服务。它有着严格的规范和标准，包括安全、事务等各个方面的内容，同时SOAP强调操作方法和操作对象的分离，使用WSDL文件规范和XSD文件分别对其定义。</p>
<p>RESTful简化了WebService的设计，它不再需要WSDL，而是通过最简单的HTTP协议传输数据（包括XML或JSON）。既简化了设计，也减少了网络传输量（因为只传输代表数据的XML或JSON，没有额外的XML包装）。REST强制所有的操作都必须是无状态的，没有上下文的约束，不需要考虑上下文和会话保持的问题，极大地提高系统的可伸缩性。</p>
<p>RESTful相对于SOAP更加简单明了，它并没有一个明确的架构标准，更像是一种设计风格，其核心是面向资源；而WebService基于SOAP协议，主要核心是面向活动。</p>
<p>移动互联网飞速发展的今天，业务随时都在变化，天然拥抱变化的RESTful架构无疑是当前互联网行业Web服务架构开发的首选。</p>
<h2 id="6-2-构建RESTful应用接口"><a href="#6-2-构建RESTful应用接口" class="headerlink" title="6.2　构建RESTful应用接口"></a>6.2　构建RESTful应用接口</h2><p>RESTful架构是目前最流行的互联网软件架构规范，是Web API（应用编程接口）的大趋势和主流规范，了解了RESTful的众多优点之后，接下来一步一步地学习如何使用Spring Boot构建RESTful Web API。</p>
<h3 id="6-2-1-Spring-Boot对RESTful的支持"><a href="#6-2-1-Spring-Boot对RESTful的支持" class="headerlink" title="6.2.1　Spring Boot对RESTful的支持"></a>6.2.1　Spring Boot对RESTful的支持</h3><p>Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API，提供了与REST操作方式（GET、POST、PUT、DELETE）对应的注解：</p>
<p>1）@GetMapping：处理GET请求，获取资源。</p>
<p>2）@PostMapping：处理POST请求，新增资源。</p>
<p>3）@PutMapping：处理PUT请求，更新资源。</p>
<p>4）@DeleteMapping：处理DELETE请求，删除资源。</p>
<p>5）@PatchMapping：处理PATCH请求，用于部分更新资源。</p>
<p>通过这些注解就可以在Spring Boot项目中轻松构建RESTful接口。其中比较常用的是@GetMapping、@PostMapping、@PutMapping、@DeleteMapping四个注解。</p>
<p>使用Spring Boot开发RESTful接口非常简单，通过@RestController定义控制器，然后使用@GetMapping和@PostMapping等注解定义地址映射，实现相应的资源操作方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserByID</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserByID:&quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(value=&quot;/user &quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;save successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PutMapping(value=&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;update successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DeleteMapping(value=&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;delete id:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过Spring Boot提供的@GetMapping等注解简单实现了对用户（user）的操作。其实，这些注解就是@RequestMapping注解的简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserByID</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getUserByID:&quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;save successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;update successed&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;delete id:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前介绍的@RequestMapping注解通过method参数定义映射的HTTP请求方法，就相当于@RequestMapping+ RequestMethod的简化版。</p>
<p>我们看到，Get和Delete、Post和Put请求的URL是相同的，不同的Method（GET、PUT、POST、DELETE）会被映射到对应的处理方法上。这就是REST的魅力，简单明了的URL就能显示它的功能和作用。</p>
<h3 id="6-2-2-Spring-Boot实现RESTful-API"><a href="#6-2-2-Spring-Boot实现RESTful-API" class="headerlink" title="6.2.2　Spring Boot实现RESTful API"></a>6.2.2　Spring Boot实现RESTful API</h3><p>接下来根据之前介绍的RESTful设计风格，以用户管理模块为例演示Spring Boot如何实现RESTful API。</p>
<p>步骤01 设计API。</p>
<p>在RESTful架构中，每个网址代表一种资源，所以URI中建议不要包含动词，只包含名词即可，而且所用的名词往往与数据库的表格名对应。表6-3是用户管理模块的接口定义，实际项目的RESTful API文档要更详细，还会定义全部请求的数据结构体。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111135907.png" alt="image-20231011113552819"></p>
<p>表6-3定义了用户管理模块的接口，根据REST的定义，我们将用户定义为一种资源，通过POST、DELETE、PUT、GET等HTTP Method实现对用户的增、删、改、查。</p>
<p>可能大家会有疑问，为什么URI中没有我们习惯的getUser、saveUser这类路径？这正是RESTful优雅的地方，它将对资源的操作都定义在HTTP Method中，使得URL地址看起来更简洁。</p>
<p>除了设计URL接口之外，还需要定义服务端向客户端返回的状态码和提示信息。详细的状态码说明见表6-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111136875.png" alt="image-20231011113647789"></p>
<p>表6-4中除了定义用户管理相关的业务状态码之外，还需要定义通用的错误码，如400对应数据校验错误、401对应数据无权限等。</p>
<p>步骤02 实现用户管理接口。</p>
<p>上面定义了RESTful API以及接口返回的状态码，接下来根据之前的接口定义先创建UserController，再实现用户管理模块的用户新增、用户修改、用户删除、用户查询等接口。</p>
<p>1）用户新增：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户创建成功：&quot;</span>+user.getName());</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">201</span>,<span class="string">&quot;用户创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping注解表示此为POST接口。通过POST方法传入用户数据，然后调用Save方法保存用户数据。</p>
<p>2）用户修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户修改成功：&quot;</span>+user.getName());</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">203</span>,<span class="string">&quot;用户修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PutMapping注解表示此为PUT接口。PUT和POST的URL是相同的，只是通过PUT、POST方法加以区分。后端处理逻辑不同，所以使用时千万别搞混了。</p>
<p>3）用户删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户删除成功：&quot;</span>+userId);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">204</span>,<span class="string">&quot;用户删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@DeleteMapping注解表示此为删除接口。通过传入参数userId删除人员信息。</p>
<p>4）获取用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONResult <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserId(userId);</span><br><span class="line">    user.setName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;获取用户成功：&quot;</span>+userId);</span><br><span class="line">    <span class="keyword">return</span> JSONResult.ok(<span class="number">200</span>,<span class="string">&quot;获取用户成功&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@GetMapping注解表示此为查询接口。@PathVariable注解用于参数映射，获取传入的参数。</p>
<p>步骤03 验证测试。</p>
<p>至此，用户管理的模块接口都实现了。接下来验证接口调用。我们可以使用单元测试或者Postman工具调用用户管理模块的相关接口，测试接口是否正常。这里就以Postman工具演示RESTful API的测试。</p>
<p>打开Postman，使用POST方法请求/user接口，验证新增人员的接口是否正常，如图6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111140998.png" alt="image-20231011114022905"></p>
<p>通过Postman发送POST请求，调用人员新增接口，后台接口处理成功后，返回人员信息保存成功。</p>
<p>接下来，使用GET方法请求/user/2001获取userId为2001的人员信息，从而验证获取人员的接口是否正常，如图6-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111140136.png" alt="image-20231011114043032"></p>
<p>通过Postman向后台接口发送GET方法请求/user/2001，RESTful API成功返回人员详细信息。</p>
<h2 id="6-3-使用Swagger生成Web-API文档"><a href="#6-3-使用Swagger生成Web-API文档" class="headerlink" title="6.3　使用Swagger生成Web API文档"></a>6.3　使用Swagger生成Web API文档</h2><p>高质量的API文档在系统开发的过程中非常重要。本节介绍什么是Swagger，如何在Spring Boot项目中集成Swagger构建RESTful API文档，以及为Swagger配置Token等通用参数。</p>
<h3 id="6-3-1-什么是Swagger"><a href="#6-3-1-什么是Swagger" class="headerlink" title="6.3.1　什么是Swagger"></a>6.3.1　什么是Swagger</h3><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务，是非常流行的API表达工具。</p>
<p>我们知道，RESTful API可能要面对多个开发人员或多个开发团队，涉及不同平台，包括iOS、Android或Web前端等。为了降低与其他团队频繁沟通的成本，一般我们会创建一份统一的API说明文档来记录所有接口的使用说明。然而，普通的API文档存在以下问题：</p>
<p>1）由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），创建这样一份高质量的文档是一件非常烦琐的工作。</p>
<p>2）随着需求的不断变化，接口文档必须同步修改，就很容易出现文档和业务不一致的情况。</p>
<p>为了解决这些问题，Swagger应运而生，它能够自动生成完善的RESTful API文档，并根据后台代码的修改同步更新。这样既可以减少维护接口文档的工作量，又能将说明内容集成到实现代码中，让维护文档和修改代码合为一体，实现代码逻辑与说明文档的同步更新。另外，Swagger也提供了完整的测试页面来调试API，让API测试变得轻松、简单。</p>
<h3 id="6-3-2-使用Swagger生成Web-API文档"><a href="#6-3-2-使用Swagger生成Web-API文档" class="headerlink" title="6.3.2　使用Swagger生成Web API文档"></a>6.3.2　使用Swagger生成Web API文档</h3><p>在Spring Boot项目中集成Swagger同样非常简单，只需在项目中引入springfox-swagger2和springfox-swagger-ui依赖即可。下面就以之前的用户管理模块接口为例来感受Swagger的魅力。</p>
<p>步骤01 配置Swagger的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger2 依赖配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在项目pom.xml配置文件中引入了springfox-swagger2和springfox-swagger-ui两个依赖包。其中swagger2是主要的文档生成组件，swagger-ui为页面显示组件。</p>
<p>步骤02 创建Swagger2配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.weiz.example01.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;Spring Boot相关文章请关注：https://www.cnblogs.com/zhangweizhong&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.cnblogs.com/zhangweizhong&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;架构师精进&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  swagger增加url映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;swagger-ui.html&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在SwaggerConfig的类上添加了@Configuration和@EnableSwagger2两个注解。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Configuration注解让Spring Boot来加载该类配置。</span><br><span class="line">@EnableSwagger2注解启用Swagger2，通过配置一个Docket Bean，来配置映射路径和要扫描的接口所在的位置。apiInfo主要配置Swagger2文档网站的信息，比如网站的标题、网站的描述、使用的协议等。</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<p>1）basePackage可以在SwaggerConfig中配置com.weiz.example01.controller，也可以在启动器ComponentScan中配置。</p>
<p>2）需要在SwaggerConfig中配置Swagger的URL映射地址：/swagger-ui.html。</p>
<p>步骤03 添加文档说明内容。</p>
<p>上面的配置完成之后，接下来需要在API上增加内容说明。我们直接在之前的用户管理模块的UserController中增加相应的接口内容说明，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &#123;&quot;用户接口&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户创建成功：&quot;</span>+user.getName());</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">201</span>,<span class="string">&quot;用户创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span></span><br><span class="line">    <span class="meta">@PutMapping(value = &quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户修改成功：&quot;</span>+user.getName());</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">203</span>,<span class="string">&quot;用户修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户删除成功：&quot;</span>+userId);</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">204</span>,<span class="string">&quot;用户删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;查询用户&quot;,notes = &quot;通过用户ID获取用户信息&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONResult <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(userId);</span><br><span class="line">        user.setName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户成功：&quot;</span>+userId);</span><br><span class="line">        <span class="keyword">return</span> JSONResult.ok(<span class="number">200</span>,<span class="string">&quot;获取用户成功&quot;</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主要为UserController中的接口增加了接口信息描述，包括接口的用途、请求参数说明等。</p>
<p>1）@Api注解：用来给整个控制器（Controller）增加说明。</p>
<p>2）@ApiOperation注解：用来给各个API方法增加说明。</p>
<p>3）@ApiImplicitParams、@ApiImplicitParam注解：用来给参数增加说明。</p>
<p>步骤04 查看生成的API文档。</p>
<p>完成上面的配置和代码修改之后，Swagger 2就集成到Spring Boot项目中了。接下来启动项目，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html，Swagger会自动构建接口说明文档，如图6-4所示。">http://localhost:8080/swagger-ui.html，Swagger会自动构建接口说明文档，如图6-4所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111218974.png" alt="image-20231011121801857"></p>
<p>Swagger自动将用户管理模块的全部接口信息展现出来，包括接口功能说明、调用方式、请求参数、返回数据结构等信息。</p>
<p>在Swagger页面上，我们发现每个接口描述右侧都有一个按钮try it out，单击try it out按钮即可调用该接口进行测试。如图6-5所示，在获取人员信息的接口上单击try it out按钮，输入userId的请求参数“2001”，单击Execute按钮就会将请求发送到后台，从而进行接口验证测试。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111219149.png" alt="image-20231011121926038"></p>
<h3 id="6-3-3-为Swagger添加token参数"><a href="#6-3-3-为Swagger添加token参数" class="headerlink" title="6.3.3　为Swagger添加token参数"></a>6.3.3　为Swagger添加token参数</h3><p>很多时候，客户端在调用API时需要在HTTP的请求头携带通用参数，比如权限验证的token参数等。但是Swagger是怎么描述此类参数的呢？接下来通过示例演示如何为Swagger添加固定的请求参数。</p>
<p>其实非常简单，修改Swagger2Config配置类，利用ParameterBuilder构成请求参数。具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 添加请求参数，这里把token作为请求头参数传入后端</span></span><br><span class="line">                <span class="type">ParameterBuilder</span> <span class="variable">parameterBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterBuilder</span>();</span><br><span class="line">                List&lt;Parameter&gt; parameters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Parameter&gt;();</span><br><span class="line">                parameterBuilder.name(<span class="string">&quot;token&quot;</span>).description(<span class="string">&quot;token令牌&quot;</span>)</span><br><span class="line">                                .modelRef(<span class="keyword">new</span> <span class="title class_">ModelRef</span>(<span class="string">&quot;string&quot;</span>)).parameterType(<span class="string">&quot;header&quot;</span>).required(<span class="literal">false</span>).build();</span><br><span class="line">                parameters.add(parameterBuilder.build());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                                .apiInfo(apiInfo())</span><br><span class="line">                                .select()</span><br><span class="line"></span><br><span class="line">                                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.weiz.example01.controller&quot;</span>))</span><br><span class="line">                                .paths(PathSelectors.any())</span><br><span class="line">                                .build()</span><br><span class="line">                                .globalOperationParameters(parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过ParameterBuilder类把token作为全局统一的参数添加到HTTP的请求头中。系统所有的API都会统一加上此参数。</p>
<p>完成之后重新启动应用，再次查看接口，如图6-6所示，我们可以看到接口参数中已经支持发送token请求参数。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111238129.png" alt="image-20231011123819035"></p>
<p>人员管理模块中的所有API都统一加上了token参数，调用时Swagger会将token参数自动加入HTTP的请求头。</p>
<h3 id="6-3-4-Swagger常用注解"><a href="#6-3-4-Swagger常用注解" class="headerlink" title="6.3.4　Swagger常用注解"></a>6.3.4　Swagger常用注解</h3><p>Swagger提供了一系列注解来描述接口信息，包括接口说明、请求方法、请求参数、返回信息等，常用注解如表6-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111241033.png" alt="image-20231011124137906"></p>
<p>在实际项目中，Swagger除了提供@ApiImplicitParams注解描述简单的参数之外，还提供了用于对象参数的@ApiModel和@ApiModelProperty两个注解，用于封装的对象作为传入参数或返回数据。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel负责描述对象的信息</span><br><span class="line">@ApiModelProperty负责描述对象中属性的相关内容</span><br></pre></td></tr></table></figure>
<p>以上是在项目中常用的一些注解，利用这些注解就可以构建出清晰的API文档</p>
<h1 id="第7章-JdbcTemplate数据连接模板"><a href="#第7章-JdbcTemplate数据连接模板" class="headerlink" title="第7章　JdbcTemplate数据连接模板"></a>第7章　JdbcTemplate数据连接模板</h1><p>本章主要介绍Spring Boot如何使用JdbcTemplate操作数据库、配置多数据源等技术。事实上，JdbcTemplate应该是最简单的数据持久化方案，其使用非常简单。接下来将学习JdbcTemplate数据连接模板的使用。</p>
<h2 id="7-1-JdbcTemplate入门"><a href="#7-1-JdbcTemplate入门" class="headerlink" title="7.1　JdbcTemplate入门"></a>7.1　JdbcTemplate入门</h2><p>本节从基础的部分开始介绍什么是JDBC、什么是JdbcTemplate，然后介绍Spring Boot项目如何使用JdbcTemplate操作数据库。</p>
<h3 id="7-1-1-JdbcTemplate简介"><a href="#7-1-1-JdbcTemplate简介" class="headerlink" title="7.1.1　JdbcTemplate简介"></a>7.1.1　JdbcTemplate简介</h3><h4 id="1-什么是JDBC"><a href="#1-什么是JDBC" class="headerlink" title="1. 什么是JDBC"></a>1. 什么是JDBC</h4><p>JDBC（Java Data Base Connectivity，Java数据库连接）是Java语言中用来规范应用程序如何访问数据库的API，为多种关系数据库提供统一访问方式，诸如查询和更新数据库中数据的方法。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
<h4 id="2-什么是JdbcTemplate"><a href="#2-什么是JdbcTemplate" class="headerlink" title="2. 什么是JdbcTemplate"></a>2. 什么是JdbcTemplate</h4><p>JDBC作为Java访问数据库的API规范，统一了各种数据库的访问方式，但是直接在Java程序中使用JDBC还是非常复杂和烦琐的，所以Spring对JDBC进行了更深层次的封装，而JdbcTemplate就是Spring提供的操作数据库的便捷工具。它主要实现数据库连接的管理，我们可以借助JdbcTemplate来执行所有数据库操作，例如查询、插入、更新、删除等操作，并且有效地避免了直接使用JDBC带来的烦琐编码。</p>
<p>Spring Boot作为Spring的集大成者，自然会将JdbcTemplate集成进去。Spring Boot针对JDBC的使用提供了对应的Starter：spring-boot-starter-jdbc，它其实就是在Spring JDBC上做进一步的封装，方便在Spring Boot项目中更好地使用JDBC。</p>
<h4 id="3-JdbcTemplate的特点"><a href="#3-JdbcTemplate的特点" class="headerlink" title="3. JdbcTemplate的特点"></a>3. JdbcTemplate的特点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">速度快，相对于ORM框架，JDBC的方式是最快的。</span><br><span class="line">配置简单，Spring封装的除了数据库连接之外，几乎没有额外的配置。</span><br><span class="line">使用方便，它更像DBUtils工具类，只需注入JdbcTemplate对象即可。</span><br></pre></td></tr></table></figure>
<h4 id="4-JdbcTemplate的几种类型的方法"><a href="#4-JdbcTemplate的几种类型的方法" class="headerlink" title="4. JdbcTemplate的几种类型的方法"></a>4. JdbcTemplate的几种类型的方法</h4><p>JdbcTemplate虽然简单，但是功能非常强大，它提供了非常丰富、实用的方法，归纳起来主要有以下几种类型的方法：</p>
<p>1）execute()方法：可以用于执行任何SQL语句，一般用于执行DDL语句。</p>
<p>2）update()、batchUpdate()方法：用于执行新增、修改与删除等语句。</p>
<p>3）query()和queryForXXX()方法：用于执行查询相关的语句。</p>
<p>4）call()方法：用于执行数据库存储过程和函数相关的语句。</p>
<p>总的来说，新增、删除与修改3种类型的操作主要使用update()和batchUpdate()方法来完成。query()和queryForObject()方法主要用来完成查询功能。execute()方法可以用来创建、修改、删除数据库表。call()方法则用来调用存储过程。</p>
<p>在大部分情况下，我们都会使用更加强大的持久化框架来访问数据库，比如MyBatis、Hibernate或者Spring Data JPA。之所以介绍JdbcTemplate这种基础的数据库框架，只是希望读者能从基础开始学习，只有掌握了这些基础的框架才能更好地学习其他复杂的ORM框架。</p>
<h3 id="7-1-2-Spring-Boot集成JdbcTemplate"><a href="#7-1-2-Spring-Boot集成JdbcTemplate" class="headerlink" title="7.1.2　Spring Boot集成JdbcTemplate"></a>7.1.2　Spring Boot集成JdbcTemplate</h3><p>Spring Boot集成JDBC很简单，只需要引入依赖并进行基础配置即可。接下来以一个具体的例子来学习如何利用Spring的JdbcTemplate进行数据库操作。</p>
<p>步骤01 添加依赖配置。</p>
<p>在pom.xml配置文件中增加JDBC等相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在pom.xml文件中引入spring-boot-starterjdbc依赖。同时，由于项目中使用MySQL作为数据库，因此项目中需要引入MySQL驱动包。spring-boot-starter-jdbc直接依赖于HikariCP和spring-jdbc。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HikariCP是Spring Boot 2.0默认使用的数据库连接池，也是传说中最快的数据库连接池。</span><br><span class="line">spring-jdbc是Spring框架对JDBC的简单封装，提供了一个简化JDBC操作的开发工具包。</span><br></pre></td></tr></table></figure>
<p>步骤02 创建数据库及表结构。</p>
<p>首先创建jdbctest测试数据库，然后创建student表，包括id、name、sex、age等字段，对应的SQL脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `student`;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">                `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">                `name` varchar(32) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">                `sex` int DEFAULT NULL,</span><br><span class="line">                `age` int DEFAULT NULL,</span><br><span class="line">                PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;;</span><br></pre></td></tr></table></figure>
<p>步骤03 配置数据源</p>
<p>在application.properties中配置MySQL数据库连接相关内容。具体配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，数据库连接配置非常简单，包括数据库连接地址、用户名、密码以及数据驱动，无须其他额外配置。在Spring Boot 2.0中，com.mysql.jdbc.Driver已经过期，推荐使用com.mysql.cj.jdbc.Driver。</p>
<p>步骤04 使用JdbcTemplate。</p>
<p>上面已经把JdbcTemplate集成到Spring Boot项目中，并创建了数据。接下来创建一个单元测试类JdbcTests，验证JdbcTemplate操作数据库。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdbcTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">querytest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(<span class="string">&quot;select * from student &quot;</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        Assert.assertNotNull(list);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是简单地使用JdbcTemplate的测试示例，Spring的JdbcTemplate是自动配置的。使用@Autowired将JdbcTemplate注入需要的Bean中即可直接调用。</p>
<p>单击Run Test或在方法上右击，选择Run ‘querytest’，运行测试方法，结果如图7-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111337679.png" alt="image-20231011133710531"></p>
<p>单元测试queryTest运行成功，并输出了相应的结果。这说明JdbcTemplate已经连接上数据库，并成功执行了数据查询操作。</p>
<p>以上就把JdbcTemplate集成到Spring Boot项目中了。</p>
<h2 id="7-2-使用JdbcTemplate操作数据库"><a href="#7-2-使用JdbcTemplate操作数据库" class="headerlink" title="7.2　使用JdbcTemplate操作数据库"></a>7.2　使用JdbcTemplate操作数据库</h2><p>成功在Spring Boot项目中集成JdbcTemplate后，如何使用JdbcTemplate数据库连接模板操作数据库呢？接下来以示例演示JdbcTemplate实现学生信息的增、删、改、查等操作，让我们在实践中边学边用，更好地理解和吸收。</p>
<h3 id="7-2-1-实现学生数据管理功能"><a href="#7-2-1-实现学生数据管理功能" class="headerlink" title="7.2.1　实现学生数据管理功能"></a>7.2.1　实现学生数据管理功能</h3><p>步骤01 创建实体类。</p>
<p>根据之前创建的Student表结构创建对应的实体类Student，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> sex, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，实体类的数据类型要和数据库字段一一对应。</p>
<p>步骤02 定义Repository接口。</p>
<p>首先，创建StudentRepository接口并定义常用的增、删、改、查接口方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在StudentRepository中定义了save()、update()、delete()和findById()方法。</p>
<p>然后，创建StudentRepositoryImpl类，继承StudentRepository接口，实现接口中的增、删、改、查等方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentRepository</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在StudentRepositoryImpl类上使用@Repository注解用于标注数据访问组件JdbcTemplate，同时在类中注入JdbcTemplate实例。</p>
<p>步骤03 实现增、删、改、查功能。</p>
<p>接下来逐个实现对应的增、删、改、查方法。</p>
<p>1）新增：</p>
<p>在StudentRepositoryImpl类中实现StudentRepository接口中的save()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(),student.getSex(),student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JdbcTemplate中，<strong>除了查询有几个API之外，新增、删除与修改操作统一都调用update()方法来完成</strong>，传入SQL即可。Update()方法的返回值就是SQL执行受影响的行数。</p>
<p>2）删除：</p>
<p>通过用户id删除用户信息，在StudentRepositoryImpl类中实现StudentRepository接口的update( )方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;DELETE FROM Student where id = ? &quot;</span>,id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里读者可能会有疑问：怎么新增、删除、修改都调用update()方法，这与其他的框架不一样？严格来说，新增、删除、修改都属于数据写入，通过update()执行对应的SQL语句即可实现对数据库中数据的变更。</p>
<p>3）修改：</p>
<p>修改和新增类似，在StudentRepositoryImpl类中实现StudentRepository接口的update()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">&quot;UPDATE Student SET name = ? , password = ? , age = ?  WHERE id=?&quot;</span>, student.getName(),student.getSex(),student.getAge(),student.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）查询：</p>
<p>根据用户id查询用户信息，同样在StudentRepositoryImpl类中实现StudentRepository接口的findById()方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM Student WHERE id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; id &#125;, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Student&gt;(Student.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，JdbcTemplate执行查询相关的语句调用query()方法及queryForXXX()方法，查询对象调用queryForObject方法。JdbcTemplate支持将查询结果转换为实体对象，使用new BeanPropertyRowMapper\<Student>(Student.class)对返回的数据进行封装，它通过名称匹配的方式自动将数据列映射到指定类的实体类中。</p>
<p>在执行查询操作时，需要有一个RowMapper将查询出来的列和实体类中的属性一一对应起来：如果列名和属性名是相同的，那么可以直接使用BeanPropertyRowMapper；如果列名和属性名不同，就需要开发者自己实现RowMapper接口，将数据列与实体类属性字段映射。</p>
<p>步骤04 验证测试。</p>
<p>接下来对封装好的StudentRepository进行测试，测试StudentRepository中的各个方法是否正确。创建StudentRepositoryTests类，将studentRepository注入测试类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentRepositoryImplTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz&quot;</span>,<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">        studentRepository.save(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz&quot;</span>,<span class="number">1</span>,<span class="number">18</span>);</span><br><span class="line">        student.setId(<span class="number">1L</span>);</span><br><span class="line">        studentRepository.update(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        studentRepository.delete(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentRepository.findById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;student == &quot;</span> + student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，依次执行上面的单元测试方法，验证学生信息的增删改查功能是否正常，结果如图7-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111356123.png" alt="image-20231011135647015"></p>
<p>结果表明单元测试执行正常，说明StudentRepository中的方法执行成功，也可以查看数据库中的数据是否符合预期。</p>
<h3 id="7-2-2-复杂查询"><a href="#7-2-2-复杂查询" class="headerlink" title="7.2.2　复杂查询"></a>7.2.2　复杂查询</h3><p>JdbcTemplate除了封装update和query等这些常用的方法外，还可以实现数据的增删改查操作。实际上，JdbcTemplate还封装了execute()、queryForXXX()等许多非常实用的方法，比如需要返回List对象时可以调用queryForList()方法，创建数据库表结构时可以调用execute()方法生成数据库表。下面通过一些简单的示例来演示这些方法的调用。</p>
<h4 id="1-execute-方法"><a href="#1-execute-方法" class="headerlink" title="1. execute()方法"></a>1. execute()方法</h4><p>调用JdbcTemplate的execute()方法执行SQL语句，生成数据库表结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.execute(<span class="string">&quot;CREATE TABLE Student (id integer, name varchar(100))&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面这个示例就是通过调用execute()方法执行建表语句，生成数据库表结构。</p>
<h4 id="2-queryForXXX-方法"><a href="#2-queryForXXX-方法" class="headerlink" title="2. queryForXXX()方法"></a>2. queryForXXX()方法</h4><p>使用JdbcTemplate进行查询时，需要返回各种不同的数据类型，调用queryForXXX()等方法即可。比如需要返回int类型，调用queryForInt()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForInt(<span class="string">&quot;SELECT COUNT(*) FROM Student &quot;</span>);</span><br></pre></td></tr></table></figure>
<p>除了queryForInt()方法之外，还有像queryForList()等很多数据类型的方法可以直接返回需要的数据类型，无须额外的类型转换。</p>
<h4 id="3-数据对象转换"><a href="#3-数据对象转换" class="headerlink" title="3. 数据对象转换"></a>3. 数据对象转换</h4><p>前面提到可以使用BeanPropertyRowMapper类自动将查询到的数据转换为数据对象信息。针对数据库字段和实体属性不一致的情况，JdbcTemplate还提供了自定义RowMapper对象进行属性映射。</p>
<p>首先，创建一个属性映射类StudentRowMapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，自定义的StudentRowMapper类继承JdbcTemplate中的RowMapper类。重写mapRow()方法，将结果集中的数据转换为Student对象。</p>
<p>然后，创建单元测试，验证数据对象转换，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rowMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students = jdbcTemplate.query(<span class="string">&quot;SELECT * FROM student&quot;</span>, <span class="keyword">new</span> <span class="title class_">StudentRowMapper</span>());</span><br><span class="line">    <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+student.getId()+<span class="string">&quot;,name:&quot;</span>+student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，调用query()返回Student列表数据，传入StudentRowMapper参数，将查询结果转换为用户列表并返回。</p>
<h4 id="4-返回主键"><a href="#4-返回主键" class="headerlink" title="4. 返回主键"></a>4. 返回主键</h4><p>前面介绍了数据的新增，但是有些时候需要在数据插入的过程中返回主键，那么可以调用PreparedStatementCreator()，代码如下：``</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">KeyHolder</span> <span class="variable">keyHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedKeyHolder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> jdbcTemplate.update(<span class="keyword">new</span> <span class="title class_">PreparedStatementCreator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PreparedStatement <span class="title function_">createPreparedStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into student (name,sex,age) values (?,?,?);&quot;</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setString(<span class="number">1</span>, student.getName());</span><br><span class="line">            ps.setInt(<span class="number">2</span>, student.getSex());</span><br><span class="line">            ps.setInt(<span class="number">3</span>, student.getAge());</span><br><span class="line">            <span class="keyword">return</span> ps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, keyHolder);</span><br><span class="line">    student.setId(keyHolder.getKey().longValue());</span><br><span class="line">    System.out.println(keyHolder.getKey().longValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，实际上就相当于调用了JDBC中的方法，首先在构建PreparedStatement时传入Statement.RETURN_GENERATED_KEYS，然后传入KeyHolder，最终从KeyHolder中获取刚刚插入数据的id，保存到student对象的id属性中。</p>
<p>单击Run Test或在方法上右击，选择Run ‘save2’，运行测试方法，结果如图7-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111409769.png" alt="image-20231011140913667"></p>
<p>结果表明单元测试方法save2运行成功，并输出了相应的结果。这说明数据已经插入成功并返回了数据的主键id。</p>
<h4 id="5-存储过程"><a href="#5-存储过程" class="headerlink" title="5. 存储过程"></a>5. 存储过程</h4><p>由于各种ORM框架的流行，存储过程的使用场景已经不多见了。但是，JdbcTemplate对存储过程同样进行了良好的封装。下面通过一个示例来演示JdbcTemplate是如何调用存储过程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">resultList</span> <span class="operator">=</span> (List) jdbcTemplate.execute(</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">CallableStatementCreator</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> CallableStatement <span class="title function_">createCallableStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">storedProc</span> <span class="operator">=</span> <span class="string">&quot;&#123;call testpro(?,?)&#125;&quot;</span>;<span class="comment">// 调用的sql</span></span><br><span class="line">           <span class="type">CallableStatement</span> <span class="variable">cs</span> <span class="operator">=</span> con.prepareCall(storedProc);</span><br><span class="line">           cs.setString(<span class="number">1</span>, <span class="string">&quot;p1&quot;</span>);<span class="comment">// 设置输入参数的值</span></span><br><span class="line">           cs.registerOutParameter(<span class="number">2</span>, OracleTypes.CURSOR);<span class="comment">// 注册输出参数的类型</span></span><br><span class="line">           <span class="keyword">return</span> cs;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="keyword">new</span> <span class="title class_">CallableStatementCallback</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">doInCallableStatement</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException,DataAccessException &#123;</span><br><span class="line">           <span class="type">List</span> <span class="variable">resultsMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">           cs.execute();</span><br><span class="line">           <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> (ResultSet) cs.getObject(<span class="number">2</span>);<span class="comment">// 获取游标一行的值</span></span><br><span class="line">           <span class="keyword">while</span> (rs.next()) &#123;<span class="comment">// 转换每行的返回值到Map中</span></span><br><span class="line">              <span class="type">Map</span> <span class="variable">rowMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">              rowMap.put(<span class="string">&quot;id&quot;</span>, rs.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">              rowMap.put(<span class="string">&quot;name&quot;</span>, rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">              resultsMap.add(rowMap);</span><br><span class="line">           &#125;</span><br><span class="line">           rs.close();</span><br><span class="line">           <span class="keyword">return</span> resultsMap;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultList.size(); i++) &#123;</span><br><span class="line">     <span class="type">Map</span> <span class="variable">rowMap</span> <span class="operator">=</span> (Map) resultList.get(i);</span><br><span class="line">     <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> rowMap.get(<span class="string">&quot;id&quot;</span>).toString();</span><br><span class="line">     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rowMap.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">     System.out.println(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;;name=&quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码说明：</p>
<p>1）JdbcTemplete通过execute()方法执行存储过程并获得输出结果。</p>
<p>2）通过CallableStatement类的prepareCall()方法设置调用的存储过程名称和输入、输出参数。</p>
<p>3）通过CallableStatementCallback中的doInCallableStatement()方法执行对应的存储过程，并返回执行结果。</p>
<h2 id="7-3-实战：实现JdbcTemplate多数据源"><a href="#7-3-实战：实现JdbcTemplate多数据源" class="headerlink" title="7.3　实战：实现JdbcTemplate多数据源"></a>7.3　实战：实现JdbcTemplate多数据源</h2><p>上一节使用JdbcTemplate成功地实现了用户信息的增删改查功能，接下来好好研究一下如何配置多数据源。</p>
<h3 id="7-3-1-什么是多数据源"><a href="#7-3-1-什么是多数据源" class="headerlink" title="7.3.1　什么是多数据源"></a>7.3.1　什么是多数据源</h3><p>所谓多数据源，其实就是在一个项目中使用多个数据库实例中的数据库或者同一个数据库实例中多个不同的库。</p>
<p>在实际开发中可能会遇到需要配置多个数据源的情况，比如项目需要使用业务数据库和日志数据库等多个数据库，或者需要使用多种数据库（如MySQL、Oracle、SQL Server等）。</p>
<p>JdbcTemplate多数据源的配置比较简单，因为一个JdbcTemplate实例对应一个DataSource，开发者只需要手动提供多个DataSource，再手动配置相应的JdbcTemplate实例，需要操作哪个数据源就使用对应的JdbcTemplate实例即可。</p>
<h3 id="7-3-2-配置JdbcTemplate多数据源"><a href="#7-3-2-配置JdbcTemplate多数据源" class="headerlink" title="7.3.2　配置JdbcTemplate多数据源"></a>7.3.2　配置JdbcTemplate多数据源</h3><p>接下来在前面项目的基础上进行改造，演示JdbcTemplate是如何配置多数据源的。</p>
<p>步骤01 配置多数据源。</p>
<p>修改application.properties文件，配置数据源连接，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.primary.jdbc-url=jdbc:mysql://localhost:3306/jdbc_test</span><br><span class="line">spring.datasource.primary.username=root</span><br><span class="line">spring.datasource.primary.password=root</span><br><span class="line">spring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.secondary.jdbc-url=jdbc:mysql://localhost:3306/jdbc_test2</span><br><span class="line">spring.datasource.secondary.username=root</span><br><span class="line">spring.datasource.secondary.password=root</span><br><span class="line">spring.datasource.secondary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，先重新创建jdbc_test2数据库，再通过jdbc_test和jdbc_test2两个数据库演示多数据库的情况。我们可以看到上面的配置和原先单数据源的配置有些不同：</p>
<p>1）在application.properties配置文件中添加了两个数据源，通过primary和secondary来区分，分别对应的是jdbc_test和jdbc_test2数据库。</p>
<p>2）单数据源的数据库连接使用spring.datasource.url配置项，多数据源使用spring.datasource.*.jdbc-url配置项。</p>
<p>步骤02 配置JDBC初始化。</p>
<p>创建DataSourceConfig类，在项目启动时读取配置文件中的数据库信息，并对JDBC初始化，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;secondaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">secondaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;primaryJdbcTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">primaryJdbcTemplate</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;secondaryJdbcTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">secondaryJdbcTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，DataSourceConfig类的作用是在项目启动时根据特定的前缀加载不同的数据源，再根据构建好的数据源创建不同的JdbcTemplate。由于Spring容器中存在两个数据源，使用默认的类型查找时会报错，因此加上@Qualifier注解，表示按照名称查找。这里创建了两个JdbcTemplate实例，分别对应了两个数据源。</p>
<p>需要注意的是，使用多个数据源时需要添加@Primary注解，表示自动装配出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者。Primary表示“主要的”，类似于SQL语句中的“Primary Key”（主键），只能有唯一一个，否则会报错。</p>
<p>步骤03 使用多数据源。</p>
<p>配置完成之后如何使用呢？下面通过单元测试实例来演示使用多数据源。在测试列中注入了两个不同数据源的JdbcTemplate实例，测试使用不同的JdbcTemplate插入两条数据，查看两个数据库中是否全部保存成功。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate primaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate secondaryJdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataSourceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz多数据源&quot;</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">    primaryJdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(), student.getSex(), student.getAge());</span><br><span class="line"></span><br><span class="line">    secondaryJdbcTemplate.update(<span class="string">&quot;INSERT INTO Student(name, sex, age) values(?, ?, ?)&quot;</span>,</span><br><span class="line">            student.getName(), student.getSex(), student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单击Run Test或在方法上右击，选择Run ‘save2’，运行测试方法，结果如图7-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111421980.png" alt="image-20231011142129862"></p>
<p>执行dataSourceTest()单元测试之后，我们看到系统自动创建了HikariPool-1和HikariPool-2两个数据库连接，查看数据库jdbc_test和jdbc_test2中的student表中是否有名为“weiz多数据源”的数据，有则说明多数据源配置成功。其他方法的测试与此大致相同。</p>
<p>这样多数据源就配置成功了。在实际开发的项目中，可以通过实现多数据源配置业务数据库与日志数据库分离。</p>
<h1 id="第8章-数据库持久层框架MyBatis"><a href="#第8章-数据库持久层框架MyBatis" class="headerlink" title="第8章　数据库持久层框架MyBatis"></a>第8章　数据库持久层框架MyBatis</h1><p>数据库是企业应用中非常重要的部分，而MyBatis是流行的数据库持久层框架之一，本章将主要介绍MyBatis的使用。MyBatis支持简单的XML或注解的方式配置与映射数据信息，支持定制化SQL、存储过程以及高级映射，从而避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</p>
<h2 id="8-1-MyBatis简介"><a href="#8-1-MyBatis简介" class="headerlink" title="8.1　MyBatis简介"></a>8.1　MyBatis简介</h2><p>本节首先会介绍什么是ORM、什么是MyBatis、MyBatis的特点以及核心概念，最后介绍MyBatis是如何启动、如何加载配置文件的？</p>
<h3 id="8-1-1-什么是ORM"><a href="#8-1-1-什么是ORM" class="headerlink" title="8.1.1　什么是ORM"></a>8.1.1　什么是ORM</h3><p>ORM（Object Relational Mapping，对象关系映射）是为了解决面向对象与关系数据库存在的互不匹配现象的一种技术。简单地说，ORM通过使用描述对象和数据库之间映射的元数据将程序中的对象自动持久化到关系数据库中。</p>
<p>当我们开发应用程序时，需要编写大量的数据访问层代码，用来操作数据库中的数据，这些代码要么是大量重复的代码，要么操作特别烦琐。针对这些问题，ORM提供了完善的解决方案，简化了将对象持久化到关系数据库中的操作。</p>
<p>ORM框架的本质是简化编程中操作数据库的编码，Java领域发展到现在，ORM框架层出不穷，但是，基本上还是Hibernate和Mybatis两个比较流行并被广泛使用。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORM框架的本质是简化编程中操作数据库的编码，Java领域发展到现在，ORM框架层出不穷，但是，基本上还是Hibernate和Mybatis两个比较流行并被广泛使用。</span><br></pre></td></tr></table></figure>
<p>Hibernate宣称可以不用写一句SQL，而MyBatis以动态SQL见长，两者各有特点，开发者可以根据需求灵活使用。有一个有趣的现象：传统企业大多喜欢使用Hibernate，而互联网行业则通常使用MyBatis。</p>
<h3 id="8-1-2-什么是MyBatis"><a href="#8-1-2-什么是MyBatis" class="headerlink" title="8.1.2　什么是MyBatis"></a>8.1.2　什么是MyBatis</h3><p>MyBatis是一款优秀的数据持久层ORM框架，被广泛地应用于应用系统。最早是Apache的一个开源项目iBatis，2010年这个项目由Apache Software Foundation迁移到了Google Code，并且改名为MyBatis，2013年11月又迁移到了GitHub。</p>
<p>MyBatis支持定制化的SQL、存储过程和高级映射，能够非常灵活地实现动态SQL，可以使用简单的XML或注解来配置和映射原生信息，能够轻松地将Java的POJO（Plain Ordinary Java Object，普通的Java对象）与数据库中的表和字段进行映射关联。</p>
<p>MyBatis作为一款使用广泛的开源软件，它的特点如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易学易用，没有任何第三方依赖。SQL被统一提取出来，便于统一管理和优化。SQL和代码解耦，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易进行单元测试。灵活动态的SQL，支持各种条件来动态生成不同的SQL。提供映射标签，支持对象与数据库的ORM关系映射。提供对象关系映射标签，支持对象关系组件维护。</span><br></pre></td></tr></table></figure>
<h3 id="8-1-3-MyBatis的核心概念"><a href="#8-1-3-MyBatis的核心概念" class="headerlink" title="8.1.3　MyBatis的核心概念"></a>8.1.3　MyBatis的核心概念</h3><p>MyBatis由Mapper配置文件、Mapper接口、执行器、会话等组件组成。下面就来介绍这些非常重要的组件和概念。</p>
<p>1）Mapper配置文件：可以使用基于XML的Mapper配置文件来实现，也可以使用基于Java注解的MyBatis注解来实现，甚至可以直接使用MyBatis提供的API来实现。</p>
<p>2）Mapper接口：是指自定义的数据操作接口，类似于通常所说的DAO接口。早期的Mapper接口需要自定义去实现，现在MyBatis会自动为Mapper接口创建动态代理对象。Mapper接口的方法通常与Mapper配置文件中的select、insert、update、delete等XML节点一一对应。</p>
<p>3）Executor（执行器）：MyBatis中所有SQL语句的执行都是通过Executor进行的，Executor是MyBatis的一个核心接口。</p>
<p>4）SqlSession（会话）：MyBatis的关键对象，类似于JDBC中的连接（Connection），SqlSession对象完全包含数据库相关的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行被映射的SQL语句。</p>
<p>5）SqlSessionFactory（会话工厂）：MyBatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象类获得。</p>
<p>6）SqlSessionFactoryBuilder构建器：用于解析配置文件，包括属性配置、别名配置、拦截器配置、数据源和事务管理器等，可以从XML配置文件或一个预定义的配置实例进行构建。</p>
<h3 id="8-1-4-MyBatis的启动流程"><a href="#8-1-4-MyBatis的启动流程" class="headerlink" title="8.1.4　MyBatis的启动流程"></a>8.1.4　MyBatis的启动流程</h3><p>MyBatis的使用虽然简单，但是，它属于高度封装的框架，因此，我们必须熟悉MyBatis的启动和执行过程。具体的工作流程如图8-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111521460.png" alt="image-20231011152153300"></p>
<p>1）加载Mapper配置的SQL映射文件，或者注解的相关SQL内容。</p>
<p>2）创建会话工厂。MyBatis通过读取配置文件的数据源信息来构造会话工厂（SqlSessionFactory）。</p>
<p>3）创建会话。MyBatis可以通过会话工厂来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含对数据库操作的增、删、改、查方法。</p>
<p>4）创建执行器。因为会话对象本身不能直接操作数据库，所以它使用了一个叫作数据库执行器（Executor）的接口来帮它执行操作。</p>
<p>5）封装SQL对象。在这一步，执行器将待处理的SQL信息封装到一个对象（MappedStatement）中，该对象包括SQL语句、输入参数映射信息（Java简单类型、HashMap或POJO）和输出结果映射信息。</p>
<p>6）操作数据库。拥有了执行器和SQL信息封装对象就可以使用它们访问数据库，最后返回操作结果，结束流程。</p>
<p>总结起来，MyBatis主要有两大核心组件：<strong>SqlSessionFactory和Mapper</strong>。SqlSessionFactory负责创建数据库会话，Mapper主要提供SQL映射。</p>
<h2 id="8-2-Spring-Boot构建MyBatis应用程序"><a href="#8-2-Spring-Boot构建MyBatis应用程序" class="headerlink" title="8.2　Spring Boot构建MyBatis应用程序"></a>8.2　Spring Boot构建MyBatis应用程序</h2><p>MyBatis官方对Spring Boot提供了完善的支持，能够方便地将MyBatis集成到Spring Boot项目中。接下来就让我们一步一步地将MyBatis集成到Spring Boot项目中，实现学生信息管理功能。</p>
<h3 id="8-2-1-MyBatis-Spring-Boot-Starter简介"><a href="#8-2-1-MyBatis-Spring-Boot-Starter简介" class="headerlink" title="8.2.1　MyBatis-Spring-Boot-Starter简介"></a>8.2.1　MyBatis-Spring-Boot-Starter简介</h3><p>MyBatis官方为帮助开发者快速集成Spring Boot项目、构建基于Spring Boot的MyBatis应用程序，提供了针对Spring Boot的启动器：MyBatis-Spring-Boot-Starter。它不是Spring Boot官方开发的启动器，所以MyBatis-Spring-Boot-Starter是一个集成包，对MyBatis、MyBatis-Spring和Spring Boot都存在依赖，需要注意三者的版本对应关系，如表8-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111524999.png" alt="image-20231011152437888"></p>
<p>由于MyBatis-Spring-Boot-Starter是MyBatis官方提供的组件而非Spring Boot开发的，因此它的版本和Spring Boot不一样，使用时需要注意版本。</p>
<p>MyBatis针对Spring Boot项目做了非常完善的支持，使用MyBatis-Spring-Boot-Starter组件可以做到以下几点：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构建独立的应用。</span><br><span class="line">几乎可以零配置。</span><br><span class="line">需要很少的XML配置。</span><br></pre></td></tr></table></figure>
<p>MyBatis的启动过程看起来很复杂，其实主要完成以下几个操作：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动发现存在的数据源。</span><br><span class="line">利用SqlSessionFactoryBean创建并注册SqlSessionFactory。</span><br><span class="line">创建并注册SqlSessionTemplate。</span><br><span class="line">自动扫描Mappers，并注册到Spring上下文中，方便程序的注入使用。</span><br></pre></td></tr></table></figure>
<p>因此，使用MyBatis-Spring-Boot-Starter启动器之后，只需要在配置文件中定义数据源，MyBatis就会使用该数据源自动创建SqlSessionFactoryBean以及SqlSessionTemplate，同时会自动扫描Mappers接口，并注册到Spring上下文中，相当于所有数据库的底层操作MyBatis都自动完成了。</p>
<p>MyBatis对于SQL映射提供了两种解决方案：一种是简化后的XML配置版，另一种是使用注解解决一切问题。</p>
<h3 id="8-2-2-Spring-Boot集成MyBatis"><a href="#8-2-2-Spring-Boot集成MyBatis" class="headerlink" title="8.2.2　Spring Boot集成MyBatis"></a>8.2.2　Spring Boot集成MyBatis</h3><p>MyBatis官方针对Spring Boot提供了启动包：MyBatis-spring-boot-starter组件，使得Spring Boot构建MyBatis应用程序更加简单方便。下面将演示Spring Boot项目集成MyBatis-spring-boot-starter组件的过程，以便进一步构建数据库应用。</p>
<h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><p>首先需要在pom.xml文件中引入MyBatis-spring-boot-starter依赖包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，引入MyBatis-spring-boot-starter组件需要指定版本号。另外，还需要引入mysql-connector-java连接驱动。</p>
<h4 id="2-应用配置"><a href="#2-应用配置" class="headerlink" title="2. 应用配置"></a>2. 应用配置</h4><p>在application.properties中添加MyBatis的相关配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mapper.xml配置文件的路径</span><br><span class="line">MyBatis.mapper-locations=classpath:/mapper/*.xml</span><br><span class="line">MyBatis.type-aliases-package=com.weiz.example01.model</span><br><span class="line"># 数据库连接</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/MyBatis_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，主要是数据库连接和Mapper文件相关的配置，具体配置说明如下：</p>
<p>1）MyBatis.mapper-locations：配置Mapper对应的XML文件路径。</p>
<p>2）MyBatis.type-aliases-package：配置项目中的实体类包路径。</p>
<p>3）spring.datasource.*：数据源相关配置。</p>
<h4 id="3-修改启动类"><a href="#3-修改启动类" class="headerlink" title="3. 修改启动类"></a>3. 修改启动类</h4><p>在启动类中添加对Mapper包的扫描注解@MapperScan，Spring Boot启动时会自动加载包路径下的Mapper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.weiz.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">　 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用MapperScan注解定义需要扫描的Mapper包。其实，也可以直接在Mapper类上添加注解@Mapper，这样Spring Boot也会自动注入Spring。不过，建议使用上面代码中使用的这种，不然给每个Mapper添加注解也挺麻烦。</p>
<h4 id="4-创建数据库和表"><a href="#4-创建数据库和表" class="headerlink" title="4. 创建数据库和表"></a>4. 创建数据库和表</h4><p>首先创建mybatis_test数据库，然后在数据库中创建student表，脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#x27;student&#x27;;</span><br><span class="line">CREATE TABLE &#x27;student&#x27; (</span><br><span class="line">    &#x27;id&#x27; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">    &#x27;name&#x27; varchar(32) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    &#x27;sex&#x27; int(11) DEFAULT NULL,</span><br><span class="line">    &#x27;age&#x27; int(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#x27;id&#x27;)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<h4 id="5-创建实体类"><a href="#5-创建实体类" class="headerlink" title="5. 创建实体类"></a>5. 创建实体类</h4><p>在model目录创建Student实体类，属性与创建的Student表中的字段一致，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> sex, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略get、set方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-添加mapper接口和映射文件"><a href="#6-添加mapper接口和映射文件" class="headerlink" title="6. 添加mapper接口和映射文件"></a>6. 添加mapper接口和映射文件</h4><p>创建数据库表之后，接下来定义mapper接口。首先在com.weiz.example01.mapper包中创建StudentMapper接口，然后定义一个查询方法，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了查询学生信息的seletAll()方法。需要注意的是，<strong>mapper接口中的方法名需要和XML配置中的id属性一致</strong>，不然找不到方法去对应执行的SQL。</p>
<p>接下来定义MyBatis的核心文件：mapper映射文件。在resources/mapper目录创建StudentMapper.xml映射文件，具体实例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.weiz.example01.mapper.StudentMapper&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        *</span><br><span class="line">        FROM student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过\<select>标签映射mapper接口中定义的selectAll()方法，标签的id为mapper接口中的方法，然后通过\<resultMap>映射查询结果集字段与实体类Student的映射关系。</p>
<h4 id="7-测试调用"><a href="#7-测试调用" class="headerlink" title="7. 测试调用"></a>7. 测试调用</h4><p>创建单元测试类和测试方法testSelectAll()，具体测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    List&lt;Student&gt; students = studentMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Student stu : students)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot;,age:&quot;</span>+stu.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是简单的使用MyBatis的测试示例，使用@Autowired将StudentMapper注入后即可直接调用。</p>
<p>单击Run Test或在方法上右击，选择Run ‘testSelectAll’，运行测试方法，结果如图8-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111537090.png" alt="image-20231011153709894"></p>
<p>结果表明单元测试方法testSelectAll()运行成功，并输出了相应的学生数据查询结果。这说明在项目中成功集成MyBatis，并成功执行了数据查询操作。</p>
<h3 id="8-2-3-实战：实现学生信息管理模块"><a href="#8-2-3-实战：实现学生信息管理模块" class="headerlink" title="8.2.3　实战：实现学生信息管理模块"></a>8.2.3　实战：实现学生信息管理模块</h3><p>前面我们成功地将MyBatis集成到了Spring Boot项目中。下面将通过示例实现完整的学生信息管理功能。</p>
<h4 id="1-修改mapper接口"><a href="#1-修改mapper接口" class="headerlink" title="1. 修改mapper接口"></a>1. 修改mapper接口</h4><p>修改原有的StudentMapper接口，定义学生数据的增、删、改、查等接口方法，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">selectOne</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-修改mapper映射文件"><a href="#2-修改mapper映射文件" class="headerlink" title="2. 修改mapper映射文件"></a>2. 修改mapper映射文件</h4><p>修改之前创建的StudentMapper.xml映射文件，定义具体的增、删、改、查SQL语句，具体示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    FROM student</span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    INSERT INTO</span><br><span class="line">    student</span><br><span class="line">    (name,sex,age)</span><br><span class="line">    VALUES</span><br><span class="line">    (#&#123;name&#125;, #&#123;sex&#125;, #&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    UPDATE</span><br><span class="line">    student</span><br><span class="line">    SET</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span>sex = #&#123;sex&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    age = #&#123;age&#125;</span><br><span class="line">    WHERE</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> &gt;</span></span><br><span class="line">    DELETE FROM</span><br><span class="line">    student</span><br><span class="line">    WHERE</span><br><span class="line">    id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们根据StudentMapper接口定义的方法配置了对应的SQL语句。可能有些人会问：update()方法中的SQL使用的if标签是怎么回事？这是MyBatis最大的特点，可以根据传入的不同条件动态生成SQL语句。</p>
<h4 id="3-测试调用"><a href="#3-测试调用" class="headerlink" title="3. 测试调用"></a>3. 测试调用</h4><p>创建单元测试方法，测试mapper中的insert、delete、update、selectOne等方法，具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    studentMapper.insert(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz新增&quot;</span>, <span class="number">1</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectOne(<span class="number">4L</span>);</span><br><span class="line">    student.setName(<span class="string">&quot;weiz修改&quot;</span>);</span><br><span class="line">    student.setSex(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    studentMapper.update(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectOne(<span class="number">4l</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name:&quot;</span>+student.getName()+<span class="string">&quot;,age:&quot;</span>+student.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    studentMapper.delete(<span class="number">4L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在测试类中注入StudentMapper接口，测试调用insert、delete、update、selectOne等方法，验证学生信息的增、删、改、查是否成功。</p>
<p>单击Run Test或在方法上右击，选择Run ‘Example01ApplicationTests’，运行全部测试方法，结果如图8-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111629496.png" alt="image-20231011162959295"></p>
<p>结果表明增、删、改、查对应的单元测试方法运行成功，并输出了相应的查询结果。这说明实现了学生信息的管理功能。</p>
<h3 id="8-2-4-MyBatis-Generator插件"><a href="#8-2-4-MyBatis-Generator插件" class="headerlink" title="8.2.4　MyBatis Generator插件"></a>8.2.4　MyBatis Generator插件</h3><p>使用ORM框架比较麻烦的一点是不仅要创建数据库和表，还要创建对应的POJO实体类和mapper映射文件，而且表结构、实体类和mapper文件三者必须保持一致。如果数据库字段发生变化，则需要同步修改这三个文件。整个过程非常烦琐，而且容易出错。因此，MyBatis提供了强大的代码自动插件：MyBatis Generator，只需简单几步就能生成POJO实体类和mapper映射文件和mapper接口文件。</p>
<p>Spring Boot支持MyBatis Generator自动生成代码插件，能在项目中自动生成POJO实体类、mapper接口以及SQL映射文件，从而提高开发效率。下面开始演示MyBatis Generator插件的使用。</p>
<h4 id="1-添加MyBatis-Generator插件"><a href="#1-添加MyBatis-Generator插件" class="headerlink" title="1. 添加MyBatis Generator插件"></a>1. 添加MyBatis Generator插件</h4><p>在项目的pom.xml中引入MyBatis Generator依赖，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis generator 自动生成代码插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.MyBatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接及MyBatis generator core依赖生成mapper时使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.MyBatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在pom.xml文件的build标签中添加了MyBatis-generator-maven-plugin插件，然后配置了generatorConfig.xml。</p>
<h2 id="8-3-使用XML配置文件实现数据库操作"><a href="#8-3-使用XML配置文件实现数据库操作" class="headerlink" title="8.3　使用XML配置文件实现数据库操作"></a>8.3　使用XML配置文件实现数据库操作</h2><p>MyBatis真正强大的地方在于它的SQL映射，这是它的魔力所在。对于任何MyBatis的使用者来说，其SQL映射文件是必须要掌握的。本节开始介绍MyBatis的SQL映射文件的语法和使用方法。</p>
<h3 id="8-3-1-SQL映射文件"><a href="#8-3-1-SQL映射文件" class="headerlink" title="8.3.1　SQL映射文件"></a>8.3.1　SQL映射文件</h3><p>SQL映射文件就是我们通常说的mapper.xml配置文件，主要实现SQL语句的配置和映射，同时实现Java的POJO对象与数据库中的表和字段进行映射关联的功能。</p>
<h4 id="1-mapper-xml的结构"><a href="#1-mapper-xml的结构" class="headerlink" title="1. mapper.xml的结构"></a>1. mapper.xml的结构</h4><p>前面我们创建的StudentMapper.xml中定义了mapper接口对应的SQL和返回类型。下面就来详细介绍mapper.xml文件的结构。首先看一个完整的mapper.xml示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.weiz.example01.mapper.StudentMapper&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        *</span><br><span class="line">        FROM student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如上述示例所示，一般mapper.xml主要分为4部分：</p>
<p>1）mapper.xml的语法声明，声明MyBatis语法。</p>
<p>2）通过namespace指明mapper.xml文件对应的Mapper接口。</p>
<p>3）通过XML标签定义接口方法对应的SQL语句，id属性对应Mapper接口中的方法，resultMap属性为返回值类型。</p>
<p>4）\<resultMap>标签定义返回的结果类型与数据库表结构的对应关系，上面映射的是Student实体类对象。</p>
<h4 id="2-mapper-xml的标签"><a href="#2-mapper-xml的标签" class="headerlink" title="2. mapper.xml的标签"></a>2. mapper.xml的标签</h4><p>mapper.xml映射文件提供了一些非常实用的标签，其中比较常用的有resultMap、sql、insert、update、delete、select等标签。熟练掌握标签的使用，这样使用MyBatis才能如鱼得水。MyBatis标签和功能说明如表8-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111641303.png" alt="image-20231011164143635"></p>
<h3 id="8-3-2-定义SQL语句"><a href="#8-3-2-定义SQL语句" class="headerlink" title="8.3.2 定义SQL语句"></a>8.3.2 定义SQL语句</h3><p>MyBatis提供了insert、update、select和delete四个标签来定义SQL语句。接下来就从SQL语句开始介绍每个标签的用法。</p>
<h4 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h4><p>select是MyBatis常用的元素之一，MyBatis在查询和结果映射中做了相当多的改进。一个简单查询的select元素是非常简单的，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span>&gt;</span></span><br><span class="line">    SELECT name,age FROM student WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过id查询学生的姓名和年龄。定义方法名为selectOne，接收一个Long类型的参数，并返回一个HashMap类型的对象。HashMap的键是列名，值是结果集中的对应值。#{id}为传入的参数符号。</p>
<p>select标签允许配置很多属性来配置每条语句的行为细节，比如参数类型、返回值类型等，包含的属性如表8-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111643951.png" alt="image-20231011164336794"></p>
<p>select标签虽然有很多属性，但是常用的是id、parameterType、resultType、resultMap这4个属性。需要注意的是，<strong>resultMap是MyBatis的强大特性之一</strong>，如果对其理解透彻，许多复杂的映射问题都能迎刃而解。</p>
<h4 id="2-insert"><a href="#2-insert" class="headerlink" title="2. insert"></a>2. insert</h4><p>insert标签主要用于定义插入数据的SQL语句，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    INSERT INTO</span><br><span class="line">    student</span><br><span class="line">    (id,name,sex,age)</span><br><span class="line">    VALUES</span><br><span class="line">    (#&#123;id&#125;,#&#123;name&#125;, #&#123;sex&#125;, #&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，插入语句的配置规则更加复杂，同时提供了额外的属性和子元素用来处理主键的生成方式。</p>
<p>如果数据库包含自动生成主键的字段，那么可以设置useGeneratedKeys=”true”，然后把keyProperty设置为目标属性。比如，上面的Student表已经在id列上使用了自动生成主键，那么语句可以修改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    INSERT INTO</span><br><span class="line">    student</span><br><span class="line">    (name,sex,age)</span><br><span class="line">    VALUES</span><br><span class="line">    (#&#123;name&#125;, #&#123;sex&#125;, #&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，设置useGeneratedKeys=”true”，然后设置keyProperty=”id”对应的主键字段。</p>
<p>insert标签包含的属性如表8-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111645712.png" alt="image-20231011164511559"></p>
<p>常用的属性有id、parameterType、useGeneratedKeys、keyProperty等，部分属性和select标签是一致的。</p>
<h4 id="3-update"><a href="#3-update" class="headerlink" title="3. update"></a>3. update</h4><p>update标签和insert标签类似，主要用来映射更新语句，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    UPDATE</span><br><span class="line">    student</span><br><span class="line">    SET</span><br><span class="line">    name = #&#123;name&#125;,</span><br><span class="line">    sex = #&#123;sex&#125;,</span><br><span class="line">    age = #&#123;age&#125;</span><br><span class="line">    WHERE</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果需要根据传入的参数来动态判断是否进行修改，可以使用if标签动态生成SQL语句，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    UPDATE</span><br><span class="line">    student</span><br><span class="line">    SET</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span>sex = #&#123;sex&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    age = #&#123;age&#125;</span><br><span class="line">    WHERE</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过if标签判断<strong>传入的name参数</strong>是否为空，实现根据参数动态生成SQL语句。</p>
<p>update标签包含的属性和insert标签基本一致，这里不再重复解释。</p>
<h4 id="4-delete"><a href="#4-delete" class="headerlink" title="4. delete"></a>4. delete</h4><p>delete标签用来映射删除语句。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> &gt;</span></span><br><span class="line">    DELETE FROM</span><br><span class="line">    student</span><br><span class="line">    WHERE</span><br><span class="line">    id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>delete标签包含的属性如表8-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111647559.png" alt="image-20231011164732401"></p>
<p>delete标签除了少了useGeneratedKeys、keyProperty和keyColumn三个属性之外，其余的和insert、update标签一样。</p>
<h3 id="8-3-3-结果映射"><a href="#8-3-3-结果映射" class="headerlink" title="8.3.3　结果映射"></a>8.3.3　结果映射</h3><p>结果映射是MyBatis重要的功能之一。对于简单的SQL查询，使用resultType属性自动将结果转换成Java数据类型。不过，如果是复杂的语句，则使用resultMap映射将查询结果转换为数据实体关系。</p>
<h4 id="1-resultType"><a href="#1-resultType" class="headerlink" title="1. resultType"></a>1. resultType</h4><p>前面介绍select标签的时候提到，select标签的返回结果可以使用resultMap和resultType两个属性指定映射结构。下面就来演示resultType的用法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.weiz. example01.model.Student&quot;</span>&gt;</span></span><br><span class="line">  select *</span><br><span class="line">  from student</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置resultType属性，MyBatis会自动把查询结果集转换为Student实体对象。当然，如果只查询部分字段，则可以返回HashMap，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span>&gt;</span></span><br><span class="line">    select name,age from student where id = #&#123;id&#125;</span><br><span class="line">&lt;/select &gt;</span><br></pre></td></tr></table></figure>
<p>上述语句，Mybatis会自动将所有的列映射成HashMap对象。</p>
<h4 id="2-resultMap"><a href="#2-resultMap" class="headerlink" title="2. resultMap"></a>2. resultMap</h4><p>在日常开发过程中，在大部分情况下resultType就能满足。但是使用resultType需要数据库字段和属性字段名称一致，否则就得使用别名，这样就使得SQL语句变得复杂。</p>
<p>所以MyBatis提供了resultMap标签定义SQL查询结果字段与实体属性的映射关系。下面演示resultMap的使用。</p>
<p>首先，定义resultMap：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用resultMap标签定义了BaseResultMap映射关系，将数据库中的字段映射为Student实体对象。</p>
<p>然后，在SQL语句中使用自定义的BaseResultMap映射关系，设置select标签的resultMap=”BaseResultMap”，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    *</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将之前的resultType改为resultMap=”BaseResultMap”。</p>
<h4 id="3-resultMap的结构"><a href="#3-resultMap的结构" class="headerlink" title="3. resultMap的结构"></a>3. resultMap的结构</h4><p>resultMap标签的结构比较复杂，包含很多子属性和子标签。resultMap标签包含id和type属性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id定义该resultMap的唯一标识。</span><br><span class="line">type为返回值的类名。</span><br></pre></td></tr></table></figure>
<p>同样，resultMap还可以包含多个子标签，包括：</p>
<p>1）id标签用于设置主键字段与领域模型属性的映射关系，此处主键为id，对应数据库字段中的主键ID。2）result标签用于设置普通字段与领域模型的属性映射关系。</p>
<p>3）association标签用于配置一对一结果映射，可以关联resultMap中的定义，或者对其他结果映射的引用。</p>
<p>4）collection标签用于配置一对多结果映射，可以关联resultMap中的定义，或者对其他结果映射的引用。</p>
<p>下面是完整的resultMap元素的结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentAndClassMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--association 用户关系映射 查询单个完整对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;classes&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.weiz.example01.model.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;class_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;memo&quot;</span> <span class="attr">property</span>=<span class="string">&quot;memo&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-4-关联关系"><a href="#8-3-4-关联关系" class="headerlink" title="8.3.4　关联关系"></a>8.3.4　关联关系</h3><p>前面介绍了resultMap结果映射，MyBatis通过resultMap标签自动将查询结果集转换成数据实体类。但是多表关联出来的复杂结果该怎么映射呢？这就需要通过collection标签和association标签配置关联关系。</p>
<h4 id="1-association（一对一）"><a href="#1-association（一对一）" class="headerlink" title="1. association（一对一）"></a>1. association（一对一）</h4><p>association通常用来映射一对一的关系，比如一个学生（Student）对应一个班级（Classes），一个学生只能属于一个班级。下面以学生和班级为例来演示association标签配置一对一关联关系。</p>
<p>步骤01 在数据库中创建班级表Classes，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;Classes&#x27;</span> (</span><br><span class="line">  <span class="string">&#x27;id&#x27;</span> <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="string">&#x27;createtime&#x27;</span> <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="string">&#x27;memo&#x27;</span> <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<h4 id="2-collection（一对多）"><a href="#2-collection（一对多）" class="headerlink" title="2. collection（一对多）"></a>2. collection（一对多）</h4><h3 id="8-3-5-SQL代码片段"><a href="#8-3-5-SQL代码片段" class="headerlink" title="8.3.5　SQL代码片段"></a>8.3.5　SQL代码片段</h3><p>当多个SQL语句中存在相同的部分，可以将其定义为公共的SQL代码片段。MyBatis提供了sql和include标签来定义和引用SQL代码片段。这样调用方便、SQL整洁。比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    id,name,age,sex</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过sql标签定义可以重新使用的SQL代码片段Base_Column_List，然后在SQL语句中引用Base_Column_List，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    FROM student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用include标签引用定义的Base_Column_List代码片段。</p>
<p>当然，sql标签也支持传入参数。我们对上面的示例进行修改：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    $&#123;alias_s&#125;.id,$&#123;alias_s&#125;.name,$&#123;alias_s&#125;.age,$&#123;alias_s&#125;.sex</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过${}定义查询表的别名作为传入参数。当引用此代码片段时，可以传入表的别名，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias_s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stu&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    FROM student stu</span><br><span class="line">    WHERE stu.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用include标签引用定义的SQL代码片段，并且通过property定义传入的参数。</p>
<h3 id="8-3-6-动态SQL拼接"><a href="#8-3-6-动态SQL拼接" class="headerlink" title="8.3.6　动态SQL拼接"></a>8.3.6　动态SQL拼接</h3><p>MyBatis提供了if、foreach、choose等标签动态拼接SQL语句，使用起来特别简单灵活。下面一一介绍这些标签的使用。</p>
<h4 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1. if标签"></a>1. if标签</h4><p>if标签通常用于WHERE语句中，通过判断参数值来决定是否使用某个查询条件，它也经常用于UPDATE语句中，用于判断是否更新某一个字段，还可以在INSERT语句中使用，用来判断是否插入某个字段的值，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentListLikeName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        where name like CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;),&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用if标签先进行判断，如果传入的参数值为null或等于空字符串，就不进行此条件的判断。</p>
<h4 id="2-foreach标签"><a href="#2-foreach标签" class="headerlink" title="2. foreach标签"></a>2. foreach标签</h4><p>foreach标签主要用于构建in条件，它可以在sql标签中对集合进行迭代。通常可以将其用到批量删除、添加等操作中。使用方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatch&quot;</span>&gt;</span></span><br><span class="line">　delete from student where id in</span><br><span class="line">　<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">　　　#&#123;id&#125;</span><br><span class="line">　<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">/delete&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过foreach标签将传入的id数组拼接成in(1,2,3)，实现批量删除的功能。</p>
<p>foreach标签包含如下几个属性：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">collection：有3个值，分别是list、array和map，分别对应Java中的类型为：List集合、Array和Map三种数据类型。示例中传的参数为数组，所以值为array。</span><br><span class="line">item：表示在迭代过程中每一个元素的别名。</span><br><span class="line">index：表示在迭代过程中每次迭代到的位置（下标）。</span><br><span class="line">open：前缀。</span><br><span class="line">close：后缀。</span><br><span class="line">separator：分隔符，表示迭代时每个元素之间以什么分隔。</span><br></pre></td></tr></table></figure>
<h4 id="3-choose标签"><a href="#3-choose标签" class="headerlink" title="3. choose标签"></a>3. choose标签</h4><p>MyBatis提供了choose标签，用于按顺序判断when中的条件是否成立，如果有一个成立，则choose结束。如果choose中的所有when条件都不满足，则执行otherwise中的SQL语句。类似于Java中的switch语句，choose为switch，when为case，otherwise为default。</p>
<p>Choose适用于从多个选项中选择一个条件的场景，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentListChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                 name like CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;),&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex! null &quot;</span>&gt;</span></span><br><span class="line">               AND sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age!=null&quot;</span>&gt;</span></span><br><span class="line">                AND age = #&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，把所有可以限制的条件都写上，匹配其中一个符合条件的拼接成where条件。</p>
<h3 id="8-3-7-格式化输出"><a href="#8-3-7-格式化输出" class="headerlink" title="8.3.7　格式化输出"></a>8.3.7　格式化输出</h3><p>MyBatis提供了where、set、trim等标签处理查询条件和update语句，使得在mapper.xml中拼接SQL语句变得非常简单高效，从而避免出错。</p>
<h4 id="1-where标签"><a href="#1-where标签" class="headerlink" title="1. where标签"></a>1. where标签</h4><p>MyBatis支持使用where标签动态拼接查询条件，如果where标签判断包含的标签中含有返回值，就在SQL语句中插入一个where。此外，如果标签返回的内容以AND或OR开头，则会自动去除，这样比我们手动拼接where条件简单许多。示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，like姓名，=性别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentListWhere&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">     select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            name like CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;),&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!= null &quot;</span>&gt;</span></span><br><span class="line">            AND sex= #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，如果参数name为null或’’，则不会生成这个条件，同时还会自动把后面多余的AND关键字去掉。这样就避免了手动判断的麻烦。</p>
<h4 id="2-set标签"><a href="#2-set标签" class="headerlink" title="2. set标签"></a>2. set标签</h4><p>与where标签类似，使用set标签可以为update语句动态配置set关键字，同时自动去除追加到条件末尾的任何逗号。使用方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">&lt;!-- 更新学生信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span>&gt;</span></span><br><span class="line">    update student</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!=null&quot;</span>&gt;</span></span><br><span class="line">            sex= #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age!=null &quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classes!=null and classes.id!=null&quot;</span>&gt;</span></span><br><span class="line">            class_id = #&#123;classes.class_id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span> &gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用了set和if标签，如果某个传入参数不为null，则生成该字段，无须额外处理末尾的逗号，整个update语句更加清晰简洁。</p>
<h4 id="3-trim标签"><a href="#3-trim标签" class="headerlink" title="3. trim标签"></a>3. trim标签</h4><p>trim标签的作用是在包含的内容前加上某些前缀，也可以在其后加上某些后缀，对应的属性是prefix和suffix；可以把内容首部的某些内容覆盖掉，即忽略，也可以把内容尾部的某些内容覆盖掉，对应的属性是prefixOverrides和suffixOverrides。</p>
<p>trim标签比Java中的trim方法功能还要强大。正因为trim有这样的功能，所以我们可以非常简单地利用trim来代替where元素的功能，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，like姓名，=性别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentListTrim&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.weiz.example01.model.Student&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span></span><br><span class="line">   select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND|OR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            name like CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;),&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!= null &quot;</span>&gt;</span></span><br><span class="line">            AND sex = #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看到，trim标签和where标签的功能类似，会自动去掉多余的AND或OR关键字。</p>
<p>trim标签与where标签或set标签不同的地方是，trim除了支持在首尾去除多余的字符外，还可以追加字符，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot; com.weiz.example01.model.Student&quot;</span>&gt;</span></span><br><span class="line">        insert into student</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                        id,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">                        name,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age!=null&quot;</span>&gt;</span></span><br><span class="line">                        age,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!=null&quot;</span>&gt;</span></span><br><span class="line">                        sex,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">                        #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age!=null&quot;</span>&gt;</span></span><br><span class="line">                        #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!=null&quot;</span>&gt;</span></span><br><span class="line">                        #&#123;sex,jdbcType=INTEGER&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用trim标签生成insert语句，通过prefix和suffix属性在首尾加上“(”和“)”，同时通过suffixOverrides属性去掉拼接字段时多余的“,”。这样省去了很多判断，使得insert语句非常简单清晰。</p>
<h2 id="8-4-使用MyBatis注解实现数据库操作"><a href="#8-4-使用MyBatis注解实现数据库操作" class="headerlink" title="8.4　使用MyBatis注解实现数据库操作"></a>8.4　使用MyBatis注解实现数据库操作</h2><p>上一节我们在Spring Boot项目中集成了MyBatis，使用XML配置文件实现了数据的增、删、改、查操作以及自动生成插件的使用。MyBatis还提供了注解的方式，相比XML的方式，注解的方式更加简单方便，无须创建XML配置文件。接下来好好研究注解的使用方式。</p>
<h3 id="8-4-1-XML和注解的异同"><a href="#8-4-1-XML和注解的异同" class="headerlink" title="8.4.1　XML和注解的异同"></a>8.4.1　XML和注解的异同</h3><p>自Java 1.5引入注解开始，注解就被广泛地应用在各种开源软件中，使用注解大大地降低了系统中的配置项，让代码变得更加简洁、优雅。MyBatis也顺应潮流，推出了基于注解的数据库操作方式，避免开发过程中频繁切换到XML或者Java代码中，从而让开发者使用MyBatis有统一的开发体验。</p>
<p>MyBatis在最初设计时是一个XML驱动的框架，配置信息和映射文件都是基于XML的，而到了MyBatis 3，就有了新的选择。注解模式为使用MyBatis提供了一种更加简单的SQL语句映射，而不会造成大量的开销。两种模式的区别如下：</p>
<p>1）注解模式使用简单，开发效率高，但是维护麻烦，修改SQL需要重新编译打包。</p>
<p>2）XML模式便于维护，SQL和代码分开，代码清晰易懂，而使用注解模式需要在方法前加各种注解和SQL语句，使得代码的可读性不强。</p>
<p>3）XML模式虽然提供了完善的标签来实现复杂的SQL语句，但是没有在Java代码中直接判断拼接那样简单方便。</p>
<p>4）XML模式因为SQL是配置在XML文件中的，某些特殊字符需要转义，所以使用起来比较麻烦，容易出错。</p>
<p>两种模式各有特点，注解模式适合简单快速的模式，在微服务架构中，一般微服务都有自己对应的数据库，多表连接查询的需求会大大降低，非常适合注解模式。而XML模式比较适合大型项目，可以灵活地动态生成SQL，方便调整SQL。在具体开发过程中，可以根据公司业务和团队技术基础进行选择。</p>
<h3 id="8-4-2-使用MyBatis注解实现数据查询"><a href="#8-4-2-使用MyBatis注解实现数据查询" class="headerlink" title="8.4.2　使用MyBatis注解实现数据查询"></a>8.4.2　使用MyBatis注解实现数据查询</h3><p>MyBatis注解模式的最大特点是取消了Mapper的XML配置，通过@Insert、、@Update、@Select、@Delete等注解将SQL语句定义在Mapper接口方法中或SQLProvider的方法中，从而省去了XML配置文件。这些注解和参数的使用与mapper.xml配置文件基本一致。下面就来演示使用MyBatis注解实现数据查询。</p>
<h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p>首先创建Spring Boot项目，集成MyBatis的过程与XML配置方式一样。</p>
<p>使用注解方式只需要在application.properties中指明实体类的包路径，其他保持不变，配置示例如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mapper.xml mapper接口的包路径</span></span><br><span class="line"><span class="attr">MyBatis.type-aliases-package</span>=<span class="string">com.weiz.example01</span></span><br><span class="line"><span class="comment"># 数据库连接</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/MyBatis_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，配置了mapper接口的包路径和数据源，无须配置mapper.xml文件的路径。</p>
<h4 id="2-添加mapper接口"><a href="#2-添加mapper接口" class="headerlink" title="2. 添加mapper接口"></a>2. 添加mapper接口</h4><p>使用MyBatis提供的SQL语句注解无须再创建mapper.xml映射文件，创建mapper接口类，然后添加相关的方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from student&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Select注解定义SQL查询语句即可实现查询所有学生列表的功能，无须再定义mapper.xml映射文件。是不是更加简单？</p>
<h4 id="3-验证测试"><a href="#3-验证测试" class="headerlink" title="3. 验证测试"></a>3. 验证测试</h4><p>增加单元测试方法，验证是否生效。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    List&lt;Student&gt; students = studentMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Student stu : students)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot;,age:&quot;</span>+stu.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单击Run Test或在方法上右击，选择Run ‘testSelectAll’，查看单元测试结果，运行结果如图8-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111719118.png" alt="image-20231011171941945"></p>
<p>结果表明单元测试方法testSelectAll运行成功，并输出了相应的查询结果。这说明使用注解成功实现了查询全部学生信息的功能。</p>
<h3 id="8-4-3-参数传递"><a href="#8-4-3-参数传递" class="headerlink" title="8.4.3　参数传递"></a>8.4.3　参数传递</h3><p>相信很多人会有疑问：MyBatis是如何将参数传递到SQL中的，有哪几种传参方式？下面就来一一介绍MyBatis注解的传参方式。</p>
<h4 id="1-直接传参"><a href="#1-直接传参" class="headerlink" title="1. 直接传参"></a>1. 直接传参</h4><p>对于简单的参数，可以直接使用#{id}的方式接收同名的变量参数。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from student where id=#&#123;id,jdbcType=VARCHAR&#125;&quot;)</span></span><br><span class="line">Student <span class="title function_">selectOne</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用#{id}传入变量参数，支持传入多个参数。只是需要注意，使用#{}方式定义的参数名必须和方法中的参数名保持一致。</p>
<h4 id="2-使用-Param注解"><a href="#2-使用-Param注解" class="headerlink" title="2. 使用@Param注解"></a>2. 使用@Param注解</h4><p>@Param注解的作用是给参数命名，参数命名后就能根据名字匹配到参数值，正确地将参数传入SQL语句中。比如，注解是@Param(“person”)，那么参数就会被命名为#{person}。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from student where name=#&#123;name&#125; and sex=#&#123;sex&#125;&quot;)</span></span><br><span class="line">Student <span class="title function_">selectByNameAndSex</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name,<span class="meta">@Param(&quot;sex&quot;)</span>Integer sex)</span>;</span><br></pre></td></tr></table></figure>
<p>如果方法有多个参数，也可以不自定义param，MyBatis在方法的参数上就能为它们取自定义的名字，参数先以”param”作为前缀，再加上它们的参数位置作为参数别名，比如#{param1}、#{param2}。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用param +参数序号或者0、1，值就是参数的值</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM student WHERE name = #&#123;param1&#125; and sex = #&#123;param2&#125;&quot;)</span></span><br><span class="line">Student <span class="title function_">selectByNameAndSex</span><span class="params">(String name, Integer sex)</span>;</span><br></pre></td></tr></table></figure>
<p>如果不想给每个参数命名，可以使用param参数，默认格式为param+参数序号或者0、1，值就是参数的值。</p>
<h4 id="3-映射传值"><a href="#3-映射传值" class="headerlink" title="3. 映射传值"></a>3. 映射传值</h4><p>需要传送多个参数时，也可以考虑使用映射（Map）的形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM student WHERE name = #&#123;name&#125; and sex = #&#123;sex&#125;&quot;)</span></span><br><span class="line">Student <span class="title function_">selectByNameAndSex</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将SQL语句需要的参数通过map类型传入，key为参数名，value为参数值。MyBatis会自动匹配对应的映射中的参数值。</p>
<p>调用时将参数依次加入映射中即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map param= <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">param.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">param.put(<span class="string">&quot;sex&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectByNameAndSex(param);</span><br></pre></td></tr></table></figure>
<p>对于参数较多的方法，使用映射还是比较方便的。</p>
<h4 id="4-使用pojo对象"><a href="#4-使用pojo对象" class="headerlink" title="4. 使用pojo对象"></a>4. 使用pojo对象</h4><p>使用pojo对象传参是比较常用的传参方式，像前面介绍的insert、update等方法，都是直接传入user对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;</span></span><br><span class="line"><span class="meta">    &quot;update student&quot;,</span></span><br><span class="line"><span class="meta">    &quot;set name = #&#123;name,jdbcType=VARCHAR&#125;,&quot;,</span></span><br><span class="line"><span class="meta">    &quot;age = #&#123;age,jdbcType=INTEGER&#125;,&quot;,</span></span><br><span class="line"><span class="meta">    &quot;sex = #&#123;sex,jdbcType=INTEGER&#125;&quot;,</span></span><br><span class="line"><span class="meta">    &quot;where id = #&#123;id,jdbcType=VARCHAR&#125;&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student record)</span>;</span><br></pre></td></tr></table></figure>
<p>对于insert、update等参数较多的方法，可以使用pojo对象传参。需要注意的是，参数的名字和类型必须和pojo对象的属性保持一致。</p>
<p>上面讲述了MyBatis传参的4种方式，使用时根据方法的参数来选择合适的传值方式即可。</p>
<h3 id="8-4-4-结果映射"><a href="#8-4-4-结果映射" class="headerlink" title="8.4.4　结果映射"></a>8.4.4　结果映射</h3><p>MyBatis会自动将查询结果集转换为需要返回的数据类型，但是有些特殊的场景需要处理，比如查询的返回结果与期望的数据格式不一致时，应该怎么处理呢？</p>
<p>这就需要使用@Results和@Result注解。这两个注解可以将数据库中查询到的数值转化为具体的属性或类型，修饰返回的结果集，比如查询的对象返回值属性名和字段名不一致，或者对象的属性中使用了枚举等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&#123;</span></span><br><span class="line"><span class="meta">    &quot;select&quot;,</span></span><br><span class="line"><span class="meta">    &quot;id, name as student_name,age, sex as student_sex&quot;,</span></span><br><span class="line"><span class="meta">    &quot;from student&quot;,</span></span><br><span class="line"><span class="meta">    &quot;where id = #&#123;id,jdbcType=VARCHAR&#125;&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;id&quot;, property=&quot;id&quot;, jdbcType= JdbcType.VARCHAR, id=true),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;student_name&quot;, property=&quot;name&quot;, jdbcType=JdbcType.VARCHAR),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;student_sex&quot;, property=&quot;sex&quot;, jdbcType=JdbcType.TIMESTAMP)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Student <span class="title function_">selectById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，查询结果集的student_name字段和实体类Student定义的name属性的名称不一致，所以需要Result进行转换；而age名称是一致的，所以不需要Result进行转换。</p>
<h2 id="8-5-动态SQL和分页"><a href="#8-5-动态SQL和分页" class="headerlink" title="8.5　动态SQL和分页"></a>8.5　动态SQL和分页</h2><p>上一节介绍了使用注解方式实现数据操作、参数传递方式以及结果映射等常用功能。然而在实际项目中，除了这些常用的增、删、改、查功能外，可能还会需要动态拼接SQL、分页查询、多数据源配置等复杂的功能。接下来介绍这些复杂且非常重要的功能。</p>
<h3 id="8-5-1-动态SQL语句"><a href="#8-5-1-动态SQL语句" class="headerlink" title="8.5.1　动态SQL语句"></a>8.5.1　动态SQL语句</h3><p>在实际项目开发中，除了使用一些常用的增、删、改、查方法之外，也会遇到复杂的业务需求，可能需要执行一些自定义的动态SQL语句。我们知道XML配置可以使用if、choose、where等标签动态拼接SQL语句，那么使用注解方式如何实现呢？</p>
<p>MyBatis除了提供@Insert、@Delete这些常用的注解外，还提供了@InsertProvider、@UpdateProvider、@DeleteProvider和@SelectProvider等注解用来建立动态SQL语句。下面以按字段更新来演示动态SQL的功能。</p>
<h3 id="8-5-2-分页查询"><a href="#8-5-2-分页查询" class="headerlink" title="8.5.2　分页查询"></a>8.5.2　分页查询</h3><p>分页查询是日常开发中比较常用的功能。MyBatis框架下也有很多插件实现分页功能，比如pageHelper。这是一款非常简单、易用的分页插件，能很好地集成在Spring Boot中。pageHelper是一款基于MyBatis的数据库分页插件，所以我们在使用它时需要使用MyBatis作为持久层框架。下面通过示例演示pageHelper实现分页查询。</p>
<h4 id="1-添加pageHelper依赖"><a href="#1-添加pageHelper依赖" class="headerlink" title="1. 添加pageHelper依赖"></a>1. 添加pageHelper依赖</h4><p>修改pom.xml文件，添加pageHelper依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>pageHelper提供了针对Spring Boot框架的依赖库pagehelper-spring-boot-starter，对于Spring Boot项目可以使用pagehelper-spring-boot-starter组件。</p>
<h4 id="2-增加pageHelper配置"><a href="#2-增加pageHelper配置" class="headerlink" title="2. 增加pageHelper配置"></a>2. 增加pageHelper配置</h4><p>在application.properties中增加pageHelper配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分页框架</span></span><br><span class="line"><span class="attr">pagehelper.helperDialect</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">pagehelper.reasonable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">pagehelper.supportMethodsArguments</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">pagehelper.params</span>=<span class="string">count=countSql</span></span><br></pre></td></tr></table></figure>
<p>上面的示例是pageHelper分页框架的初始配置，主要用于指定数据库类型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helperDialect：指定数据库类型，可以不配置，pageHelper插件会自动检测数据库的类型。</span><br><span class="line">reasonable：分页合理化参数，默认为false，当该参数设置为true时，当pageNum≤0时，默认显示第一页，	当pageNum超过pageSize时，显示最后一页。</span><br><span class="line">supportMethodsArguments：分页插件会根据查询方法的参数，自动在params配置的字段中取值，找到合适的	值会自动分页。</span><br><span class="line">params：用于从对象中根据属性名取值，可以配置pageNum、pageSize，count不用配置映射的默认值。</span><br></pre></td></tr></table></figure>
<h4 id="3-调用测试"><a href="#3-调用测试" class="headerlink" title="3. 调用测试"></a>3. 调用测试</h4><p>增加单元测试方法，验证分页功能是否生效。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectListPaged</span><span class="params">()</span> &#123;</span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    List&lt;Student&gt; students = studentMapper.selectAll();</span><br><span class="line">    PageInfo&lt;Student&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;Student&gt;(students);</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数:&quot;</span>+pageInfo.getPages()+<span class="string">&quot;,总条数:&quot;</span>+pageInfo.getTotal()+<span class="string">&quot;,当前页:&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">    <span class="keyword">for</span> (Student stu : students)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot;,age:&quot;</span>+stu.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，分页的核心只有一行代码，PageHelper.startPage(page,pageSize);就标识开始分页。添加此行代码之后，pageHelper插件会通过其内部的拦截器将执行的SQL语句转化为分页的SQL语句。</p>
<p>单击Run Test或在方法上右击，选择Run ‘testSelectListPaged’，查看单元测试结果，运行结果如图8-11所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111753547.png" alt="image-20231011175327337"></p>
<p>结果表明单元测试方法运行成功，控制台输出了当前页的数据列表、总页数、数据总条数和当前页。这说明使用pageHelper插件成功实现了分页功能。</p>
<p>使用时PageHelper.startPage(pageNum, pageSize)一定要放在列表查询的方法中，这样在查询时会查出相应的数据量以及总数。</p>
<h3 id="8-5-3-多数据源配置"><a href="#8-5-3-多数据源配置" class="headerlink" title="8.5.3　多数据源配置"></a>8.5.3　多数据源配置</h3><p>在很多应用场景下，我们需要在一个项目中配置多个数据源来实现业务逻辑，比如现有电商业务、商品和库存数据分别放在不同的数据库中，这就要求我们的系统架构支持同时配置多个数据源实现相关业务操作。那么Spring Boot如何应对这种多数据源的场景呢？其实，在Spring Boot项目中配置多数据源十分便捷。接下来介绍Spring Boot集成MyBatis实现多数据源的相关配置。</p>
<h4 id="1-配置数据源"><a href="#1-配置数据源" class="headerlink" title="1. 配置数据源"></a>1. 配置数据源</h4><p>在系统配置文件中配置多个数据源，即在application.properties文件中增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyBatis多数据源配置</span></span><br><span class="line"><span class="comment"># 数据库1的配置</span></span><br><span class="line"><span class="attr">spring.datasource.test1.driver-class-name</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.test1.jdbc-url</span> = <span class="string">jdbc:mysql://localhost:3306/MyBatis_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">spring.datasource.test1.username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.test1.password</span> = <span class="string">root</span></span><br><span class="line"><span class="comment"># 数据库2的配置</span></span><br><span class="line"><span class="attr">spring.datasource.test2.driver-class-name</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.test2.jdbc-url</span> = <span class="string">jdbc:mysql://localhost:3306/MyBatis2_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">spring.datasource.test2.username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.test2.password</span> = <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，配置的是两个一样的数据库MyBatis_test和MyBatis2_test。连接数据库的配置使用的是jdbc-url，而不是之前的url，这一点需要注意。</p>
<h4 id="2-自定义数据源配置类"><a href="#2-自定义数据源配置类" class="headerlink" title="2. 自定义数据源配置类"></a>2. 自定义数据源配置类</h4><p>1）在config包中创建DataSource1Config类，此类用于配置主数据源。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.weiz.example01.mapper.test1&quot;, sqlSessionFactoryRef = &quot;test1SqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSource1Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;test1DataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.test1&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">testDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test1SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">testSqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test1TransactionManager&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">testTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test1SqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;test1SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，配置主数据源需要添加@Primary注解，其他普通数据源不能加这个注解，否则会报错。</p>
<p>2）在config包中创建DataSource2Config类，此类用于配置其他普通数据源。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.weiz.example01.mapper.test2&quot;, sqlSessionFactoryRef = &quot;test2SqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSource2Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;test2DataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">testDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test2SqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">testSqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;test2DataSource&quot;)</span> DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test2TransactionManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">testTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;test2DataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;test2SqlSessionTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">testSqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;test2SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，DataSource2Config是普通数据源配置类。可以看到两个数据源都配置了各自的DataSource、SqlSessionFactory、TransactionManager和SqlSessionTemplate。</p>
<p>两个数据源通过配置basePackages扫描mapper包路径，匹配对应的mapper包。配置时需要注意，配置错了不会出现异常，但是运行时会找错数据库。</p>
<h4 id="3-创建Mapper"><a href="#3-创建Mapper" class="headerlink" title="3. 创建Mapper"></a>3. 创建Mapper</h4><p>创建com.weiz.example01.mapper.test1和com.weiz.example01.mapper.test2包，将之前的StudentMapper分别重命名为PrimaryStudentMapper和SecondaryStudentMapper并复制到相应的包中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrimaryStudentMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from student&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;</span></span><br><span class="line"><span class="meta">            &quot;insert into student (&quot;,</span></span><br><span class="line"><span class="meta">            &quot;name, &quot;,</span></span><br><span class="line"><span class="meta">            &quot;age, &quot;,</span></span><br><span class="line"><span class="meta">            &quot;sex)&quot;,</span></span><br><span class="line"><span class="meta">            &quot;values (&quot;,</span></span><br><span class="line"><span class="meta">            &quot;#&#123;name,jdbcType=VARCHAR&#125;,&quot;,</span></span><br><span class="line"><span class="meta">            &quot;#&#123;age,jdbcType=INTEGER&#125;,&quot;,</span></span><br><span class="line"><span class="meta">            &quot;#&#123;sex,jdbcType=INTEGER&#125;)&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Student record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例为Primary数据库操作。SecondaryStudentMapper与PrimaryStudentMapper的代码基本一致。</p>
<h4 id="4-调用测试"><a href="#4-调用测试" class="headerlink" title="4. 调用测试"></a>4. 调用测试</h4><p>增加单元测试方法，验证多数据源的操作是否生效。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMultiDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    primaryStudentMapper.insert(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz primary&quot;</span>, <span class="number">1</span>, <span class="number">30</span>));</span><br><span class="line">    secondaryStudentMapper.insert(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;weiz secondary&quot;</span>, <span class="number">1</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    System.out.println(<span class="string">&quot;primary 库:&quot;</span>);</span><br><span class="line">    List&lt;Student&gt; studentsPrimary = primaryStudentMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Student stu : studentsPrimary)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot;,age:&quot;</span>+stu.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;secondary 库:&quot;</span>);</span><br><span class="line">    List&lt;Student&gt; studentsSecondary = primaryStudentMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Student stu : studentsSecondary)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+stu.getName()+<span class="string">&quot;,age:&quot;</span>+stu.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，分别往两个数据库中写入学生信息数据，然后执行查询，从而验证多数据源操作是否生效。</p>
<p>单击Run Test或在方法上右击，选择Run ‘testMultiDataSource’，查看单元测试结果，运行结果如图8-12所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111802599.png" alt="image-20231011180225425"></p>
<p>结果表明单元测试方法运行成功，通过控制台的输出可以看到，系统启动时创建了两个数据源连接，并且MyBatis_test和MyBatis2_test数据插入、查询都正常。这说明多数据源配置成功。</p>
<h1 id="第9章-认识JPA"><a href="#第9章-认识JPA" class="headerlink" title="第9章　认识JPA"></a>第9章　认识JPA</h1><p>JPA（Java Persistence API，Java持久层API）是Spring Boot体系中“约定优于配置”的最佳实现，它大大简化了项目中数据库的操作。本章将主要介绍Spring Data JPA的使用。使用JPA会感觉它简直就是神器，几乎不需要编写任何关于数据库访问的代码就能轻松完成一个基本的增、删、改、查功能模块。接下来将从JPA的由来开始讲解，了解JPA、Spring Boot JPA的实现、JPA实现查询、JPA复杂查询、实体关系映射等。</p>
<h2 id="9-1-JPA入门"><a href="#9-1-JPA入门" class="headerlink" title="9.1　JPA入门"></a>9.1　JPA入门</h2><p>本节从基础的概念开始介绍JPA的由来、JPA是什么，然后介绍Spring Boot是如何支持JPA的，最后通过示例讲述在Spring Boot中使用JPA。</p>
<h3 id="9-1-1-JPA简介"><a href="#9-1-1-JPA简介" class="headerlink" title="9.1.1　JPA简介"></a>9.1.1　JPA简介</h3><h4 id="1-JPA是什么"><a href="#1-JPA是什么" class="headerlink" title="1. JPA是什么"></a>1. JPA是什么</h4><p>JPA是Sun官方提出的Java持久化规范，它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据，通过注解或者XML描述“对象-关系表”之间的映射关系，并将实体对象持久化到数据库中，极大地简化现有的持久化开发工作以及集成ORM技术。</p>
<p>JPA不是一种新的ORM框架，它的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。它是一套规范而不是产品，而像Hibernate、TopLink等产品实现了JPA规范，我们就可以称它们为JPA的实现产品，关系如图9-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111803292.png" alt="image-20231011180358116"></p>
<p>总体来说，ORM是一种思想，JPA（Java Persistence API）是对这种思想进行规范，也就是一套标准（接口和抽象类），Hibernate和TopLink等产品则通过实现JPA规范实现数据持久化的框架，通过JPA规范使得所有的数据持久化框架达到统一、规范，减少开发者的学习成本。</p>
<h4 id="2-JPA能做什么"><a href="#2-JPA能做什么" class="headerlink" title="2. JPA能做什么"></a>2. JPA能做什么</h4><p>JPA是在充分吸收了现有的Hibernate、TopLink、JDO等ORM框架的基础上发展而来的，具有易于使用、伸缩性强等优点。总的来说，JPA包括以下3方面的技术</p>
<p>1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p>
<p>2）Java持久化API：用来操作实体对象，执行增、删、改、查（CRUD）操作，框架在后台替代我们完成所有的事情，将开发者从烦琐的JDBC和SQL代码中解脱出来。</p>
<p>3）查询语言（JPQL）：这是持久化操作中重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p>
<p>JPA解放了我们对数据库的操作，使得开发者不再需要关心数据库的表结构，需要更改的时候只需要修改对应实体类的属性即可。在微服务架构中，服务拆分得越来越细，微服务内部只需要关心自身的业务，不需要我们过多关注数据库。因此，在微服务架构中更推荐使用JPA技术。</p>
<h3 id="9-1-2-Spring-Data对JPA的支持"><a href="#9-1-2-Spring-Data对JPA的支持" class="headerlink" title="9.1.2　Spring Data对JPA的支持"></a>9.1.2　Spring Data对JPA的支持</h3><p>Spring Data JPA是Spring在ORM框架、JPA规范的基础上封装的一套JPA应用框架。从名字就可以看出，它是Spring Data家族的一部分，旨在让开发者用极简的代码实现复杂的数据操作，使得构建Spring应用程序变得更加容易。</p>
<p>在相当长的一段时间内，实现应用程序的数据访问一直很麻烦，必须编写大量的SQL代码来执行数据查询、更新等操作。使用Spring Data JPA开发人员只需要编写repository接口和自定义查找器方法，其他的SQL语句由Spring自动提供，使得开发者从烦琐的JDBC和SQL代码中解脱出来。</p>
<p>虽然主流的ORM框架都实现了JPA规范，但是在不同ORM框架之间切换需要编写各自的代码，而通过使用Spring Data Jpa能够方便开发者在不同的ORM框架之间进行切换而无需要更改任何代码。这样方便开发者在Spring Boot项目中使用JPA技术，具体关系如图9-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111806482.png" alt="image-20231011180622948"></p>
<h2 id="9-2-在Spring-Boot项目中使用JPA"><a href="#9-2-在Spring-Boot项目中使用JPA" class="headerlink" title="9.2　在Spring Boot项目中使用JPA"></a>9.2　在Spring Boot项目中使用JPA</h2><p>既然Spring Data JPA有着众多优点，又是当前开发趋势中的主流工具，接下来我们就一步一步地在Spring Boot项目中集成并使用JPA。</p>
<h3 id="9-2-1-集成Spring-Data-JPA"><a href="#9-2-1-集成Spring-Data-JPA" class="headerlink" title="9.2.1　集成Spring Data JPA"></a>9.2.1　集成Spring Data JPA</h3><p>Spring Boot提供了启动器spring-boot-starter-data-jpa，只需要添加启动器（Starters）就能实现在项目中使用JPA。下面一步一步演示集成Spring Data JPA所需的配置。</p>
<p>步骤01 添加JPA依赖</p>
<p>首先创建新的Spring Boot项目，在项目的pom.xml中增加JPA相关依赖，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，除了引用spring-boot-starter-data-jpa之外，还需要依赖MySQL驱动mysql-connector-java。</p>
<p>步骤02 添加配置文件。</p>
<p>在application.properties中配置数据源和JPA的基本相关属性，具体代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库连接</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/jpa_test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># JPA配置</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">create</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br><span class="line"><span class="comment"># SQL输出</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># format 下SQL输出</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.format_sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>在上面的参数中，主要是配置数据库的连接以及JPA的属性。下面重点分析一下JPA中的4个配置。</p>
<p>1）spring.jpa.properties.hibernate.hbm2ddl.auto：该配置比较常用，配置实体类维护数据库表结构的具体行为。当服务首次启动时会在数据库中生成相应的表，后续启动服务时，如果实体类有增加属性就会在数据中添加相应字段，原来的数据仍然存在。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update：常用的属性，表示当实体类的属性发生变化时，表结构跟着更新。</span><br><span class="line">create：表示启动时删除上一次生成的表，并根据实体类重新生成表，之前表中的数据会被清空。</span><br><span class="line">create-drop：表示启动时根据实体类生成表，但是当sessionFactory关闭时表会被删除。</span><br><span class="line">validate：表示启动时验证实体类和数据表是否一致。none：什么都不做。</span><br></pre></td></tr></table></figure>
<p>2）spring.jpa.show-sql：表示hibernate在操作时在控制台打印真实的SQL语句，便于调试。</p>
<p>3）spring.jpa.properties.hibernate.format_sql：表示格式化输出的JSON字符串，便于查看。</p>
<p>4）spring.jpa.properties.hibernate.dialect：指定生成表名的存储引擎为InnoDB。</p>
<p>步骤03 添加实体类。</p>
<p>首先，创建User实体类，它是一个实体类，同时也是定义数据库中的表结构的类，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;Users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(length = 64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(length = 64)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String password, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用@Table注解映射数据库中的表，使用@Column注解映射数据库中的字段。具体说明如下：</p>
<p>1）@Entity：必选的注解，声明这个类对应了一个数据库表。</p>
<p>2）@Table：可选的注解，声明了数据库实体对应的表信息，包括表名称、索引信息等。这里声明这个实体类对应的表名是Users。如果没有指定，则表名和实体的名称保持一致，与@Entity注解配合使用。</p>
<p>3）@Id注解：声明了实体唯一标识对应的属性。</p>
<p>4）@Column注解：用来声明实体属性的表字段的定义。默认的实体每个属性都对应表的一个字段，字段名默认与属性名保持一致。字段的类型根据实体属性类型自动对应。这里主要声明了字符字段的长度，如果不这么声明，则系统会采用255作为该字段的长度。</p>
<p>5）@GeneratedValue注解：设置数据库主键自动生成规则。strategy属性提供4种值：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AUTO：主键由程序控制，是默认选项。</span><br><span class="line">IDENTITY：主键由数据库自动生成，即采用数据库ID自增长的方式，Oracle不支持这种方式。</span><br><span class="line">SEQUENCE：通过数据库的序列产生主键，通过@SequenceGenerator注解指定序列名，MySQL不支持这种方式。</span><br><span class="line">TABLE：通过特定的数据库表产生主键，使用该策略可以使应用更易于数据库移植。</span><br></pre></td></tr></table></figure>
<p>除了上面使用到的@Entity注解、@Table注解等之外，还有一些常用的实体注解，具体说明如表9-1所示。这些注解用于描述实体对象与数据库字段的对应关系，需要注意的是，JPA与MyBatis是有区别的，千万别混淆。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111812245.png" alt="image-20231011181215058"></p>
<p>步骤04 测试验证。</p>
<p>以上几步就是集成JPA的全部配置，配置完之后启动项目，就可以看到日志中显示如图9-3所示的内容。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111812526.png" alt="image-20231011181239343"></p>
<p>由图9-3可知，系统启动后自动连接数据库，创建数据表结构，并打印出执行的SQL语句。如果查看数据库，可以看到数据库中对应的Users表也创建成功了，说明项目已经成功集成JPA并创建实体表。</p>
<h3 id="9-2-2-JpaRepository简介"><a href="#9-2-2-JpaRepository简介" class="headerlink" title="9.2.2　JpaRepository简介"></a>9.2.2　JpaRepository简介</h3><p>JpaRepository是Spring Data JPA中非常重要的类。它继承自Spring Data的统一数据访问接口——Repository，实现了完整的增、删、改、查等数据操作方法。JpaRepository提供了30多个默认方法，基本能满足项目中的数据库操作功能，如图9-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111818780.png" alt="image-20231011181851557"></p>
<p>我们可以通过IntelliJ IDEA查看JpaRepository的类图结构，打开类JpaRepository并右击，在弹出的快捷菜单中选择show diagrams命令，用图表的方式查看类的关系层次，如图9-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310111819830.png" alt="image-20231011181904574"></p>
<p>JpaRepository是实现Spring Data JPA技术访问数据库的关键接口。JpaRepository继承自PagingAndSortingRepository接口，而PagingAndSortingRepository接口继承自CrudRepository接口。CrudRepository和Repository接口则是Spring Data底层通用的接口，定义了几乎所有的数据库接口方法，统一了数据访问的操作。</p>
<p>另外，JPA提供了非常完善的数据查询功能，包括自定义查询、自定义SQL、已命名查询等多种数据查询方式。</p>
<h3 id="9-2-3-实战：实现人员信息管理模块"><a href="#9-2-3-实战：实现人员信息管理模块" class="headerlink" title="9.2.3　实战：实现人员信息管理模块"></a>9.2.3　实战：实现人员信息管理模块</h3><p>JpaRespository默认实现完整的增、删、改、查等数据操作。只需定义一个Repository数据访问接口并继承JpaRepository类即可。下面通过之前创建的User用户类和表实现用户的增、删、改、查功能来演示用户管理模块的实现。</p>
<h4 id="1-定义Repository"><a href="#1-定义Repository" class="headerlink" title="1. 定义Repository"></a>1. 定义Repository</h4><p>首先创建UserRepository接口并加上@Repository注解，然后继承JpaRepository类，不需要编写任何代码，即可实现人员信息管理模块的全部功能。具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRespository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到UserRepository虽然什么方法都没有定义，但是继承了JpaRepository之后，自然就拥有JpaRepository中的所有方法。</p>
<h4 id="2-实现新增、修改、删除、查询"><a href="#2-实现新增、修改、删除、查询" class="headerlink" title="2. 实现新增、修改、删除、查询"></a>2. 实现新增、修改、删除、查询</h4><p>（1）新增</p>
<p>接下来创建UserRepositoryTests单元测试类，并实现用户新增的测试方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;weiz&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">40</span>)</span><br><span class="line">userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在UserRepositoryTests单元测试类中注入UserRepository对象，然后使用JpaRespository预生成的save()方法实现人员数据保存的功能。</p>
<p>略</p>
<h2 id="9-3-简单查询"><a href="#9-3-简单查询" class="headerlink" title="9.3　简单查询"></a>9.3　简单查询</h2><h1 id="第10章-搞定定时任务"><a href="#第10章-搞定定时任务" class="headerlink" title="第10章　搞定定时任务"></a>第10章　搞定定时任务</h1><p>在项目开发过程中，经常需要定时任务来帮助我们实现某些业务功能，比如定时生成数据报表、生成对账单、订单超时处理等。Spring Boot提供了两种实现定时任务的方式：一种是Spring Boot内置的注解方式，只需在类上增加@Scheduled即可实现；另一种是基于Quartz实现，Quartz是目前完善的定时任务解决方案，适合处理复杂的应用场景。</p>
<h1 id="第11章-数据缓存Redis实现高并发"><a href="#第11章-数据缓存Redis实现高并发" class="headerlink" title="第11章　数据缓存Redis实现高并发"></a>第11章　数据缓存Redis实现高并发</h1><p>Redis是目前使用广泛的缓存服务，与Memcached等缓存中间件相比，Redis支持数据持久化，支持更多的数据结构和更丰富的数据操作，此外，Redis有着高可用的集群方案和广泛的应用场景。本章将学习Spring Boot如何集成Redis实现各种应用场景。</p>
<p>本章主要内容：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis简介：了解Redis的特点、数据结构。</span><br><span class="line">整合Redis：学会Spring Boot如何整合Redis，实现缓存数据。</span><br><span class="line">Redis数据类型：介绍Spring Boot中Redis常用数据结构的用法、优缺点和适用场景。Redis项目实战：从项目实战出发，演示实际应用场景如何使用Redis，实现基于Redis的数据缓存和基于Redis的Session共享。</span><br></pre></td></tr></table></figure>
<h2 id="11-1-Redis入门"><a href="#11-1-Redis入门" class="headerlink" title="11.1　Redis入门"></a>11.1　Redis入门</h2><p>本节首先介绍Redis的基本概念，包括Redis的优点和适用场景，然后介绍Spring Boot提供的Redis组件以及它们的依赖关系。通过这些基础的介绍，使读者对Redis有全局、直观的了解。</p>
<h3 id="11-1-1-Redis简介"><a href="#11-1-1-Redis简介" class="headerlink" title="11.1.1　Redis简介"></a>11.1.1　Redis简介</h3><p>Redis是一个开源的Key-Value（键-值）数据库，支持数据的持久化，支持更多的数据结构和更丰富的数据操作，提供了多种语言的API客户端，如Java、C/C++、C#、PHP、JavaScript、Perl、Object-C、Python、Ruby、Erlang等，使用起来简单方便。另外，Redis拥有丰富的集群方案，适合各种复杂的应用场景。因此，Redis是目前使用广泛的开源<strong>缓存中间件</strong>。</p>
<p>Redis的主要特点如下：</p>
<p>1）支持数据的持久化，可以将内存中的数据持久化保存在磁盘中，重启后再次将磁盘中的数据加载到内存。</p>
<p>2）丰富的数据类型，不仅支持简单的key-value类型的数据，还提供List、Set、ZSet、Hash等数据结构的存储。</p>
<p>3）支持数据的备份，即master-slave（主-从）模式的数据备份。</p>
<p>4）丰富的特性，支持publish/subscribe（发布/订阅）、通知、key过期等特性</p>
<p>Redis以其超高的性能、完善的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。很多大型互联网公司都使用Redis，可以说Redis已成为当下后端开发者的必备技能。</p>
<h3 id="11-1-2-Redis数据类型"><a href="#11-1-2-Redis数据类型" class="headerlink" title="11.1.2　Redis数据类型"></a>11.1.2　Redis数据类型</h3><p>Redis是一款高性能的非关系数据库（Non-Relational Database），支持丰富的数据类型，如String（字符串）、Hash（哈希）、List（列表）、Set（集合）以及ZSet（Sorted Set，有序集合），如表11-1所示。这些数据类型都支持push/pop、add/remove以及交集，并集和差集等操作。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121407227.png" alt="image-20231012140719093"></p>
<p>这5种数据类型各有优缺点和适用的场景，使用时根据实际业务需求选择合适的数据类型即可。</p>
<h2 id="11-2-Spring-Boot集成Redis实现数据缓存"><a href="#11-2-Spring-Boot集成Redis实现数据缓存" class="headerlink" title="11.2　Spring Boot集成Redis实现数据缓存"></a>11.2　Spring Boot集成Redis实现数据缓存</h2><p>本节首先会一步一步介绍Spring Boot项目如何集成Redis，然后介绍如何操作Redis实现缓存数据的创建、更新以及缓存失效等常见操作，最后从实际项目的角度介绍如何将Redis的相关操作封装成通用的工具类。</p>
<h3 id="11-2-1-Spring-Boot对Redis的支持"><a href="#11-2-1-Spring-Boot对Redis的支持" class="headerlink" title="11.2.1　Spring Boot对Redis的支持"></a>11.2.1　Spring Boot对Redis的支持</h3><p>Spring Boot提供了集成Redis的组件包spring-boot-starter-data-redis，能够非常方便地集成到项目中。spring-boot-starter-data-redis组件主要依赖spring-data-redis和lettuce库。Spring Boot 1.0默认使用的是Jedis客户端，Spring Boot 2.0版本之后改为Lettuce客户端。</p>
<h4 id="1-Jedis与Lettuce的区别"><a href="#1-Jedis与Lettuce的区别" class="headerlink" title="1. Jedis与Lettuce的区别"></a>1. Jedis与Lettuce的区别</h4><p>虽然Lettuce与Jedis都是连接Redis的客户端程序，但是两者在实现上还是有些不同的：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jedis在实现上直连Redis服务器，在多线程环境下是非线程安全的，除非使用连接池为每个	Jedis实例增加物理连接。</span><br><span class="line">Lettuce基于Netty的连接实例（StatefulRedisConnection）可以在多个线程间并发访问，并且是线程安全的，它支持多线程环境下的并发访问，同时也是可伸缩的设计，在一个连接实例不够的情况下可以按需增加连接实例。</span><br></pre></td></tr></table></figure>
<h4 id="2-组件的依赖关系"><a href="#2-组件的依赖关系" class="headerlink" title="2. 组件的依赖关系"></a>2. 组件的依赖关系</h4><p>Spring Boot提供的Redis组件spring-boot-starter-data-redis也是基于Spring Data封装的，它们之间的依赖关系如图11-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121413693.png" alt="image-20231012141356625"></p>
<p>如图11-1所示，spring-boot-starter-data-redis和Spring Data Redis两者是包含与被包含的关系，或者说前者更好地封装了后者。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lettuce：可伸缩的Redis客户端，基于Netty NIO框架来有效地管理多个连接。</span><br><span class="line">Spring Data Redis：Spring Data项目中的模块，封装了多个Redis客户端，让开发者对Redis的操作更加高效便捷。</span><br><span class="line">Spring Data：Spring框架中的重要组成部分，它极大地简化了构建基于Spring框架应用的数据操作，包括非关系数据库、Map-Reduce框架、云数据服务等，同时也支持关系数据库。</span><br><span class="line">spring-boot-starter-data-redis：Spring Boot提供的Redis集成启动器（Starter），依赖于spring-data-redis和lettuce库。</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-RedisTemplate"><a href="#11-2-2-RedisTemplate" class="headerlink" title="11.2.2　RedisTemplate"></a>11.2.2　RedisTemplate</h3><p>上一小节介绍了Spring Boot提供的Redis组件spring-boot-starter-data-redis，其中重要的是RedisTemplate。与JdbcTemplate类似，RedisTemplate是Spring针对Redis封装的一个比较强大的模板，以方便使用。只要在所需的地方注入RedisTemplate即可，无须其他额外配置，开箱即用。</p>
<p>RedisTemplate有两个方法经常用到：<strong>opsForXXX()</strong>和<strong>boundXXXOps(</strong>)，XXX是value（值）的数据类型。opsForXXX获取到一个操作（Operation），但是没有指定操作的key（键），可以在一个连接（事务）内操作多个key以及对应的value；boundXXXOps获取到一个指定key的操作，在一个连接内只操作这个key对应的value。</p>
<h4 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h4><p>RedisTemplate针对Redis的String、List、Hash、Set、ZSet五种数据类型提供了下面五个基本类来操作对应的数据类型：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValueOperations：针对String类型，实现简单的键-值操作。</span><br><span class="line">SetOperations：针对Set类型的数据操作。</span><br><span class="line">ZSetOperations：针对ZSet类型的数据操作。</span><br><span class="line">HashOperations：针对Hash类型的数据操作。</span><br><span class="line">ListOperations：针对List类型的数据操作。</span><br></pre></td></tr></table></figure>
<p>它们的使用特别简单，在调用类中注入RedisTemplate，操作哪种类型的数据就调用其对应的Operations（操作）。调用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作String类型</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// 操作Hash类型</span></span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 操作List</span></span><br><span class="line">redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line"><span class="comment">// 操作Set</span></span><br><span class="line">redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;weiz&quot;</span>)</span><br><span class="line"><span class="comment">// 操作ZSet</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过上面的示例，如果要操作String类型的数据，则调用redisTemplate.opsForValue()方法获取<strong>ValueOperations</strong>实例，最后调用set()或get()方法即可。</p>
<p>当然，RedisTemplate也提供了DefaultValueOperations对象操作字符串类型数据，比如set()、get()、incr()等方法。调用这些方法可以方便地存储任意的Java类型，而无须进行数据的序列化和反序列化操作。</p>
<h4 id="2-BoundValueOperations"><a href="#2-BoundValueOperations" class="headerlink" title="2. BoundValueOperations"></a>2. BoundValueOperations</h4><p>RedisTemplate提供了API用于对key执行bound（绑定）便捷化操作，可以通过bound封装指定的key，然后执行一系列的操作，而无须显式地再次指定key，即BoundKeyOperations将事务操作封装，由容器控制。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BoundValueOperations是针对String类型的绑定操作。</span><br><span class="line">BoundSetOperations是针对Set类型的绑定操作。</span><br><span class="line">BoundListOperations是针对List类型的绑定操作。</span><br><span class="line">BoundZSetOperations是针对ZSet类型的绑定操作。</span><br><span class="line">BoundHashOperations是针对Hash类型的绑定操作。</span><br></pre></td></tr></table></figure>
<p>例如，我们在某个类或方法中需要反复操作某个特定的key中的数据，则可以先定义对应的BoundKeyOperations，然后使用此类重复操作key中的数据，无须再调用方法中指定的key。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;weiz&quot;</span>;</span><br><span class="line"><span class="comment">// 获取Redis对value的操作对象，需要先设置key</span></span><br><span class="line"><span class="type">BoundValueOperations</span> <span class="variable">boundTemplate</span> <span class="operator">=</span> redisTemplate.boundValueOps(key);</span><br><span class="line"></span><br><span class="line">boundTemplate.set(<span class="string">&quot;bound test&quot;</span>);</span><br><span class="line"><span class="comment">// 获取value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> boundTemplate.get();</span><br></pre></td></tr></table></figure>
<p>通过上面的示例，首先定义key为“weiz”的BoundValueOperations实例，然后在后续的操作中直接使用定义的boundTemplate实例，操作这个key对应的数据，无须在调用方法中指定key</p>
<h3 id="11-2-3-Spring-Boot项目中实现Redis数据缓存"><a href="#11-2-3-Spring-Boot项目中实现Redis数据缓存" class="headerlink" title="11.2.3　Spring Boot项目中实现Redis数据缓存"></a>11.2.3　Spring Boot项目中实现Redis数据缓存</h3><p>Spring Boot项目集成Redis非常简单，只需在项目中增加spring-boot-starter-data-redis的依赖。下面通过示例演示如何在Spring Boot项目中集成Redis。</p>
<p>步骤01 引入Redis依赖包。</p>
<p>在pom.xml中增加spring-boot-starter-data-redis的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>步骤02 修改配置文件。</p>
<p>在application.properties配置文件增加有关Redis的配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis 数据库（默认为 0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis 服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis 服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis 服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制），默认为8</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制），默认为-1</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接，默认为10</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接，默认为0</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.min-idle</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 超时时间</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">6000</span></span><br></pre></td></tr></table></figure>
<p>上面的示例配置中，最主要的就是Redis的连接配置，其他的属性都可以使用默认值。</p>
<p>步骤03 验证测试。</p>
<p>配置完成之后，Redis就集成到项目中了。接下来测试Redis是否配置成功。首先创建单元测试类，注入RedisTemplate，然后调用set()方法写入缓存数据来测试Redis是否集成成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedisTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用set()方法创建缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;hello:redis&quot;</span>, <span class="string">&quot;hello spring boot&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello redis: &quot;</span>+ redisTemplate.opsForValue().get(<span class="string">&quot;hello:redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用redisTemplate的set方法缓存了字符串数据“hello spring boot”，然后调用get()方法获取该缓存数据，从而验证数据是否缓存成功。</p>
<p>缓存数据的修改也特别简单，重新调用set()方法即可，Redis会判断key是否存在，若存在则更新缓存的数据。</p>
<p>单击Run Test或在方法上右击，选择Run ‘testString’，运行单元测试方法，结果如图11-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121424618.png" alt="image-20231012142435556"></p>
<p>结果表明创建的单元测试运行成功，我们使用RedisTemplate成功创建并读取缓存数据。同时也说明Spring Boot项目成功集成Redis。</p>
<h3 id="11-2-4-Redis缓存的常用操作"><a href="#11-2-4-Redis缓存的常用操作" class="headerlink" title="11.2.4　Redis缓存的常用操作"></a>11.2.4　Redis缓存的常用操作</h3><p>在实际项目中，对Redis缓存的常用操作是：创建与读取缓存数据、删除缓存数据、缓存超时等。下面通过示例演示Redis常用操作。</p>
<h4 id="1-创建与读取缓存数据"><a href="#1-创建与读取缓存数据" class="headerlink" title="1. 创建与读取缓存数据"></a>1. 创建与读取缓存数据</h4><p>对于常用的缓存数据的创建与读取操作，调用RedisTemplate中的set()、get()方法即可。下面通过示例演示人员信息的缓存创建与读取。</p>
<p>首先，创建User实体类，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span>  String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;,locale = &quot;zh&quot;,timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line">    <span class="keyword">private</span>  String desc;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个普通的User实体类。需要注意的是，Redis缓存整个实体类对象就需要继承Serializable可序列化接口。</p>
<p>然后，创建TestRedisTemplate单元测试，添加读取、创建缓存的测试方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    ValueOperations&lt;String, User&gt; operations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">// 调用set()方法创建缓存</span></span><br><span class="line">    operations.set(<span class="string">&quot;user:weiz&quot;</span>, user);</span><br><span class="line">    <span class="comment">// 调用get()方法获取数据</span></span><br><span class="line">    User u=operations.get(<span class="string">&quot;user:weiz&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span>+u.getName()+<span class="string">&quot;,u.age:&quot;</span>+u.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，调用redisTemplate类的set()方法存储用户对象数据，存储成功后通过get()方法获取该缓存数据。</p>
<p>最后，单击Run Test或在方法上右击，选择Run ‘testString’，运行单元测试方法，结果如图11-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121431598.png" alt="image-20231012143135532"></p>
<p>结果表明创建的单元测试运行成功，我们使用RedisTemplate成功创建并读取缓存数据。同时也说明Spring Boot项目成功集成Redis。</p>
<h4 id="2-删除缓存数据"><a href="#2-删除缓存数据" class="headerlink" title="2. 删除缓存数据"></a>2. 删除缓存数据</h4><p>有时需要把过期或者没用的缓存数据删除，应该如何实现呢？RedisTemplate提供了delete()方法来删除过期的缓存key。下面我们来测试如何删除缓存，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">                ValueOperations&lt;String, User&gt; operations=redisTemplate.opsForValue();</span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;weiz:deletekey&quot;</span>, <span class="string">&quot;need delete&quot;</span>);</span><br><span class="line">                <span class="comment">// 删除缓存</span></span><br><span class="line">                redisTemplate.delete(<span class="string">&quot;deletekey&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断key是否存在</span></span><br><span class="line">                <span class="type">boolean</span> exists=redisTemplate.hasKey(<span class="string">&quot;deletekey&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;exists is true&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;exists is false&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，首先创建缓存weiz:deletekey，然后删除此key来判断数据是否存在。如图11-4所示，输出结果表明缓存的key和对应的value字符串已经被成功删除。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121436036.png" alt="image-20231012143621959"></p>
<h4 id="3-缓存超时失效"><a href="#3-缓存超时失效" class="headerlink" title="3. 缓存超时失效"></a>3. 缓存超时失效</h4><p>Redis可以对存入数据设置缓存超时时间，超过缓存时间Redis就会自动删除该数据。这种特性非常适合有时效限制的数据缓存及删除的场景。下面创建一个User对象，将user数据存入Redis并设置10秒后缓存失效，然后判断数据是否存在并打印结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExpire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;weiz expire&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    ValueOperations&lt;String, User&gt; operations=redisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">// 创建缓存并设置缓存失效时间</span></span><br><span class="line">    operations.set(<span class="string">&quot;weiz:expire&quot;</span>, user,<span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">// 10秒后判断缓存是否存在</span></span><br><span class="line">    <span class="type">boolean</span> exists=redisTemplate.hasKey(<span class="string">&quot;weiz:expire&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exists is true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exists is false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 10秒后判断缓存是否存在</span></span><br><span class="line">    exists=redisTemplate.hasKey(<span class="string">&quot;weiz:expire&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exists is true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exists is false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单击Run Test或在方法上右击，选择Run ‘testExpire’，运行单元测试方法，结果如图11-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121438005.png" alt="image-20231012143852941"></p>
<p>结果表明Redis缓存中已经不存在之前插入的数据，这说明该数据已经过期并被删除。在这种测试方法中可以使用hasKey方法判断key是否存在。</p>
<h2 id="11-3-操作Redis数据结构"><a href="#11-3-操作Redis数据结构" class="headerlink" title="11.3　操作Redis数据结构"></a>11.3　操作Redis数据结构</h2><p>本节介绍Spring Boot如何使用Redis的5个常用数据结构，了解在实际项目开发中各种数据结构的优缺点和适用场景。这是学习使用Redis的基础，只有了解了这些数据结构的概念和用法，才能在实际应用场景中选择合适的Redis数据结构，让其发挥出最好的性能。</p>
<h3 id="11-3-1-String"><a href="#11-3-1-String" class="headerlink" title="11.3.1　String"></a>11.3.1　String</h3><p>String（字符串）是常用的数据格式，一般在缓存数据时基本是使用String格式来进行存储的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">                ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">                <span class="comment">// 调用set()方法创建缓存</span></span><br><span class="line">                operations.set((<span class="string">&quot;string&quot;</span>,<span class="string">&quot;you&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取缓存数据</span></span><br><span class="line">                String value=(String) operations.get(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;string value :&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的示例可以看到，我们调用了set()和get()方法来创建与获取缓存数据，使用起来特别简单方便。</p>
<p>Redis除了提供set()、get()方法之外，还提供了decr()和incr()方法。当String类型的值为整数时，Redis可以把它当作整数一样执行自增（incr）和自减（decr）操作。由于Redis所有的操作都是原子性的，因此不必担心在多客户端连接时可能出现的事务处理问题。具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStringIncr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前在线用户数</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:online&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 当前在线用户数+1</span></span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">&quot;user:online&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取缓存数据</span></span><br><span class="line">    Integer value=(Integer) redisTemplate.opsForValue().get(<span class="string">&quot;user:online&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;string value :&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的示例可以看到，RedisTemplate提供了increment()和decrement()方法实现String数据类型的自增（incr）、自减（decr）操作。</p>
<h3 id="11-3-2-Hash"><a href="#11-3-2-Hash" class="headerlink" title="11.3.2　Hash"></a>11.3.2　Hash</h3><p>我们使用缓存时基本都是使用String进行存储的，但是有些场景String类型存储可能不太适用。因为Redis每存储一个key都会占用一个内存空间，key太多会消耗不必要的内存，也不方便数据的管理，因此合理地使用Hash（哈希）<strong>可以减少key的数量</strong>，也能节省内存。</p>
<p>Hash是一个String类型的field和value的映射表。如果key不存在，就会创建新的哈希表并进行HSET操作；如果字段（field）已经存在于哈希表中，则旧值将被覆盖。Hash适用于存储对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">                HashOperations&lt;String, Object, Object&gt; hash = redisTemplate.opsForHash();</span><br><span class="line">                <span class="comment">// 调用put()方法创建Hash数据缓存</span></span><br><span class="line">                hash.put(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                hash.put(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">                hash.put(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;boot&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取Hash数据</span></span><br><span class="line">                String value=(String) hash.get(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;you&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;hash value :&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的示例可以看到，使用Hash存储数据时需要传入3个参数：第一个参数为key，第二个参数为字段（field），第三个参数为要存储的值（value）。</p>
<p>Hash删除时特别方便，比如将同类的数据聚集在一个Hash中，删除key就可以实现全部删除，清理数据比较方便。除此之外，另一种是删除Hash中的部分key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除Hash中的部分key</span></span><br><span class="line">redisTemplate.opsForHash().delete(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如上面的示例所示，如果需要删除Hash集合中的某个数据，传入对应的key和field参数即可。</p>
<h3 id="11-3-3-List"><a href="#11-3-3-List" class="headerlink" title="11.3.3　List"></a>11.3.3　List</h3><p>List（列表）的应用场景非常广泛，是Redis重要的数据结构之一。使用List可以轻松地实现数据队列，List典型的应用场景就是消息队列，通过List的Push操作将消息数据存储到List中，然后在“消费”线程中再用POP操作将消息取出并进行相应的处理。</p>
<p>List的实现为一个双向链表，可以按照插入顺序排序。另外，也可以把一个元素到添加列链表的头部（左边）或者链表的尾部（右边），操作起来更加方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    ListOperations&lt;String, String&gt; list = redisTemplate.opsForList();</span><br><span class="line">    <span class="comment">// 把数据插入到List的左边</span></span><br><span class="line">    list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;boot&quot;</span>);</span><br><span class="line">    <span class="comment">// 从左边取出List中的数据</span></span><br><span class="line">    String value=(String)list.leftPop(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list value :&quot;</span>+value.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子表示把值从左侧插入（leftPush）一个key为“list”的队列中，然后从该队列的最左侧取出（leftPop）一个数据。</p>
<p>List还有很多其他API操作函数，比如从右侧插入（rightPush）队列，从右侧读取（rightPop）数据，或者调用range()方法读取队列的一部分。接着上面的例子，我们调用range()方法进行读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListRange</span><span class="params">()</span> &#123;</span><br><span class="line">                ListOperations&lt;String, String&gt; list = redisTemplate.opsForList();</span><br><span class="line">                <span class="comment">// 从List的左边插入数据</span></span><br><span class="line">                list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">                list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">                list.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;boot&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用range()方法获取部分List</span></span><br><span class="line">                List&lt;String&gt; values=list.range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span> (String v:values)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;list range :&quot;</span>+v);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Range()方法包含3个参数：第一个参数是key，第二个参数是读取的起始位置，第三个参数是读取的结束位置。输入不同的参数就可以从队列中读取对应的数据。</p>
<h3 id="11-3-4-Set"><a href="#11-3-4-Set" class="headerlink" title="11.3.4　Set"></a>11.3.4　Set</h3><p>Set（集合）是String类型的无序集合。集合成员是唯一的，所以集合中不能出现重复的数据。Set的功能与List类似，不同之处在于Set可以自动去除重复的数据。因此，当我们需要存储一个列表数据又不希望其中出现重复的数据时，Set类型就是一个很好的选择。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;set&quot;</span>;</span><br><span class="line">    SetOperations&lt;String, String&gt; set = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">// 在Set中插入数据</span></span><br><span class="line">    set.add(key, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    set.add(key, <span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    set.add(key, <span class="string">&quot;boot&quot;</span>);</span><br><span class="line">    set.add(key, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用members()方法判断某个数据</span></span><br><span class="line">    Set&lt;String&gt; values = set.members(key);</span><br><span class="line">    <span class="keyword">for</span> (String v : values) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set value :&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子可以发现，Set提供了members()方法获取集合中全部的数据。而且，当存入两个相同的数据“hello”时，全部读取Set时只剩下一个数据，说明Set对队列进行了自动去重操作。</p>
<p>Set还为集合提供了求交集、并集、差集等操作函数，使用起来非常方便，适用于各种业务需求。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetUnion</span><span class="params">()</span> &#123;</span><br><span class="line">    SetOperations&lt;String, String&gt; set = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">// 在seta中插入数据</span></span><br><span class="line">    set.add(<span class="string">&quot;set:a&quot;</span>,<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;set:a&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;set:a&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 在setb中插入数据</span></span><br><span class="line">    set.add(<span class="string">&quot;set:b&quot;</span>,<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;set:b&quot;</span>,<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;set:b&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回多个集合的并集</span></span><br><span class="line">    redisTemplate.opsForSet().union(<span class="string">&quot;set:a&quot;</span>, <span class="string">&quot;set:b&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回多个集合的交集</span></span><br><span class="line">    redisTemplate.opsForSet().intersect(<span class="string">&quot;set:a&quot;</span>, <span class="string">&quot;set:b&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回集合key1中存在但是key2中不存在的数据集合，即差集</span></span><br><span class="line">    redisTemplate.opsForSet().difference(<span class="string">&quot;set:a&quot;</span>, <span class="string">&quot;set:b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-5-ZSet"><a href="#11-3-5-ZSet" class="headerlink" title="11.3.5　ZSet"></a>11.3.5　ZSet</h3><p>ZSet的使用场景与Set类似，区别在于Set是无序的，而ZSet可以通过一个优先级（Score）参数来为成员排序。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    String key=<span class="string">&quot;zset&quot;</span>;</span><br><span class="line">    redisTemplate.delete(key);</span><br><span class="line">    ZSetOperations&lt;String, String&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">    zset.add(key,<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    zset.add(key,<span class="string">&quot;weiz&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    zset.add(key,<span class="string">&quot;boot&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    zset.add(key,<span class="string">&quot;spring&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 调用range()方法获取数据</span></span><br><span class="line">    Set&lt;String&gt; zsets=zset.range(key,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (String v:zsets)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zset value :&quot;</span>+v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子可以发现，保存ZSet类型的缓存时会传入key、value、Score三个参数，然后通过range获取数据。</p>
<p>ZSet还可以根据Score的值对集合进行排序。我们可以利用这个特性来实现具有权重的队列，比如普通消息的Score为1，重要消息的Score为2，然后消费线程可以选择按Score的倒序来获取相关数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">                String key=<span class="string">&quot;zset&quot;</span>;</span><br><span class="line">                redisTemplate.delete(key);</span><br><span class="line">                ZSetOperations&lt;String, String&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">                zset.add(key,<span class="string">&quot;it&quot;</span>,<span class="number">1</span>);</span><br><span class="line">                zset.add(key,<span class="string">&quot;you&quot;</span>,<span class="number">6</span>);</span><br><span class="line">                zset.add(key,<span class="string">&quot;know&quot;</span>,<span class="number">4</span>);</span><br><span class="line">                zset.add(key,<span class="string">&quot;neo&quot;</span>,<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 调用range()方法获取数据并排序</span></span><br><span class="line">                Set&lt;String&gt; zsetB=zset.rangeByScore(key,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">for</span> (String v:zsetB)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;zsetB value :&quot;</span>+v);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的示例可以发现，插入ZSet的数据会自动根据Score进行排序，还可以调用rangeByScore()方法获取Score范围内排序后的数据。根据这个特性可以实现优先队列的功能。</p>
<h2 id="11-4-实战：实现数据缓存框架"><a href="#11-4-实战：实现数据缓存框架" class="headerlink" title="11.4　实战：实现数据缓存框架"></a>11.4　实战：实现数据缓存框架</h2><p>本节从项目实战出发介绍使用Redis来实现数据缓存框架，高效的数据缓存可以极大地提高系统的访问速度和并发性能，Spring Boot关于数据缓存有很多实现方案，下面将讲解其中的部分方案。</p>
<h3 id="11-4-1-数据缓存的原理"><a href="#11-4-1-数据缓存的原理" class="headerlink" title="11.4.1　数据缓存的原理"></a>11.4.1　数据缓存的原理</h3><p>Spring Boot提供了完善的数据缓存方案，系统会自动根据调用的方法缓存请求的数据。当再次调用该方法时，系统会首先从缓存中查找是否有相应的数据，如果命中缓存，则从缓存中读取数据并返回；如果没有命中，则请求数据库查询相应的数据并再次缓存。系统架构如图11-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121501370.png" alt="image-20231012150110275"></p>
<p>如图11-6所示，每一个用户请求都会先查询缓存中的数据，如果缓存命中，则会返回缓存中的数据。这样能减少数据库查询，提高系统的响应速度。</p>
<h3 id="11-4-2-使用Redis实现数据缓存框架"><a href="#11-4-2-使用Redis实现数据缓存框架" class="headerlink" title="11.4.2　使用Redis实现数据缓存框架"></a>11.4.2　使用Redis实现数据缓存框架</h3><p>接下来，以用户信息管理模块为例演示使用Redis实现数据缓存框架。</p>
<h4 id="1-添加Redis-Cache的配置类"><a href="#1-添加Redis-Cache的配置类" class="headerlink" title="1. 添加Redis Cache的配置类"></a>1. 添加Redis Cache的配置类</h4><p>RedisConfig类为Redis设置了一些全局配置，比如配置主键的生产策略KeyGenerator()方法，此类继承CachingConfigurerSupport类，并重写方法keyGenerator()，如果不配置，就默认使用参数名作为主键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    / **</span><br><span class="line">     * 采用RedisCacheManager作为缓存管理器</span><br><span class="line">     * 为了处理高可用Redis，可以使用RedisSentinelConfiguration来支持Redis Sentinel</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">redisCacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(connectionFactory).build();</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    / **</span><br><span class="line">     * 自定义生成key的规则</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyGenerator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">generate</span><span class="params">(Object o, Method method, Object...objects)</span> &#123;</span><br><span class="line">                <span class="comment">// 格式化缓存key字符串</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="comment">// 追加类名</span></span><br><span class="line">                stringBuilder.append(o.getClass().getName());</span><br><span class="line">                <span class="comment">// 追加方法名</span></span><br><span class="line">                stringBuilder.append(method.getName());</span><br><span class="line">                <span class="comment">// 遍历参数并且追加</span></span><br><span class="line">                <span class="keyword">for</span> (Object obj :objects) &#123;</span><br><span class="line">                    stringBuilder.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;调用Redis缓存Key: &quot;</span> + stringBuilder.toString());</span><br><span class="line">                <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主要是自定义配置RedisKey的生成规则，使用@EnableCaching注解和@Configuration注解。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching：开启基于注解的缓存，也可以写在启动类上。</span><br><span class="line">@Configuration：标识它是配置类的注解。</span><br></pre></td></tr></table></figure>
<h4 id="2-添加-Cacheable注解"><a href="#2-添加-Cacheable注解" class="headerlink" title="2. 添加@Cacheable注解"></a>2. 添加@Cacheable注解</h4><p>在读取数据的方法上添加@Cacheable注解，这样就会自动将该方法获取的数据结果放入缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    / **</span><br><span class="line">     * <span class="meta">@Cacheable</span>应用到读取数据的方法上，先从缓存中读取，如果没有，再从DB获取数据，然后把数据添加到缓存中</span><br><span class="line">     * unless表示条件表达式成立的话不放入缓存</span><br><span class="line">     * <span class="meta">@param</span> username</span><br><span class="line">     * <span class="meta">@return</span></span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(username);</span><br><span class="line">        user.setAge(<span class="number">30</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user info from database&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，使用@Cacheable注解标注该方法要使用缓存。@Cacheable注解主要针对方法进行配置，能够根据方法的请求对参数及其结果进行缓存。</p>
<p>1）这里缓存key的规则为简单的字符串组合，如果不指定key参数，则自动通过keyGenerator生成对应的key。</p>
<p>2）Spring Cache提供了一些可以使用的SpEL上下文数据，通过#进行引用。</p>
<h4 id="3-测试数据缓存"><a href="#3-测试数据缓存" class="headerlink" title="3. 测试数据缓存"></a>3. 测试数据缓存</h4><p>创建单元测试方法调用getUserByName()方法，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.getUserByName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span>+ user.getName()+<span class="string">&quot;,age:&quot;</span>+user.getAge());</span><br><span class="line"></span><br><span class="line">    user = userRepository.getUserByName(<span class="string">&quot;weiz&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span>+ user.getName()+<span class="string">&quot;,age:&quot;</span>+user.getAge());</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实例分别调用了两次getUserByName()方法，输出获取到的User信息。</p>
<p>最后，单击Run Test或在方法上右击，选择Run ‘testGetUserByName’，运行单元测试方法，结果如图11-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121514412.png" alt="image-20231012151422335"></p>
<p>通过上面的日志输出可以看到，首次调用getPersonByName()方法请求User数据时，由于缓存中未保存该数据，因此从数据库中获取User信息并存入Redis缓存，再次调用会命中此缓存并直接返回。</p>
<h3 id="11-4-3-常用缓存注解"><a href="#11-4-3-常用缓存注解" class="headerlink" title="11.4.3　常用缓存注解"></a>11.4.3　常用缓存注解</h3><h4 id="1-常用注解和参数"><a href="#1-常用注解和参数" class="headerlink" title="1. 常用注解和参数"></a>1. 常用注解和参数</h4><p>Spring提供了@EnableCaching、@Cacheable、@CacheEvict、@CachePut、@CacheConfig五个注解用来声明数据缓存规则，理解这几个常用的注解和方法就可以在项目中轻松实现数据缓存。如表11-2所示，这5个注解除了@CacheConfig是类级别的注解之外，其余4个注解在类和方法上均可使用，使用在类上时表示对该类下的所有方法生效，使用在方法上时只对该方法生效，并且只能用于public修饰的方法，而protected或者private修饰的方法则不适用。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121518766.png" alt="image-20231012151814665"></p>
<h4 id="2-keyGenerator"><a href="#2-keyGenerator" class="headerlink" title="2. keyGenerator"></a>2. keyGenerator</h4><p>前面介绍了通过key参数生成对应缓存的key值，除了key参数之外，还有keyGenerator参数，用于指定key的生成器的主键ID。使用keyGenerator能够更加灵活地生成缓存的key值。需要注意的是，key和keyGenerator两个参数只能使用一个。下面演示keyGenerator如何使用。</p>
<p>首先，定义keyGenerator生成器，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义生成key的规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;myKeyGenerator&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyGenerator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">generate</span><span class="params">(Object o, Method method, Object... objects)</span> &#123;</span><br><span class="line">                <span class="comment">// 格式化缓存key字符串</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="comment">// 追加类名</span></span><br><span class="line">                stringBuilder.append(o.getClass().getName());</span><br><span class="line">                <span class="comment">// 追加方法名</span></span><br><span class="line">                stringBuilder.append(method.getName());</span><br><span class="line">                <span class="comment">// 遍历参数并且追加</span></span><br><span class="line">                <span class="keyword">for</span> (Object obj :objects) &#123;</span><br><span class="line">                    stringBuilder.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;调用Redis缓存Key: &quot;</span> + stringBuilder.toString());</span><br><span class="line">                <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，我们定义了keyGenerator生成器：myKeyGenerator。Key的生成规则是：类名+方法名+参数名。</p>
<p>定义了keyGenerator生成器，接下来在缓存中指定keyGenerator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;user&quot;, keyGenerator=&quot;myKeyGenerator&quot;, unless = &quot;#result eq null&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPersonByName</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personRepo.getPersonByName(username);</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，我们通过keyGenerator参数指定了缓存的生成器为前面定义的myKeyGenerator。</p>
<h2 id="11-5-实战：实现Session共享"><a href="#11-5-实战：实现Session共享" class="headerlink" title="11.5　实战：实现Session共享"></a>11.5　实战：实现Session共享</h2><p>本节从项目实战出发介绍使用Redis实现Session共享。在分布式或微服务系统中会出现这样一个问题：用户在服务器A上登录以后，假如后续的业务操作被负载均衡服务转发到服务器B上，服务器B上没有这个用户的Session状态，就会强制让用户重新登录，导致业务无法顺利完成。因此，这就需要将Session进行共享，保证每个系统都能获取用户的Session状态。</p>
<h3 id="11-5-1-分布式Session共享解决方案"><a href="#11-5-1-分布式Session共享解决方案" class="headerlink" title="11.5.1　分布式Session共享解决方案"></a>11.5.1　分布式Session共享解决方案</h3><p>目前主流的分布式Session共享主要有以下几种解决方案：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端存储：使用Cookie来完成，其缺点是不安全、不可靠。</span><br><span class="line">Session绑定：使用Nginx中的IP绑定策略，同一个IP指定访问同一台机器，其缺点是容易造成单点故障。如果某一台服务器宕机，那么该台服务器上的Session信息将会丢失。Session同步：使用Tomcat内置的Session同步，其缺点是同步可能会产生延迟。Session共享：将Session存储在Redis等缓存中间件中。</span><br></pre></td></tr></table></figure>
<p>以上解决方案各有优缺点，其中比较流行的是使用Redis等缓存中间件的Session共享解决方案。将所有的Session会话信息存入Redis缓存中，然后Web应用从Redis中取出Session信息实现所有应用的Session共享。具体示意图如图11-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121522915.png" alt="image-20231012152222823"></p>
<p>从图11-8可以看出，所有的服务都将Session信息存储到Redis中，无论是对Session的注销、更新都会同步到Redis中，从而达到Session共享的目的。</p>
<h3 id="11-5-2-使用Redis快速实现Session共享"><a href="#11-5-2-使用Redis快速实现Session共享" class="headerlink" title="11.5.2　使用Redis快速实现Session共享"></a>11.5.2　使用Redis快速实现Session共享</h3><p>前面介绍了使用Redis实现Session共享的解决方案。下面通过示例演示使用Redis实现Session信息存储，并实现多系统的Session信息共享。</p>
<h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 redis 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，除了引入Redis组件外，还需要引入spring-session-data-redis依赖。通过此组件实现Session信息的管理。</p>
<h4 id="2-添加Session配置类"><a href="#2-添加Session配置类" class="headerlink" title="2. 添加Session配置类"></a>2. 添加Session配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例配置了Session的缓存时间。maxInactiveIntervalInSeconds用于设置Session的失效时间，使用Redis共享Session之后，原Spring Boot的server.session.timeout属性不再有效。</p>
<p>经过上面的配置后，Session调用就会自动去Redis上存取。另外，想要达到Session共享的目的，只需要在其他系统上进行同样的配置即可。</p>
<h4 id="3-测试验证"><a href="#3-测试验证" class="headerlink" title="3. 测试验证"></a>3. 测试验证</h4><p>首先，增加Session的测试方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/uid&quot;)</span></span><br><span class="line">String <span class="title function_">uid</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uid</span> <span class="operator">=</span> (UUID) session.getAttribute(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>) &#123;</span><br><span class="line">        uid = UUID.randomUUID();</span><br><span class="line">    &#125;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;uid&quot;</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> session.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，启动项目，运行一个程序实例，启动端口号为8080，在浏览器中输入地址：<a target="_blank" rel="noopener" href="http://localhost:8080/uid，页面返回会话的sessionId，如图11-9所示。">http://localhost:8080/uid，页面返回会话的sessionId，如图11-9所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121525238.png" alt="image-20231012152515157"></p>
<p>我们可以登录Redis客户端，查看Session是否已经保存到Redis，输入“keys ‘<em>sessions</em>‘”查看所有的Session信息，如图11-10所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121525290.png" alt="image-20231012152549217"></p>
<p>从上面的输出可以看到，sessionId是7433a35d-a086-4b7d-bb64-37cf8b4e18f7，与页面返回的sessionId一致。说明Redis中缓存的SessionId和实际使用的Session一致，Session已经在Redis中进行了有效的管理。</p>
<p>最后，模拟分布式系统再启动一个程序实例，启动端口号为8081，在浏览器中输入<a target="_blank" rel="noopener" href="http://localhost:8081/uid，页面返回会话的SessionId如图11-11所示。">http://localhost:8081/uid，页面返回会话的SessionId如图11-11所示。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121526908.png" alt="image-20231012152616809"></p>
<p>从输出结果可以看到，程序实例1和程序实例2获取的是同一个Session，这说明两个程序实现了Session共享。</p>
<h1 id="第12章-RabbitMQ消息队列"><a href="#第12章-RabbitMQ消息队列" class="headerlink" title="第12章　RabbitMQ消息队列"></a>第12章　RabbitMQ消息队列</h1><p>本章主要介绍Spring Boot使用RabbitMQ实现消息队列，主要包括RabbitMQ的核心概念、交换机等，然后在Spring Boot项目中使用RabbitMQ实现消息的发送和接收，最后从项目实战出发介绍让消息100%可靠性发送的解决方案。</p>
<h2 id="12-1-RabbitMQ入门"><a href="#12-1-RabbitMQ入门" class="headerlink" title="12.1　RabbitMQ入门"></a>12.1　RabbitMQ入门</h2><p>本节介绍RabbitMQ的核心概念和消息中间件中非常重要的协议——AMQP协议，然后介绍Direct、Topic、Headers、Fanout等交换机的作用和特点。</p>
<h3 id="12-1-1-RabbitMQ简介"><a href="#12-1-1-RabbitMQ简介" class="headerlink" title="12.1.1　RabbitMQ简介"></a>12.1.1　RabbitMQ简介</h3><p>消息中间件在互联网公司使用的越来越多，主要用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。消息队列实现系统之间的双向解耦，生产者往消息队列中发送消息，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到系统解耦的目的，也大大提高了系统的高可用性和高并发能力。</p>
<p>RabbitMQ基于开源的AMQP协议实现，服务器端用Erlang语言编写，支持多种客户端，如Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP、AJAX等。</p>
<p>RabbitMQ的主要优势如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可靠性（Reliability）：使用了一些机制来保证可靠性，比如持久化、传输确认、发布确认。</span><br><span class="line">灵活的路由（Flexible Routing）：在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，Rabbit已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，既可以将多个Exchange绑定在一起，又可以通过插件机制实现自己的Exchange。</span><br><span class="line">消息集群（Clustering）：多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</span><br><span class="line">高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出现问题的情况下队列仍然可用。</span><br><span class="line">多种协议（Multi-Protocol）：支持多种消息队列协议，如STOMP、MQTT等。</span><br><span class="line">多种语言客户端（Many Clients）：几乎支持所有常用语言，比如Java、.NET、Ruby等。</span><br><span class="line">管理界面（Management UI）：提供了易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</span><br><span class="line">跟踪机制（Tracing）：如果消息异常，RabbitMQ提供了消息的跟踪机制，使用者可以找出发生了什么。</span><br><span class="line">插件机制（Plugin System）：提供了许多插件进行扩展，也可以编辑自己的插件。</span><br></pre></td></tr></table></figure>
<p>RabbitMQ作为流行的消息中间件，实现了应用程序的异步和解耦，同时也能起到消息缓冲、消息分发的作用，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="12-1-2-AMQP"><a href="#12-1-2-AMQP" class="headerlink" title="12.1.2　AMQP"></a>12.1.2　AMQP</h3><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是应用层协议的开放标准，是为面向消息的中间件设计。基于此协议的客户端可与消息中间件传递消息，从而不受产品、开发语言等条件限制。消息中间件主要用于组件之间的解耦，消息发送者无须知道消息使用者的存在，反之亦然。</p>
<p>与其他消息队列协议不同的是，AMQP中增加了Exchange和Binging角色。生产者把消息发布到Exchange上，消息最终到达队列并被消费者接收；而Binding决定Exchange的消息应该发送到哪个队列。</p>
<p>图12-1展示的就是消息路由传递的过程：生产者首先将消息发送到Exchange，通过Exchange转发到绑定的各个消息队列上，然后消费者从队列中读取消息。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121538677.png" alt="image-20231012153832537"></p>
<h3 id="12-1-3-RabbitMQ组件功能"><a href="#12-1-3-RabbitMQ组件功能" class="headerlink" title="12.1.3　RabbitMQ组件功能"></a>12.1.3　RabbitMQ组件功能</h3><p>RabbitMQ中有几个非常重要的组件：服务实体（Broker）、虚拟主机（Virtual Host）、交换机（Exchange）、队列（Queue）和绑定（Binging）等，如图12-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121539191.png" alt="image-20231012153908104"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务实体（Broker）：标识消息队列的服务器实体。</span><br><span class="line">虚拟主机（Virtual Host）：一个虚拟主机只有一组交换机、队列和绑定，为什么还需要多个虚拟主机呢？很简单，在RabbitMQ中，用户只能在虚拟主机的粒度上进行权限控制。因此，如果需要禁用A组访问B组的交换机/队列/绑定，就必须为A和B分别创建一个虚拟主机，每个RabbitMQ服务器都有一个默认的虚拟主机“/”。</span><br><span class="line">交换机（Exchange）：客户端不会直接给服务端发送消息，而是通过交换机转发。交换机用于转发消息，但是它不会进行存储，如果没有消息队列发送到交换机，它就会直接丢弃生成者（Producer）发送过来的消息。</span><br><span class="line">队列（Queue）：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列中，等待消费者连接到这个队列将其取走。</span><br><span class="line">绑定（Binging）：也就是交换机需要与队列相互绑定，如图12-2所示就是多对多的关系。</span><br></pre></td></tr></table></figure>
<p>通常我们谈到消息队列服务时有3个基本概念：消息发送者、消息队列和消息接收者。RabbitMQ在这些基本概念之上多做了一层抽象，在消息发送者和消息队列之间加入了交换机，这样消息发送者与队列之间就没有直接联系，变成消息发送者将消息发送给交换机，再由交换机根据调度策略把消息发送到各个队列。</p>
<h3 id="12-1-4-交换机"><a href="#12-1-4-交换机" class="headerlink" title="12.1.4　交换机"></a>12.1.4　交换机</h3><p>交换机（Exchange）的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，只是把消息分发给各自的队列。但是我们给交换机发送消息，它怎么知道给哪个消息队列发送呢？<strong>这里就要用到RoutingKey和BindingKey。</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BindingKey是交换机和消息队列绑定的规则描述。</span><br><span class="line">RoutingKey是消息发送时携带的消息路由信息描述。</span><br></pre></td></tr></table></figure>
<p>当消息发送到交换机（Exchange）时，通过消息携带的RoutingKey与当前交换机所有绑定的BindingKey进行匹配，如果满足匹配规则，则往BindingKey所绑定的消息队列发送消息，这样就解决了向RabbitMQ发送一次消息，可以分发到不同的消息队列，实现消息路由分发的功能。</p>
<p>交换机有Direct、Topic、Headers和Fanout四种消息分发类型。不同的类型在处理绑定到队列方面的行为时会有所不同。</p>
<p>1）Direct：其类型的行为是“先匹配，再发送”，即在绑定时设置一个BindingKey，当消息的RoutingKey匹配队列绑定的BindingKey时，才会被交换机发送到绑定的队列中。</p>
<p>2）Topic：按规则转发消息（最灵活）。支持用“<em>”或“#”的模式进行绑定。“</em>”表示匹配一个单词，“#”表示匹配0个或者多个单词。比如，某消息队列绑定的BindingKey为“*.user.#”时，能够匹配到RoutingKey为usd.user和eur.user.db的消息，但是不匹配user.hello。</p>
<p>3）Headers：设置header attribute参数类型的交换机。根据应用程序消息的特定属性进行匹配，这些消息可能在绑定key中标记为可选或者必选。</p>
<p>4）Fanout：转发消息到所有绑定队列（广播）。将消息广播到所有绑定到它的队列中，而不考虑队列绑定的BindingKey的值。</p>
<h4 id="1-Direct模式"><a href="#1-Direct模式" class="headerlink" title="1. Direct模式"></a>1. Direct模式</h4><p>Direct是RabbitMQ默认的交换机模式，也是简单的模式，根据key全字匹配去寻找队列，如图12-3所示。当消息的RoutingKey为orange时，匹配Q1队列，所以消息被发送到Q1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121543382.png" alt="image-20231012154350300"></p>
<h4 id="2-Topic模式"><a href="#2-Topic模式" class="headerlink" title="2. Topic模式"></a>2. Topic模式</h4><p>Topic是RabbitMQ中使用最多的交换机模式（见图12-4），RoutingKey必须是一串字符，用符号“.”隔开，比如user.msg或者user.order.msg等。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121544648.png" alt="image-20231012154418568"></p>
<p>Topic与Direct类似，只是路由匹配上支持通配符，可以使用以下两个通配符：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*：表示匹配一个词。</span></span><br><span class="line"><span class="emphasis">#：表示匹配0个或多个词。</span></span><br></pre></td></tr></table></figure>
<p>当消息的RoutingKey为color.orange.msg时，匹配Q1队列，所以消息被发送到Q1。</p>
<h4 id="3-Headers模式"><a href="#3-Headers模式" class="headerlink" title="3. Headers模式"></a>3. Headers模式</h4><p>Headers也是根据规则匹配的，相较于Direct和Topic固定地使用RoutingKey与BindingKey的匹配规则来路由消息，Headers是根据发送的消息内容中的headers属性进行匹配的。</p>
<p>消息队列绑定的header数据中有一个特殊的键x-match，有all和any两个值：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all：表示传送消息的header中的“键-值对”（Key-Value Pair）和交换机的header中的“键-值对”全部匹配，才可以路由到对应的交换机。</span><br><span class="line">any：表示传送消息的header中的“键-值对”和交换机的header中的“键-值对”中的任意一个匹配，就可以路由到对应的交换机。</span><br></pre></td></tr></table></figure>
<p>如图12-5所示，在绑定队列与交换机时指定一组“键-值对”，当消息发送到交换机时，RabbitMQ会取到该消息的Headers，然后对比其中的“键-值对”是否匹配队列与Exchange绑定时指定的“键-值对”；如果匹配则消息会路由到该队列，否则不会路由到该队列。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121546006.png" alt="image-20231012154608922"></p>
<h4 id="4-Fanout模式"><a href="#4-Fanout模式" class="headerlink" title="4. Fanout模式"></a>4. Fanout模式</h4><p>Fanout是消息广播模式，交换机不处理RoutingKey，发送到交换机的消息都会分发到所有绑定的队列上。Fanout模式不需要RoutingKey，只需要提前将交换机与队列进行绑定即可。</p>
<p>如图12-6所示，每个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout模式转发消息是最快的。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310121546209.png" alt="image-20231012154641129"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/">https://wdpname.github.io/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Cloud微服务和分布式系统实践</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java编程的逻辑</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86Spring-Boot"><span class="toc-number">1.</span> <span class="toc-text">第1章　初识Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Spring-Boot%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.1　Spring Boot是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Boot%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Spring Boot的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-Boot%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Spring Boot的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Spring Boot的核心组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Spring-Boot%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2　Spring Boot的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0Spring-Boot"><span class="toc-number">1.3.</span> <span class="toc-text">1.3　为什么学习Spring Boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE%E2%80%9D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4　什么是“约定优于配置”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Spring%E3%80%81Spring-Boot%E5%92%8CSpring-Cloud%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5　Spring、Spring Boot和Spring Cloud的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%A7%8BSpring-Boot%E4%B9%8B%E6%97%85"><span class="toc-number">2.</span> <span class="toc-text">第2章　开始Spring Boot之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AC%AC%E4%B8%80%E4%B8%AASpring-Boot%E9%A1%B9%E7%9B%AE%EF%BC%9Ahelloworld"><span class="toc-number">2.1.</span> <span class="toc-text">2.1　第一个Spring Boot项目：helloworld</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1　创建Spring Boot项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Spring%E5%AE%98%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9E%84%E5%BB%BA%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1. 使用Spring官网提供的构建页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8IDEA%E6%9E%84%E5%BB%BA"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2. 使用IDEA构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2　项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-pom-xml%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3　pom.xml详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1. 项目的描述信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2. 项目的依赖配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%85%AC%E5%85%B1%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3. 构建时需要的公共变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">4. 构建配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E7%AC%AC%E4%B8%80%E4%B8%AAhelloworld%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4　第一个helloworld程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2　单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Spring-Boot%E9%9B%86%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1　Spring Boot集成单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2. 创建单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">3. 运行单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%B5%8B%E8%AF%95Service%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2　测试Service方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAService%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1. 创建Service测试类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2. 实现单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%B5%8B%E8%AF%95Controller%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3　测试Controller接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4　常用的单元测试注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3　开发环境热部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-devtools%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1　devtools实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2　配置开发环境热部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Spring-Boot%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">第3章　Spring Boot的系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1　系统配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-application-properties"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1　application.properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2. 配置文件加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">3. 修改默认配置文件名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-application-yml"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2　application.yml</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2. 数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-Properties%E4%B8%8EYML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3　Properties与YML配置文件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4　实战：自定义系统的启动图案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.</span> <span class="toc-text">3.2　自定义配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-Value"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1　@Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-Environment"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2　Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ConfigurationProperties"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3　@ConfigurationProperties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. 创建自定义配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 创建实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3. 调用配置项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4　使用配置文件注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3　其他配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1　随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E9%85%8D%E7%BD%AE%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2　配置引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.</span> <span class="toc-text">3.4　日志配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Spring-Boot%E6%97%A5%E5%BF%97%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1　Spring Boot日志简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2　配置日志格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E7%BA%A7%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3　日志输出级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BF%9D%E5%AD%98%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4　保存日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">3.5　实战：实现系统多环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1　多环境的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">1. 创建多环境配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">2. 修改配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2　多环境的切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Web%E5%BC%80%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">第4章　Web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Web%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1　Web开发简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Web%E5%85%A5%E9%97%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1　Web入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-spring-boot-starter-web%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">1. spring-boot-starter-web介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Web%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">2. Web项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84Web%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">3. 实现简单的Web请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Controller%E5%92%8C-RestController"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2　@Controller和@RestController</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Controller%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1. @Controller的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RestController%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">2. @RestController的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RestController%E5%92%8C-Controller%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">3. @RestController和@Controller的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-RequestMapping"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3　@RequestMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-ResponseBody"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4　@ResponseBody</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-URL%E6%98%A0%E5%B0%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.2　URL映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-URL%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1　URL路径匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1. 精确匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">2. 通配符匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-Method%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2　Method匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-consumes%E5%92%8Cproduces%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3　consumes和produces匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-params%E5%92%8Cheader%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4　params和header匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-params"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">1. params</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-header"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">2. header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.3.</span> <span class="toc-text">4.3　参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-PathVariable"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1　@PathVariable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89URL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">1. 定义URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AAURL%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">2. 定义多个URL变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%B9%E9%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">3. 匹配正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E4%BD%BF%E7%94%A8Bean%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2　使用Bean对象接收参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0Bean%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1. 增加Bean实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A2%9E%E5%8A%A0%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2. 增加后台方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-RequsetBody%E6%8E%A5%E6%94%B6JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3　@RequsetBody接收JSON数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-ModelAttribute"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4　@ModelAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-ModelAndView%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5　ModelAndView对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="toc-number">4.4.</span> <span class="toc-text">4.4　数据验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-Hibernate-Validator%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1　Hibernate Validator简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2　数据校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JavaBean%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">1. JavaBean参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-URL%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">2. URL参数校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JavaBean%E5%AF%B9%E8%B1%A1%E7%BA%A7%E8%81%94%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">3. JavaBean对象级联校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">4. 分组校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3　自定义校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">1. 声明一个自定义校验注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">2. 使用自定义校验注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.5　拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1　应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-HandlerInterceptor%E7%AE%80%E4%BB%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2　HandlerInterceptor简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E4%BD%BF%E7%94%A8HandlerInterceptor%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3　使用HandlerInterceptor实现拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">4.6　过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1　过滤器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E4%BD%BF%E7%94%A8FilterRegistrationBean%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2　使用FilterRegistrationBean实现过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Web%E9%85%8D%E7%BD%AE"><span class="toc-number">4.7.</span> <span class="toc-text">4.7　Web配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-WebMvcConfigurer%E7%AE%80%E4%BB%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1　WebMvcConfigurer简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE"><span class="toc-number">4.7.2.</span> <span class="toc-text">4.7.2　跨域访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E9%85%8D%E7%BD%AE"><span class="toc-number">4.7.3.</span> <span class="toc-text">4.7.3　数据转换配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">4.7.4.</span> <span class="toc-text">4.7.4　静态资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-%E8%B7%B3%E8%BD%AC%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.7.5.</span> <span class="toc-text">4.7.5　跳转指定页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.</span> <span class="toc-text">4.8　实战：实现优雅的数据返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.8.1.</span> <span class="toc-text">4.8.1　为什么要统一返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.2.</span> <span class="toc-text">4.8.2　统一数据返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">1. 定义数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">2. 定义状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">4.8.2.3.</span> <span class="toc-text">3. 定义数据处理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E"><span class="toc-number">4.8.2.4.</span> <span class="toc-text">4. 处理数据返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.8.2.5.</span> <span class="toc-text">5. 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.8.3.</span> <span class="toc-text">4.8.3　全局异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.8.3.1.</span> <span class="toc-text">1. 全局异常处理的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-ControllerAdvice%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.8.3.2.</span> <span class="toc-text">2. 使用@ControllerAdvice注解实现全局异常处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">第5章　Thymeleaf模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Thymeleaf%E5%85%A5%E9%97%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1　Thymeleaf入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-Thymeleaf%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1　Thymeleaf简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Thymeleaf%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1. Thymeleaf的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Thymeleaf%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">2. Thymeleaf的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-Spring-Boot%E4%BD%BF%E7%94%A8Thymeleaf"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2　Spring Boot使用Thymeleaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-Thymeleaf%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3　Thymeleaf常用的配置参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Thymeleaf%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2　Thymeleaf表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1　变量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%80%89%E6%8B%A9%E6%88%96%E6%98%9F%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2　选择或星号表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-URL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3　URL表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">1. 引入静态资源文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-%E2%80%A6-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">2. 使用 @{…} 设置背景图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-URL%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">3. URL链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E6%96%87%E5%AD%97%E5%9B%BD%E9%99%85%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4　文字国际化表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">5.3　表达式的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1　赋值和拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E8%B5%8B%E5%80%BC"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">（1）文本赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E6%9C%AC%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">（2）文本拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2　条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-switch"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3　switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4　循环遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.</span> <span class="toc-text">5.3.5　运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">1. 算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">2. 关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.3.</span> <span class="toc-text">3. 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.4.</span> <span class="toc-text">4. 三目运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Thymeleaf%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">5.4　Thymeleaf的高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1　内联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">1. 文本内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%9A%E6%9C%AC%E5%86%85%E8%81%94"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">2. 脚本内联</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="github搜索技巧"/></a><div class="content"><a class="title" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧">github搜索技巧</a><time datetime="2023-12-10T12:59:37.000Z" title="发表于 2023-12-10 20:59:37">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="伙伴匹配系统"/></a><div class="content"><a class="title" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统">伙伴匹配系统</a><time datetime="2023-12-10T05:50:00.000Z" title="发表于 2023-12-10 13:50:00">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码托管怎么搞"/></a><div class="content"><a class="title" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞">代码托管怎么搞</a><time datetime="2023-12-09T01:20:35.000Z" title="发表于 2023-12-09 09:20:35">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用户中心"/></a><div class="content"><a class="title" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心">用户中心</a><time datetime="2023-12-05T06:58:33.000Z" title="发表于 2023-12-05 14:58:33">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2023-12-04T15:23:36.000Z" title="发表于 2023-12-04 23:23:36">2023-12-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>