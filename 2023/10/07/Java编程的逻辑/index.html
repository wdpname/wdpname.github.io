<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java编程的逻辑 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第三部分 泛型与容器第9章 列表和队列9.1刨析ArrayList9.1.1 基本用法12ArrayList&lt;Integer&gt; intList &#x3D; new ArrayList&lt;Integer&gt;();ArrayList&lt;String&gt; strList &#x3D; new ArrayList&lt;String&gt;(); 9.1.2 基本原理内部有一个数组element">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程的逻辑">
<meta property="og:url" content="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第三部分 泛型与容器第9章 列表和队列9.1刨析ArrayList9.1.1 基本用法12ArrayList&lt;Integer&gt; intList &#x3D; new ArrayList&lt;Integer&gt;();ArrayList&lt;String&gt; strList &#x3D; new ArrayList&lt;String&gt;(); 9.1.2 基本原理内部有一个数组element">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-07T08:55:18.000Z">
<meta property="article:modified_time" content="2023-10-07T12:43:20.967Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java编程的逻辑',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-07 20:43:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">156</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java编程的逻辑</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-07T12:43:20.967Z" title="更新于 2023-10-07 20:43:20">2023-10-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java编程的逻辑"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第三部分-泛型与容器"><a href="#第三部分-泛型与容器" class="headerlink" title="第三部分 泛型与容器"></a>第三部分 泛型与容器</h1><h2 id="第9章-列表和队列"><a href="#第9章-列表和队列" class="headerlink" title="第9章 列表和队列"></a>第9章 列表和队列</h2><h3 id="9-1刨析ArrayList"><a href="#9-1刨析ArrayList" class="headerlink" title="9.1刨析ArrayList"></a>9.1刨析ArrayList</h3><h4 id="9-1-1-基本用法"><a href="#9-1-1-基本用法" class="headerlink" title="9.1.1 基本用法"></a>9.1.1 基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-基本原理"><a href="#9-1-2-基本原理" class="headerlink" title="9.1.2 基本原理"></a>9.1.2 基本原理</h4><p>内部有一个数组elementData，一般会有一些预留的空间，有一个整数size记录实际的元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p>各种public方法内部操作的基本都是这个数组和这个整数，elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数。</p>
<p><strong>默认</strong>容量：DEFAULT_CAPACITY的值为10</p>
<p><strong>增容</strong>：newCapacity相当于oldCapacity的1.5倍，如果扩展1.5倍还是小于minCapacity，就扩展为minCapacity  </p>
<h4 id="9-1-3-迭代"><a href="#9-1-3-迭代" class="headerlink" title="9.1.3 迭代"></a>9.1.3 迭代</h4><p>ArrayList支持foreach语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line">intList.add(<span class="number">456</span>);</span><br><span class="line">intList.add(<span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer a : intList)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当然，这种循环也可以使用如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;intList.size(); i++)&#123;</span><br><span class="line">    System.out.println(intList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，foreach看上去更为简洁，而且它适用于各种容器，更为通用。</p>
<p>这种foreach语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = intList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1．迭代器接口"><a href="#1．迭代器接口" class="headerlink" title="1．迭代器接口"></a>1．迭代器接口</h5><p>ArrayList实现了Iterable接口，Iterable表示可迭代，Java 7中的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义很简单，就是要求实现iterator方法。iterator方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>它返回一个实现了Iterator接口的对象，Java 7中Iterator接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要对象实现了Iterable接口，就可以使用foreach语法，编译器会转换为调用Iterable和Iterator接口的方法。初次见到<strong>Iterable</strong>和<strong>Iterator</strong>，可能会比较容易混淆，我们再澄清一下：</p>
<p>❑ Iterable表示对象可以被迭代，它有一个方法iterator()，返回Iterator对象，实际通过Iterator接口的方法进行遍历；</p>
<p>❑ 如果对象实现了Iterable，就可以使用foreach语法；</p>
<p>❑ 类可以不实现Iterable，也可以创建Iterator对象。</p>
<h5 id="2-ListIterator"><a href="#2-ListIterator" class="headerlink" title="2. ListIterator"></a>2. ListIterator</h5><p>除了iterator(), ArrayList还提供了两个返回Iterator接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<h5 id="3．迭代的陷阱"><a href="#3．迭代的陷阱" class="headerlink" title="3．迭代的陷阱"></a>3．迭代的陷阱</h5><p>关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。比如，要删除一个整数ArrayList中所有小于100的数，直觉上，代码可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer a : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            list.remove(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但运行时会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>发生了并发修改异常，为什么呢？因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p>
<p>如何避免异常呢？可以使用迭代器的remove方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.next()&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器如何知道发生了结构性变化，并抛出异常？它自己的remove方法为何又可以使用呢？我们需要看下迭代器实现的原理。</p>
<h5 id="4．迭代器实现的原理"><a href="#4．迭代器实现的原理" class="headerlink" title="4．迭代器实现的原理"></a>4．迭代器实现的原理</h5><p>我们来看下ArrayList中iterator方法的实现，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了一个Itr对象，Itr是一个成员内部类，实现了Iterator接口，声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>它有三个实例成员变量，为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;        <span class="comment">//下一个要返回的元素位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//最后一个返回的索引位置，如果没有，为-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>
<p>cursor表示下一个要返回的元素位置，lastRet表示最后一个返回的索引位置，expected-ModCount表示期望的修改次数，初始化为外部类当前的修改次数modCount，回顾一下，成员内部类可以直接访问外部类的实例变量。每次发生结构性变化的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。</p>
<h5 id="5．迭代器的好处"><a href="#5．迭代器的好处" class="headerlink" title="5．迭代器的好处"></a>5．迭代器的好处</h5><p>​    为什么要通过迭代器这种方式访问元素呢？直接使用size()/get(index)语法不也可以吗？在一些场景下，确实没有什么差别，两者都可以。不过，foreach语法更为简洁一些，更重要的是，迭代器语法更为通用，它适用于各种容器类。此外，迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供Iterator接口的代码了解数据的组织方式，可以提供高效的实现。在ArrayList中， size/get(index)语法与迭代器性能是差不多的，但在后续介绍的其他容器中，则不一定，比如LinkedList，迭代器性能就要高很多。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口</p>
<h4 id="9-1-4-ArrayList实现的接口"><a href="#9-1-4-ArrayList实现的接口" class="headerlink" title="9.1.4 ArrayList实现的接口"></a>9.1.4 ArrayList实现的接口</h4><h5 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h5><p>Collection表示一个数据集合，数据间没有位置或顺序的概念</p>
<h5 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h5><p>List表示有顺序或位置的数据集合，它扩展了Collection</p>
<h5 id="3-RandomAccess"><a href="#3-RandomAccess" class="headerlink" title="3. RandomAccess"></a>3. RandomAccess</h5><p>RandomAccess的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有定义任何代码。这有什么用呢？这种没有任何代码的接口在Java中被称为<strong>标记接口</strong>，用于声明类的一种属性。</p>
<p>这里，实现了RandomAccess接口的类表示可以<strong>随机访问</strong>，可随机访问就是具备类似<strong>数组</strong>那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。下节我们会介绍LinkedList，它就不能随机访问</p>
<h3 id="9-2-剖析LinkedList"><a href="#9-2-剖析LinkedList" class="headerlink" title="9.2 剖析LinkedList"></a>9.2 剖析LinkedList</h3><h4 id="9-2-1-用法"><a href="#9-2-1-用法" class="headerlink" title="9.2.1 用法"></a>9.2.1 用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>Java中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口Deque中</p>
<p>Java中有一个类Stack，单词意思是栈，它也实现了栈的一些方法，如push/pop/peek等，但它没有实现Deque接口，它是Vector的子类(所以不推荐使用，推荐使用Deque)，它增加的这些方法也通过synchronized实现了线程安全，具体就不介绍了。不需要线程安全的情况下，推荐使用LinkedList或下节介绍的ArrayDeque</p>
<p>简单总结下：LinkedList的用法是比较简单的，与ArrayList用法类似，支持List接口，只是，LinkedList增加了一个接口Deque，可以把它看作队列、栈、双端队列，方便地在两端进行操作。如果只是用作List，那应该用ArrayList还是LinkedList呢？我们需要了解LinkedList的实现原理。</p>
<h4 id="9-2-2-实现原理"><a href="#9-2-2-实现原理" class="headerlink" title="9.2.2 实现原理"></a>9.2.2 实现原理</h4><p>​    我们知道，ArrayList内部是数组，元素在内存是连续存放的，但LinkedList不是。LinkedList直译就是链表，确切地说，它的内部实现是<strong>双向链表</strong>，每个元素在内存都是单独存放的，元素之间通过链接连在一起，类似于小朋友之间手拉手一样。</p>
<p>​    为了表示链接关系，需要一个节点的概念。节点包括实际的元素，但同时有两个链接，分别指向前一个节点（前驱）和后一个节点（后继）。节点是一个内部类，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedList内部组成就是如下三个实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-剖析ArrayDeque"><a href="#9-3-剖析ArrayDeque" class="headerlink" title="9.3 剖析ArrayDeque"></a>9.3 剖析ArrayDeque</h3><p>LinkedList实现了队列接口Queue和双端队列接口Deque, Java容器类中还有一个双端队列的实现类ArrayDeque，它是基于数组实现的。我们知道，一般而言，由于需要移动元素，数组的插入和删除效率比较低，但ArrayDeque的效率却非常高，它是怎么实现的呢？本节就来详细探讨。</p>
<p>ArrayDeque有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>numElements表示元素个数，初始分配的空间会至少容纳这么多元素，但空间不是正好numElements这么大，待会我们会介绍其实现细节。</p>
<p>ArrayDeque实现了Deque接口，同LinkedList一样，它的队列长度也是没有限制的， Deque扩展了Queue，有队列的所有方法，还可以看作栈，有栈的基本方法push/pop/peek，还有明确的操作两端的方法如addFirst/removeLast等，具体用法与LinkedList一节介绍的类似，就不赘述了，下面看其实现原理（基于Java 7）。</p>
<h4 id="9-3-1-实现原理"><a href="#9-3-1-实现原理" class="headerlink" title="9.3.1 实现原理"></a>9.3.1 实现原理</h4><p>ArrayDeque内部主要有如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>elements就是存储元素的数组。ArrayDeque的高效来源于head和tail这两个变量，它们使得物理上简单的从头到尾的数组变为了一个逻辑上循环的数组，避免了在头尾操作时的移动。我们来解释下循环数组的概念。</p>
<h5 id="1．循环数组"><a href="#1．循环数组" class="headerlink" title="1．循环数组"></a>1．循环数组</h5><p>对于一般数组，比如arr，第一个元素为arr[0]，最后一个为arr[arr.length-1]。但对于ArrayDeque中的数组，它是一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始，数组的长度、第一个和最后一个元素都与head和tail这两个变量有关，具体来说：</p>
<p>1）如果head和tail相同，则数组为空，长度为0。</p>
<p>2）如果tail大于head，则第一个元素为elements[head]，最后一个为elements[tail-1]，长度为tail-head，元素索引从head到tail-1。</p>
<p>3）如果tail小于head，且为0，则第一个元素为elements[head]，最后一个为elements [elements.length-1]，元素索引从head到elements.length-1。</p>
<p>4）如果tail小于head，且大于0，则会形成循环，第一个元素为elements[head]，最后一个是elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1。</p>
<h2 id="第10章-Map和Set"><a href="#第10章-Map和Set" class="headerlink" title="第10章 Map和Set"></a>第10章 Map和Set</h2><h3 id="10-1-剖析HashMap"><a href="#10-1-剖析HashMap" class="headerlink" title="10.1 剖析HashMap"></a>10.1 剖析HashMap</h3><p>​    字面上看，HashMap由Hash和Map两个单词组成，这里Map不是地图的意思，而是表示映射关系，是一个接口，实现Map接口有多种方式，HashMap实现的方式利用了哈希（Hash）。下面先来看Map接口，接着看HashMap的用法，然后看实现原理，最后总结分析HashMap的特点。</p>
<h4 id="10-1-1-Map接口"><a href="#10-1-1-Map接口" class="headerlink" title="10.1.1 Map接口"></a>10.1.1 Map接口</h4><p>​    Map有键和值的概念。一个键映射到一个值，Map按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用Map可以方便地处理需要根据键访问对象的场景。</p>
<p>Map中的键是没有重复的，所以ketSet()返回了一个Set。keySet()、values()、entrySet()有一个共同的特点，它们返回的都是视图，不是复制的值，基于返回值的修改会直接修改Map自身，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.keySet().clear();</span><br></pre></td></tr></table></figure>
<p>会删除所有键值对。</p>
<p>​    Set是一个接口，表示的是数学中的集合概念，即没有重复的元素集合.它扩展了Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保Set的语义约束，即不能有重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-2-HashMap"><a href="#10-1-2-HashMap" class="headerlink" title="10.1.2 HashMap"></a>10.1.2 HashMap</h4><p>HashMap还有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>最后一个以一个已有的Map构造，复制其中的所有键值对到当前Map。前两个涉及参数initialCapacity和loadFactor，它们是什么意思呢？我们需要看下HashMap的实现原理。</p>
<h4 id="10-1-3-实现原理"><a href="#10-1-3-实现原理" class="headerlink" title="10.1.3 实现原理"></a>10.1.3 实现原理</h4><h5 id="1．内部组成"><a href="#1．内部组成" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>HashMap内部有如下几个主要的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K, V&gt;[] table = (Entry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>size表示实际键值对的个数。table是一个Entry类型的数组，称为哈希表或哈希桶，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对。Entry是一个内部类，它的实例变量和构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K, V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，key和value分别表示键和值，next指向下一个Entry节点，hash是key的hash值，待会我们会介绍其计算方法。直接存储hash值是为了在比较的时候加快计算，待会我们看代码。</p>
<p>table的初始值为EMPTY_TABLE，是一个空表，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;? , ? &gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>当添加键值对后，table就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于ArrayList。添加第一个元素时，默认分配的大小为<strong>16</strong>，不过，并不是size大于16时再进行扩展，下次什么时候扩展与threshold有关。</p>
<p>threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。threshold是怎么算出来的呢？一般而言，threshold等于table.length乘以loadFactor。比如，如果table. length为16, loadFactor为0.75，则threshold为12。loadFactor是负载因子，表示整体上table被占用的程度，是一个浮点数，默认为0.75，可以通过构造方法进行修改。</p>
<h5 id="2．默认构造方法"><a href="#2．默认构造方法" class="headerlink" title="2．默认构造方法"></a>2．默认构造方法</h5><p>默认构造方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DEFAULT_INITIAL_CAPACITY为16, DEFAULT_LOAD_FACTOR为0.75，默认构造方法调用的构造方法主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是设置loadFactor和threshold的初始值。</p>
<h5 id="6．实现原理小结"><a href="#6．实现原理小结" class="headerlink" title="6．实现原理小结"></a>6．实现原理小结</h5><p>需要说明的是，Java 8对HashMap的实现进行了优化，在哈希冲突比较严重的情况下，即大量元素映射到同一个链表的情况下（具体是至少8个元素，且总的键值对个数至少是64）, <strong>Java 8会将该链表转换为一个平衡的排序二叉树，以提高查询的效率</strong>，关于排序二叉树我们在10.3节介绍，Java 8的具体代码就不介绍了。</p>
<h3 id="10-2-剖析HashSet"><a href="#10-2-剖析HashSet" class="headerlink" title="10.2 剖析HashSet"></a>10.2 剖析HashSet</h3><p>10.1节提到了Set接口，Map接口的两个方法keySet和entrySet返回的都是Set，本节介绍Set接口的一个重要实现类HashSet。与HashMap类似，字面上看，HashSet由两个单词组成：Hash和Set。其中，Set表示接口，实现Set接口也有多种方式，各有特点，Hash-Set实现的方式利用了Hash</p>
<h4 id="10-2-1-用法"><a href="#10-2-1-用法" class="headerlink" title="10.2.1 用法"></a>10.2.1 用法</h4><p>与HashMap类似，HashSet的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>initialCapacity和loadFactor的含义与HashMap中的是一样的。</p>
<p>HashSet的使用也很简单，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">set.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;老马&quot;</span>&#125;));</span><br><span class="line"><span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">    System.out.print(s+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 老马 world</span><br></pre></td></tr></table></figure>
<p>“hello”被添加了两次，但只会保存一份，输出也没有什么特别的顺序。</p>
<p>与HashMap类似，HashSet要求元素重写hashCode和equals方法，且对于两个对象，如果equals相同，则hashCode也必须相同，如果元素是自定义的类，需要注意这一点。比如，有一个表示规格的类Spec，有大小和颜色两个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spec</span> &#123;</span><br><span class="line">    String size;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Spec</span><span class="params">(String size, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[size=&quot;</span> + size + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spec的Set为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Spec&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Spec&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[size=M, color=red], [size=M, color=red]]</span><br></pre></td></tr></table></figure>
<p>同一个规格输出了两次，为避免这一点，需要为Spec重写hashCode和equals方法。</p>
<h4 id="10-2-2-实现原理"><a href="#10-2-2-实现原理" class="headerlink" title="10.2.2 实现原理"></a>10.2.2 实现原理</h4><p>HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>我们知道，Map有键和值，HashSet相当于只有键，值都是相同的固定值，这个值的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h3 id="10-3-排序二叉树"><a href="#10-3-排序二叉树" class="headerlink" title="10.3 排序二叉树"></a>10.3 排序二叉树</h3><p>​    HashMap和HashSet的共同实现机制是哈希表，一个共同的限制是<strong>没有顺序</strong>，我们提到，它们都有一个能保持顺序的对应类<strong>TreeMap</strong>和<strong>TreeSet</strong>，这两个类的共同实现基础是排序二叉树。为了更好地理解TreeMap和TreeSet，</p>
<h4 id="10-3-3-平衡的排序二叉树"><a href="#10-3-3-平衡的排序二叉树" class="headerlink" title="10.3.3 平衡的排序二叉树"></a>10.3.3 平衡的排序二叉树</h4><p>在TreeMap的实现中，用的并不是AVL树，而是<strong>红黑树</strong>，与AVL树类似，红黑树也是一种平衡的排序二叉树，也是在插入和删除节点时通过旋转操作来平衡的，但它并不是高度平衡的，而是大致平衡的。所谓大致是指，它确保任意一条从根到叶子节点的路径，没有任何一条路径的长度会比其他路径长过两倍红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树。</p>
<p>为什么叫红黑树呢？因为它对每个节点进行着色，颜色或黑或红，并对节点的着色有一些约束，满足这个约束即可以确保树是大致平衡的。</p>
<p>对AVL树和红黑树，它们保持平衡的细节都是比较复杂的，我们就不介绍了，需要知道的是，它们都是排序二叉树，都通过在插入和删除时执行开销不大的旋转操作保持了树的高度平衡或大致平衡，从而保证了树的查找效率。</p>
<h3 id="10-4-剖析TreeMap"><a href="#10-4-剖析TreeMap" class="headerlink" title="10.4 剖析TreeMap"></a>10.4 剖析TreeMap</h3><p>​    在介绍HashMap时，我们提到，HashMap有一个重要局限，键值对之间没有特定的顺序，我们还提到，Map接口有另一个重要的实现类TreeMap，在TreeMap中，键值对之间按键有序，TreeMap的实现基础是<strong>排序二叉树</strong></p>
<h4 id="10-4-1-基本用法"><a href="#10-4-1-基本用法" class="headerlink" title="10.4.1 基本用法"></a>10.4.1 基本用法</h4><p>​    TreeMap有两个基本构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个为默认构造方法，如果使用默认构造方法，要求Map中的键实现Comparabe接口，TreeMap内部进行各种比较时会调用键的Comparable接口中的compareTo方法。</p>
<p>第二个接受一个比较器对象comparator，如果comparator不为null，在TreeMap内部进行比较时会调用这个comparator的compare方法，而不再调用键的compareTo方法，也不再要求键实现Comparable接口。</p>
<p>应该用哪一个呢？第一个更为简单，但要求键实现Comparable接口，且期望的排序和键的比较结果是一致的；第二个更为灵活，不要求键实现Comparable接口，比较器可以用灵活复杂的方式进行实现。</p>
<p>需要强调的是，TreeMap是按键而不是按值有序，无论哪一种，都是对键而非值进行比较。</p>
<p>看段简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个TreeMap，但只是当作Map使用，不过迭代时，其输出却是按键排序的，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=tree a=<span class="keyword">abstract</span> b=basic c=call</span><br></pre></td></tr></table></figure>
<p>T排在最前面，是因为大写字母的ASCII码都小于小写字母。如果希望忽略大小写呢？可以传递一个比较器，String类有一个静态成员CASE_INSENSITIVE_ORDER，它就是一个忽略大小写的Comparator对象，替换第一行代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure>
<p>输出就会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">abstract</span> b=basic c=call T=tree</span><br></pre></td></tr></table></figure>
<p>正常排序是从小到大，如果希望逆序呢？可以传递一个不同的Comparator对象，第一行代码可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=call b=basic a=<span class="keyword">abstract</span> T=tree</span><br></pre></td></tr></table></figure>
<p>为什么这样就可以逆序呢？正常排序中，compare方法内是o1.compareTo(o2)，两个对象翻过来，自然就是逆序了，Collections类有一个静态方法reverseOrder()可以返回一个逆序比较器，也就是说，上面的代码也可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p>如果希望逆序且忽略大小写呢？第一行可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">        Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>需要说明的是，TreeMap使用键的比较结果对键进行排重，即使键实际上不同，但只要比较结果相同，它们就会被认为相同，键只会保存一份。比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;try&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去有两个不同的键”T”和”t”，但因为比较器忽略大小写，所以只会有一个，输出会是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="keyword">try</span></span><br></pre></td></tr></table></figure>
<p>键为第一次put时的，这里即”T”，而值为最后一次put时的，这里即”try”。</p>
<p>我们再来看一个例子，键为字符串形式的日期，值为一个统计数字，希望按照日期输出，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;2016-7-3&quot;</span>, <span class="number">100</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-7-10&quot;</span>, <span class="number">120</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-8-1&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.println(kv.getKey()+<span class="string">&quot;, &quot;</span>+kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>7月10号的排在了7月3号的前面，与期望的不符，这是因为，它们是按照字符串比较的，按字符串，2016-7-10就是小于2016-7-3，因为第一个不同之处1小于3。</p>
<p>怎么解决呢？可以使用一个自定义的比较器，将字符串转换为日期，按日期进行比较，第一行代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(o1).compareTo(sdf.parse(o2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出就符合期望了，会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>以上就是TreeMap的基本用法，与HashMap相比：相同的是，它们都实现了Map接口，都可以按Map进行操作。不同的是，迭代时，TreeMap按键有序，为了实现有序，它要求要么键实现Comparable接口，要么创建TreeMap时传递一个Comparator对象。</p>
<h4 id="10-4-2-实现原理"><a href="#10-4-2-实现原理" class="headerlink" title="10.4.2 实现原理"></a>10.4.2 实现原理</h4><p>TreeMap内部是用红黑树实现的，红黑树是一种大致平衡的排序二叉树</p>
<h5 id="1．内部组成-1"><a href="#1．内部组成-1" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>TreeMap内部主要有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>comparator就是比较器，在构造方法中传递，如果没传，就是null。size为当前键值对个数。root指向树的根节点，从根节点可以访问到每个节点，节点的类型为Entry。Entry是TreeMap的一个内部类，其内部成员和构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; left = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; right = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K, V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点除了键（key）和值（value）之外，还有三个引用，分别指向其左孩子（left）、右孩子（right）和父节点（parent），对于根节点，父节点为null，对于叶子节点，孩子节点都为null，还有一个成员color表示颜色，TreeMap是用红黑树实现的，每个节点都有一个颜色，非黑即红。</p>
<h3 id="10-5-剖析TreeSet"><a href="#10-5-剖析TreeSet" class="headerlink" title="10.5 剖析TreeSet"></a>10.5 剖析TreeSet</h3><p>在介绍HashSet时，我们提到，HashSet有一个重要局限，元素之间没有特定的顺序，我们还提到，Set接口还有另一个重要的实现类TreeSet，它是有序的，与HashSet和HashMap的关系一样，TreeSet是基于TreeMap的</p>
<h4 id="10-5-1-基本用法"><a href="#10-5-1-基本用法" class="headerlink" title="10.5.1 基本用法"></a>10.5.1 基本用法</h4><p>TreeSet的基本构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个是默认构造方法，假定元素实现了Comparable接口；第二个使用传入的比较器，不要求元素实现Comparable。TreeSet经常也只是当作Set使用，只是希望迭代输出有序，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">    System.out.print(w+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash map tree</span><br></pre></td></tr></table></figure>
<p>TreeSet实现了两点：排重和有序。如果希望不同的排序，可以传递一个Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;Map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>
<p>忽略大小写进行比较，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hash, map, tree]</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Set是排重的，排重是基于比较结果的，结果为0即视为相同，”map”和”Map”虽然不同，但比较结果为0，所以只会保留第一个元素。</p>
<h4 id="10-5-2-实现原理"><a href="#10-5-2-实现原理" class="headerlink" title="10.5.2 实现原理"></a>10.5.2 实现原理</h4><p>之前章节介绍过，HashSet是基于HashMap实现的，元素就是HashMap中的键，值是一个固定的值，TreeSet是类似的，它是基于TreeMap实现的。</p>
<p>TreeSet的内部有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E, Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>m就是背后的那个TreeMap，这里用的是更为通用的接口类型NavigableMap,PRESENT就是那个固定的共享值。TreeSet的方法实现主要就是调用m的方法，我们具体来看下。</p>
<p>TreeSet的实现代码都比较简单，主要就是调用内部NavigatableMap的方法。</p>
<h3 id="10-6-剖析LinkedHashMap"><a href="#10-6-剖析LinkedHashMap" class="headerlink" title="10.6 剖析LinkedHashMap"></a>10.6 剖析LinkedHashMap</h3><p>前面我们介绍了Map接口的两个实现类HashMap和TreeMap，本节介绍另一个实现类LinkedHashMap。它是HashMap的子类，但可以保持元素按插入或访问有序，这与TreeMap按键排序不同。按插入有序容易理解，按访问有序是什么意思呢？这两个有序有什么用呢？内部是怎么实现的？本节就来探讨这些问题，从用法开始。</p>
<h4 id="10-6-1-基本用法"><a href="#10-6-1-基本用法" class="headerlink" title="10.6.1 基本用法"></a>10.6.1 基本用法</h4><p>LinkedHashMap是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。LinkedHashMap支持两种顺序：一种是插入顺序；另外一种是访问顺序。</p>
<p>插入顺序容易理解，先添加的在前面，后添加的在后面，修改操作不影响顺序。访问顺序是什么意思呢？所谓访问是指get/put操作，对一个键执行get/put操作后，其对应的键值对会移到链表末尾，所以，最末尾的是最近访问的，最开始的最久没被访问的，这种顺序就是访问顺序。</p>
<p>LinkedHashMap有5个构造方法，其中4个都是按插入顺序，只有一个构造方法可以指定按访问顺序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> accessOrder)</span></span><br></pre></td></tr></table></figure>
<p>其中参数accessOrder就是用来指定是否按访问顺序，如果为true，就是访问顺序。默认情况下，LinkedHashMap是按插入有序的，我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; seqMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">seqMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : seqMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>键是按照”c”、”d”、”a”的顺序插入的，修改”d”的值不会修改顺序，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br><span class="line">a <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望保持插入顺序呢？</p>
<p>Map经常用来处理一些数据，其处理模式是：接收一些键值对作为输入，处理，然后输出，输出时希望保持原来的顺序。比如一个配置文件，其中有一些键值对形式的配置项，但其中有一些键是重复的，希望保留最后一个值，但还是按原来的键顺序输出， LinkedHashMap就是一个合适的数据结构。</p>
<p>再如，希望的数据模型可能就是一个Map，但希望保持添加的顺序，如一个购物车，键为购买项目，值为购买数量，按用户添加的顺序保存。</p>
<p>另外一种常见的场景是：希望Map能够按键有序，但在添加到Map前，键已经通过其他方式排好序了，这时，就没有必要使用TreeMap了，毕竟TreeMap的开销要大一些。比如，在从数据库查询数据放到内存时，可以使用SQL的order by语句让数据库对数据排序。</p>
<p>我们来看按访问有序的例子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; accessMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">accessMap.get(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : accessMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次访问都会将该键值对移到末尾，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">500</span></span><br><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望按访问有序呢？一种典型的应用是LRU缓存。</p>
<p>使用LinkedHashMap，可以非常容易地实现LRU缓存，默认情况下，LinkedHashMap没有对容量做限制，但它可以容易地做到，它有一个protected方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加元素到LinkedHashMap后，LinkedHashMap会调用这个方法，传递的参数是最久没被访问的键值对，如果这个方法返回true，则这个最久的键值对就会被删除。Linked-HashMap的实现总是返回false，所有容量没有限制，但子类可以重写该方法，在满足一定条件的情况，返回true。</p>
<p>代码清单如下就是一个简单的LRU缓存的实现，它有一个容量限制，这个限制在构造方法中传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxEntries;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> maxEntries)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个缓存可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">System.out.println(cache);</span><br></pre></td></tr></table></figure>
<p>限定缓存容量为3，先后添加了4个键值对，最久没被访问的键是”b”，会被删除，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;c=call, a=<span class="keyword">abstract</span>, d=call&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-6-2-实现原理"><a href="#10-6-2-实现原理" class="headerlink" title="10.6.2 实现原理"></a>10.6.2 实现原理</h4><p>理解了LinkedHashMap的用法，下面我们来看其实现代码（基于Java 7）。先来看内部组成，再看一些主要方法的实现。LinkedHashMap是HashMap的子类，内部增加了如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; header;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>accessOrder表示是按访问顺序还是插入顺序。header表示双向链表的头，它的类型Entry是一个内部类，这个类是HashMap.Entry的子类，增加了两个变量before和after，指向链表中的前驱和后继.Entry的完整定义如代码清单如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    Entry&lt;K, V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">          before.after = after;</span><br><span class="line">          after.before = before;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K, V&gt; existingEntry)</span> &#123;</span><br><span class="line">          after   = existingEntry;</span><br><span class="line">          before = existingEntry.before;</span><br><span class="line">          before.after = <span class="built_in">this</span>;</span><br><span class="line">          after.before = <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          LinkedHashMap&lt;K, V&gt; lm = (LinkedHashMap&lt;K, V&gt;)m;</span><br><span class="line">          <span class="keyword">if</span>(lm.accessOrder) &#123;</span><br><span class="line">              lm.modCount++;</span><br><span class="line">              remove();</span><br><span class="line">              addBefore(lm.header);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordRemoval</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>recordAccess和recordRemoval是HashMap.Entry中定义的方法，在HashMap中，这两个方法的实现为空，它们就是被设计用来被子类重写的。在put被调用且键存在时，HashMap会调用Entry的recordAccess方法；在键被删除时，HashMap会调用Entry的recordRemoval方法。</p>
<p>LinkedHashMap.Entry重写了这两个方法。在recordAccess方法中，如果是按访问顺序的，则将该节点移到链表的末尾；在recordRemoval方法中，将该节点从链表中移除。</p>
<h4 id="10-6-3-LinkedHashSet"><a href="#10-6-3-LinkedHashSet" class="headerlink" title="10.6.3 LinkedHashSet"></a>10.6.3 LinkedHashSet</h4><p>之前介绍的Map接口的实现类都有一个对应的Set接口的实现类，比如HashMap有HashSet, TreeMap有TreeSet, LinkedHashMap也不例外，它也有一个对应的Set接口的实现类LinkedHashSet。LinkedHashSet是HashSet的子类，它内部的Map的实现类是LinkedHashMap,所以它也可以保持插入顺序,比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b, c, a]</span><br></pre></td></tr></table></figure>
<p>LinkedHashSet的实现比较简单.</p>
<h3 id="10-7-剖析EnumMap"><a href="#10-7-剖析EnumMap" class="headerlink" title="10.7 剖析EnumMap"></a>10.7 剖析EnumMap</h3><p>如果需要一个Map的实现类，并且键的类型为<strong>枚举类型</strong>，可以使用HashMap，但应该使用一个专门的实现类<strong>EnumMap</strong>。为什么要有一个专门的类呢？我们之前介绍过枚举的本质，主要是因为枚举类型有两个特征：一是它可能的值是有限的且预先定义的；二是枚举值都有一个顺序，这两个特征使得可以更为高效地实现Map接口。我们先来看EnumMap的用法，然后看它到底是怎么实现的。</p>
<h3 id="10-8-剖析EnumSet"><a href="#10-8-剖析EnumSet" class="headerlink" title="10.8 剖析EnumSet"></a>10.8 剖析EnumSet</h3><p>本节介绍同样针对枚举类型的Set接口的实现类EnumSet。与EnumMap类似，之所以会有一个专门的针对枚举类型的实现类，主要是因为它可以非常高效地实现Set接口。</p>
<p>之前介绍的Set接口的实现类HashSet/TreeSet，它们内部都是用对应的HashMap/TreeMap实现的，但EnumSet不是，<strong>它的实现与EnumMap没有任何关系</strong>，而是用极为精简和高效的位向量实现的。位向量是计算机程序中解决问题的一种常用方式，我们有必要理解和掌握</p>
<p>除了实现机制，EnumSet的用法也有一些不同。EnumSet可以说是<strong>处理枚举类型数据的一把利器</strong>，在一些应用领域，它非常方便和高效。</p>
<h4 id="10-8-1-基本用法"><a href="#10-8-1-基本用法" class="headerlink" title="10.8.1 基本用法"></a>10.8.1 基本用法</h4><p>与TreeSet/HashSet不同，EnumSet是一个抽象类，不能直接通过new新建</p>
<p>不过，EnumSet提供了若干静态工厂方法，可以创建EnumSet类型的对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br></pre></td></tr></table></figure>
<p>noneOf方法会创建一个指定枚举类型的EnumSet，不含任何元素。创建的EnumSet对象的实际类型是EnumSet的子类，待会我们再分析其具体实现。</p>
<p>为方便举例，我们定义一个表示星期几的枚举类Day，值从周一到周日，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么用noneOf方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; weekend = EnumSet.noneOf(Day.class);</span><br><span class="line">weekend.add(Day.SATURDAY);</span><br><span class="line">weekend.add(Day.SUNDAY);</span><br><span class="line">System.out.println(weekend);</span><br></pre></td></tr></table></figure>
<p>weekend表示休息日，noneOf返回的Set为空，添加了周六和周日，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SATURDAY, SUNDAY]</span><br></pre></td></tr></table></figure>
<h4 id="10-8-2-应用场景"><a href="#10-8-2-应用场景" class="headerlink" title="10.8.2 应用场景"></a>10.8.2 应用场景</h4><p>下面，我们通过一个场景来看EnumSet的应用。想象一个场景，在一些工作中（如医生、客服），不是每个工作人员每天都在的，每个人可工作的时间是不一样的，比如张三可能是周一和周三，李四可能是周四和周六，给定每个人可工作的时间，我们可能有一些问题需要回答。比如：</p>
<p>❑ 有没有哪天一个人都不会来？</p>
<p>❑ 有哪些天至少会有一个人来？</p>
<p>❑ 有哪些天至少会有两个人来？</p>
<p>❑ 有哪些天所有人都会来，以便开会？</p>
<p>❑ 哪些人周一和周二都会来？</p>
<p>使用EnumSet，可以方便高效地回答这些问题，怎么做呢？我们先来定义一个表示工作人员的类Worker，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Set&lt;Day&gt; availableDays;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, Set&lt;Day&gt; availableDays)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.availableDays = availableDays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为演示方便，将所有工作人员的信息放到一个数组workers中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.FRIDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李四&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;王五&quot;</span>, EnumSet.of(Day.TUESDAY, Day.THURSDAY)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个工作人员的可工作时间用一个EnumSet表示。有了这个信息，我们就可以回答以上的问题了。哪些天一个人都不会来？代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.removeAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>days初始化为所有值，然后遍历workers，从days中删除可工作的所有时间，最终剩下的就是一个人都不会来的时间，这实际是在求worker时间并集的补集，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SUNDAY]</span><br></pre></td></tr></table></figure>
<p>有哪些天至少会有一个人来？就是求worker时间的并集，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.addAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]</span><br></pre></td></tr></table></figure>
<h2 id="第11章-堆与优先级队列"><a href="#第11章-堆与优先级队列" class="headerlink" title="第11章 堆与优先级队列"></a>第11章 堆与优先级队列</h2><p>前面两章介绍了Java中的基本容器类，每个容器类背后都有一种数据结构，ArrayList是动态数组，LinkedList是链表，HashMap/HashSet是哈希表，TreeMap/TreeSet是红黑树，本章介绍另一种数据结构：堆。之前我们提到过堆，那里，堆指的是内存中的区域，保存动态分配的对象，与栈相对应。这里的堆是一种数据结构，与内存区域和分配无关。</p>
<p>堆到底是什么结构呢？这个待会再细看。我们先来说明，堆有什么用？为什么要介绍它？<strong>堆可以非常高效方便地解决很多问题</strong>。比如：</p>
<p>1）优先级队列，我们之前介绍的队列实现类LinkedList是按添加顺序排列的，但现实中，经常需要按优先级来，每次都应该处理当前队列中优先级最高的，高优先级的即使来得晚，也应该被优先处理。</p>
<p>2）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。</p>
<p>3）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，甚至源源不断到来。</p>
<h3 id="11-1-堆的概念与算法"><a href="#11-1-堆的概念与算法" class="headerlink" title="11.1 堆的概念与算法"></a>11.1 堆的概念与算法</h3><p>我们先来了解堆的概念，然后介绍堆的一些主要算法。</p>
<h4 id="11-1-1-基本概念"><a href="#11-1-1-基本概念" class="headerlink" title="11.1.1 基本概念"></a>11.1.1 基本概念</h4><p>堆首先是一棵二叉树，但它是<strong>完全二叉树</strong>。</p>
<h3 id="11-2-剖析PriorityQueue"><a href="#11-2-剖析PriorityQueue" class="headerlink" title="11.2 剖析PriorityQueue"></a>11.2 剖析PriorityQueue</h3><p>节探讨堆在Java中的具体实现类：PriorityQueue。顾名思义，PriorityQueue是优先级队列，它首先实现了队列接口（Queue），与LinkedList类似，它的队列长度也没有限制，与一般队列的区别是，它有优先级的概念，每个元素都有优先级，队头的元素永远都是优先级最高的。</p>
<p>PriorityQueue内部是用堆实现的，内部元素不是完全有序的，不过，逐个出队会得到有序的输出。虽然名字叫优先级队列，但也可以将PriorityQueue看作一种比较通用的实现了堆的性质的数据结构，可以用PriorityQueue来解决适合用堆解决的问题，下一小节我们会来看一些具体的例子。下面，我们先介绍其用法，接着分析实现代码，最后总结分析其特点。</p>
<h2 id="第12章-通用容器类和总结"><a href="#第12章-通用容器类和总结" class="headerlink" title="第12章 通用容器类和总结"></a>第12章 通用容器类和总结</h2><p>之前的章节中，我们介绍的都是具体的容器类，本章介绍一些抽象容器类、一些通用的算法和功能，并对整个容器类体系进行梳理总结。</p>
<p>之前介绍的具体容器类其实都不是从头构建的，它们都继承了一些抽象容器类。这些抽象类提供了容器接口的部分实现，方便了Java具体容器类的实现。此外，通过继承抽象类，自定义的类也可以更为容易地实现容器接口。为什么需要实现容器接口呢？至少有两个原因。</p>
<p>1）容器类是一个大家庭，它们之间可以方便地协作，比如很多方法的参数和返回值都是容器接口对象，实现了容器接口，就可以方便地参与这种协作。</p>
<p>2）Java有一个类Collections，提供了很多针对容器接口的通用算法和功能，实现了容器接口，可以直接利用Collections中的算法和功能。</p>
<h3 id="12-1-抽象容器类"><a href="#12-1-抽象容器类" class="headerlink" title="12.1 抽象容器类"></a>12.1 抽象容器类</h3><p>抽象容器类与之前介绍的接口和具体容器类的关系如图12-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310072039878.png" alt="image-20231007203919721"></p>
<p>虚线框表示接口，有Collection、List、Set、Queue、Deque和Map。有6个抽象容器类。</p>
<p>1）AbstractCollection：实现了Collection接口，被抽象类AbstractList、AbstractSet、AbstractQueue继承，ArrayDeque也继承自AbstractCollection（图中未画出）。</p>
<p>2）AbstractList：父类是AbstractCollection，实现了List接口，被ArrayList、Abstract-SequentialList继承。</p>
<p>3）AbstractSequentialList：父类是AbstractList，被LinkedList继承。</p>
<p>4）AbstractMap：实现了Map接口，被TreeMap、HashMap、EnumMap继承。</p>
<p>5）AbstractSet：父类是AbstractCollection，实现了Set接口，被HashSet、TreeSet和EnumSet继承。</p>
<p>6）AbstractQueue：父类是AbstractCollection，实现了Queue接口，被PriorityQueue继承。</p>
<h3 id="12-2-Collections"><a href="#12-2-Collections" class="headerlink" title="12.2 Collections"></a>12.2 Collections</h3><p>类Collections以静态方法的方式提供了很多通用算法和功能，这些功能大概可以分为两类。</p>
<p>1）对容器接口对象进行操作。</p>
<p>2）返回一个容器接口对象。</p>
<h1 id="第四部分-文件"><a href="#第四部分-文件" class="headerlink" title="第四部分 文件"></a>第四部分 文件</h1><h2 id="第13章-文件基本技术"><a href="#第13章-文件基本技术" class="headerlink" title="第13章 文件基本技术"></a>第13章 文件基本技术</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/">https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript高级程序设计（第三版）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div><div><a href="/2022/11/10/SpringMVC%E5%9F%BA%E7%A1%80/" title="SpringMVC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">SpringMVC基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">156</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">第三部分 泛型与容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">第9章 列表和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E5%88%A8%E6%9E%90ArrayList"><span class="toc-number">1.1.1.</span> <span class="toc-text">9.1刨析ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">9.1.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">9.1.2 基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">9.1.3 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">1．迭代器接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ListIterator"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">2. ListIterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E8%BF%AD%E4%BB%A3%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">3．迭代的陷阱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.3.4.</span> <span class="toc-text">4．迭代器实现的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.1.3.5.</span> <span class="toc-text">5．迭代器的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-ArrayList%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">9.1.4 ArrayList实现的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Collection"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text">1. Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-List"><span class="toc-number">1.1.1.4.2.</span> <span class="toc-text">2. List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-RandomAccess"><span class="toc-number">1.1.1.4.3.</span> <span class="toc-text">3. RandomAccess</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%89%96%E6%9E%90LinkedList"><span class="toc-number">1.1.2.</span> <span class="toc-text">9.2 剖析LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">9.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">9.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%89%96%E6%9E%90ArrayDeque"><span class="toc-number">1.1.3.</span> <span class="toc-text">9.3 剖析ArrayDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">9.3.1 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">1．循环数组</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-Map%E5%92%8CSet"><span class="toc-number">1.2.</span> <span class="toc-text">第10章 Map和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%89%96%E6%9E%90HashMap"><span class="toc-number">1.2.1.</span> <span class="toc-text">10.1 剖析HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">10.1.1 Map接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-HashMap"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">10.1.2 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">10.1.3 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">1．内部组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">2．默认构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">6．实现原理小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%89%96%E6%9E%90HashSet"><span class="toc-number">1.2.2.</span> <span class="toc-text">10.2 剖析HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">10.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">10.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">10.3 排序二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">10.3.3 平衡的排序二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%89%96%E6%9E%90TreeMap"><span class="toc-number">1.2.4.</span> <span class="toc-text">10.4 剖析TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">10.4.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">10.4.2 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-1"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">1．内部组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%89%96%E6%9E%90TreeSet"><span class="toc-number">1.2.5.</span> <span class="toc-text">10.5 剖析TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">10.5.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">10.5.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E5%89%96%E6%9E%90LinkedHashMap"><span class="toc-number">1.2.6.</span> <span class="toc-text">10.6 剖析LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">10.6.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">10.6.2 实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-3-LinkedHashSet"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">10.6.3 LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E5%89%96%E6%9E%90EnumMap"><span class="toc-number">1.2.7.</span> <span class="toc-text">10.7 剖析EnumMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-%E5%89%96%E6%9E%90EnumSet"><span class="toc-number">1.2.8.</span> <span class="toc-text">10.8 剖析EnumSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">10.8.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">10.8.2 应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">第11章 堆与优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">11.1 堆的概念与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">11.1.1 基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%89%96%E6%9E%90PriorityQueue"><span class="toc-number">1.3.2.</span> <span class="toc-text">11.2 剖析PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">第12章 通用容器类和总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%8A%BD%E8%B1%A1%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">12.1 抽象容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Collections"><span class="toc-number">1.4.2.</span> <span class="toc-text">12.2 Collections</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">第四部分 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">第13章 文件基本技术</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程的逻辑"/></a><div class="content"><a class="title" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑">Java编程的逻辑</a><time datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript高级程序设计（第三版）"/></a><div class="content"><a class="title" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）">JavaScript高级程序设计（第三版）</a><time datetime="2023-10-05T14:44:18.000Z" title="发表于 2023-10-05 22:44:18">2023-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树的技巧"/></a><div class="content"><a class="title" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧">二叉树的技巧</a><time datetime="2023-08-15T04:23:33.000Z" title="发表于 2023-08-15 12:23:33">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表的技巧"/></a><div class="content"><a class="title" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧">链表的技巧</a><time datetime="2023-08-14T04:03:55.000Z" title="发表于 2023-08-14 12:03:55">2023-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/7-21/" title="7-21"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="7-21"/></a><div class="content"><a class="title" href="/2023/07/21/7-21/" title="7-21">7-21</a><time datetime="2023-07-21T03:07:00.000Z" title="发表于 2023-07-21 11:07:00">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>