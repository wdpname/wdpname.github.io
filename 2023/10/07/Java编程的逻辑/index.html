<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java编程的逻辑 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第二部分 面向对象第3章 类的基础程序主要就是数据以及对数据的操作，为方便理解和操作，高级语言使用数据类型这个概念，不同的数据类型有不同的特征和操作，Java定义了8种基本数据类型：4种整型byte、short、int、long，两种浮点类型float、double，一种真假类型boolean，一种字符类型char。其他类型的数据都用类这个概念表达。 类比较复杂，本章主要介绍类的一些基础知识，具体">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程的逻辑">
<meta property="og:url" content="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第二部分 面向对象第3章 类的基础程序主要就是数据以及对数据的操作，为方便理解和操作，高级语言使用数据类型这个概念，不同的数据类型有不同的特征和操作，Java定义了8种基本数据类型：4种整型byte、short、int、long，两种浮点类型float、double，一种真假类型boolean，一种字符类型char。其他类型的数据都用类这个概念表达。 类比较复杂，本章主要介绍类的一些基础知识，具体">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-07T08:55:18.000Z">
<meta property="article:modified_time" content="2023-10-30T02:44:00.098Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java编程的逻辑',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-30 10:44:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java编程的逻辑</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-30T02:44:00.098Z" title="更新于 2023-10-30 10:44:00">2023-10-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java编程的逻辑"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第二部分-面向对象"><a href="#第二部分-面向对象" class="headerlink" title="第二部分 面向对象"></a>第二部分 面向对象</h1><h2 id="第3章-类的基础"><a href="#第3章-类的基础" class="headerlink" title="第3章 类的基础"></a>第3章 类的基础</h2><p>程序主要就是数据以及对数据的操作，为方便理解和操作，高级语言使用数据类型这个概念，不同的数据类型有不同的特征和操作，Java定义了8种基本数据类型：4种整型byte、short、int、long，两种浮点类型float、double，一种真假类型boolean，一种字符类型char。其他类型的数据都用类这个概念表达。</p>
<p>类比较复杂，本章主要介绍类的一些基础知识，具体分为3节：3.1节主要介绍类的基本概念；3.2节主要通过一些例子来演示如何将一些现实概念和问题通过类以及类的组合来表示和处理；3.3节介绍类代码的组织机制。</p>
<h3 id="3-1-类的基本概念"><a href="#3-1-类的基本概念" class="headerlink" title="3.1 类的基本概念"></a>3.1 类的基本概念</h3><p>在第1章，我们暂时将类看作函数的容器，在某些情况下，类也确实只是函数的容器，但类更多表示的是自定义数据类型。本节我们先从容器的角度，然后从自定义数据类型的角度介绍类。</p>
<h4 id="3-1-1-函数容器"><a href="#3-1-1-函数容器" class="headerlink" title="3.1.1 函数容器"></a>3.1.1 函数容器</h4><p>我们看个例子——Java API中的类Math，它里面主要包含了若干数学函数，表3-1列出了其中一些。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310191812296.png" alt="image-20231019181247149"></p>
<p>要使用这些函数，直接在前面加Math．即可，例如Math.abs(-1)返回1。这些函数都有相同的修饰符：public static。static表示类方法，也叫静态方法，与类方法相对的是实例方法。实例方法没有static修饰符，必须通过实例或者对象调用，而类方法可以直接通过类名进行调用，不需要创建实例。public表示这些函数是公开的，可以在任何地方被外部调用。</p>
<p>与public相对的是private。如果是private，则表示私有，这个函数只能在同一个类内被别的函数调用，而不能被外部的类调用。在Math类中，有一个函数Random initRNG()就是private的，这个函数被public的方法random()调用以生成随机数，但不能在Math类以外的地方被调用。</p>
<p>将函数声明为private可以避免该函数被外部类误用，调用者可以清楚地知道哪些函数是可以调用的，哪些是不可以调用的。类实现者通过private函数封装和隐藏内部实现细节，而调用者只需要关心public就可以了。可以说，通过private封装和隐藏内部实现细节，避免被误操作，是计算机程序的一种基本思维方式。</p>
<p>除了Math类，我们再来看一个例子Arrays。Arrays里面包含很多与数组操作相关的函数，表3-2列出了其中一些。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310191814003.png" alt="image-20231019181447945"></p>
<p>这里将类看作函数的容器，更多的是从语言实现的角度看，从概念的角度看，Math和Arrays也可以看作自定义数据类型，分别表示数学和数组类型，其中的public static函数可以看作类型能进行的操作。接下来更为详细地讨论自定义数据类型。</p>
<h4 id="3-1-2-自定义数据类型"><a href="#3-1-2-自定义数据类型" class="headerlink" title="3.1.2 自定义数据类型"></a>3.1.2 自定义数据类型</h4><p>我们将类看作自定义数据类型，所谓自定义数据类型就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。一个数据类型由其包含的属性以及该类型可以进行的操作组成，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。</p>
<p>这样，一个数据类型就主要由4部分组成：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❑ 类型本身具有的属性，通过类变量体现。</span><br><span class="line">❑ 类型本身可以进行的操作，通过类方法体现。</span><br><span class="line">❑ 类型实例具有的属性，通过实例变量体现。</span><br><span class="line">❑ 类型实例可以进行的操作，通过实例方法体现。</span><br></pre></td></tr></table></figure>
<p>不过，对于一个具体类型，每一个部分不一定都有，Arrays类就只有类方法。</p>
<p>类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。</p>
<p>类方法我们上面已经看过了，Math和Arrays类中定义的方法就是类方法，这些方法的修饰符必须有static。下面解释类变量、实例变量和实例方法。</p>
<h5 id="1．类变量"><a href="#1．类变量" class="headerlink" title="1．类变量"></a>1．类变量</h5><p>类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。比如Math类，定义了两个数学中常用的常量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">E</span> <span class="operator">=</span> <span class="number">2.7182818284590452354</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>
<p>E表示数学中自然对数的底数，自然对数在很多学科中有重要的意义；PI表示数学中的圆周率π。与类方法一样，类变量可以直接通过类名访问，如Math.PI。</p>
<p>这两个变量的修饰符也都有public static, public表示外部可以访问，static表示是类变量。与public相对的也是private，表示变量只能在类内被访问。与static相对的是实例变量，没有static修饰符。</p>
<p>这里多了一个修饰符final, final在修饰变量的时候表示常量，即变量赋值后就不能再修改了。使用final可以避免误操作，比如，如果有人不小心将Math.PI的值改了，那么很多相关的计算就会出错。另外，Java编译器可以对final变量进行一些特别的优化。所以，如果数据赋值后就不应该再变了，就加final修饰符。</p>
<p>表示类变量的时候，static修饰符是必需的，但public和final都不是必需的。</p>
<h5 id="2．实例变量和实例方法"><a href="#2．实例变量和实例方法" class="headerlink" title="2．实例变量和实例方法"></a>2．实例变量和实例方法</h5><p>所谓实例，字面意思就是一个实际的例子。实例变量表示具体的实例所具有的属性，实例方法表示具体的实例可以进行的操作。如果将微信订阅号看作一个类型，那“老马说编程”订阅号就是一个实例，订阅号的头像、功能介绍、发布的文章可以看作实例变量，而修改头像、修改功能介绍、发布新文章可以看作实例方法。与基本类型对比，“int a; ”这个语句中，int就是类型，而a就是实例。</p>
<p>接下来，我们通过定义和使用类来进一步理解自定义数据类型。</p>
<h4 id="3-1-3-定义第一个类"><a href="#3-1-3-定义第一个类" class="headerlink" title="3.1.3 定义第一个类"></a>3.1.3 定义第一个类</h4><p>我们定义一个简单的类，表示在平面坐标轴中的一个点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(x＊x+y＊y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span></span><br></pre></td></tr></table></figure>
<p>表示类型的名字是Point，是可以被外部公开访问的。这个public修饰似乎是多余的，不能被外部访问还能有什么用？在这里，确实不能用private修饰Point。但修饰符可以没有（即留空），表示一种包级别的可见性，关于包，3.3节再介绍。另外，类可以定义在一个类的内部，这时可以使用private 修饰符，关于内部类我们在第5章介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> y;</span><br></pre></td></tr></table></figure>
<p>定义了两个实例变量x和y，分别表示x坐标和y坐标，与类变量类似，修饰符也有public或private修饰符，表示含义类似，public表示可被外部访问，而private表示私有，不能直接被外部访问，实例变量不能有static修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(x＊x+y＊y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了实例方法distance，表示该点到坐标原点的距离。该方法可以直接访问实例变量x和y，这是实例方法和类方法的最大区别。实例方法直接访问实例变量，到底是什么意思呢？其实，在实例方法中，有一个隐含的参数，这个参数就是当前操作的实例自己，直接操作实例变量，实际也需要通过参数进行。实例方法和类方法的更多区别如下所示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❑ 类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。</span><br><span class="line">❑ 实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。</span><br></pre></td></tr></table></figure>
<p>如果这些让你感到困惑，没有关系，关于实例方法和类方法的更多细节，后续会进一步介绍。</p>
<h4 id="3-1-4-使用第一个类"><a href="#3-1-4-使用第一个类" class="headerlink" title="3.1.4 使用第一个类"></a>3.1.4 使用第一个类</h4><p>定义了类本身和定义了一个函数类似，本身不会做什么事情，不会分配内存，也不会执行代码。方法要执行需要被调用，而实例方法被调用，首先需要一个实例。实例也称为对象，我们可能会交替使用。下面的代码演示了如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    p.x = <span class="number">2</span>;</span><br><span class="line">    p.y = <span class="number">3</span>;</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br></pre></td></tr></table></figure>
<p>这个语句包含了Point类型的变量声明和赋值，它可以分为两部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Point p;</span><br><span class="line"><span class="number">2</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>()；</span><br></pre></td></tr></table></figure>
<p>Point p声明了一个变量，这个变量叫p，是Point类型的。这个变量和数组变量是类似的，都有两块内存：一块存放实际内容，一块存放实际内容的位置。声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们也都称为引用类型的变量。</p>
<p>p = new Point()；创建了一个实例或对象，然后赋值给了Point类型的变量p，它至少做了两件事：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）分配内存，以存储新对象的数据，对象数据包括这个对象的属性，具体包括其实例变量x和y。</span><br><span class="line">2）给实例变量设置默认值，int类型默认值为0。</span><br></pre></td></tr></table></figure>
<p>与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的，数值类型变量的默认值是0, boolean是false, char是“\u0000”，引用类型变量都是null。null是一个特殊的值，表示不指向任何对象。这些默认值可以修改，我们稍后介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.x = <span class="number">2</span>;</span><br><span class="line">p.y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>给对象的变量赋值，语法形式是：&lt;对象变量名&gt;.&lt;成员名&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p.distance());</span><br></pre></td></tr></table></figure>
<p>调用实例方法distance，并输出结果，语法形式是：&lt;对象变量名&gt;.&lt;方法名&gt;。实例方法内对实例变量的操作，实际操作的就是p这个对象的数据。</p>
<p>我们在介绍基本类型的时候，先定义数据，然后赋值，最后是操作，自定义类型与此类似：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❑ Point p = new Point()；是定义数据并设置默认值。</span><br><span class="line">❑ p.x = 2; p.y = 3；是赋值。</span><br><span class="line">❑ p.distance()是数据的操作。</span><br></pre></td></tr></table></figure>
<p>可以看出，对实例变量和实例方法的访问都通过对象进行，通过对象来访问和操作其内部的数据是一种基本的面向对象思维。本例中，我们通过对象直接操作了其内部数据x和y，这是一个不好的习惯，一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作。这也是为了减少误操作，直接访问变量没有办法进行参数检查和控制，而通过方法修改，可以在方法中进行检查。</p>
<h4 id="3-1-5-变量默认值"><a href="#3-1-5-变量默认值" class="headerlink" title="3.1.5 变量默认值"></a>3.1.5 变量默认值</h4><p>之前我们说实例变量都有一个默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用{}包围，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#123;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x的默认值设为了1, y的默认值设为了2。在新建一个对象的时候，会先调用这个初始化，然后才会执行构造方法中的代码，关于构造方法，我们稍后介绍。</p>
<p>静态变量也可以这样初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> STATIC_TWO;</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    STATIC_TWO = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STATIC_TWO=2；语句外面包了一个static {}，这叫静态初始化代码块。静态初始化代码块在类加载的时候执行，这是在任何对象创建之前，且只执行一次。</p>
<h4 id="3-1-6-private变量"><a href="#3-1-6-private变量" class="headerlink" title="3.1.6 private变量"></a>3.1.6 private变量</h4><p>前面我们说一般不应该将实例变量声明为public，下面我们修改一下类的定义，将实例变量定义为private，通过实例方法来操作变量，如代码清单3-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.y = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Math.sqrt(x ＊ x + y ＊ y);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个定义中，我们加了4个方法，setⅩ/setY用于设置实例变量的值，getⅩ/getY用于获取实例变量的值。</p>
<p>这里面需要介绍的是this这个关键字。this表示当前实例，在语句this.x=x；中，this.x表示实例变量x，而右边的x表示方法参数中的x。前面我们提到，在实例方法中，有一个隐含的参数，这个参数就是this，没有歧义的情况下，可以直接访问实例变量，在这个例子中，两个变量名都叫x，则需要通过加上this来消除歧义。</p>
<p>这4个方法看上去是非常多余的，直接访问变量不是更简洁吗？而且第1章我们也说过，函数调用是有成本的。在这个例子中，意义确实不太大，实际上，Java编译器一般也会将对这几个方法的调用转换为直接访问实例变量，而避免函数调用的开销。但在很多情况下，通过函数调用可以封装内部数据，避免误操作，我们一般还是不将成员变量定义为public。</p>
<p>使用这个类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    p.setX(<span class="number">2</span>);</span><br><span class="line">    p.setY(<span class="number">3</span>);</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将对实例变量的直接访问改为了方法调用。</p>
<h4 id="3-1-7-构造方法"><a href="#3-1-7-构造方法" class="headerlink" title="3.1.7 构造方法"></a>3.1.7 构造方法</h4><p>在初始化对象的时候，前面我们都是直接对每个变量赋值，有一个更简单的方式对实例变量赋初值，就是构造方法，我们先看下代码。在Point类定义中增加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.x = x;</span><br><span class="line">      <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这两个就是构造方法，构造方法可以有多个。不同于一般方法，构造方法有一些特殊的地方：</p>
<p>1）名称是固定的，与类名相同。这也容易理解，靠这个用户和Java系统就都能容易地知道哪些是构造方法。</p>
<p>2）没有返回值，也不能有返回值。构造方法隐含的返回值就是实例本身。</p>
<p>与普通方法一样，构造方法也可以重载。第二个构造方法是比较容易理解的，使用this对实例变量赋值。</p>
<p>我们解释下第一个构造方法，this(0,0)的意思是调用第二个构造方法，并传递参数“0,0”，我们前面解释说this表示当前实例，可以通过this访问实例变量，这是this的第二个用法，用于在构造方法中调用其他构造方法。</p>
<p>这个this调用必须放在第一行，这个规定也是为了避免误操作。构造方法是用于初始化对象的，如果要调用别的构造方法，先调别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。</p>
<p>这个例子中，不带参数的构造方法通过this(0,0)又调用了第二个构造方法，这个调用是多余的，因为x和y的默认值就是0，不需要再单独赋值，我们这里主要是演示其语法。</p>
<p>我们来看下如何使用构造方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>这个调用就可以将实例变量x和y的值设为2和3。前面我们介绍new Point()的时候说，它至少做了两件事，一件是分配内存，另一件是给实例变量设置默认值，这里我们需要加上一件事，就是调用构造方法。调用构造方法是new操作的一部分。</p>
<p>通过构造方法，可以更为简洁地对实例变量进行赋值。关于构造方法，下面我们讨论两个细节概念：一个是默认构造方法；另一个是私有构造方法。</p>
<h5 id="1．默认构造方法"><a href="#1．默认构造方法" class="headerlink" title="1．默认构造方法"></a>1．默认构造方法</h5><p>每个类都至少要有一个构造方法，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。Java编译器会自动生成一个默认构造方法，也没有具体操作。但一旦定义了构造方法，Java就不会再自动生成默认的，具体什么意思呢？在这个例子中，如果我们只定义了第二个构造方法（带参数的），则下面语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br></pre></td></tr></table></figure>
<p>就会报错，因为找不到不带参数的构造方法。</p>
<p>为什么Java有时候自动生成，有时候不生成呢？在没有定义任何构造方法的时候，Java认为用户不需要，所以就生成一个空的以被new过程调用；定义了构造方法的时候，Java认为用户知道自己在干什么，认为用户是有意不想要不带参数的构造方法，所以不会自动生成。</p>
<h5 id="2．私有构造方法"><a href="#2．私有构造方法" class="headerlink" title="2．私有构造方法"></a>2．私有构造方法</h5><p>构造方法可以是私有方法，即修饰符可以为private，为什么需要私有构造方法呢？大致可能有这么几种场景：</p>
<p>1）不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。</p>
<p>2）能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但是只能有一个，即单例（单个实例）。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。</p>
<p>3）只是用来被其他多个构造方法调用，用于减少重复代码。</p>
<h4 id="3-1-8-类和对象的生命周期"><a href="#3-1-8-类和对象的生命周期" class="headerlink" title="3.1.8 类和对象的生命周期"></a>3.1.8 类和对象的生命周期</h4><p>了解了类和对象的定义与使用，下面我们再从程序运行的角度理解下类和对象的生命周期。</p>
<p>在程序运行的时候，<strong>当第一次通过new创建一个类的对象时，或者直接通过类名访问类变量和类方法时，Java会将类加载进内存</strong>，为这个类分配一块空间，这个空间会包括类的定义、它的变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。下一章会进一步介绍有关细节。</p>
<p>类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。</p>
<p>当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。</p>
<p>每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。</p>
<p>实例方法可以理解为一个静态方法，只是多了一个参数this。通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传给this。</p>
<p>对象的释放是被Java用垃圾回收机制管理的，大部分情况下，我们不用太操心，当对象不再被使用的时候会被自动释放。</p>
<p>具体来说，对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。</p>
<p>堆中的内存是被垃圾回收机制管理的，当没有活跃变量指向对象的时候，对应的堆空间就可能被释放，具体释放时间是Java虚拟机自己决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。</p>
<h3 id="3-2-类的组合"><a href="#3-2-类的组合" class="headerlink" title="3.2 类的组合"></a>3.2 类的组合</h3><p>程序是用来解决现实问题的，将现实中的概念映射为程序中的概念，是初学编程过程中的一步跨越。本节通过一些例子来演示如何将一些现实概念和问题通过类以及类的组合来表示和处理，涉及的概念包括图形处理、电商、人之间的血缘关系以及计算机中的文件和目录。</p>
<p>我们先介绍两个基础类String和Date，它们都是Java API中的类，分别表示文本字符串和日期。</p>
<h4 id="3-2-1-String和Date"><a href="#3-2-1-String和Date" class="headerlink" title="3.2.1 String和Date"></a>3.2.1 String和Date</h4><p>String是Java API中的一个类，表示多个字符，即一段文本或字符串，它内部是一个char的数组，提供了若干方法用于操作字符串。</p>
<p>String可以用一个字符串常量初始化，字符串常量用双引号括起来（注意与字符常量区别，字符常量是用单引号）。例如，如下语句声明了一个String变量name，并赋值为“老马说编程”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老马说编程&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>String类提供了很多方法，用于操作字符串。在Java中，由于String用得非常普遍， Java对它有一些特殊的处理，本节暂不介绍这些内容，只是把它当作一个表示字符串的类型来看待。</p>
<p>Date也是Java API中的一个类，表示日期和时间，它内部是一个long类型的值，也提供了若干方法用于操作日期和时间。</p>
<p>用无参的构造方法新建一个Date对象，这个对象就表示当前时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<p>日期和时间处理是一个比较大的话题，我们留待第7章详解，本节我们只是把它当作表示日期和时间的类型来看待。</p>
<h4 id="3-2-2-图形类"><a href="#3-2-2-图形类" class="headerlink" title="3.2.2 图形类"></a>3.2.2 图形类</h4><p>我们先扩展一下Point类，在其中增加一个方法，计算到另一个点的距离，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x-p.getX(), <span class="number">2</span>)+Math.pow(y-p.getY(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类Point中，属性x、y都是基本类型，但类的属性也可以是类。我们考虑一个表示线的类，它由两个点组成，有一个实例方法计算线的长度，如代码清单3-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start= start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Line由两个Point组成，在创建Line时这两个Point是必需的，所以只有一个构造方法，且需传递这两个点，length方法计算线的长度，它调用了Point计算距离的方法获取线的长度。可以看出，在设计线时，我们考虑的层次是点，而不考虑点的内部细节。每个类封装其内部细节，对外提供高层次的功能，使其他类在更高层次上考虑和解决问题，是程序设计的一种基本思维方式。</p>
<p>使用这个类的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Point</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">      <span class="type">Point</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">      <span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>(start, end);</span><br><span class="line">      System.out.println(line.length());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这也很简单。我们再说明一下内存布局，line的两个实例成员都是引用类型，引用实际的point，整体内存布局如图3-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310191848475.png" alt="image-20231019184819333"></p>
<p>start、end、line三个引用型变量分配在栈中，保存的是实际内容的地址，实际内容保存在堆中，line的两个实例变量line.start和line.end还是引用，同样保存的是实际内容的地址。</p>
<h4 id="3-2-3-用类描述电商概念"><a href="#3-2-3-用类描述电商概念" class="headerlink" title="3.2.3 用类描述电商概念"></a>3.2.3 用类描述电商概念</h4><p>接下来，我们用类来描述一下电商系统中的一些基本概念，电商系统中最基本的有产品、用户和订单。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）产品：有产品唯一id、名称、描述、图片、价格等属性。</span><br><span class="line">2）用户：有用户名、密码等属性。</span><br><span class="line">3）订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。</span><br></pre></td></tr></table></figure>
<p>当然，实际情况可能非常复杂，这是一个非常简化的描述。</p>
<p>产品类Product如代码清单3-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//唯一id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//产品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//产品图片链接</span></span><br><span class="line">    <span class="keyword">private</span> String pictureUrl;</span><br><span class="line">    <span class="comment">//产品描述</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//产品价格</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们省略了类的构造方法，以及属性的getter/setter方法，下面大部分示例代码也都会省略。</p>
<p>这是用户类User的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个订单可能会有多个产品，每个产品可能有不同的数量，我们用订单条目OrderItem这个类来描述单个产品及选购的数量，如代码清单3-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;</span><br><span class="line">    <span class="comment">//购买产品</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">//购买数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderItem</span><span class="params">(Product product, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product.getPrice()*quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OrderItem引用了产品类Product，我们定义了一个构造方法，以及计算该订单条目价格的方法。</p>
<p>订单类Order如代码清单3-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">//订单号</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//购买用户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">//购买产品列表及数量</span></span><br><span class="line">    <span class="keyword">private</span> OrderItem[] items;</span><br><span class="line">    <span class="comment">//下单时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line">    <span class="comment">//收货地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">//订单状态</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computeTotalPrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(items! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(OrderItem item : items)&#123;</span><br><span class="line">                totalPrice+=item.computePrice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Order类引用了用户类User，以及一个订单条目的数组OrderItem，它定义了一个计算总价的方法。这里用一个String类表示状态status，更合适的应该是枚举类型，枚举我们第5章再介绍。</p>
<p>以上类定义是非常简化的，但是大致演示了将现实概念映射为类以及类组合的过程，这个过程大概就是，想想现实问题有哪些概念，这些概念有哪些属性、哪些行为，概念之间有什么关系，然后定义类、定义属性、定义方法、定义类之间的关系。概念的属性和行为可能是非常多的，但定义的类只需要包括那些与现实问题相关的就行了。</p>
<h4 id="3-2-4-用类描述人之间的血缘关系"><a href="#3-2-4-用类描述人之间的血缘关系" class="headerlink" title="3.2.4 用类描述人之间的血缘关系"></a>3.2.4 用类描述人之间的血缘关系</h4><p>上面介绍的图形类和电商类只会引用别的类，但一个类定义中还可以引用它自己，比如我们要描述人以及人之间的血缘关系。我们用类Person表示一个人，它的实例成员包括其父亲、母亲、和孩子，这些成员也都是Person类型，如代码清单3-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//父亲</span></span><br><span class="line">    <span class="keyword">private</span> Person father;</span><br><span class="line">    <span class="comment">//母亲</span></span><br><span class="line">    <span class="keyword">private</span> Person mother;</span><br><span class="line">    <span class="comment">//孩子数组</span></span><br><span class="line">    <span class="keyword">private</span> Person[] children;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里同样省略了setter/getter方法。对初学者，初看起来这是比较难以理解的，有点类似于函数调用中的递归调用，这里面的关键点是，实例变量不需要一开始就有值。我们来看下如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">laoma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;老马&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小马&quot;</span>);</span><br><span class="line">    xiaoma.setFather(laoma);</span><br><span class="line">    laoma.setChildren(<span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;xiaoma&#125;);</span><br><span class="line">    System.out.println(xiaoma.getFather().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码先创建了老马（laoma），然后创建了小马（xiaoma），接着调用xiaoma的set-Father方法和laoma的setChildren方法设置了父子关系，Person类对象的内存布局如图3-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310191853808.png" alt="image-20231019185303744"></p>
<h4 id="3-2-5-目录和文件"><a href="#3-2-5-目录和文件" class="headerlink" title="3.2.5 目录和文件"></a>3.2.5 目录和文件</h4><p>接下来，我们介绍两个类MyFile和MyFolder，分别表示文件管理中的两个概念：文件和文件夹。文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。文件类MyFile如代码清单3-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line">    <span class="comment">//文件名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//文件大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//上级目录</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>文件夹类MyFolder如代码清单3-8所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFolder</span> &#123;</span><br><span class="line">    <span class="comment">//文件夹名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//上级文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//包含的文件</span></span><br><span class="line">    <span class="keyword">private</span> MyFile[] files;</span><br><span class="line">    <span class="comment">//包含的子文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder[] subFolders;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(files! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFile file : files)&#123;</span><br><span class="line">                totalSize+=file.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(subFolders! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFolder folder : subFolders)&#123;</span><br><span class="line">                totalSize+=folder.totalSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyFile和MyFolder都省略了构造方法、settter/getter方法，以及关于父子关系维护的代码，主要演示实例变量间的组合关系。两个类之间可以互相引用，MyFile引用了MyFolder，而MyFolder也引用了MyFile，这是没有问题的。因为正如之前所说，这些属性不需要一开始就设置，也不是必须设置的。另外，演示了一个递归方法totalSize()，返回当前文件夹下所有文件的大小，这是使用递归函数的一个很好的场景。</p>
<h4 id="3-2-6-一些说明"><a href="#3-2-6-一些说明" class="headerlink" title="3.2.6 一些说明"></a>3.2.6 一些说明</h4><p>类中应该定义哪些变量和方法，这是与要解决的问题密切相关的，本节中并没有特别强调问题是什么，定义的属性和方法主要用于演示基本概念，实际应用中应该根据具体问题进行调整。</p>
<p>类中实例变量的类型可以是当前定义的类型，两个类之间可以互相引用，这些初听起来可能难以理解，但现实世界就是这样的，创建对象的时候这些值不需要一开始就有，也可以没有，所以是没有问题的。</p>
<p>类之间的组合关系在Java中实现的都是引用，但在逻辑关系上，有两种明显不同的关系，一种是包含，另一种是单纯引用。比如，在订单类Order中，Order与User的关系就是单纯引用，User是独立存在的；而Order与OrderItem的关系就是包含，OrderItem总是从属于某一个Order。</p>
<h3 id="3-3-代码的组织机制"><a href="#3-3-代码的组织机制" class="headerlink" title="3.3 代码的组织机制"></a>3.3 代码的组织机制</h3><p>使用任何语言进行编程都有一个类似的问题，那就是如何组织代码。具体来说，如何避免命名冲突？如何合理组织各种源文件？如何使用第三方库？各种代码和依赖库如何编译链接为一个完整的程序？本节就来讨论Java中的解决机制，具体包括包、jar包、程序的编译与链接等。</p>
<h4 id="3-3-1-包的概念"><a href="#3-3-1-包的概念" class="headerlink" title="3.3.1 包的概念"></a>3.3.1 包的概念</h4><p>使用任何语言进行编程都有一个相同的问题，就是命名冲突。程序一般不全是一个人写的，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人就不同的目的可能定义同样的类名/接口名，Java中解决这个问题的主要方法就是包。</p>
<p>即使代码都是一个人写的，将多个关系不太大的类和接口都放在一起，也不便于理解和维护，Java中组织类和接口的方式也是包。</p>
<p>包是一个比较容易理解的概念，类似于计算机中的文件夹，正如我们在计算机中管理文件，文件放在文件夹中一样，类和接口放在包中，为便于组织，文件夹一般是一个层次结构，包也类似。</p>
<p>包有包名，这个名称以点号（.）分隔表示层次结构。比如，我们之前常用的String类就位于包java.lang下，其中java是上层包名，lang是下层包名。带完整包名的类名称为其完全限定名，比如String类的完全限定名为java.lang.String。Java API中所有的类和接口都位于包Java或javax下，Java是标准包，javax是扩展包。</p>
<p>接下来，我们讨论包的细节，包括包的声明、使用和包范围可见性。</p>
<h5 id="1．声明类所在的包"><a href="#1．声明类所在的包" class="headerlink" title="1．声明类所在的包"></a>1．声明类所在的包</h5><p>我们之前定义类的时候没有定义其所在的包，默认情况下，类位于默认包下，使用默认包是不建议的，我们使用默认包只是简单起见。</p>
<p>定义类的时候，应该先使用关键字package声明其包名，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">//类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上声明类Hello的包名为shuo.laoma，包声明语句应该位于源代码的最前面，前面不能有注释外的其他语句。</p>
<p>包名和文件目录结构必须匹配，如果源文件的根目录为<strong>E:\src\</strong>，则上面的Hello类对应的文件Hello.java，其全路径就应该是E:\src\shuo\laoma\Hello.java。如果不匹配，Java会提示编译错误。</p>
<p>为避免命名冲突，Java中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，<strong>一般按照域名的反序来定义包名</strong>，比如，域名是apache.org，包名就以org.apache开头。</p>
<p>没有域名的也没关系，使用一个其他代码不太会用的包名即可，比如本节使用的shuo. laoma。如果代码需要公开给其他人用，最好有一个域名以确保唯一性，如果只是内部使用，则确保内部没有其他代码使用该包名即可。</p>
<p>除了避免命名冲突，包也是一种方便组织代码的机制。一般而言，同一个项目下的所有代码都有一个相同的包前缀，这个前缀是唯一的，不会与其他代码重名，在项目内部，根据不同目的再细分为子包，子包可能又会分为下一级子包，形成层次结构，内部实现一般位于比较底层的包。</p>
<p>包可以方便模块化开发，不同功能可以位于不同包内，不同开发人员负责不同的包。包也可以方便封装，供外部使用的类可以放在包的上层，而内部的实现细节则可以放在比较底层的子包内。</p>
<h5 id="2．通过包使用类"><a href="#2．通过包使用类" class="headerlink" title="2．通过包使用类"></a>2．通过包使用类</h5><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包。使用有两种方式：一种是通过类的完全限定名；另外一种是将用到的类引入当前类。只有一个例外，java.lang包下的类可以直接使用，不需要引入，也不需要使用完全限定名，比如String类、System类，其他包内的类则不行。</p>
<p>看个例子，使用Arrays类中的sort方法，通过完全限定名可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">java.util.Arrays.sort(arr);</span><br><span class="line">System.out.println(java.util.Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>显然，这样比较烦琐，另外一种就是将该类引入当前类。引入的关键字是import,import需要放在package定义之后，类定义之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做import操作时，可以一次将某个包下的所有类引入，语法是使用． <em>，比如，将java. util包下的所有类引入，语法是：import java.util.</em>。需要注意的是，这个引入不能递归，它只会引入java.util包下的直接类，而不会引入java.util下嵌套包内的类，比如，不会引入包java.util.zip下面的类。试图嵌套引入的形式也是无效的，如import java.util.*.*。</p>
<p>在一个类内，对其他类的引用必须是唯一确定的，不能有重名的类，如果有，则通过import只能引入其中的一个类，其他同名的类则必须要使用完全限定名。</p>
<p>引入类是一个比较烦琐的工作，不过，大多数Java开发环境都提供工具自动做这件事。比如，在Eclipse中，通过执行Source→Organize Imports命令或按对应的快捷键Ctrl+Shift+O就可以自动管理引用的类。</p>
<p>有一种特殊类型的导入，称为静态导入，它有一个static关键字，可以直接导入类的公开静态方法和成员。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.＊; <span class="comment">//静态导入Arrays中的所有静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out; <span class="comment">//导入静态变量out</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr);  <span class="comment">//可以直接使用Arrays中的sort方法</span></span><br><span class="line">        out.println(Arrays.toString(arr)); <span class="comment">//可以直接使用out变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态导入不应过度使用，否则难以区分访问的是哪个类的代码。</p>
<h5 id="3．包范围可见性"><a href="#3．包范围可见性" class="headerlink" title="3．包范围可见性"></a>3．包范围可见性</h5><p>前面章节我们介绍过，对于类、变量和方法，都可以有一个可见性修饰符public/private，我们还提到，可以不写修饰符。如果什么修饰符都不写，它的可见性范围就是同一个包内，同一个包内的其他类可以访问，而其他包内的类则不可以访问。</p>
<p>需要说明的是，同一个包指的是同一个直接包，子包下的类并不能访问。比如，类shuo.laoma.Hello和shuo.laoma.inner.Test，其所在的包shuo.laoma和shuo.laoma.inner是两个完全独立的包，并没有逻辑上的联系，Hello类和Test类不能互相访问对方的包可见性方法和属性。</p>
<p>除了public和private修饰符，还有一个与继承有关的修饰符protected。关于protected的细节我们下章介绍，这里需要说明的是，protected可见性包括包可见性，也就是说，声明为protected不仅表明子类可以访问，还表明同一个包内的其他类可以访问，即使这些类不是子类也可以。</p>
<p>总结来说，可见性范围从小到大是：private &lt; 默认(包) &lt; protected &lt; public。</p>
<h4 id="3-3-2-jar包"><a href="#3-3-2-jar包" class="headerlink" title="3.3.2 jar包"></a>3.3.2 jar包</h4><p>为方便使用第三方代码，也为了方便我们写的代码给其他人使用，各种程序语言大多有打包的概念，打包的一般不是源代码，而是编译后的代码。打包将多个编译后的文件打包为一个文件，方便其他程序调用。</p>
<p>在Java中，编译后的一个或多个包的Java class文件可以打包为一个文件，Java中打包命令为jar，打包后的文件扩展名为．jar，一般称之为jar包。</p>
<p>可以使用如下方式打包，首先到编译后的java class文件根目录，然后运行如下命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf &lt;包名&gt;.jar &lt;最上层包名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，对前面介绍的类打包，如果Hello.class位于E:\bin\shuo\laoma\Hello.class，则可以到目录 E:\bin下，然后运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf hello.jar shuo</span><br></pre></td></tr></table></figure>
<p>hello.jar就是jar包，jar包其实就是一个压缩文件，可以使用解压缩工具打开。</p>
<p>Java类库、第三方类库都是以jar包形式提供的。如何使用jar包呢？将其加入类路径（classpath）中即可。类路径是什么呢？我们下面来看。</p>
<h4 id="3-3-3-程序的编译与链接"><a href="#3-3-3-程序的编译与链接" class="headerlink" title="3.3.3 程序的编译与链接"></a>3.3.3 程序的编译与链接</h4><p>从Java源代码到运行的程序，有编译和链接两个步骤。编译是将源代码文件变成扩展名是．class的一种字节码，这个工作一般是由javac命令完成的。链接是在运行时动态执行的，.class文件不能直接运行，运行的是Java虚拟机，虚拟机听起来比较抽象，执行的就是Java命令，这个命令解析．class文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是根据引用到的类加载相应的字节码并执行。</p>
<p>Java编译和运行时，都需要以参数指定一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称（包括路径和jar包名）。在Windows系统中，多个路径用分号“; ”分隔；在其他系统中，以冒号“:”分隔。</p>
<p>在Java源代码编译时，Java编译器会确定引用的每个类的完全限定名，确定的方式是根据import语句和classpath。如果导入的是完全限定类名，则可以直接比较并确定。如果是模糊导入（import带．*），则根据classpath找对应父包，再在父包下寻找是否有对应的类。如果多个模糊导入的包下都有同样的类名，则Java会提示编译错误，此时应该明确指定导入哪个类。</p>
<p>Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。</p>
<p>总结来说，import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类，编译和运行时都依赖类路径，类路径中的jar文件会被解压缩用于寻找和加载类。</p>
<h2 id="第4章-类的继承"><a href="#第4章-类的继承" class="headerlink" title="第4章 类的继承"></a>第4章 类的继承</h2><p>上一章，我们谈到了如何将现实中的概念映射为程序中的概念，我们谈了类以及类之间的组合，现实中的概念间还有一种非常重要的关系，就是分类。分类有个根，然后向下不断细化，形成一个层次分类体系，这种例子是非常多的。</p>
<p>1）在自然世界中，生物有动物和植物，动物有不同的科目，食肉动物、食草动物、杂食动物等，食肉动物有狼、豹、虎等，这些又细分为不同的种类。</p>
<p>2）打开电商网站，在显著位置一般都有分类列表，比如家用电器、服装，服装有女装、男装，男装有衬衫、牛仔裤等。</p>
<p>计算机程序经常使用类之间的继承关系来表示对象之间的分类关系。在继承关系中，有父类和子类，比如动物类Animal和狗类Dog, Animal是父类，Dog是子类。父类也叫基类，子类也叫派生类。父类、子类是相对的，一个类B可能是类A的子类，但又是类C的父类。</p>
<p>之所以叫继承，是因为子类继承了父类的属性和行为，父类有的属性和行为子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>本节介绍Java中继承的基本概念，在Java中，所有类都有一个父类Object，我们先来看这个类，然后主要通过图形处理中的一些简单例子来介绍继承的基本概念</p>
<h4 id="4-1-1-根父类Object"><a href="#4-1-1-根父类Object" class="headerlink" title="4.1.1 根父类Object"></a>4.1.1 根父类Object</h4><p>在Java中，即使没有声明父类，也有一个隐含的父类，这个父类叫Object。Object没有定义属性，但定义了一些方法，如图4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310191920721.png" alt="image-20231019192047645"></p>
<p>本节我们会介绍toString()方法，其他方法我们会在后续章节中逐步介绍。toString()方法的目的是返回一个对象的文本描述，这个方法可以直接被所有类使用。</p>
<p>比如，对于我们上一章介绍的Point类，可以这样使用toString方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(p.toString());</span><br></pre></td></tr></table></figure>
<p>输出类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point@76f9aa66</span><br></pre></td></tr></table></figure>
<p>这是什么意思呢？@之前是类名，@之后的内容是什么呢？我们来看下toString()方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getClass().getName() 返回当前对象的类名，hashCode()返回一个对象的哈希值，哈希我们会在后续章节进一步介绍，这里可以理解为是一个整数，这个整数默认情况下，通常是对象的内存地址值，Integer.toHexString(hashCode())返回这个哈希值的十六进制表示。</p>
<p>为什么要这么写呢？写类名是可以理解的，表示对象的类型，而写哈希值则是不得已的，因为Object类并不知道具体对象的属性，不知道怎么用文本描述，但又需要区分不同对象，只能是写一个哈希值。</p>
<p>但子类是知道自己的属性的，子类可以重写父类的方法，以反映自己的不同实现。所谓重写，就是定义和父类一样的方法，并重新实现。</p>
<h4 id="4-1-2-方法重写"><a href="#4-1-2-方法重写" class="headerlink" title="4.1.2 方法重写"></a>4.1.2 方法重写</h4><p>上一章，我们介绍了一些图形处理类，其中有Point类，这次我们重写其toString()方法，如代码清单4-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.x = x;</span><br><span class="line">          <span class="built_in">this</span>.y = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point point)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Math.sqrt(Math.pow(<span class="built_in">this</span>.x-point.getX(),<span class="number">2</span>)</span><br><span class="line">                  +Math.pow(<span class="built_in">this</span>.y-point.getY(), <span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;, &quot;</span>+y+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>toString()方法前面有一个@Override，这表示toString()这个方法是重写的父类的方法，重写后的方法返回Point的x和y坐标的值。重写后，将调用子类的实现。比如，如下代码的输出就变成了(2,3)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(p.toString());</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3-图形类继承体系"><a href="#4-1-3-图形类继承体系" class="headerlink" title="4.1.3 图形类继承体系"></a>4.1.3 图形类继承体系</h4><p>接下来，我们以一些图形处理中的例子来进一步解释。先来看一些图形的例子，如图4-2所示。</p>
<p>这都是一些基本的图形，图形有线、正方形、三角形、圆形等，图形有不同的颜色。接下来，我们定义以下类来说明关于继承的一些概念：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❑ 父类Shape，表示图形。</span><br><span class="line">❑ 类Circle，表示圆。</span><br><span class="line">❑ 类Line，表示直线。</span><br><span class="line">❑ 类ArrowLine，表示带箭头的直线。</span><br></pre></td></tr></table></figure>
<h5 id="1．图形"><a href="#1．图形" class="headerlink" title="1．图形"></a>1．图形</h5><p>所有图形（Shape）都有一个表示颜色的属性，有一个表示绘制的方法，如代码清单4-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_COLOR</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_COLOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码非常简单，实例变量color表示颜色，draw方法表示绘制，我们没有写实际的绘制代码，主要是演示继承关系。</p>
<h5 id="2．圆"><a href="#2．圆" class="headerlink" title="2．圆"></a>2．圆</h5><p>圆（Circle）继承自Shape，但包括了额外的属性：中心点和半径，以及额外的方法area，用于计算面积，另外，重写了draw方法，如代码清单4-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> r;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Point center, <span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw circle at &quot;</span> +center.toString()+<span class="string">&quot; with r &quot;</span>+r</span><br><span class="line">                +<span class="string">&quot;, using color : &quot;</span>+getColor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI＊r＊r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）Java使用extends关键字表示继承关系，一个类最多只能有一个父类；</span><br><span class="line">2）子类不能直接访问父类的私有属性和方法。比如，在Circle中，不能直接访问Shape的私有实例变量color；</span><br><span class="line">3）除了私有的外，子类继承了父类的其他属性和方法。比如，在Circle的draw方法中，可以直接调用getColor()方法。</span><br></pre></td></tr></table></figure>
<p>使用它的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">center</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//创建圆，赋值给circle</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(center,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//调用draw方法，会执行Circle的draw方法</span></span><br><span class="line">    circle.draw();</span><br><span class="line">    <span class="comment">//输出圆面积</span></span><br><span class="line">    System.out.println(circle.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">draw circle at (2,3) with r 2.0, using color : black</span><br><span class="line">12.566370614359172</span><br></pre></td></tr></table></figure>
<p>这里比较奇怪的是，color是什么时候赋值的？在new的过程中，父类的构造方法也会执行，且会优先于子类执行。在这个例子中，父类Shape的默认构造方法会在子类Circle的构造方法之前执行。关于new过程的细节，我们会在4.3节进一步介绍。</p>
<h5 id="3．直线"><a href="#3．直线" class="headerlink" title="3．直线"></a>3．直线</h5><p>线（Line）继承自Shape，但有两个点，以及一个获取长度的方法，并重写了draw方法，如代码清单4-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Line</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> Point start;</span><br><span class="line">            <span class="keyword">private</span> Point end;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end, String color)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>(color);</span><br><span class="line">                <span class="built_in">this</span>.start = start;</span><br><span class="line">                <span class="built_in">this</span>.end = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> start.distance(end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> Point <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> Point <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw line from &quot;</span></span><br><span class="line">                + start.toString()+<span class="string">&quot; to &quot;</span>+end.toString()</span><br><span class="line">                + <span class="string">&quot;, using color &quot;</span>+<span class="built_in">super</span>.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要说明的是super这个关键字，super用于指代父类，可用于调用父类构造方法，访问父类方法和变量。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）在Line构造方法中，super(color)表示调用父类的带color参数的构造方法。调用父类构造方法时，super必须放在第一行。</span><br><span class="line">2）在draw方法中，super.getColor()表示调用父类的getColor方法，当然不写super.也是可以的，因为这个方法子类没有同名的，没有歧义，当有歧义的时候，通过super．可以明确表示调用父类的方法。</span><br><span class="line">3）super同样可以引用父类非私有的变量。</span><br></pre></td></tr></table></figure>
<p>可以看出，super的使用与this有点像，但super和this是不同的，this引用一个对象，是实实在在存在的，可以作为函数参数，可以作为返回值，但super只是一个关键字，不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。</p>
<h5 id="4．带箭头直线"><a href="#4．带箭头直线" class="headerlink" title="4．带箭头直线"></a>4．带箭头直线</h5><p>带箭头直线（ArrowLine）继承自Line，但多了两个属性，分别表示两端是否有箭头，也重写了draw方法，如代码清单4-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrowLine</span> <span class="keyword">extends</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> startArrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> endArrow;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrowLine</span><span class="params">(Point start, Point end, String color,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> startArrow, <span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(start, end, color);</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        <span class="keyword">if</span>(startArrow)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;draw start arrow&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endArrow)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;draw end arrow&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ArrowLine继承自Line，而Line继承自Shape, ArrowLine的对象也有Shape的属性和方法。</p>
<p>注意draw()方法的第一行，super.draw()表示调用父类的draw()方法，这时候不带super．是不行的，因为当前的方法也叫draw()。</p>
<p>需要说明的是，这里ArrowLine继承了Line，也可以直接在类Line里加上属性，而不需要单独设计一个类ArrowLine，这里主要是演示继承的层级性。</p>
<h5 id="5．图形管理器"><a href="#5．图形管理器" class="headerlink" title="5．图形管理器"></a>5．图形管理器</h5><p>使用继承的一个好处是可以统一处理不同子类型的对象。比如，我们来看一个图形管理者类，它负责管理画板上的所有图形对象并负责绘制，在绘制代码中，只需要将每个对象当作Shape并调用draw方法就可以了，系统会自动执行子类的draw方法。如代码清单4-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Shape[] shapes = <span class="keyword">new</span> <span class="title class_">Shape</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">shapeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShape</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeNum&lt;MAX_NUM)&#123;</span><br><span class="line">            shapes[shapeNum++] = shape;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;shapeNum; i++)&#123;</span><br><span class="line">            shapes[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。ShapeManager并不知道每个shape具体的类型，也不关心，但可以调用到子类的draw方法。</p>
<p>我们来看下使用ShapeManager的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShapeManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeManager</span>();</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>,<span class="number">4</span>),<span class="number">3</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Line</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>), <span class="string">&quot;green&quot;</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">ArrowLine</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">5</span>,<span class="number">5</span>), <span class="string">&quot;black&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>));</span><br><span class="line">    manager.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了三个shape，分别是一个圆、直线和带箭头的线，然后加到了shape manager中，然后调用manager的draw方法。</p>
<p>需要说明的是，在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line和ArrowLine。子类对象赋值给父类引用变量，这叫向上转型，转型就是转换类型，向上转型就是转换为父类类型。</p>
<p><strong>变量shape可以引用任何Shape子类类型的对象，这叫多态，即一种类型的变量，可引用多种实际类型对象。</strong>这样，对于变量shape，它就有两个类型：类型Shape，我们称之为shape的静态类型；类型Circle/Line/ArrowLine，我们称之为shape的动态类型。在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的动态绑定。</p>
<p>为什么要有多态和动态绑定呢？创建对象的代码（ShapeManager以外的代码）和操作对象的代码（ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。</p>
<p>可以说，多态和动态绑定是计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。在4.3节，我们会进一步介绍动态绑定的实现原理。</p>
<h3 id="4-2-继承的细节"><a href="#4-2-继承的细节" class="headerlink" title="4.2 继承的细节"></a>4.2 继承的细节</h3><p>本节探讨继续的一些细节，具体包括：</p>
<p>❑ 构造方法；</p>
<p>❑ 重名与静态绑定；</p>
<p>❑ 重载和重写；</p>
<p>❑ 父子类型转换；</p>
<p>❑ 继承访问权限（protected）；</p>
<p>❑ 可见性重写；</p>
<p>❑ 防止继承（final）。</p>
<p>下面我们逐个介绍。</p>
<h4 id="4-2-1-构造方法"><a href="#4-2-1-构造方法" class="headerlink" title="4.2.1 构造方法"></a>4.2.1 构造方法</h4><p>前面我们说过，子类可以通过super调用父类的构造方法，如果子类没有通过super调用，则会自动调动父类的默认构造方法，那如果父类没有默认构造方法呢？如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String member;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String member)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.member = member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类只有一个带参数的构造方法，没有默认构造方法。这个时候，它的任何子类都必须在构造方法中通过super调用Base的带参数构造方法，如下所示，否则，Java会提示编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String member)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(member);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是，如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。我们来看个例子，下面是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法调用了test()方法。这是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类有一个实例变量a，初始赋值为123，重写了test()方法，输出a的值。看下使用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>第一次输出为0，第二次输出为123。第一行为什么是0呢？第一次输出是在new过程中输出的，在new过程中，首先是初始化父类，父类构造方法调用test()方法，test()方法被子类重写了，就会调用子类的test()方法，子类方法访问子类实例变量a，而这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的是其默认值0。</p>
<p>像这样，在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法。</p>
<h4 id="4-2-2-重名与静态绑定"><a href="#4-2-2-重名与静态绑定" class="headerlink" title="4.2.2 重名与静态绑定"></a>4.2.2 重名与静态绑定</h4><p>4.1节我们提到，子类可以重写父类非private的方法，当调用的时候，会动态绑定，执行子类的方法。那实例变量、静态方法和静态变量呢？它们可以重名吗？如果重名，访问的是哪一个呢？</p>
<p>重名是可以的，重名后实际上有两个变量或方法。private变量和方法只能在类内访问，访问的也永远是当前类的，即：在子类中访问的是子类的；在父类中访问的是父类的，它们只是碰巧名字一样而已，没有任何关系。</p>
<p>public变量和方法，则要看如何访问它。在类内，访问的是当前类的，但子类可以通过super．明确指定访问父类的。在类外，则要看访问变量的静态类型：静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问的是子类的变量和方法。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;static_base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base static: &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个public静态变量s，一个public实例变量m，一个静态方法staticTest。这是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;child_base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child static: &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类定义了和父类重名的变量和方法。对于一个子类对象，它就有了两份变量和方法，在子类内部访问的时候，访问的是子类的，或者说，子类变量和方法隐藏了父类对应的变量和方法，下面看一下外部访问的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">    System.out.println(b.s);</span><br><span class="line">    System.out.println(b.m);</span><br><span class="line">    b.staticTest();</span><br><span class="line">    System.out.println(c.s);</span><br><span class="line">    System.out.println(c.m);</span><br><span class="line">    c.staticTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个子类对象，然后将对象分别赋值给了子类引用变量c和父类引用变量b，然后通过b和c分别引用变量和方法。这里需要说明的是，静态变量和静态方法一般通过类名直接访问，但也可以通过类的对象访问。程序输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static_base</span><br><span class="line">base</span><br><span class="line">base static: static_base</span><br><span class="line">child_base</span><br><span class="line">child</span><br><span class="line">child static: child_base</span><br></pre></td></tr></table></figure>
<p>当通过b（静态类型Base）访问时，访问的是Base的变量和方法，当通过c（静态类型Child）访问时，访问的是Child的变量和方法，这称之为静态绑定，即访问绑定到变量的静态类型。静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。实例变量、静态变量、静态方法、private方法，都是静态绑定的。</p>
<h4 id="4-2-3-重载和重写"><a href="#4-2-3-重载和重写" class="headerlink" title="4.2.3 重载和重写"></a>4.2.3 重载和重写</h4><p>重载是指方法名称相同但参数签名不同（参数个数、类型或顺序不同），重写是指子类重写与父类相同参数签名的方法。对一个函数调用而言，可能有多个匹配的方法，有时候选择哪一个并不是那么明显。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_int_int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它定义了方法sum，下面是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_long_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是调用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    c.sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Child和Base都定义了sum方法，这里调用的是哪个sum方法呢？子类的sum方法参数类型虽然不完全匹配但是是兼容的，父类的sum方法参数类型是完全匹配的。程序输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_int_int</span><br></pre></td></tr></table></figure>
<p>父类类型完全匹配的方法被调用了。如果父类代码改成下面这样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_int_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类方法类型也不完全匹配了。程序输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_int_long</span><br></pre></td></tr></table></figure>
<p>调用的还是父类的方法。父类和子类的两个方法的类型都不完全匹配，为什么调用父类的呢？因为父类的更匹配一些。现在修改一下子类代码，更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_int_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出变为了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_int_long</span><br></pre></td></tr></table></figure>
<p>终于调用了子类的方法。可以看出，当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的，换句话说，寻找在所有重载版本中最匹配的，然后才看变量的动态类型，进行动态绑定。</p>
<h4 id="4-2-4-父子类型转换"><a href="#4-2-4-父子类型转换" class="headerlink" title="4.2.4 父子类型转换"></a>4.2.4 父子类型转换</h4><p>之前我们说过，子类型的对象可以赋值给父类型的引用变量，这叫向上转型，那父类型的变量可以赋值给子类型的变量吗？或者说可以向下转型吗？语法上可以进行强制类型转换，但不一定能转换成功。我们以前面的例子来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;</span><br></pre></td></tr></table></figure>
<p>Child c = (Child)b就是将变量b的类型强制转换为Child并赋值为c，这是没有问题的，因为b的动态类型就是Child，但下面的代码是不行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;</span><br></pre></td></tr></table></figure>
<p>语法上Java不会报错，但运行时会抛出错误，错误为类型转换异常。</p>
<p>一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。</p>
<p>给定一个父类的变量能不能知道它到底是不是某个子类的对象，从而安全地进行类型转换呢？答案是可以，通过instanceof关键字，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCast</span><span class="params">(Base b)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b <span class="keyword">instanceof</span> Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回Base类型变量是否可以转换为Child类型，instanceof前面是变量，后面是类，返回值是boolean值，表示变量引用的对象是不是该类或其子类的对象。</p>
<h4 id="4-2-5-继承访问权限protected"><a href="#4-2-5-继承访问权限protected" class="headerlink" title="4.2.5 继承访问权限protected"></a>4.2.5 继承访问权限protected</h4><p>变量和函数有public/private修饰符，public表示外部可以访问，private表示只能内部使用，还有一种可见性介于中间的修饰符protected，表示虽然不能被外部任意访问，但可被子类访问。另外，protected还表示可被同一个包中的其他类访问，不管其他类是不是该类的子类。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span>   <span class="type">int</span> currentStep;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.currentStep = <span class="number">1</span>;</span><br><span class="line">        step1();</span><br><span class="line">        <span class="built_in">this</span>.currentStep = <span class="number">2</span>;</span><br><span class="line">        step2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>action表示对外提供的行为，内部有两个步骤step1()和step2()，使用currentStep变量表示当前进行到了哪个步骤，step1()、step2()和currentStep是protected的，子类一般不重写action，而只重写step1和step2，同时，子类可以直接访问currentStep查看进行到了哪一步。子类的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child step &quot;</span> + <span class="built_in">this</span>.currentStep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child step &quot;</span> + <span class="built_in">this</span>.currentStep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Child的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child step <span class="number">1</span></span><br><span class="line">child step <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>基类定义了表示对外行为的方法action，并定义了可以被子类重写的两个步骤step1()和step2()，以及被子类查看的变量currentStep，子类通过重写protected方法step1()和step2()来修改对外的行为。</p>
<p>这种思路和设计是一种设计模式，称之为模板方法。action方法就是一个模板方法，它定义了实现的模板，而具体实现则由子类提供。模板方法在很多框架中有广泛的应用，这是使用<strong>protected</strong>的一种常见场景。</p>
<h4 id="4-2-6-可见性重写"><a href="#4-2-6-可见性重写" class="headerlink" title="4.2.6 可见性重写"></a>4.2.6 可见性重写</h4><p>重写方法时，一般并不会修改方法的可见性。但我们还是要说明一点，<strong>重写时，子类方法不能降低父类方法的可见性</strong>。不能降低是指，父类如果是public，则子类也必须是public，父类如果是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性但不能降低。看个例子，基类代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">protect</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//以下是不允许的，会有编译错误</span></span><br><span class="line">    <span class="comment">//private void protect()&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//以下是不允许的，会有编译错误</span></span><br><span class="line">    <span class="comment">//protected void open()&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">protect</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要这样规定呢？继承反映的是“is-a”的关系，即子类对象也属于父类，子类必须支持父类所有对外的行为，将可见性降低就会减少子类对外的行为，从而破坏“is-a”的关系，但子类可以增加父类的行为，所以提升可见性是没有问题的。</p>
<h4 id="4-2-7-防止继承final"><a href="#4-2-7-防止继承final" class="headerlink" title="4.2.7 防止继承final"></a>4.2.7 防止继承final</h4><p>4.3节我们会提到，继承是把双刃剑，带来的影响就是，有的时候我们不希望父类方法被子类重写，有的时候甚至不希望类被继承，可以通过final关键字实现。final关键字可以修饰变量，而这是final的另一种用法。一个Java类，默认情况下都是可以被继承的，但加了final关键字之后就不能被继承了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个非final的类，其中的public/protected实例方法默认情况下都是可以被重写的，但加了final关键字后就不能被重写了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能被重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，关于Java继承概念一些细节就介绍完了。但还有些重要的地方我们没有讨论，比如，创建子类对象的具体过程？动态绑定是如何实现的？让我们下节来探讨继承实现的基本原理。</p>
<h3 id="4-3-继承实现的基本原理"><a href="#4-3-继承实现的基本原理" class="headerlink" title="4.3 继承实现的基本原理"></a>4.3 继承实现的基本原理</h3><p>本节通过一个例子来介绍继承实现的基本原理。需要说明的是，本节主要从概念上来介绍原理，实际实现细节可能与此不同。</p>
<h4 id="4-3-1-示例"><a href="#4-3-1-示例" class="headerlink" title="4.3.1 示例"></a>4.3.1 示例</h4><p>基类Base如代码清单4-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类静态代码块， s: &quot;</span>+s);</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类实例代码块， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类构造方法， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base s: &quot;</span> + s +<span class="string">&quot;, a: &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        step();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base包括一个静态变量s，一个实例变量a，一段静态初始化代码块，一段实例初始化代码块，一个构造方法，两个方法step和action。子类Child如代码清单4-8所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块， s: &quot;</span>+s);</span><br><span class="line">        s = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实例代码块， a: &quot;</span>+a);</span><br><span class="line">          a = <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;子类构造方法， a: &quot;</span>+a);</span><br><span class="line">          a = <span class="number">20</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;child s: &quot;</span> + s +<span class="string">&quot;, a: &quot;</span>+a);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Child继承了Base，也定义了和基类同名的静态变量s和实例变量a，静态初始化代码块，实例初始化代码块，构造方法，重写了方法step。使用的例子如代码清单4-9所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;---- new Child()&quot;</span>);</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- c.action()&quot;</span>);</span><br><span class="line">    c.action();</span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- b.action()&quot;</span>);</span><br><span class="line">    b.action();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- b.s: &quot;</span> + b.s);</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- c.s: &quot;</span> + c.s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了Child类型的对象，赋值给了Child类型的引用变量c，通过c调用action方法，又赋值给了Base类型的引用变量b，通过b也调用了action，最后通过b和c访问静态变量s并输出。这是屏幕的输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---- new Child()</span><br><span class="line">基类静态代码块， s: 0</span><br><span class="line">子类静态代码块， s: 0</span><br><span class="line">基类实例代码块， a: 0</span><br><span class="line">基类构造方法， a: 1</span><br><span class="line">子类实例代码块， a: 0</span><br><span class="line">子类构造方法， a: 10</span><br><span class="line">---- c.action()</span><br><span class="line">start</span><br><span class="line">child s: 10, a: 20</span><br><span class="line">end</span><br><span class="line">---- b.action()</span><br><span class="line">start</span><br><span class="line">child s: 10, a: 20</span><br><span class="line">end</span><br><span class="line">---- b.s: 1</span><br><span class="line">---- c.s: 10</span><br></pre></td></tr></table></figure>
<p>下面我们来解释一下背后都发生了一些什么事情，从类的加载开始。</p>
<h4 id="4-3-2-类加载过程"><a href="#4-3-2-类加载过程" class="headerlink" title="4.3.2 类加载过程"></a>4.3.2 类加载过程</h4><p>在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。</p>
<p>1）一个类的信息主要包括以下部分：❑ 类变量（静态变量）；</p>
<p>❑ 类初始化代码；❑ 类方法（静态方法）；❑ 实例变量；❑ 实例初始化代码；❑ 实例方法；❑ 父类信息引用。</p>
<p>2）类初始化代码包括：❑ 定义静态变量时的赋值语句；❑ 静态初始化代码块。</p>
<p>3）实例初始化代码包括：❑ 定义实例变量时的赋值语句；❑ 实例初始化代码块；❑ 构造方法。</p>
<p>4）类加载过程包括：❑ 分配内存保存类的信息；❑ 给类变量赋默认值；❑ 加载父类；❑ 设置父子关系；❑ 执行类初始化代码。</p>
<p>注意，类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值。对于默认值，我们之前说过，数字型变量都是0, boolean是false, char是’\u0000’，引用型变量是null。</p>
<p>之前我们说过，内存分为栈和堆，栈存放函数的局部变量，而堆存放动态分配的对象，还有一个内存区，存放类的信息，这个区在Java中称为方法区。</p>
<p>加载后，Java方法区就有了一份这个类的信息。以我们的例子来说，有3份类信息，分别是Child、Base、Object，内存布局如图4-3所示</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310192038049.png" alt="image-20231019203808211"></p>
<p>我们用class_init()来表示类初始化代码，用instance_init()表示实例初始化代码，实例初始化代码包括了实例初始化代码块和构造方法。例子中只有一个构造方法，实际情况则可能有多个实例初始化方法。</p>
<p>本例中，类的加载大致就是在内存中形成了类似上面的布局，然后分别执行了Base和Child的类初始化代码。接下来，我们看对象创建的过程。</p>
<h4 id="4-3-3-对象创建的过程"><a href="#4-3-3-对象创建的过程" class="headerlink" title="4.3.3 对象创建的过程"></a>4.3.3 对象创建的过程</h4><p>在类加载之后，new Child()就是创建Child对象，创建对象过程包括：</p>
<p>1）分配内存；</p>
<p>2）对所有实例变量赋默认值；</p>
<p>3）执行实例初始化代码。</p>
<p>分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。</p>
<p>每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。</p>
<p>Child c = new Child()；会将新创建的Child对象引用赋给变量c，而Base b = c；会让b也引用这个Child对象。创建和赋值后，内存布局如图4-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310192040859.png" alt="image-20231019204047761"></p>
<p>引用型变量c和b分配在栈中，它们指向相同的堆中的Child对象。Child对象存储着方法区中Child类型的地址，还有Base中的实例变量a和Child中的实例变量a。创建了对象，接下来，来看方法调用的过程。</p>
<h4 id="4-3-4-方法调用的过程"><a href="#4-3-4-方法调用的过程" class="headerlink" title="4.3.4 方法调用的过程"></a>4.3.4 方法调用的过程</h4><p>我们先来看c.action(); ，这句代码的执行过程：</p>
<p>1）查看c的对象类型，找到Child类型，在Child类型中找action方法，发现没有，到父类中寻找；</p>
<p>2）在父类Base中找到了方法action，开始执行action方法；</p>
<p>3）action先输出了start，然后发现需要调用step()方法，就从Child类型开始寻找step()方法；</p>
<p>4）在Child类型中找到了step()方法，执行Child中的step()方法，执行完后返回action方法；</p>
<p>5）继续执行action方法，输出end。</p>
<p>寻找要执行的实例方法的时候，<strong>是从对象的实际类型信息开始查找的</strong>，找不到的时候，再查找父类类型信息。</p>
<p>我们来看b.action()，这句代码的输出和c.action()是一样的，这<strong>称为动态绑定，而动态绑定实现的机制就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。</strong>这里，因为b和c指向相同的对象，所以执行结果是一样的。</p>
<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。大多数系统使用一种称为虚方法表的方法来优化调用的效率。</p>
<p>所谓虚方法表，就是在类加载的时候为每个类创建一个表，记录该类的对象所有动态绑定的方法（包括父类的方法）及其地址，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。对于本例来说，Child和Base的虚方法表如图4-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310192043887.png" alt="image-20231019204355799"></p>
<p>对Child类型来说，action方法指向Base中的代码，toString方法指向Object中的代码，而step()指向本类中的代码。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。接下来，我们介绍变量访问的过程。</p>
<h4 id="4-3-5-变量访问的过程"><a href="#4-3-5-变量访问的过程" class="headerlink" title="4.3.5 变量访问的过程"></a>4.3.5 变量访问的过程</h4><p>对变量的访问是静态绑定的，无论是类变量还是实例变量。代码中演示的是类变量：b.s和c.s，通过对象访问类变量，系统会转换为直接访问类变量Base.s和Child.s。</p>
<p>例子中的实例变量都是private的，不能直接访问；如果是public的，则b.a访问的是对象中Base类定义的实例变量a，而c.a访问的是对象中Child类定义的实例变量a。</p>
<p>本节通过一个例子来介绍类的加载、对象创建、方法调用以及变量访问的内部过程。现在，我们应该对继承的实现有了比较清楚的理解。之前我们提到，继承是把双刃剑，为什么这么说呢？让我们下节来探讨。</p>
<h3 id="4-4-为什么说继承是把双刃剑"><a href="#4-4-为什么说继承是把双刃剑" class="headerlink" title="4.4 为什么说继承是把双刃剑"></a>4.4 为什么说继承是把双刃剑</h3><p>继承其实是把双刃剑：一方面继承是非常强大的；另一方面继承的破坏力也是很强的。</p>
<p>继承广泛应用于各种Java API、框架和类库之中，一方面它们内部大量使用继承，另一方面它们设计了良好的框架结构，提供了大量基类和基础公共代码。使用者可以使用继承，重写适当方法进行定制，就可以简单方便地实现强大的功能。</p>
<p>但，继承为什么会有破坏力呢？主要是因为继承可能破坏封装，而封装可以说是程序设计的第一原则；另外，继承可能没有反映出is-a关系。下面我们详细来说明。</p>
<h4 id="4-4-1-继承破坏封装"><a href="#4-4-1-继承破坏封装" class="headerlink" title="4.4.1 继承破坏封装"></a>4.4.1 继承破坏封装</h4><p>什么是封装呢？封装就是隐藏实现细节，提供简化接口。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。实现细节可以随时修改，而不影响使用者。函数是封装，类也是封装。通过封装，才能在更高的层次上考虑和解决问题。可以说，封装是程序设计的第一原则，没有封装，代码之间会到处存在着实现细节的依赖，则构建和维护复杂的程序是难以想象的。</p>
<p>继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。我们通过一些例子来说明。这些例子主要用于演示，可以基本忽略其实际意义。</p>
<h4 id="4-4-2-封装是如何被破坏的"><a href="#4-4-2-封装是如何被破坏的" class="headerlink" title="4.4.2 封装是如何被破坏的"></a>4.4.2 封装是如何被破坏的</h4><p>我们来看一个简单的例子，基类Base如代码清单4-10所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;MAX_NUM)&#123;</span><br><span class="line">            arr[count++] = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : numbers)&#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Base提供了两个方法add和addAll，将输入数字添加到内部数组中。对使用者来说， add和addAll就是能够添加数字，具体是怎么添加的，不用关心。</p>
<p>子类代码Child如代码清单4-11所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.add(number);</span><br><span class="line">        sum+=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addAll(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写了基类的add和addAll方法，在添加数字的同时汇总数字，存储数字的和到实例变量sum中，并提供了方法getSum获取sum的值。使用Child的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(c.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用addAll添加1、2、3，期望的输出是1+2+3=6，实际输出为12！为什么是12呢？查看代码不难看出，同一个数字被汇总了两次。子类的addAll方法首先调用了父类的add-All方法，而父类的addAll方法通过add方法添加，由于动态绑定，子类的add方法会执行，子类的add也会做汇总操作。</p>
<p>可以看出，如果子类不知道基类方法的实现细节，它就不能正确地进行扩展。知道了错误，现在我们修改子类实现，修改addAll方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addAll(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，addAll方法不再进行重复汇总。这次，程序就可以输出正确结果6了。</p>
<p>但是，基类Base决定修改addAll方法的实现，改为下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;MAX_NUM)&#123;</span><br><span class="line">            arr[count++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，它不再通过调用add方法添加，这是Base类的实现细节。但是，修改了基类的内部细节后，上面使用子类的程序却错了，输出由正确值6变为了0。</p>
<p>从这个例子，可以看出，子类和父类之间是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还需要知道父类是怎么做的，而父类的实现细节也不能随意修改，否则可能影响子类。</p>
<p>更具体地说，子类需要知道父类的可重写方法之间的依赖关系，具体到上例中，就是add和addAll方法之间的关系，而且这个依赖关系，父类不能随意改变。</p>
<p>但即使这个依赖关系不变，封装还是可能被破坏。还是上面的例子，我们先将addAll方法改回去，这次，我们在基类Base中添加一个方法clear，这个方法的作用是将所有添加的数字清空，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类添加一个方法不需要告诉子类，Child类不知道Base类添加了这么一个方法，但因为继承关系，Child类却自动拥有了这么一个方法。因此，Child类的使用者可能会这么使用Child类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    c.clear();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(c.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先添加一次，之后调用clear清空，又添加一次，最后输出sum，期望结果是6，但实际输出是12。因为Child没有重写clear方法，它需要增加如下代码，重置其内部的sum值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">    <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，父类不能随意增加公开方法，因为给父类增加就是给所有子类增加，而子类可能必须要重写该方法才能确保方法的正确性。</p>
<p>总结一下：对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏；而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</p>
<h4 id="4-4-3-继承没有反映is-a关系"><a href="#4-4-3-继承没有反映is-a关系" class="headerlink" title="4.4.3 继承没有反映is-a关系"></a>4.4.3 继承没有反映is-a关系</h4><p>继承关系是设计用来反映is-a关系的，子类是父类的一种，子类对象也属于父类，父类的属性和行为也适用于子类。就像橙子是水果一样，水果有的属性和行为，橙子也必然都有。</p>
<p>但现实中，设计完全符合is-a关系的继承关系是困难的。比如，绝大部分鸟都会飞，可能就想给鸟类增加一个方法fly()表示飞，但有一些鸟就不会飞，比如企鹅。</p>
<p>在is-a关系中，重写方法时，子类不应该改变父类预期的行为，但是这是没有办法约束的。还是以鸟为例，你可能给父类增加了fly()方法，对企鹅，你可能想，企鹅不会飞，但可以走和游泳，就在企鹅的fly()方法中，实现了有关走或游泳的逻辑。</p>
<p>继承是应该被当作is-a关系使用的，但是，Java并没有办法约束，父类有的属性和行为，子类并不一定都适用，子类还可以重写方法，实现与父类预期完全不一样的行为。</p>
<p>但对于通过父类引用操作子类对象的程序而言，它是把对象当作父类对象来看待的，期望对象符合父类中声明的属性和行为。如果不符合，结果是什么呢？混乱。</p>
<h4 id="4-4-4-如何应对继承的双面性"><a href="#4-4-4-如何应对继承的双面性" class="headerlink" title="4.4.4 如何应对继承的双面性"></a>4.4.4 如何应对继承的双面性</h4><p>继承既强大又有破坏性，那怎么办呢？</p>
<p>1）避免使用继承；</p>
<p>2）正确使用继承。</p>
<p>我们先来看怎么避免继承，有三种方法：</p>
<p>❑ 使用final关键字；</p>
<p>❑ 优先使用组合而非继承；</p>
<p>❑ 使用接口。</p>
<h5 id="1．使用final避免继承"><a href="#1．使用final避免继承" class="headerlink" title="1．使用final避免继承"></a>1．使用final避免继承</h5><p>在4.2节，我们提到过final类和final方法，final方法不能被重写，final类不能被继承，我们没有解释为什么需要它们。通过上面的介绍，我们就应该能够理解其中的一些原因了。</p>
<p>给方法加final修饰符，父类就保留了随意修改这个方法内部实现的自由，使用这个方法的程序也可以确保其行为是符合父类声明的。</p>
<p>给类加final修饰符，父类就保留了随意修改这个类实现的自由，使用者也可以放心地使用它，而不用担心一个父类引用的变量，实际指向的却是一个完全不符合预期行为的子类对象。</p>
<h5 id="2．优先使用组合而非继承"><a href="#2．优先使用组合而非继承" class="headerlink" title="2．优先使用组合而非继承"></a>2．优先使用组合而非继承</h5><p>使用组合可以抵挡父类变化对子类的影响，从而保护子类，应该优先使用组合。还是上面的例子，我们使用组合来重写一下子类，如代码清单4-12所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">        base = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        base.add(number);</span><br><span class="line">        sum+=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        base.addAll(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，子类就不需要关注基类是如何实现的了，基类修改实现细节，增加公开方法，也不会影响到子类了。但组合的问题是，子类对象不能当作基类对象来统一处理了。解决方法是使用接口。接口是什么呢？我们留待下章介绍。</p>
<h5 id="3．正确使用继承"><a href="#3．正确使用继承" class="headerlink" title="3．正确使用继承"></a>3．正确使用继承</h5><p>如果要使用继承，怎么正确使用呢？使用继承大概主要有三种场景：</p>
<p>1）基类是别人写的，我们写子类；</p>
<p>2）我们写基类，别人可能写子类；</p>
<p>3）基类、子类都是我们写的。</p>
<p>第1种场景中，基类主要是Java API、其他框架或类库中的类，在这种情况下，我们主要通过扩展基类，实现自定义行为，这种情况下需要注意的是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❑ 重写方法不要改变预期的行为；</span><br><span class="line">❑ 阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的依赖关系；</span><br><span class="line">❑ 在基类修改的情况下，阅读其修改说明，相应修改子类。</span><br></pre></td></tr></table></figure>
<p>第2种场景中，我们写基类给别人用，在这种情况下，需要注意的是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❑ 使用继承反映真正的is-a关系，只将真正公共的部分放到基类；</span><br><span class="line">❑ 对不希望被重写的公开方法添加final修饰符；</span><br><span class="line">❑ 写文档，说明可重写方法的实现机制，为子类提供指导，告诉子类应该如何重写；</span><br><span class="line">❑ 在基类修改可能影响子类时，写修改说明。</span><br></pre></td></tr></table></figure>
<p>第3种场景，我们既写基类也写子类，关于基类，注意事项和第2种场景类似，关于子类，注意事项和第1种场景类似，不过程序都由我们控制，要求可以适当放松一些。</p>
<p>至此，关于继承就介绍完了，本章最后，我们提到了一个概念：接口，接口到底是什么呢？让我们下章探讨。</p>
<h2 id="第5章-类的扩展"><a href="#第5章-类的扩展" class="headerlink" title="第5章 类的扩展"></a>第5章 类的扩展</h2><h3 id="5-3-内部类的本质"><a href="#5-3-内部类的本质" class="headerlink" title="5.3 内部类的本质"></a>5.3 内部类的本质</h3><h4 id="5-3-1-静态内部类"><a href="#5-3-1-静态内部类" class="headerlink" title="5.3.1 静态内部类"></a>5.3.1 静态内部类</h4><p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<h1 id="第三部分-泛型与容器"><a href="#第三部分-泛型与容器" class="headerlink" title="第三部分 泛型与容器"></a>第三部分 泛型与容器</h1><h2 id="第8章-泛型"><a href="#第8章-泛型" class="headerlink" title="第8章 泛型"></a>第8章 泛型</h2><p>之前章节中我们多次提到过泛型这个概念，本章我们就来详细讨论Java中的泛型。虽然泛型的基本思维和概念是比较简单的，但它有一些非常令人费解的语法、细节，以及局限性。</p>
<p>后续章节我们会介绍各种容器类。容器类可以说是日常程序开发中天天用到的，没有容器类，难以想象能开发什么真正有用的程序。而容器类是基于泛型的，不理解泛型，就难以深刻理解容器类。那泛型到底是什么呢？本章我们分为三节逐步来讨论：8.1节主要介绍泛型的基本概念和原理；8.2节重点介绍令人费解的通配符；8.3节介绍一些细节和泛型的局限性。</p>
<h3 id="8-1-基本概念和原理"><a href="#8-1-基本概念和原理" class="headerlink" title="8.1 基本概念和原理"></a>8.1 基本概念和原理</h3><p>之前我们一直强调数据类型的概念，Java有8种基本类型，可以定义类，类相当于自定义数据类型，类之间还可以有组合和继承。我们也介绍了接口，其中提到，很多时候我们关心的不是类型，而是能力，针对接口和能力编程，不仅可以复用代码，还可以降低耦合，提高灵活性。</p>
<p>泛型将接口的概念进一步延伸，“泛型”的字面意思就是广泛的类型。类、接口和方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型，这样，不仅可以复用代码，降低耦合，而且可以提高代码的可读性和安全性。</p>
<p>这么说可能比较抽象，接下来，我们通过一些例子逐步进行说明。在Java中，类、接口、方法都可以是泛型的，我们先来看泛型类。</p>
<h4 id="8-1-1-一个简单泛型类"><a href="#8-1-1-一个简单泛型类" class="headerlink" title="8.1.1 一个简单泛型类"></a>8.1.1 一个简单泛型类</h4><p>我们通过一个简单的例子来说明泛型类的基本概念、基本原理和泛型的好处。</p>
<h5 id="1．基本概念"><a href="#1．基本概念" class="headerlink" title="1．基本概念"></a>1．基本概念</h5><p>我们直接来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pair就是一个泛型类，与普通类的区别体现在：</p>
<p>1）类名后面多了一个\<T>；</p>
<p>2）first和second的类型都是T。</p>
<p>T是什么呢？T表示类型参数，<strong>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入</strong>。怎么用这个泛型类，并传递类型参数呢？看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; minmax = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> minmax.getFirst();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> minmax.getSecond();</span><br></pre></td></tr></table></figure>
<p>Pair\<Integer>中的Integer就是传递的实际类型参数。Pair类的代码和它处理的数据类型不是绑定的，具体类型可以变化。上面是Integer，也可以是String，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; kv = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>类型参数可以有多个，Pair类中的first和second可以是不同的类型，多个类型之间以逗号分隔，来看改进后的Pair类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;U, V&gt; &#123;</span><br><span class="line">        U first;</span><br><span class="line">        V second;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(U first, V second)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.first = first;</span><br><span class="line">            <span class="built_in">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> U <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><String, Integer>既出现在了声明变量时，也出现在了new后面，比较烦琐，从Java 7开始，支持省略后面的类型参数，可以如下使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h5 id="2．基本原理"><a href="#2．基本原理" class="headerlink" title="2．基本原理"></a>2．基本原理</h5><p>泛型类型参数到底是什么呢？为什么一定要定义类型参数呢？定义普通类，直接使用Object不就行了吗？比如，Pair类可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    Object first;</span><br><span class="line">    Object second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Pair的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">minmax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> (Integer)minmax.getFirst();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> (Integer)minmax.getSecond();</span><br><span class="line"><span class="type">Pair</span> <span class="variable">kv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String)kv.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String)kv.getSecond();</span><br></pre></td></tr></table></figure>
<p>这样是可以的。实际上，Java泛型的内部原理就是这样的。</p>
<p>我们知道，Java有Java编译器和Java虚拟机，编译器将Java源代码转换为．class文件，虚拟机加载并运行．class文件。对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，就像上面的普通Pair类代码及其使用代码一样，将类型参数T擦除，替换为Object，插入必要的强制类型转换。Java虚拟机实际执行的时候，它是不知道泛型这回事的，只知道普通的类及代码。</p>
<p>再强调一下，Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数，比如Pair\<Integer>，运行中只知道Pair，而不知道Integer。认识到这一点是非常重要的，它有助于我们理解Java泛型的很多限制。</p>
<p>Java为什么要这么设计呢？泛型是Java 5以后才支持的，这么设计是为了兼容性而不得已的一个选择。</p>
<h5 id="3．泛型的好处"><a href="#3．泛型的好处" class="headerlink" title="3．泛型的好处"></a>3．泛型的好处</h5><p>既然只使用普通类和Object就可以，而且泛型最后也转换为了普通类，那为什么还要用泛型呢？或者说，泛型到底有什么好处呢？泛型主要有两个好处：</p>
<p>❑ 更好的安全性。</p>
<p>❑ 更好的可读性。</p>
<p>语言和程序设计的一个重要目标是将bug尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代码写完程序运行的时候。<strong>只使用Object</strong>，代码写错的时候，开发环境和编译器不能帮我们发现问题，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;老马&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer)pair.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)pair.getSecond();</span><br></pre></td></tr></table></figure>
<p>看出问题了吗？写代码时不小心把类型弄错了，不过，代码编译时是没有任何问题的，但运行时程序抛出了类型转换异常ClassCastException。如果使用泛型，则不可能犯这个错误，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> pair.getFirst(); <span class="comment">//有编译错误</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pair.getSecond(); <span class="comment">//有编译错误</span></span><br></pre></td></tr></table></figure>
<p>开发环境（如Eclipse）会提示类型错误，即使没有好的开发环境，编译时Java编译器也会提示。这称之为类型安全，也就是说，通过使用泛型，开发环境和编译器能确保不会用错类型，为程序多设置一道安全防护网。使用泛型，还可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。</p>
<h4 id="8-1-2-容器类"><a href="#8-1-2-容器类" class="headerlink" title="8.1.2 容器类"></a>8.1.2 容器类</h4><p>泛型类最常见的用途是作为容器类。所谓容器类，简单地说，就是容纳并管理多项数据的类。数组就是用来管理多项数据的，但数组有很多限制，比如，长度固定，插入、删除操作效率比较低。计算机技术有一门课程叫数据结构，专门讨论管理数据的各种方式。</p>
<p>这些数据结构在Java中的实现主要就是Java中的各种容器类，甚至Java泛型的引入主要也是为了更好地支持Java容器。后续章节我们会详细讨论主要的Java容器，本节先实现一个非常简单的Java容器，来解释泛型的一些概念。</p>
<p>我们来实现一个简单的动态数组容器。所谓动态数组，就是长度可变的数组。底层数组的长度当然是不可变的，但我们提供一个类，对这个类的使用者而言，好像就是一个长度可变的数组。Java容器中有一个对应的类ArrayList，本节我们来实现一个简化版，如代码清单8-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicArray</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="keyword">if</span>(oldCapacity &gt;= minCapacity)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newCapacity &lt; minCapacity)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E)elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DynamicArray就是一个动态数组，内部代码与我们之前分析过的StringBuilder类似，通过ensureCapacity方法来根据需要扩展数组。作为一个容器类，它容纳的数据类型是作为参数传递过来的，比如，存放Double类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Double&gt; arr = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;Double&gt;();</span><br><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>+rnd.nextInt(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">      arr.add(Math.random());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> arr.get(rnd.nextInt(size));</span><br></pre></td></tr></table></figure>
<p>这就是一个简单的容器类，适用于各种数据类型，且类型安全。后文还会以Dynamic-Array为例进行扩展，以解释泛型概念。</p>
<p>具体的类型还可以是一个泛型类，比如，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Pair&lt;Integer, String&gt;&gt; arr = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>
<p>arr表示一个动态数组，每个元素是Pair<Integer, String>类型。</p>
<h4 id="8-1-3-泛型方法"><a href="#8-1-3-泛型方法" class="headerlink" title="8.1.3 泛型方法"></a>8.1.3 泛型方法</h4><p>除了泛型类，方法也可以是泛型的，而且，一个方法是不是泛型的，与它所在的类是不是泛型没有什么关系。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T[] arr, T elm)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(elm))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是一个泛型方法，类型参数为T，放在返回值前面，它可以如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>也可以如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;老马&quot;</span>, <span class="string">&quot;编程&quot;</span>&#125;, <span class="string">&quot;老马&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>indexOf表示一个算法，在给定数组中寻找某个元素，这个算法的基本过程与具体数据类型没有什么关系，通过泛型，它可以方便地应用于各种数据类型，且由编译器保证类型安全。</p>
<p>与泛型类一样，类型参数可以有多个，以逗号分隔，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U, V&gt; Pair&lt;U, V&gt; <span class="title function_">makePair</span><span class="params">(U first, V second)</span>&#123;</span><br><span class="line">    Pair&lt;U, V&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(first, second);</span><br><span class="line">    <span class="keyword">return</span> pair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与泛型类不同，调用方法时一般并不需要特意指定类型参数的实际类型，比如调用make-Pair：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makePair(<span class="number">1</span>, <span class="string">&quot;老马&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>并不需要告诉编译器U的类型是Integer, V的类型是String, Java编译器可以自动推断出来。</p>
<h4 id="8-1-4-泛型接口"><a href="#8-1-4-泛型接口" class="headerlink" title="8.1.4 泛型接口"></a>8.1.4 泛型接口</h4><p>接口也可以是泛型的，我们之前介绍过的Comparable和Comparator接口都是泛型的，它们的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面一样，T是类型参数。实现接口时，应该指定具体的类型，比如，对Integer类，实现代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="built_in">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过implements Comparable\<Integer>, Integer实现了Comparable接口，指定了实际类型参数为Integer，表示Integer只能与Integer对象进行比较。</p>
<p>再看Comparator的一个例子，String类内部一个Comparator的接口实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveComparator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="comment">//省略主体代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，指定了实际类型参数为String。</p>
<h4 id="8-1-5-类型参数的限定"><a href="#8-1-5-类型参数的限定" class="headerlink" title="8.1.5 类型参数的限定"></a>8.1.5 类型参数的限定</h4><p>在之前的介绍中，无论是泛型类、泛型方法还是泛型接口，关于类型参数，我们都知之甚少，只能把它当作Object，但Java支持限定这个参数的一个上界，也就是说，参数必须为给定的上界类型或其子类型，这个限定是通过extends关键字来表示的。这个上界可以是某个具体的类或者某个具体的接口，也可以是其他的类型参数，我们逐个介绍其应用。</p>
<h5 id="1．上界为某个具体类"><a href="#1．上界为某个具体类" class="headerlink" title="1．上界为某个具体类"></a>1．上界为某个具体类</h5><p>比如，上面的Pair类，可以定义一个子类NumberPair，限定两个类型参数必须为Number，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberPair</span>&lt;U <span class="keyword">extends</span> <span class="title class_">Number</span>, V <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;</span><br><span class="line">      <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;U, V&gt; &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">NumberPair</span><span class="params">(U first, V second)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(first, second);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>限定类型后，就可以使用该类型的方法了。比如，对于NumberPair类，first和second变量就可以当作Number进行处理了。比如可以定义一个求和方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst().doubleValue() +getSecond().doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberPair&lt;Integer, Double&gt; pair = <span class="keyword">new</span> <span class="title class_">NumberPair</span>&lt;&gt;(<span class="number">10</span>, <span class="number">12.34</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> pair.sum();</span><br></pre></td></tr></table></figure>
<p>限定类型后，如果类型使用错误，编译器会提示。指定边界后，类型擦除时就不会转换为Object了，而是会转换为它的边界类型，这也是容易理解的。</p>
<h5 id="2．上界为某个接口"><a href="#2．上界为某个接口" class="headerlink" title="2．上界为某个接口"></a>2．上界为某个接口</h5><p>在泛型方法中，一种常见的场景是限定类型必须实现Comparable接口，我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">max</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>max方法计算一个泛型数组中的最大值。计算最大值需要进行元素之间的比较，要求元素实现Comparable接口，所以给类型参数设置了一个上边界Comparable, T必须实现Comparable接口。</p>
<p>不过，直接这么编写代码，Java中会给一个警告信息，因为Comparable是一个泛型接口，它也需要一个类型参数，所以完整的方法声明应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><T extends Comparable\<T>&gt;是一种令人费解的语法形式，这种形式称为<strong>递归类型限制</strong>，可以这么解读：<strong>T表示一种数据类型，必须实现Comparable接口，且必须可以与相同类型的元素进行比较。</strong></p>
<h5 id="3．上界为其他类型参数"><a href="#3．上界为其他类型参数" class="headerlink" title="3．上界为其他类型参数"></a>3．上界为其他类型参数</h5><p>上面的限定都是指定了一个明确的类或接口，Java支持一个类型参数以另一个类型参数作为上界。为什么需要这个呢？我们看个例子，给上面的DynamicArray类增加一个实例方法addAll，这个方法将参数容器中的所有元素都添加到当前容器里来，直觉上，代码可以如下书写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(DynamicArray&lt;E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这么写有一些局限性，我们看使用它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints); <span class="comment">//会提示编译错误</span></span><br></pre></td></tr></table></figure>
<p>numbers是一个Number类型的容器，ints是一个Integer类型的容器，我们希望将ints添加到numbers中，因为Integer是Number的子类，应该说，这是一个合理的需求和操作。</p>
<p>但Java会在numbers.addAll(ints)这行代码上提示编译错误：addAll需要的参数类型为DynamicArray\<Number>，而传递过来的参数类型为DynamicArray\<Integer>，不适用。Integer是Number的子类，怎么会不适用呢？</p>
<p>事实就是这样，确实不适用，而且是很有道理的，假设适用，我们看下会发生什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Number&gt; numbers = ints; <span class="comment">//假设这行是合法的</span></span><br><span class="line">numbers.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.34</span>));</span><br></pre></td></tr></table></figure>
<p>那最后一行就是合法的，这时，DynamicArray\<Integer>中就会出现Double类型的值，而这显然破坏了Java泛型关于类型安全的保证。</p>
<p>我们强调一下，虽然Integer是Number的子类，但DynamicArray\<Integer>并不是DynamicArray\<Number>的子类，DynamicArray\<Integer>的对象也不能赋值给Dynamic-Array\<Number>的变量，这一点初看上去是违反直觉的，但这是事实，必须要理解这一点。</p>
<p>不过，我们的需求是合理的，将Integer添加到Number容器中并没有问题。这个问题可以通过类型限定来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">E</span>&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E是DynamicArray的类型参数，T是addAll的类型参数，T的上界限定为E，这样，下面的代码就没有问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints);</span><br></pre></td></tr></table></figure>
<p>对于这个例子，这种写法有点烦琐，8.2节中我们会介绍一种简化的方式。</p>
<h3 id="8-2-解析通配符"><a href="#8-2-解析通配符" class="headerlink" title="8.2 解析通配符"></a>8.2 解析通配符</h3><p>本节主要讨论泛型中的通配符概念。通配符有着令人费解和混淆的语法，但通配符大量应用于Java容器类中，它到底是什么？下面我们逐步来解析。</p>
<h4 id="8-2-1-更简洁的参数类型限定"><a href="#8-2-1-更简洁的参数类型限定" class="headerlink" title="8.2.1 更简洁的参数类型限定"></a>8.2.1 更简洁的参数类型限定</h4><p>在8.1节最后，我们提到一个例子，为了将Integer对象添加到Number容器中，我们的类型参数使用了其他类型参数作为上界，我们提到，这种写法有点烦琐，它可以替换为更为简洁的通配符形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法没有定义类型参数，c的类型是DynamicArray&lt;? extends E&gt;, ？表示通配符，&lt;? extends E&gt;表示有限定通配符，匹配E或E的某个子类型，具体什么子类型是未知的。使用这个方法的代码不需要做任何改动，还可以是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints);</span><br></pre></td></tr></table></figure>
<p>这里，E是Number类型，DynamicArray&lt;? extends E&gt;可以匹配DynamicArray\<Integer>。</p>
<p>那么问题来了，同样是extends关键字，同样应用于泛型，\<T extends E>和&lt;? extends E&gt;到底有什么关系？它们用的地方不一样，我们解释一下：</p>
<p>1）\<T extends E>用于<strong>定义</strong>类型参数，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。</p>
<p>2）&lt;? extends E&gt;用于<strong>实例化</strong>类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。</p>
<p>虽然它们不一样，但两种写法经常可以达成相同目标，比如，前面例子中，下面两种写法都可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">E</span>&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>那么，到底应该用哪种形式呢？我们先进一步理解通配符，然后再解释。</p>
<h4 id="8-2-2-理解通配符"><a href="#8-2-2-理解通配符" class="headerlink" title="8.2.2 理解通配符"></a>8.2.2 理解通配符</h4><p>除了有限定通配符，还有一种通配符，形如DynamicArray&lt;? &gt;，称为无限定通配符。我们来看个例子，在DynamicArray中查找指定元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(DynamicArray&lt;? &gt; arr, Object elm)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.get(i).equals(elm))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，这种无限定通配符形式也可以改为使用类型参数。也就是说，下面的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(DynamicArray&lt;? &gt; arr, Object elm)</span></span><br></pre></td></tr></table></figure>
<p>可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(DynamicArray&lt;T&gt; arr, Object elm)</span></span><br></pre></td></tr></table></figure>
<p>不过，通配符形式更为简洁。虽然通配符形式更为简洁，但上面两种通配符都有一个重要的限制：<strong>只能读，不能写</strong>。怎么理解呢？看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; numbers = ints;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">numbers.add(a); <span class="comment">//错误！</span></span><br><span class="line">numbers.add((Number)a); <span class="comment">//错误！</span></span><br><span class="line">numbers.add((Object)a); <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>三种add方法都是非法的，无论是Integer，还是Number或Object，编译器都会报错。为什么呢？问号就是表示类型安全无知，? extends Number表示是Number的某个子类型，但不知道具体子类型，如果允许写入，Java就无法确保类型安全性，所以干脆禁止。我们来看个例子，看看如果允许写入会发生什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">DynamicArray&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; numbers = ints;</span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">23.0</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">numbers.add(n);</span><br><span class="line">numbers.add(o);</span><br></pre></td></tr></table></figure>
<p>如果允许写入Object或Number类型，则最后两行编译就是正确的，也就是说，Java将允许把Double或String对象放入Integer容器，这显然违背了Java关于类型安全的承诺。</p>
<p>大部分情况下，这种限制是好的，但这使得一些理应正确的基本操作无法完成，比如交换两个元素的位置，看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(DynamicArray&lt;? &gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">    arr.set(i, arr.get(j));</span><br><span class="line">    arr.set(j, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码看上去应该是正确的，但Java会提示编译错误，两行set语句都是非法的。不过，借助带类型参数的泛型方法，这个问题可以如下解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">swapInternal</span><span class="params">(DynamicArray&lt;T&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">tmp</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">    arr.set(i, arr.get(j));</span><br><span class="line">    arr.set(j, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(DynamicArray&lt;? &gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    swapInternal(arr, i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swap可以调用swapInternal，而带类型参数的swapInternal可以写入。Java容器类中就有类似这样的用法，公共的API是通配符形式，形式更简单，但内部调用带类型参数的方法。</p>
<p>除了这种需要写的场合，如果参数类型之间有依赖关系，也只能用类型参数，比如，将src容器中的内容复制到dest中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;D, S <span class="keyword">extends</span> <span class="title class_">D</span>&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(DynamicArray&lt;D&gt; dest,</span></span><br><span class="line"><span class="params">        DynamicArray&lt;S&gt; src)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++)&#123;</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>S和D有依赖关系，要么相同，要么S是D的子类，否则类型不兼容，有编译错误。不过，上面的声明可以使用通配符简化，两个参数可以简化为一个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;D&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(DynamicArray&lt;D&gt; dest,</span></span><br><span class="line"><span class="params">        DynamicArray&lt;? extends D&gt; src)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++)&#123;</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回值依赖于类型参数，也不能用通配符，比如，计算动态数组中的最大值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.get(i).compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max = arr.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就难以用通配符代替。</p>
<p>现在我们再来看泛型方法到底应该用通配符的形式还是加类型参数。两者到底有什么关系？我们总结如下。</p>
<p>1）通配符形式都可以用类型参数的形式来替代，通配符能做的，用类型参数都能做。</p>
<p>2）通配符形式可以减少类型参数，形式上往往更为简单，可读性也更好，所以，能用通配符的就用通配符。</p>
<p>3）如果类型参数之间有依赖关系，或者返回值依赖类型参数，或者需要写操作，则只能用类型参数。</p>
<p>4）通配符形式和类型参数往往配合使用，比如，上面的copy方法，定义必要的类型参数，使用通配符表达依赖，并接受更广泛的数据类型。</p>
<h4 id="8-2-3-超类型通配符"><a href="#8-2-3-超类型通配符" class="headerlink" title="8.2.3 超类型通配符"></a>8.2.3 超类型通配符</h4><p>还有一种通配符，与形式&lt;? extends E&gt;正好相反，它的形式为&lt;? super E&gt;，称为超类型通配符，表示E的某个父类型。它有什么用呢？有了它，我们就可以更灵活地写入了。</p>
<p>如果没有这种语法，写入会有一些限制。来看个例子，我们给DynamicArray添加一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(DynamicArray&lt;E&gt; dest)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也很简单，将当前容器中的元素添加到传入的目标容器中。我们可能希望这么使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;Integer&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;Number&gt;();</span><br><span class="line">ints.copyTo(numbers);</span><br></pre></td></tr></table></figure>
<p>Integer是Number的子类，将Integer对象拷贝入Number容器，这种用法应该是合情合理的，但Java会提示编译错误，理由我们之前也说过了，期望的参数类型是Dynamic-Array\<Integer>, DynamicArray\<Number>并不适用。</p>
<p>如之前所说，一般而言，不能将DynamicArray\<Integer>看作DynamicArray\<Number>，但我们这里的用法是没有问题的，Java解决这个问题的方法就是超类型通配符，可以将copyTo代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(DynamicArray&lt;? <span class="built_in">super</span> E&gt; dest)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就没有问题了。</p>
<p>超类型通配符另一个常用的场合是Comparable/Comparator接口。同样，我们先来看下如果不使用会有什么限制。以前面计算最大值的方法为例，它的方法声明是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>这个声明有什么限制呢？举个简单的例子，有两个类Base和Child, Base的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt;&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> sortOrder;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sortOrder = sortOrder;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(sortOrder &lt; o.sortOrder)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sortOrder &gt; o.sortOrder)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base代码很简单，实现了Comparable接口，根据实例变量sortOrder进行比较。Child代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，Child非常简单，只是继承了Base。注意：Child没有重新实现Comparable接口，因为Child的比较规则和Base是一样的。我们可能希望使用前面的max方法操作Child容器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Child&gt; childs = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;Child&gt;();</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">20</span>));</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">80</span>));</span><br><span class="line"><span class="type">Child</span> <span class="variable">maxChild</span> <span class="operator">=</span> max(childs);</span><br></pre></td></tr></table></figure>
<p>遗憾的是，Java会提示编译错误，类型不匹配。为什么不匹配呢？我们可能会认为，Java会将max方法的类型参数T推断为Child类型，但类型T的要求是extends Comparable\<T>，而Child并没有实现Comparable\<Child>，它实现的是Comparable\<Base>。</p>
<p>但我们的需求是合理的，Base类的代码已经有了关于比较所需要的全部数据，它应该可以用于比较Child对象。解决这个问题的方法，就是修改max的方法声明，使用超类型通配符，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>这么修改一下就可以了，这种写法比较抽象，将T替换为Child，就是：</p>
<p>Child extends Comparable&lt;? super Child&gt;</p>
<p>&lt;? super Child&gt;可以匹配Base，所以整体就是匹配的。</p>
<p>我们比较一下类型参数限定与超类型通配符，类型参数限定只有extends形式，没有super形式，比如，前面的copyTo方法的通配符形式的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(DynamicArray&lt;? <span class="built_in">super</span> E&gt; dest)</span></span><br></pre></td></tr></table></figure>
<p>如果类型参数限定支持super形式，则应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="built_in">super</span> E&gt; <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(DynamicArray&lt;T&gt; dest)</span></span><br></pre></td></tr></table></figure>
<p>事实是，Java并不支持这种语法。</p>
<p>前面我们说过，对于有限定的通配符形式&lt;? extends E&gt;，可以用类型参数限定替代，但是对于类似上面的超类型通配符，则无法用类型参数替代。</p>
<h4 id="8-2-4-通配符比较"><a href="#8-2-4-通配符比较" class="headerlink" title="8.2.4 通配符比较"></a>8.2.4 通配符比较</h4><p>本节介绍了泛型中的三种通配符形式&lt;? &gt;、&lt;? super E&gt;和&lt;? extends E&gt;，并分析了与类型参数形式的区别和联系，它们比较容易混淆，我们总结比较如下：</p>
<p>1）它们的目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。</p>
<p>2）&lt;? super E&gt;用于灵活写入或比较，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象，它不能被类型参数形式替代。</p>
<p>3）&lt;? &gt;和&lt;? extends E&gt;用于灵活读取，使得方法可以读取E或E的任意子类型的容器对象，它们可以用类型参数的形式替代，但通配符形式更为简洁。</p>
<p>Java容器类的实现中，有很多使用通配符的例子，比如，类Collections中就有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll,</span></span><br><span class="line"><span class="params">    Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br></pre></td></tr></table></figure>
<p>通过前面两节，我们应该可以理解这些方法声明的含义了。关于泛型，还有一些细节以及限制，让我们下一节继续探讨。</p>
<h3 id="8-3-细节和局限性"><a href="#8-3-细节和局限性" class="headerlink" title="8.3 细节和局限性"></a>8.3 细节和局限性</h3><p>本节介绍泛型中的一些细节和局限性，这些局限性主要与Java的实现机制有关。Java中，泛型是通过类型擦除来实现的，类型参数在编译时会被替换为Object，运行时Java虚拟机不知道泛型这回事，这带来了很多局限性，其中有的部分是比较容易理解的，有的则是非常违反直觉的。</p>
<p>一项技术，往往只有理解了其局限性，才算是真正理解了它，才能更好地应用它。下面我们将从以下几个方面来介绍这些细节和局限性：</p>
<p>❑ 使用泛型类、方法和接口。</p>
<p>❑ 定义泛型类、方法和接口。</p>
<p>❑ 泛型与数组。</p>
<h4 id="8-3-1-使用泛型类、方法和接口"><a href="#8-3-1-使用泛型类、方法和接口" class="headerlink" title="8.3.1 使用泛型类、方法和接口"></a>8.3.1 使用泛型类、方法和接口</h4><p>在使用泛型类、方法和接口时，有一些值得注意的地方，比如：</p>
<p>❑ 基本类型不能用于实例化类型参数。</p>
<p>❑ 运行时类型信息不适用于泛型。</p>
<p>❑ 类型擦除可能会引发一些冲突。</p>
<p>我们逐个来看下。Java中，因为类型参数会被替换为Object，所以Java泛型中不能使用基本数据类型，也就是说，类似下面的写法是不合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; minmax = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>解决方法是使用基本类型对应的包装类。</p>
<p>在介绍继承的实现原理时，我们提到在内存中每个类都有一份类型信息，而每个对象也都保存着其对应类型信息的引用。关于运行时信息，后续章节我们会进一步详细介绍，这里简要说明一下。在Java中，这个类型信息也是一个对象，它的类型为Class, Class本身也是一个泛型类，每个类的类型对象可以通过&lt;类名&gt;.class的方式引用，比如String. class、Integer.class。这个类型对象也可以通过对象的getClass()方法获得，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? &gt; cls = <span class="string">&quot;hello&quot;</span>.getClass();</span><br></pre></td></tr></table></figure>
<p>这个类型对象只有一份，与泛型无关，所以Java不支持类似如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt;.class</span><br></pre></td></tr></table></figure>
<p>一个泛型对象的getClass方法的返回值与原始类型对象也是相同的，比如，下面代码的输出都是true：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">Pair&lt;String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(Pair.class==p1.getClass()); <span class="comment">//true</span></span><br><span class="line">System.out.println(Pair.class==p2.getClass()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>之前，我们介绍过instanceof关键字，instanceof后面是接口或类名，instanceof是运行时判断，也与泛型无关，所以，Java也不支持类似如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Pair&lt;Integer&gt;)</span><br></pre></td></tr></table></figure>
<p>不过，Java支持如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Pair&lt;? &gt;)</span><br></pre></td></tr></table></figure>
<p>由于类型擦除，可能会引发一些编译冲突，这些冲突初看上去并不容易理解，我们通过一些例子介绍。8.2.3节我们介绍过一个例子，有两个类Base和Child, Base的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt;</span><br></pre></td></tr></table></figure>
<p>Child的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br></pre></td></tr></table></figure>
<p>Child没有专门实现Comparable接口，8.2.3节我们说Base类已经有了比较所需的全部信息，所以Child没有必要实现，可是如果Child希望自定义这个比较方法呢？直觉上，可以这样修改Child类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Child&gt;&#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遗憾的是，Java编译器会提示错误，Comparable接口不能被实现两次，且两次实现的类型参数还不同，一次是Comparable\<Base>，一次是Comparable\<Child>。为什么不允许呢？因为类型擦除后，实际上只能有一个。</p>
<p>那Child有什么办法修改比较方法呢？只能是重写Base类的实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(! (o <span class="keyword">instanceof</span> Child))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)o;</span><br><span class="line">        <span class="comment">//比较代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，你可能认为可以如下定义重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray&lt;Integer&gt; intArr)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray&lt;String&gt; strArr)</span></span><br></pre></td></tr></table></figure>
<p>虽然参数都是DynamicArray，但实例化类型不同，一个是DynamicArray\<Integer>，另一个是DynamicArray\<String>，同样，遗憾的是，Java不允许这种写法，理由同样是类型擦除后它们的声明是一样的。</p>
<h4 id="8-3-2-定义泛型类、方法和接口"><a href="#8-3-2-定义泛型类、方法和接口" class="headerlink" title="8.3.2 定义泛型类、方法和接口"></a>8.3.2 定义泛型类、方法和接口</h4><p>在定义泛型类、方法和接口时，也有一些需要注意的地方，比如：</p>
<p>❑ 不能通过类型参数创建对象。</p>
<p>❑ 泛型类类型参数不能用于静态变量和静态方法。</p>
<p>❑ 了解多个类型限定的语法。</p>
<p>我们逐个介绍。不能通过类型参数创建对象，比如，T是类型参数，下面的写法都是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">elm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>为什么非法呢？因为如果允许，那么用户会以为创建的就是对应类型的对象，但由于类型擦除，Java只能创建Object类型的对象，而无法创建T类型的对象，容易引起误解，所以Java干脆禁止这么做。</p>
<p>那如果确实希望根据类型创建对象呢？需要设计API接受类型对象，即Class对象，并使用Java中的反射机制。第21章会介绍反射，这里简要说明一下。如果类型有默认构造方法，可以调用Class的newInstance方法构建对象，类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> create(Date.class);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> create(StringBuilder.class);</span><br></pre></td></tr></table></figure>
<p>对于泛型类声明的类型参数，可以在实例变量和方法中使用，但在静态变量和静态方法中是不能使用的。类似下面这种写法是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> T <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//创建实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么静态属性和静态方法不能使用类型参数？如果合法，那么对于每种实例化类型，都需要有一个对应的静态变量和方法。但由于类型擦除，Singleton类型只有一份，静态变量和方法都是类型的属性，且与类型参数无关，所以不能使用泛型类类型参数。</p>
<p>不过，对于静态方法，它可以是泛型方法，可以声明自己的类型参数，这个参数与泛型类的类型参数是没有关系的。</p>
<p>之前介绍类型参数限定的时候，我们提到上界可以为某个类、某个接口或者其他类型参数，但上界都是只有一个，Java中还支持多个上界，多个上界之间以&amp;分隔，类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Base</span> &amp; Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>
<p>Base为上界类，Comparable和Serializable为上界接口。如果有上界类，类应该放在第一个，类型擦除时，会用第一个上界替换。</p>
<h4 id="8-3-3-泛型与数组"><a href="#8-3-3-泛型与数组" class="headerlink" title="8.3.3 泛型与数组"></a>8.3.3 泛型与数组</h4><p>泛型与数组的关系稍微复杂一些，我们单独介绍。</p>
<p>引入泛型后，一个令人惊讶的事实是，不能创建泛型数组。比如，我们可能想这样创建一个Pair的泛型数组，以表示7.6节中介绍的奖励面额和权重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Object, Integer&gt;[] options = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Object, Integer&gt;[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Java会提示编译错误，不能创建泛型数组。这是为什么呢？我们先来进一步理解一下数组。</p>
<p>前面我们解释过，类型参数之间有继承关系的容器之间是没有关系的，比如，一个DynamicArray\<Integer>对象不能赋值给一个DynamicArray\<Number>变量。不过，数组是可以的，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] ints = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">Number[] numbers = ints;</span><br><span class="line">Object[] objs = ints;</span><br></pre></td></tr></table></figure>
<p>后面两种赋值都是允许的。数组为什么可以呢？数组是Java直接支持的概念，它知道数组元素的实际类型，知道Object和Number都是Integer的父类型，所以这个操作是允许的。</p>
<p>虽然Java允许这种转换，但如果使用不当，可能会引起运行时异常，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] ints = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">Object[] objs = ints;</span><br><span class="line">objs[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译是没有问题的，运行时会抛出ArrayStoreException，因为Java知道实际的类型是Integer，所以写入String会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Object, Integer&gt;[] options = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Object, Integer&gt;[<span class="number">3</span>];</span><br><span class="line">Object[] objs = options;</span><br><span class="line">objs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Double, String&gt;(<span class="number">12.34</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果可以创建泛型数组options，那它就可以赋值给其他类型的数组objs，而最后一行明显错误的赋值操作，则既不会引起编译错误，也不会触发运行时异常，因为Pair<Double, String>的运行时类型是Pair，和objs的运行时类型Pair[]是匹配的。但我们知道，它的实际类型是不匹配的，在程序的其他地方，当把objs[0]作为Pair<Object, Integer>进行处理的时候，一定会触发异常。</p>
<p>也就是说，如果允许创建泛型数组，那就可能会有上面这种错误操作，它既不会引起编译错误，也不会立即触发运行时异常，却相当于埋下了一颗炸弹，不定什么时候爆发，为避免这种情况，Java干脆就禁止创建泛型数组。</p>
<p>但现实需要能够存放泛型对象的容器，怎么办呢？可以使用原始类型的数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair[] options = <span class="keyword">new</span> <span class="title class_">Pair</span>[]&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的选择是，使用后续章节介绍的泛型容器。目前，可以使用我们自己实现的Dy-namicArray，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Pair&lt;String, Integer&gt;&gt; options = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;&gt;();</span><br><span class="line">options.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>));</span><br><span class="line">options.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;2元&quot;</span>,<span class="number">2</span>));</span><br><span class="line">options.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String, Integer&gt;(<span class="string">&quot;10元&quot;</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>DynamicArray内部的数组为Object类型，一些操作插入了强制类型转换，外部接口是类型安全的，对数组的访问都是内部代码，可以避免误用和类型异常。</p>
<p>有时，我们希望转换泛型容器为一个数组，比如，对于DynamicArray，我们可能希望它有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()</span><br></pre></td></tr></table></figure>
<p>而希望可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;Integer&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">Integer[] arr = ints.toArray();</span><br></pre></td></tr></table></figure>
<p>先使用动态容器收集一些数据，然后转换为一个固定数组，这也是一个常见的合理需求，怎么来实现这个toArray方法呢？可能想先这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[] arr = <span class="keyword">new</span> <span class="title class_">E</span>[size];</span><br></pre></td></tr></table></figure>
<p>遗憾的是，如之前所述，这是不合法的。Java运行时根本不知道E是什么，也就无法做到创建E类型的数组。另一种想法是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()&#123;</span><br><span class="line">    Object[] copy = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, copy, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (E[])copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用之前介绍的Arrays方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()&#123;</span><br><span class="line">    <span class="keyword">return</span> (E[])Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果都是一样的，没有编译错误了，但运行时会抛出ClassCastException异常，原因是Object类型的数组不能转换为Integer类型的数组。</p>
<p>那怎么办呢？可以利用Java中的运行时类型信息和反射机制，这些概念我们后续章节再详细介绍。这里我们简要介绍下。Java必须在运行时知道要转换成的数组类型，类型可以作为参数传递给toArray方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray(Class&lt;E&gt; type)&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">copy</span> <span class="operator">=</span> Array.newInstance(type, size);</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, copy, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (E[])copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class\<E>表示要转换成的数组类型信息，有了这个类型信息，Array类的newInstance方法就可以创建出真正类型的数组对象。调用toArray方法时，需要传递需要的类型，比如，可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = ints.toArray(Integer.class);</span><br></pre></td></tr></table></figure>
<p>我们来稍微总结下泛型与数组的关系：</p>
<p>❑ Java不支持创建泛型数组。</p>
<p>❑ 如果要存放泛型对象，可以使用原始类型的数组，或者使用泛型容器。</p>
<p>❑ 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射。</p>
<h2 id="第9章-列表和队列"><a href="#第9章-列表和队列" class="headerlink" title="第9章 列表和队列"></a>第9章 列表和队列</h2><h3 id="9-1刨析ArrayList"><a href="#9-1刨析ArrayList" class="headerlink" title="9.1刨析ArrayList"></a>9.1刨析ArrayList</h3><h4 id="9-1-1-基本用法"><a href="#9-1-1-基本用法" class="headerlink" title="9.1.1 基本用法"></a>9.1.1 基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-基本原理"><a href="#9-1-2-基本原理" class="headerlink" title="9.1.2 基本原理"></a>9.1.2 基本原理</h4><p>内部有一个数组elementData，一般会有一些预留的空间，有一个整数size记录实际的元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p>各种public方法内部操作的基本都是这个数组和这个整数，elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数。</p>
<p><strong>默认</strong>容量：DEFAULT_CAPACITY的值为10</p>
<p><strong>增容</strong>：newCapacity相当于oldCapacity的1.5倍，如果扩展1.5倍还是小于minCapacity，就扩展为minCapacity  </p>
<h4 id="9-1-3-迭代"><a href="#9-1-3-迭代" class="headerlink" title="9.1.3 迭代"></a>9.1.3 迭代</h4><p>ArrayList支持foreach语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line">intList.add(<span class="number">456</span>);</span><br><span class="line">intList.add(<span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer a : intList)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当然，这种循环也可以使用如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;intList.size(); i++)&#123;</span><br><span class="line">    System.out.println(intList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，foreach看上去更为简洁，而且它适用于各种容器，更为通用。</p>
<p>这种foreach语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = intList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1．迭代器接口"><a href="#1．迭代器接口" class="headerlink" title="1．迭代器接口"></a>1．迭代器接口</h5><p>ArrayList实现了Iterable接口，Iterable表示可迭代，Java 7中的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义很简单，就是要求实现iterator方法。iterator方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>它返回一个实现了Iterator接口的对象，Java 7中Iterator接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要对象实现了Iterable接口，就可以使用foreach语法，编译器会转换为调用Iterable和Iterator接口的方法。初次见到<strong>Iterable</strong>和<strong>Iterator</strong>，可能会比较容易混淆，我们再澄清一下：</p>
<p>❑ Iterable表示对象可以被迭代，它有一个方法iterator()，返回Iterator对象，实际通过Iterator接口的方法进行遍历；</p>
<p>❑ 如果对象实现了Iterable，就可以使用foreach语法；</p>
<p>❑ 类可以不实现Iterable，也可以创建Iterator对象。</p>
<h5 id="2-ListIterator"><a href="#2-ListIterator" class="headerlink" title="2. ListIterator"></a>2. ListIterator</h5><p>除了iterator(), ArrayList还提供了两个返回Iterator接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<h5 id="3．迭代的陷阱"><a href="#3．迭代的陷阱" class="headerlink" title="3．迭代的陷阱"></a>3．迭代的陷阱</h5><p>关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。比如，要删除一个整数ArrayList中所有小于100的数，直觉上，代码可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer a : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            list.remove(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但运行时会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>发生了并发修改异常，为什么呢？因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p>
<p>如何避免异常呢？可以使用迭代器的remove方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.next()&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器如何知道发生了结构性变化，并抛出异常？它自己的remove方法为何又可以使用呢？我们需要看下迭代器实现的原理。</p>
<h5 id="4．迭代器实现的原理"><a href="#4．迭代器实现的原理" class="headerlink" title="4．迭代器实现的原理"></a>4．迭代器实现的原理</h5><p>我们来看下ArrayList中iterator方法的实现，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了一个Itr对象，Itr是一个成员内部类，实现了Iterator接口，声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>它有三个实例成员变量，为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;        <span class="comment">//下一个要返回的元素位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//最后一个返回的索引位置，如果没有，为-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>
<p>cursor表示下一个要返回的元素位置，lastRet表示最后一个返回的索引位置，expectedModCount表示期望的修改次数，初始化为外部类当前的修改次数modCount，回顾一下，成员内部类可以直接访问外部类的实例变量。每次发生结构性变化的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。</p>
<h5 id="5．迭代器的好处"><a href="#5．迭代器的好处" class="headerlink" title="5．迭代器的好处"></a>5．迭代器的好处</h5><p>​    为什么要通过迭代器这种方式访问元素呢？直接使用size()/get(index)语法不也可以吗？在一些场景下，确实没有什么差别，两者都可以。不过，foreach语法更为简洁一些，更重要的是，迭代器语法更为通用，它适用于各种容器类。此外，迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供Iterator接口的代码了解数据的组织方式，可以提供高效的实现。在ArrayList中， size/get(index)语法与迭代器性能是差不多的，但在后续介绍的其他容器中，则不一定，比如LinkedList，迭代器性能就要高很多。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口</p>
<h4 id="9-1-4-ArrayList实现的接口"><a href="#9-1-4-ArrayList实现的接口" class="headerlink" title="9.1.4 ArrayList实现的接口"></a>9.1.4 ArrayList实现的接口</h4><h5 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h5><p>Collection表示一个数据集合，数据间没有位置或顺序的概念</p>
<h5 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h5><p>List表示有顺序或位置的数据集合，它扩展了Collection</p>
<h5 id="3-RandomAccess"><a href="#3-RandomAccess" class="headerlink" title="3. RandomAccess"></a>3. RandomAccess</h5><p>RandomAccess的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有定义任何代码。这有什么用呢？这种没有任何代码的接口在Java中被称为<strong>标记接口</strong>，用于声明类的一种属性。</p>
<p>这里，实现了RandomAccess接口的类表示可以<strong>随机访问</strong>，可随机访问就是具备类似<strong>数组</strong>那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。下节我们会介绍LinkedList，它就不能随机访问</p>
<h3 id="9-2-剖析LinkedList"><a href="#9-2-剖析LinkedList" class="headerlink" title="9.2 剖析LinkedList"></a>9.2 剖析LinkedList</h3><h4 id="9-2-1-用法"><a href="#9-2-1-用法" class="headerlink" title="9.2.1 用法"></a>9.2.1 用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>Java中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口Deque中</p>
<p>Java中有一个类Stack，单词意思是栈，它也实现了栈的一些方法，如push/pop/peek等，但它没有实现Deque接口，它是Vector的子类(所以不推荐使用，推荐使用Deque)，它增加的这些方法也通过synchronized实现了线程安全，具体就不介绍了。不需要线程安全的情况下，推荐使用LinkedList或下节介绍的ArrayDeque</p>
<p>简单总结下：LinkedList的用法是比较简单的，与ArrayList用法类似，支持List接口，只是，LinkedList增加了一个接口Deque，可以把它看作队列、栈、双端队列，方便地在两端进行操作。如果只是用作List，那应该用ArrayList还是LinkedList呢？我们需要了解LinkedList的实现原理。</p>
<h4 id="9-2-2-实现原理"><a href="#9-2-2-实现原理" class="headerlink" title="9.2.2 实现原理"></a>9.2.2 实现原理</h4><p>​    我们知道，ArrayList内部是数组，元素在内存是连续存放的，但LinkedList不是。LinkedList直译就是链表，确切地说，它的内部实现是<strong>双向链表</strong>，每个元素在内存都是单独存放的，元素之间通过链接连在一起，类似于小朋友之间手拉手一样。</p>
<p>​    为了表示链接关系，需要一个节点的概念。节点包括实际的元素，但同时有两个链接，分别指向前一个节点（前驱）和后一个节点（后继）。节点是一个内部类，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedList内部组成就是如下三个实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-剖析ArrayDeque"><a href="#9-3-剖析ArrayDeque" class="headerlink" title="9.3 剖析ArrayDeque"></a>9.3 剖析ArrayDeque</h3><p>LinkedList实现了队列接口Queue和双端队列接口Deque, Java容器类中还有一个双端队列的实现类ArrayDeque，它是基于数组实现的。我们知道，一般而言，由于需要移动元素，数组的插入和删除效率比较低，但ArrayDeque的效率却非常高，它是怎么实现的呢？本节就来详细探讨。</p>
<p>ArrayDeque有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>numElements表示元素个数，初始分配的空间会至少容纳这么多元素，但空间不是正好numElements这么大，待会我们会介绍其实现细节。</p>
<p>ArrayDeque实现了Deque接口，同LinkedList一样，它的队列长度也是没有限制的， Deque扩展了Queue，有队列的所有方法，还可以看作栈，有栈的基本方法push/pop/peek，还有明确的操作两端的方法如addFirst/removeLast等，具体用法与LinkedList一节介绍的类似，就不赘述了，下面看其实现原理（基于Java 7）。</p>
<h4 id="9-3-1-实现原理"><a href="#9-3-1-实现原理" class="headerlink" title="9.3.1 实现原理"></a>9.3.1 实现原理</h4><p>ArrayDeque内部主要有如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>elements就是存储元素的数组。ArrayDeque的高效来源于head和tail这两个变量，它们使得物理上简单的从头到尾的数组变为了一个逻辑上循环的数组，避免了在头尾操作时的移动。我们来解释下循环数组的概念。</p>
<h5 id="1．循环数组"><a href="#1．循环数组" class="headerlink" title="1．循环数组"></a>1．循环数组</h5><p>对于一般数组，比如arr，第一个元素为arr[0]，最后一个为arr[arr.length-1]。但对于ArrayDeque中的数组，它是一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始，数组的长度、第一个和最后一个元素都与head和tail这两个变量有关，具体来说：</p>
<p>1）如果head和tail相同，则数组为空，长度为0。</p>
<p>2）如果tail大于head，则第一个元素为elements[head]，最后一个为elements[tail-1]，长度为tail-head，元素索引从head到tail-1。</p>
<p>3）如果tail小于head，且为0，则第一个元素为elements[head]，最后一个为elements [elements.length-1]，元素索引从head到elements.length-1。</p>
<p>4）如果tail小于head，且大于0，则会形成循环，第一个元素为elements[head]，最后一个是elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1。</p>
<h2 id="第10章-Map和Set"><a href="#第10章-Map和Set" class="headerlink" title="第10章 Map和Set"></a>第10章 Map和Set</h2><h3 id="10-1-剖析HashMap"><a href="#10-1-剖析HashMap" class="headerlink" title="10.1 剖析HashMap"></a>10.1 剖析HashMap</h3><p>​    字面上看，HashMap由Hash和Map两个单词组成，这里Map不是地图的意思，而是表示映射关系，是一个接口，实现Map接口有多种方式，HashMap实现的方式利用了哈希（Hash）。下面先来看Map接口，接着看HashMap的用法，然后看实现原理，最后总结分析HashMap的特点。</p>
<h4 id="10-1-1-Map接口"><a href="#10-1-1-Map接口" class="headerlink" title="10.1.1 Map接口"></a>10.1.1 Map接口</h4><p>​    Map有键和值的概念。一个键映射到一个值，Map按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用Map可以方便地处理需要根据键访问对象的场景。</p>
<p>Map中的键是没有重复的，所以ketSet()返回了一个Set。keySet()、values()、entrySet()有一个共同的特点，它们返回的都是视图，不是复制的值，基于返回值的修改会直接修改Map自身，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.keySet().clear();</span><br></pre></td></tr></table></figure>
<p>会删除所有键值对。</p>
<p>​    Set是一个接口，表示的是数学中的集合概念，即没有重复的元素集合.它扩展了Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保Set的语义约束，即不能有重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-2-HashMap"><a href="#10-1-2-HashMap" class="headerlink" title="10.1.2 HashMap"></a>10.1.2 HashMap</h4><p>HashMap还有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>最后一个以一个已有的Map构造，复制其中的所有键值对到当前Map。前两个涉及参数initialCapacity和loadFactor，它们是什么意思呢？我们需要看下HashMap的实现原理。</p>
<h4 id="10-1-3-实现原理"><a href="#10-1-3-实现原理" class="headerlink" title="10.1.3 实现原理"></a>10.1.3 实现原理</h4><h5 id="1．内部组成"><a href="#1．内部组成" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>HashMap内部有如下几个主要的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K, V&gt;[] table = (Entry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>size表示实际键值对的个数。table是一个Entry类型的数组，称为哈希表或哈希桶，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对。Entry是一个内部类，它的实例变量和构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K, V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，key和value分别表示键和值，next指向下一个Entry节点，hash是key的hash值，待会我们会介绍其计算方法。直接存储hash值是为了在比较的时候加快计算，待会我们看代码。</p>
<p>table的初始值为EMPTY_TABLE，是一个空表，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;? , ? &gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>当添加键值对后，table就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于ArrayList。添加第一个元素时，默认分配的大小为<strong>16</strong>，不过，并不是size大于16时再进行扩展，下次什么时候扩展与threshold有关。</p>
<p>threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。threshold是怎么算出来的呢？一般而言，threshold等于table.length乘以loadFactor。比如，如果table. length为16, loadFactor为0.75，则threshold为12。loadFactor是负载因子，表示整体上table被占用的程度，是一个浮点数，默认为0.75，可以通过构造方法进行修改。</p>
<h5 id="2．默认构造方法"><a href="#2．默认构造方法" class="headerlink" title="2．默认构造方法"></a>2．默认构造方法</h5><p>默认构造方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DEFAULT_INITIAL_CAPACITY为16, DEFAULT_LOAD_FACTOR为0.75，默认构造方法调用的构造方法主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是设置loadFactor和threshold的初始值。</p>
<h5 id="6．实现原理小结"><a href="#6．实现原理小结" class="headerlink" title="6．实现原理小结"></a>6．实现原理小结</h5><p>需要说明的是，Java 8对HashMap的实现进行了优化，在哈希冲突比较严重的情况下，即大量元素映射到同一个链表的情况下（具体是至少8个元素，且总的键值对个数至少是64）, <strong>Java 8会将该链表转换为一个平衡的排序二叉树(平衡二叉树)，可是我看一些博客说是实现的红黑树，以提高查询的效率</strong>，关于排序二叉树我们在10.3节介绍，Java 8的具体代码就不介绍了。</p>
<h3 id="10-2-剖析HashSet"><a href="#10-2-剖析HashSet" class="headerlink" title="10.2 剖析HashSet"></a>10.2 剖析HashSet</h3><p>10.1节提到了Set接口，Map接口的两个方法keySet和entrySet返回的都是Set，本节介绍Set接口的一个重要实现类HashSet。与HashMap类似，字面上看，HashSet由两个单词组成：Hash和Set。其中，Set表示接口，实现Set接口也有多种方式，各有特点，Hash-Set实现的方式利用了Hash</p>
<h4 id="10-2-1-用法"><a href="#10-2-1-用法" class="headerlink" title="10.2.1 用法"></a>10.2.1 用法</h4><p>与HashMap类似，HashSet的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>initialCapacity和loadFactor的含义与HashMap中的是一样的。</p>
<p>HashSet的使用也很简单，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">set.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;老马&quot;</span>&#125;));</span><br><span class="line"><span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">    System.out.print(s+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 老马 world</span><br></pre></td></tr></table></figure>
<p>“hello”被添加了两次，但只会保存一份，输出也没有什么特别的顺序。</p>
<p>与HashMap类似，HashSet要求元素重写hashCode和equals方法，且对于两个对象，如果equals相同，则hashCode也必须相同，如果元素是自定义的类，需要注意这一点。比如，有一个表示规格的类Spec，有大小和颜色两个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spec</span> &#123;</span><br><span class="line">    String size;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Spec</span><span class="params">(String size, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[size=&quot;</span> + size + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spec的Set为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Spec&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Spec&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[size=M, color=red], [size=M, color=red]]</span><br></pre></td></tr></table></figure>
<p>同一个规格输出了两次，为避免这一点，需要为Spec重写hashCode和equals方法。</p>
<h4 id="10-2-2-实现原理"><a href="#10-2-2-实现原理" class="headerlink" title="10.2.2 实现原理"></a>10.2.2 实现原理</h4><p>HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>我们知道，Map有键和值，HashSet相当于只有键，值都是相同的固定值，这个值的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h3 id="10-3-排序二叉树"><a href="#10-3-排序二叉树" class="headerlink" title="10.3 排序二叉树"></a>10.3 排序二叉树</h3><p>​    HashMap和HashSet的共同实现机制是哈希表，一个共同的限制是<strong>没有顺序</strong>，我们提到，它们都有一个能保持顺序的对应类<strong>TreeMap</strong>和<strong>TreeSet</strong>，这两个类的共同实现基础是排序二叉树。为了更好地理解TreeMap和TreeSet，</p>
<h4 id="10-3-3-平衡的排序二叉树"><a href="#10-3-3-平衡的排序二叉树" class="headerlink" title="10.3.3 平衡的排序二叉树"></a>10.3.3 平衡的排序二叉树</h4><p>在TreeMap的实现中，用的并不是AVL树，而是<strong>红黑树</strong>，与AVL树类似，红黑树也是一种平衡的排序二叉树，也是在插入和删除节点时通过旋转操作来平衡的，但它并不是高度平衡的，而是大致平衡的。所谓大致是指，它确保任意一条从根到叶子节点的路径，没有任何一条路径的长度会比其他路径长过两倍红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树。</p>
<p>为什么叫红黑树呢？因为它对每个节点进行着色，颜色或黑或红，并对节点的着色有一些约束，满足这个约束即可以确保树是大致平衡的。</p>
<p>对AVL树和红黑树，它们保持平衡的细节都是比较复杂的，我们就不介绍了，需要知道的是，它们都是排序二叉树，都通过在插入和删除时执行开销不大的旋转操作保持了树的高度平衡或大致平衡，从而保证了树的查找效率。</p>
<h3 id="10-4-剖析TreeMap"><a href="#10-4-剖析TreeMap" class="headerlink" title="10.4 剖析TreeMap"></a>10.4 剖析TreeMap</h3><p>​    在介绍HashMap时，我们提到，HashMap有一个重要局限，键值对之间没有特定的顺序，我们还提到，Map接口有另一个重要的实现类TreeMap，在TreeMap中，键值对之间按键有序，TreeMap的实现基础是<strong>排序二叉树</strong></p>
<h4 id="10-4-1-基本用法"><a href="#10-4-1-基本用法" class="headerlink" title="10.4.1 基本用法"></a>10.4.1 基本用法</h4><p>​    TreeMap有两个基本构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个为默认构造方法，如果使用默认构造方法，要求Map中的键实现Comparabe接口，TreeMap内部进行各种比较时会调用键的Comparable接口中的compareTo方法。</p>
<p>第二个接受一个比较器对象comparator，如果comparator不为null，在TreeMap内部进行比较时会调用这个comparator的compare方法，而不再调用键的compareTo方法，也不再要求键实现Comparable接口。</p>
<p>应该用哪一个呢？第一个更为简单，但要求键实现Comparable接口，且期望的排序和键的比较结果是一致的；第二个更为灵活，不要求键实现Comparable接口，比较器可以用灵活复杂的方式进行实现。</p>
<p>需要强调的是，TreeMap是按键而不是按值有序，无论哪一种，都是对键而非值进行比较。</p>
<p>看段简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个TreeMap，但只是当作Map使用，不过迭代时，其输出却是按键排序的，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=tree a=<span class="keyword">abstract</span> b=basic c=call</span><br></pre></td></tr></table></figure>
<p>T排在最前面，是因为大写字母的ASCII码都小于小写字母。如果希望忽略大小写呢？可以传递一个比较器，String类有一个静态成员CASE_INSENSITIVE_ORDER，它就是一个忽略大小写的Comparator对象，替换第一行代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure>
<p>输出就会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">abstract</span> b=basic c=call T=tree</span><br></pre></td></tr></table></figure>
<p>正常排序是从小到大，如果希望逆序呢？可以传递一个不同的Comparator对象，第一行代码可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=call b=basic a=<span class="keyword">abstract</span> T=tree</span><br></pre></td></tr></table></figure>
<p>为什么这样就可以逆序呢？正常排序中，compare方法内是o1.compareTo(o2)，两个对象翻过来，自然就是逆序了，Collections类有一个静态方法reverseOrder()可以返回一个逆序比较器，也就是说，上面的代码也可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p>如果希望逆序且忽略大小写呢？第一行可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">        Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>需要说明的是，TreeMap使用键的比较结果对键进行排重，即使键实际上不同，但只要比较结果相同，它们就会被认为相同，键只会保存一份。比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;try&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去有两个不同的键”T”和”t”，但因为比较器忽略大小写，所以只会有一个，输出会是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="keyword">try</span></span><br></pre></td></tr></table></figure>
<p>键为第一次put时的，这里即”T”，而值为最后一次put时的，这里即”try”。</p>
<p>我们再来看一个例子，键为字符串形式的日期，值为一个统计数字，希望按照日期输出，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;2016-7-3&quot;</span>, <span class="number">100</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-7-10&quot;</span>, <span class="number">120</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-8-1&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.println(kv.getKey()+<span class="string">&quot;, &quot;</span>+kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>7月10号的排在了7月3号的前面，与期望的不符，这是因为，它们是按照字符串比较的，按字符串，2016-7-10就是小于2016-7-3，因为第一个不同之处1小于3。</p>
<p>怎么解决呢？可以使用一个自定义的比较器，将字符串转换为日期，按日期进行比较，第一行代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(o1).compareTo(sdf.parse(o2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出就符合期望了，会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>以上就是TreeMap的基本用法，与HashMap相比：相同的是，它们都实现了Map接口，都可以按Map进行操作。不同的是，迭代时，TreeMap按键有序，为了实现有序，它要求要么键实现Comparable接口，要么创建TreeMap时传递一个Comparator对象。</p>
<h4 id="10-4-2-实现原理"><a href="#10-4-2-实现原理" class="headerlink" title="10.4.2 实现原理"></a>10.4.2 实现原理</h4><p>TreeMap内部是用红黑树实现的，红黑树是一种大致平衡的排序二叉树</p>
<h5 id="1．内部组成-1"><a href="#1．内部组成-1" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>TreeMap内部主要有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>comparator就是比较器，在构造方法中传递，如果没传，就是null。size为当前键值对个数。root指向树的根节点，从根节点可以访问到每个节点，节点的类型为Entry。Entry是TreeMap的一个内部类，其内部成员和构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; left = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; right = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K, V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点除了键（key）和值（value）之外，还有三个引用，分别指向其左孩子（left）、右孩子（right）和父节点（parent），对于根节点，父节点为null，对于叶子节点，孩子节点都为null，还有一个成员color表示颜色，TreeMap是用红黑树实现的，每个节点都有一个颜色，非黑即红。</p>
<h3 id="10-5-剖析TreeSet"><a href="#10-5-剖析TreeSet" class="headerlink" title="10.5 剖析TreeSet"></a>10.5 剖析TreeSet</h3><p>在介绍HashSet时，我们提到，HashSet有一个重要局限，元素之间没有特定的顺序，我们还提到，Set接口还有另一个重要的实现类TreeSet，它是有序的，与HashSet和HashMap的关系一样，TreeSet是基于TreeMap的</p>
<h4 id="10-5-1-基本用法"><a href="#10-5-1-基本用法" class="headerlink" title="10.5.1 基本用法"></a>10.5.1 基本用法</h4><p>TreeSet的基本构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个是默认构造方法，假定元素实现了Comparable接口；第二个使用传入的比较器，不要求元素实现Comparable。TreeSet经常也只是当作Set使用，只是希望迭代输出有序，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">    System.out.print(w+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash map tree</span><br></pre></td></tr></table></figure>
<p>TreeSet实现了两点：排重和有序。如果希望不同的排序，可以传递一个Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;Map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>
<p>忽略大小写进行比较，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hash, map, tree]</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Set是排重的，排重是基于比较结果的，结果为0即视为相同，”map”和”Map”虽然不同，但比较结果为0，所以只会保留第一个元素。</p>
<h4 id="10-5-2-实现原理"><a href="#10-5-2-实现原理" class="headerlink" title="10.5.2 实现原理"></a>10.5.2 实现原理</h4><p>之前章节介绍过，HashSet是基于HashMap实现的，元素就是HashMap中的键，值是一个固定的值，TreeSet是类似的，它是基于TreeMap实现的。</p>
<p>TreeSet的内部有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E, Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>m就是背后的那个TreeMap，这里用的是更为通用的接口类型NavigableMap,PRESENT就是那个固定的共享值。TreeSet的方法实现主要就是调用m的方法，我们具体来看下。</p>
<p>TreeSet的实现代码都比较简单，主要就是调用内部NavigatableMap的方法。</p>
<h3 id="10-6-剖析LinkedHashMap"><a href="#10-6-剖析LinkedHashMap" class="headerlink" title="10.6 剖析LinkedHashMap"></a>10.6 剖析LinkedHashMap</h3><p>前面我们介绍了Map接口的两个实现类HashMap和TreeMap，本节介绍另一个实现类LinkedHashMap。它是HashMap的子类，但可以保持元素按插入或访问有序，这与TreeMap按键排序不同。按插入有序容易理解，按访问有序是什么意思呢？这两个有序有什么用呢？内部是怎么实现的？本节就来探讨这些问题，从用法开始。</p>
<h4 id="10-6-1-基本用法"><a href="#10-6-1-基本用法" class="headerlink" title="10.6.1 基本用法"></a>10.6.1 基本用法</h4><p>LinkedHashMap是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。LinkedHashMap支持两种顺序：一种是插入顺序；另外一种是访问顺序。</p>
<p>插入顺序容易理解，先添加的在前面，后添加的在后面，修改操作不影响顺序。访问顺序是什么意思呢？所谓访问是指get/put操作，对一个键执行get/put操作后，其对应的键值对会移到链表末尾，所以，最末尾的是最近访问的，最开始的最久没被访问的，这种顺序就是访问顺序。</p>
<p>LinkedHashMap有5个构造方法，其中4个都是按插入顺序，只有一个构造方法可以指定按访问顺序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> accessOrder)</span></span><br></pre></td></tr></table></figure>
<p>其中参数accessOrder就是用来指定是否按访问顺序，如果为true，就是访问顺序。默认情况下，LinkedHashMap是按插入有序的，我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; seqMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">seqMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : seqMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>键是按照”c”、”d”、”a”的顺序插入的，修改”d”的值不会修改顺序，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br><span class="line">a <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望保持插入顺序呢？</p>
<p>Map经常用来处理一些数据，其处理模式是：接收一些键值对作为输入，处理，然后输出，输出时希望保持原来的顺序。比如一个配置文件，其中有一些键值对形式的配置项，但其中有一些键是重复的，希望保留最后一个值，但还是按原来的键顺序输出， LinkedHashMap就是一个合适的数据结构。</p>
<p>再如，希望的数据模型可能就是一个Map，但希望保持添加的顺序，如一个购物车，键为购买项目，值为购买数量，按用户添加的顺序保存。</p>
<p>另外一种常见的场景是：希望Map能够按键有序，但在添加到Map前，键已经通过其他方式排好序了，这时，就没有必要使用TreeMap了，毕竟TreeMap的开销要大一些。比如，在从数据库查询数据放到内存时，可以使用SQL的order by语句让数据库对数据排序。</p>
<p>我们来看按访问有序的例子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; accessMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">accessMap.get(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : accessMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次访问都会将该键值对移到末尾，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">500</span></span><br><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望按访问有序呢？一种典型的应用是LRU缓存。</p>
<p>使用LinkedHashMap，可以非常容易地实现LRU缓存，默认情况下，LinkedHashMap没有对容量做限制，但它可以容易地做到，它有一个protected方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加元素到LinkedHashMap后，LinkedHashMap会调用这个方法，传递的参数是最久没被访问的键值对，如果这个方法返回true，则这个最久的键值对就会被删除。Linked-HashMap的实现总是返回false，所有容量没有限制，但子类可以重写该方法，在满足一定条件的情况，返回true。</p>
<p>代码清单如下就是一个简单的LRU缓存的实现，它有一个容量限制，这个限制在构造方法中传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxEntries;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> maxEntries)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个缓存可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">System.out.println(cache);</span><br></pre></td></tr></table></figure>
<p>限定缓存容量为3，先后添加了4个键值对，最久没被访问的键是”b”，会被删除，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;c=call, a=<span class="keyword">abstract</span>, d=call&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-6-2-实现原理"><a href="#10-6-2-实现原理" class="headerlink" title="10.6.2 实现原理"></a>10.6.2 实现原理</h4><p>理解了LinkedHashMap的用法，下面我们来看其实现代码（基于Java 7）。先来看内部组成，再看一些主要方法的实现。LinkedHashMap是HashMap的子类，内部增加了如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; header;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>accessOrder表示是按访问顺序还是插入顺序。header表示双向链表的头，它的类型Entry是一个内部类，这个类是HashMap.Entry的子类，增加了两个变量before和after，指向链表中的前驱和后继.Entry的完整定义如代码清单如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    Entry&lt;K, V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">          before.after = after;</span><br><span class="line">          after.before = before;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K, V&gt; existingEntry)</span> &#123;</span><br><span class="line">          after   = existingEntry;</span><br><span class="line">          before = existingEntry.before;</span><br><span class="line">          before.after = <span class="built_in">this</span>;</span><br><span class="line">          after.before = <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          LinkedHashMap&lt;K, V&gt; lm = (LinkedHashMap&lt;K, V&gt;)m;</span><br><span class="line">          <span class="keyword">if</span>(lm.accessOrder) &#123;</span><br><span class="line">              lm.modCount++;</span><br><span class="line">              remove();</span><br><span class="line">              addBefore(lm.header);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordRemoval</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>recordAccess和recordRemoval是HashMap.Entry中定义的方法，在HashMap中，这两个方法的实现为空，它们就是被设计用来被子类重写的。在put被调用且键存在时，HashMap会调用Entry的recordAccess方法；在键被删除时，HashMap会调用Entry的recordRemoval方法。</p>
<p>LinkedHashMap.Entry重写了这两个方法。在recordAccess方法中，如果是按访问顺序的，则将该节点移到链表的末尾；在recordRemoval方法中，将该节点从链表中移除。</p>
<h4 id="10-6-3-LinkedHashSet"><a href="#10-6-3-LinkedHashSet" class="headerlink" title="10.6.3 LinkedHashSet"></a>10.6.3 LinkedHashSet</h4><p>之前介绍的Map接口的实现类都有一个对应的Set接口的实现类，比如HashMap有HashSet, TreeMap有TreeSet, LinkedHashMap也不例外，它也有一个对应的Set接口的实现类LinkedHashSet。LinkedHashSet是HashSet的子类，它内部的Map的实现类是LinkedHashMap,所以它也可以保持插入顺序,比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b, c, a]</span><br></pre></td></tr></table></figure>
<p>LinkedHashSet的实现比较简单.</p>
<h3 id="10-7-剖析EnumMap"><a href="#10-7-剖析EnumMap" class="headerlink" title="10.7 剖析EnumMap"></a>10.7 剖析EnumMap</h3><p>如果需要一个Map的实现类，并且键的类型为<strong>枚举类型</strong>，可以使用HashMap，但应该使用一个专门的实现类<strong>EnumMap</strong>。为什么要有一个专门的类呢？我们之前介绍过枚举的本质，主要是因为枚举类型有两个特征：一是它可能的值是有限的且预先定义的；二是枚举值都有一个顺序，这两个特征使得可以更为高效地实现Map接口。我们先来看EnumMap的用法，然后看它到底是怎么实现的。</p>
<h3 id="10-8-剖析EnumSet"><a href="#10-8-剖析EnumSet" class="headerlink" title="10.8 剖析EnumSet"></a>10.8 剖析EnumSet</h3><p>本节介绍同样针对枚举类型的Set接口的实现类EnumSet。与EnumMap类似，之所以会有一个专门的针对枚举类型的实现类，主要是因为它可以非常高效地实现Set接口。</p>
<p>之前介绍的Set接口的实现类HashSet/TreeSet，它们内部都是用对应的HashMap/TreeMap实现的，但EnumSet不是，<strong>它的实现与EnumMap没有任何关系</strong>，而是用极为精简和高效的位向量实现的。位向量是计算机程序中解决问题的一种常用方式，我们有必要理解和掌握</p>
<p>除了实现机制，EnumSet的用法也有一些不同。EnumSet可以说是<strong>处理枚举类型数据的一把利器</strong>，在一些应用领域，它非常方便和高效。</p>
<h4 id="10-8-1-基本用法"><a href="#10-8-1-基本用法" class="headerlink" title="10.8.1 基本用法"></a>10.8.1 基本用法</h4><p>与TreeSet/HashSet不同，EnumSet是一个抽象类，不能直接通过new新建</p>
<p>不过，EnumSet提供了若干静态工厂方法，可以创建EnumSet类型的对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br></pre></td></tr></table></figure>
<p>noneOf方法会创建一个指定枚举类型的EnumSet，不含任何元素。创建的EnumSet对象的实际类型是EnumSet的子类，待会我们再分析其具体实现。</p>
<p>为方便举例，我们定义一个表示星期几的枚举类Day，值从周一到周日，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么用noneOf方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; weekend = EnumSet.noneOf(Day.class);</span><br><span class="line">weekend.add(Day.SATURDAY);</span><br><span class="line">weekend.add(Day.SUNDAY);</span><br><span class="line">System.out.println(weekend);</span><br></pre></td></tr></table></figure>
<p>weekend表示休息日，noneOf返回的Set为空，添加了周六和周日，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SATURDAY, SUNDAY]</span><br></pre></td></tr></table></figure>
<h4 id="10-8-2-应用场景"><a href="#10-8-2-应用场景" class="headerlink" title="10.8.2 应用场景"></a>10.8.2 应用场景</h4><p>下面，我们通过一个场景来看EnumSet的应用。想象一个场景，在一些工作中（如医生、客服），不是每个工作人员每天都在的，每个人可工作的时间是不一样的，比如张三可能是周一和周三，李四可能是周四和周六，给定每个人可工作的时间，我们可能有一些问题需要回答。比如：</p>
<p>❑ 有没有哪天一个人都不会来？</p>
<p>❑ 有哪些天至少会有一个人来？</p>
<p>❑ 有哪些天至少会有两个人来？</p>
<p>❑ 有哪些天所有人都会来，以便开会？</p>
<p>❑ 哪些人周一和周二都会来？</p>
<p>使用EnumSet，可以方便高效地回答这些问题，怎么做呢？我们先来定义一个表示工作人员的类Worker，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Set&lt;Day&gt; availableDays;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, Set&lt;Day&gt; availableDays)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.availableDays = availableDays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为演示方便，将所有工作人员的信息放到一个数组workers中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.FRIDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李四&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;王五&quot;</span>, EnumSet.of(Day.TUESDAY, Day.THURSDAY)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个工作人员的可工作时间用一个EnumSet表示。有了这个信息，我们就可以回答以上的问题了。哪些天一个人都不会来？代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.removeAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>days初始化为所有值，然后遍历workers，从days中删除可工作的所有时间，最终剩下的就是一个人都不会来的时间，这实际是在求worker时间并集的补集，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SUNDAY]</span><br></pre></td></tr></table></figure>
<p>有哪些天至少会有一个人来？就是求worker时间的并集，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.addAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]</span><br></pre></td></tr></table></figure>
<h2 id="第11章-堆与优先级队列"><a href="#第11章-堆与优先级队列" class="headerlink" title="第11章 堆与优先级队列"></a>第11章 堆与优先级队列</h2><p>前面两章介绍了Java中的基本容器类，每个容器类背后都有一种数据结构，ArrayList是动态数组，LinkedList是链表，HashMap/HashSet是哈希表，TreeMap/TreeSet是红黑树，本章介绍另一种数据结构：堆。之前我们提到过堆，那里，堆指的是内存中的区域，保存动态分配的对象，与栈相对应。这里的堆是一种数据结构，与内存区域和分配无关。</p>
<p>堆到底是什么结构呢？这个待会再细看。我们先来说明，堆有什么用？为什么要介绍它？<strong>堆可以非常高效方便地解决很多问题</strong>。比如：</p>
<p>1）优先级队列，我们之前介绍的队列实现类LinkedList是按添加顺序排列的，但现实中，经常需要按优先级来，每次都应该处理当前队列中优先级最高的，高优先级的即使来得晚，也应该被优先处理。</p>
<p>2）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。</p>
<p>3）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，甚至源源不断到来。</p>
<h3 id="11-1-堆的概念与算法"><a href="#11-1-堆的概念与算法" class="headerlink" title="11.1 堆的概念与算法"></a>11.1 堆的概念与算法</h3><p>我们先来了解堆的概念，然后介绍堆的一些主要算法。</p>
<h4 id="11-1-1-基本概念"><a href="#11-1-1-基本概念" class="headerlink" title="11.1.1 基本概念"></a>11.1.1 基本概念</h4><p>堆首先是一棵二叉树，但它是<strong>完全二叉树</strong>。</p>
<h3 id="11-2-剖析PriorityQueue"><a href="#11-2-剖析PriorityQueue" class="headerlink" title="11.2 剖析PriorityQueue"></a>11.2 剖析PriorityQueue</h3><p>节探讨堆在Java中的具体实现类：PriorityQueue。顾名思义，PriorityQueue是优先级队列，它首先实现了队列接口（Queue），与LinkedList类似，它的队列长度也没有限制，与一般队列的区别是，它有优先级的概念，每个元素都有优先级，队头的元素永远都是优先级最高的。</p>
<p>PriorityQueue内部是用堆实现的，内部元素不是完全有序的，不过，逐个出队会得到有序的输出。虽然名字叫优先级队列，但也可以将PriorityQueue看作一种比较通用的实现了堆的性质的数据结构，可以用PriorityQueue来解决适合用堆解决的问题，下一小节我们会来看一些具体的例子。下面，我们先介绍其用法，接着分析实现代码，最后总结分析其特点。</p>
<h2 id="第12章-通用容器类和总结"><a href="#第12章-通用容器类和总结" class="headerlink" title="第12章 通用容器类和总结"></a>第12章 通用容器类和总结</h2><p>之前的章节中，我们介绍的都是具体的容器类，本章介绍一些抽象容器类、一些通用的算法和功能，并对整个容器类体系进行梳理总结。</p>
<p>之前介绍的具体容器类其实都不是从头构建的，它们都继承了一些抽象容器类。这些抽象类提供了容器接口的部分实现，方便了Java具体容器类的实现。此外，通过继承抽象类，自定义的类也可以更为容易地实现容器接口。为什么需要实现容器接口呢？至少有两个原因。</p>
<p>1）容器类是一个大家庭，它们之间可以方便地协作，比如很多方法的参数和返回值都是容器接口对象，实现了容器接口，就可以方便地参与这种协作。</p>
<p>2）Java有一个类Collections，提供了很多针对容器接口的通用算法和功能，实现了容器接口，可以直接利用Collections中的算法和功能。</p>
<h3 id="12-1-抽象容器类"><a href="#12-1-抽象容器类" class="headerlink" title="12.1 抽象容器类"></a>12.1 抽象容器类</h3><p>抽象容器类与之前介绍的接口和具体容器类的关系如图12-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310072039878.png" alt="image-20231007203919721"></p>
<p>虚线框表示接口，有Collection、List、Set、Queue、Deque和Map。有6个抽象容器类。</p>
<p>1）AbstractCollection：实现了Collection接口，被抽象类AbstractList、AbstractSet、AbstractQueue继承，ArrayDeque也继承自AbstractCollection（图中未画出）。</p>
<p>2）AbstractList：父类是AbstractCollection，实现了List接口，被ArrayList、Abstract-SequentialList继承。</p>
<p>3）AbstractSequentialList：父类是AbstractList，被LinkedList继承。</p>
<p>4）AbstractMap：实现了Map接口，被TreeMap、HashMap、EnumMap继承。</p>
<p>5）AbstractSet：父类是AbstractCollection，实现了Set接口，被HashSet、TreeSet和EnumSet继承。</p>
<p>6）AbstractQueue：父类是AbstractCollection，实现了Queue接口，被PriorityQueue继承。</p>
<h3 id="12-2-Collections"><a href="#12-2-Collections" class="headerlink" title="12.2 Collections"></a>12.2 Collections</h3><p>类Collections以静态方法的方式提供了很多通用算法和功能，这些功能大概可以分为两类。</p>
<p>1）对容器接口对象进行操作。</p>
<p>2）返回一个容器接口对象。</p>
<h1 id="第四部分-文件"><a href="#第四部分-文件" class="headerlink" title="第四部分 文件"></a>第四部分 文件</h1><h2 id="第13章-文件基本技术"><a href="#第13章-文件基本技术" class="headerlink" title="第13章 文件基本技术"></a>第13章 文件基本技术</h2><h1 id="第五部分-并发"><a href="#第五部分-并发" class="headerlink" title="第五部分 并发"></a>第五部分 并发</h1><h2 id="第15章-并发基础知识"><a href="#第15章-并发基础知识" class="headerlink" title="第15章 并发基础知识"></a>第15章 并发基础知识</h2><h3 id="15-1-线程的基本概念"><a href="#15-1-线程的基本概念" class="headerlink" title="15.1 线程的基本概念"></a>15.1 线程的基本概念</h3><p>本节，我们介绍Java中线程的一些基本概念，包括创建线程、线程的基本属性和方法、共享内存及问题、线程的优点及成本。</p>
<h4 id="15-1-1-创建线程"><a href="#15-1-1-创建线程" class="headerlink" title="15.1.1 创建线程"></a>15.1.1 创建线程</h4><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。下面，我们通过创建线程来对线程建立一个直观感受。在Java中创建线程有两种方式：一种是继承Thread；另外一种是实现Runnable接口。</p>
<h5 id="1．继承Thread"><a href="#1．继承Thread" class="headerlink" title="1．继承Thread"></a>1．继承Thread</h5><p>Java中java.lang.Thread这个类表示线程，一个类可以继承Thread并重写其run方法来实现一个线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloThread这个类继承了Thread，并重写了run方法。run方法的方法签名是固定的， public，没有参数，没有返回值，不能抛出受检异常。<strong>run方法类似于单线程程序中的main方法</strong>，线程从run方法的第一条语句开始执行直到结束。</p>
<p>定义了这个类不代表代码就会开始执行，线程需要被启动，启动需要先创建一个HelloThread对象，然后调用Thread的start方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在main方法中创建了一个线程对象，并调用了其start方法，调用start方法后， HelloThread的run方法就会开始执行，屏幕输出为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>为什么调用的是start，执行的却是run方法呢？start表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源，每个线程会有单独的程序执行计数器和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行，执行的起点就是run方法。</p>
<p>调用start后，就有了两条执行流，新的一条执行run方法，旧的一条继续执行main方法，两条执行流并发执行，操作系统负责调度，在单CPU的机器上，同一时刻只能有一个线程在执行，在多CPU的机器上，同一时刻可以有多个线程同时执行，但操作系统给我们屏蔽了这种差异，给程序员的感觉就是多个线程并发执行，但哪条语句先执行哪条后执行是不一定的。当所有线程都执行完毕的时候，程序退出。</p>
<h5 id="2．实现Runnable接口"><a href="#2．实现Runnable接口" class="headerlink" title="2．实现Runnable接口"></a>2．实现Runnable接口</h5><p>通过继承Thread来实现线程虽然比较简单，但Java中只支持单继承，每个类最多只能有一个父类，如果类已经有父类了，就不能再继承Thread，这时，可以通过实现java.lang. Runnable接口来实现线程。Runnable接口的定义很简单，只有一个run方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以实现该接口，并实现run方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅实现Runnable是不够的，要启动线程，还是要创建一个Thread对象，但传递一个Runnable对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">helloThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>());</span><br><span class="line">    helloThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是通过继承Thead还是实现Runnable接口来创建线程，启动线程都是调用start方法。</p>
<h4 id="15-1-2-线程的基本属性和方法"><a href="#15-1-2-线程的基本属性和方法" class="headerlink" title="15.1.2 线程的基本属性和方法"></a>15.1.2 线程的基本属性和方法</h4><p>线程有一些基本属性和方法，包括id、name、优先级、状态、是否daemo线程、sleep方法、yield方法、join方法、过时方法等，我们简要介绍。</p>
<h5 id="1-id和name"><a href="#1-id和name" class="headerlink" title="1. id和name"></a>1. id和name</h5><p>​    前面我们提到，每个线程都有一个id和name。id是一个递增的整数，每创建一个线程就加一。name的默认值是Thread-后跟一个编号，name可以在Thread的构造方法中进行指定，也可以通过setName方法进行设置，给Thread设置一个友好的名字，可以方便调试。</p>
<h5 id="2．优先级"><a href="#2．优先级" class="headerlink" title="2．优先级"></a>2．优先级</h5><p>线程有一个优先级的概念，在Java中，优先级从1到10，默认为5，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个优先级会被映射到操作系统中线程的优先级，不过，因为操作系统各不相同，不一定都是10个优先级，Java中不同的优先级可能会被映射到操作系统中相同的优先级。另外，优先级对操作系统而言主要是一种建议和提示，而非强制。简单地说，在编程中，不要过于依赖优先级。</p>
<h5 id="3．状态"><a href="#3．状态" class="headerlink" title="3．状态"></a>3．状态</h5><p>线程有一个状态的概念，Thread有一个方法用于获取线程的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>返回值类型为Thread.State，它是一个枚举类型，有如下值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITING,</span><br><span class="line">  TIMED_WAITING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这些状态，我们简单解释下：</p>
<p>1）NEW：没有调用start的线程状态为NEW。</p>
<p>2）TERMINATED：线程运行结束后状态为TERMINATED。</p>
<p>3）RUNNABLE：调用start后线程在执行run方法且没有阻塞时状态为RUNNABLE，不过，RUNNABLE不代表CPU一定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只是它没有在等待其他条件。</p>
<p>4）BLOCKED、WAITING、TIMED_WAITING：都表示线程被阻塞了，在等待一些条件，其中的区别我们在后续章节再介绍。</p>
<p>Thread还有一个方法，返回线程是否活着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>线程被启动后，run方法运行结束前，返回值都是true。</p>
<h5 id="4．是否daemon线程"><a href="#4．是否daemon线程" class="headerlink" title="4．是否daemon线程"></a>4．是否daemon线程</h5><p>Thread有一个是否daemon线程的属性，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>前面我们提到，启动线程会启动一条单独的执行流，整个程序只有在所有线程都结束的时候才退出，但daemon线程是例外，当整个程序中剩下的都是daemon线程的时候，程序就会退出。</p>
<p>daemon线程有什么用呢？它一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。在我们运行一个即使最简单的”hello world”类型的程序时，实际上，Java也会创建多个线程，除了main线程外，至少还有一个负责垃圾回收的线程，这个线程就是daemon线程，在main线程结束的时候，垃圾回收线程也会退出。</p>
<h5 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5. sleep方法"></a>5. sleep方法</h5><p>Thread有一个静态的sleep方法，调用该方法会让当前线程睡眠指定的时间，单位是毫秒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>睡眠期间，该线程会让出CPU，但睡眠的时间不一定是确切的给定毫秒数，可能有一定的偏差，偏差与系统定时器和操作系统调度器的准确度和精度有关。睡眠期间，线程可以被中断，如果被中断，sleep会抛出InterruptedException，关于中断以及中断处理，我们在15.4节介绍。</p>
<h5 id="6-yield方法"><a href="#6-yield方法" class="headerlink" title="6. yield方法"></a>6. yield方法</h5><p>Thread还有一个让出CPU的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这也是一个静态方法，调用该方法，是告诉操作系统的调度器：我现在不着急占用CPU，你可以先让其他线程运行。不过，这对调度器也仅仅是建议，调度器如何处理是不一定的，它可能完全忽略该调用。</p>
<h5 id="7-join方法"><a href="#7-join方法" class="headerlink" title="7. join方法"></a>7. join方法</h5><p>在前面HelloThread的例子中，HelloThread没执行完，main线程可能就执行完了， Thread有一个join方法，可以让调用join的线程优先执行，当前线程被阻塞，join方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<p>在等待线程结束的过程中，这个等待可能被中断，如果被中断，会抛出Interrupted-Exception。</p>
<p>join方法还有一个变体，可以限定等待的最长时间，单位为毫秒，如果为0，表示无期限等待：</p>
<p>在前面HelloThread示例中，如果希望main线程在子线程结束后再退出，main方法可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="8．过时方法"><a href="#8．过时方法" class="headerlink" title="8．过时方法"></a>8．过时方法</h5><p>Thread类中还有一些看上去可以控制线程生命周期的方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法因为各种原因已被标记为了过时，我们不应该在程序中使用它们。</p>
<h4 id="15-1-3-共享内存及可能存在的问题"><a href="#15-1-3-共享内存及可能存在的问题" class="headerlink" title="15.1.3 共享内存及可能存在的问题"></a>15.1.3 共享内存及可能存在的问题</h4><p>前面我们提到，每个线程表示一条单独的执行流，有自己的程序计数器，有自己的栈，但线程之间可以共享内存，它们可以访问和操作相同的对象。我们看个例子，如代码清单15-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareMemoryDemo</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incrShared</span><span class="params">()</span>&#123;</span><br><span class="line">                shared ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChildThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                List&lt;String&gt; list;</span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">ChildThread</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.list = list;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    incrShared();</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildThread</span>(list);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildThread</span>(list);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(shared);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，定义了一个静态变量shared和静态内部类ChildThread，在main方法中，创建并启动了两个ChildThread对象，传递了相同的list对象，ChildThread的run方法访问了共享的变量shared和list, main方法最后输出了共享的shared和list的值，大部分情况下，会输出期望的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">[Thread-<span class="number">0</span>, Thread-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>通过这个例子，我们想强调说明执行流、内存和程序代码之间的关系。</p>
<p>1）该例中有三条执行流，一条执行main方法，另外两条执行ChildThread的run方法。</p>
<p>2）不同执行流可以访问和操作相同的变量，如本例中的shared和list变量。</p>
<p>3）不同执行流可以执行相同的程序代码，如本例中incrShared方法，ChildThread的run方法，被两条ChildThread执行流执行，incrShared方法是在外部定义的，但被ChildThread的执行流执行。在分析代码执行过程时，理解代码在被哪个线程执行是很重要的。</p>
<p>4）当多条执行流执行相同的程序代码时，每条执行流都有单独的栈，方法中的参数和局部变量都有自己的一份。</p>
<p>当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果，包括<strong>竞态条件</strong>和<strong>内存可见性</strong>，我们来看下。</p>
<h5 id="1．竞态条件"><a href="#1．竞态条件" class="headerlink" title="1．竞态条件"></a>1．竞态条件</h5><p>所谓竞态条件（race condition）是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。我们看一个例子，如代码清单15-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">          Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">CounterThread</span>();</span><br><span class="line">              threads[i].start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">              threads[i].join();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(counter);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码容易理解，有一个共享静态变量counter，初始值为0，在main方法中创建了1000个线程，每个线程对counter循环加1000次，main线程等待所有线程结束后输出counter的值。</p>
<p>期望的结果是100万，但实际执行，发现每次输出的结果都不一样，一般都不是100万，经常是99万多。为什么会这样呢？<strong>因为counter++这个操作不是原子操作</strong>，它分为三个步骤：</p>
<p>1）取counter的当前值；</p>
<p>2）在当前值基础上加1；</p>
<p>3）将新值重新赋值给counter。</p>
<p>两个线程可能同时执行第一步，取到了相同的counter值，比如都取到了100，第一个线程执行完后counter变为101，而第二个线程执行完后还是101，最终的结果就与期望不符。</p>
<p>怎么解决这个问题呢？有多种方法：</p>
<p>❑ 使用synchronized关键字；</p>
<p>❑ 使用显式锁；</p>
<p>❑ 使用原子变量。</p>
<p>关于这些方法，我们在后续章节会逐步介绍。</p>
<h5 id="2．内存可见性"><a href="#2．内存可见性" class="headerlink" title="2．内存可见性"></a>2．内存可见性</h5><p>多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到。这可能有悖直觉，我们来看一个例子，如代码清单15-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityDemo</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! shutdown)&#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;exit hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HelloThread</span>().start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    shutdown = <span class="literal">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;exit main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，有一个共享的boolean变量shutdown，初始为false, HelloThread在shutdown不为true的情况下一直死循环，当shutdown为true时退出并输出”exit hello”, main线程启动HelloThread后休息了一会儿，然后设置shutdown为true，最后输出”exit main”。</p>
<p>期望的结果是两个线程都退出，但实际执行时，很可能会发现HelloThread永远都不会退出，也就是说，在HelloThread执行流看来，shutdown永远为false，即使main线程已经更改为了true。</p>
<p>这是怎么回事呢？这就是内存可见性问题。在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。在单线程的程序中，这一般不是问题，但在多线程的程序中，尤其是在有多CPU的情况下，这就是严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。</p>
<p>怎么解决这个问题呢？有多种方法：</p>
<p>❑ 使用volatile关键字。</p>
<p>❑ 使用synchronized关键字或显式锁同步。</p>
<p>关于这些方法，我们在后续章节会逐步介绍。</p>
<h4 id="15-1-4-线程的优点及成本"><a href="#15-1-4-线程的优点及成本" class="headerlink" title="15.1.4 线程的优点及成本"></a>15.1.4 线程的优点及成本</h4><p>为什么要创建单独的执行流？或者说线程有什么优点呢？至少有以下几点：</p>
<p>1）充分利用多CPU的计算能力，单线程只能利用一个CPU，使用多线程可以利用多CPU的计算能力。</p>
<p>2）充分利用硬件资源，CPU和硬盘、网络是可以同时工作的，一个线程在等待网络IO的同时，另一个线程完全可以利用CPU，对于多个独立的网络请求，完全可以使用多个线程同时请求。</p>
<p>3）在用户界面（GUI）应用程序中，保持程序的响应性，界面和后台任务通常是不同的线程，否则，如果所有事情都是一个线程来执行，当执行一个很慢的任务时，整个界面将停止响应，也无法取消该任务。</p>
<p>4）简化建模及IO处理，比如，在服务器应用程序中，对每个用户请求使用一个单独的线程进行处理，相比使用一个线程，处理来自各种用户的各种请求，以及各种网络和文件IO事件，建模和编写程序要容易得多。</p>
<p>关于线程，我们需要知道，它是有成本的。创建线程需要消耗操作系统的资源，操作系统会为每个线程创建必要的数据结构、栈、程序计数器等，创建也需要一定的时间。</p>
<p>此外，线程调度和切换也是有成本的，当有大量可运行线程的时候，操作系统会忙于调度，为一个线程分配一段时间，执行完后，再让另一个线程执行，一个线程被切换出去后，操作系统需要保存它的当前上下文状态到内存，上下文状态包括当前CPU寄存器的值、程序计数器的值等，而一个线程被切换回来后，操作系统需要恢复它原来的上下文状态，整个过程称为上下文切换，这个切换不仅耗时，而且使CPU中的很多缓存失效。</p>
<p>当然，这些成本是相对而言的，如果线程中实际执行的事情比较多，这些成本是可以接受的；但如果只是执行本节示例中的counter++，那相对成本就太高了。</p>
<p>另外，如果执行的任务都是CPU密集型的，即主要消耗的都是CPU，那创建超过CPU数量的线程就是没有必要的，并不会加快程序的执行。</p>
<h3 id="15-2-理解synchronized"><a href="#15-2-理解synchronized" class="headerlink" title="15.2 理解synchronized"></a>15.2 理解synchronized</h3><p>上一节，我们提到，共享内存有两个重要问题，一个是竞态条件，另一个是内存可见性，解决这两个问题的一个方案是使用synchronized关键字</p>
<h4 id="15-2-1-用法和基本原理"><a href="#15-2-1-用法和基本原理" class="headerlink" title="15.2.1 用法和基本原理"></a>15.2.1 用法和基本原理</h4><p>synchronized可以用于修饰类的实例方法、静态方法和代码块，我们分别介绍。</p>
<h5 id="1．实例方法"><a href="#1．实例方法" class="headerlink" title="1．实例方法"></a>1．实例方法</h5><p>上节我们介绍了一个计数的例子，当多个线程并发执行counter++的时候，由于该语句不是原子操作，出现了意料之外的结果，这个问题可以用synchronized解决，如代码清单15-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Counter是一个简单的计数器类，incr方法和getCount方法都加了synchronized修饰。加了synchronized后，方法内的代码就变成了原子操作，当多个线程并发更新同一个Counter对象的时候，也不会出现问题。使用的代码如代码清单15-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter.incr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上节类似，我们创建了1000个线程，传递了相同的counter对象，每个线程主要就是调用Counter的incr方法1000次，main线程等待子线程结束后输出counter的值，这次，不论运行多少次，结果都是正确的100万。</p>
<p>这里，synchronized到底做了什么呢？看上去，synchronized使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的即可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">counter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>这里，t1和t2两个线程是可以同时执行Counter的incr方法的，因为它们访问的是不同的Counter对象，一个是counter1，另一个是counter2。</p>
<p>所以，synchronized实例方法实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行。再具体来说，synchronized实例方法保护的是当前实例对象，即this, this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待。执行synchronized实例方法的过程大致如下:</p>
<p>1）尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒。</p>
<p>2）执行实例方法体代码。</p>
<p>3）释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性。</p>
<p>synchronized的实际执行过程比这要复杂得多，而且Java虚拟机采用了多种优化方式以提高性能，但从概念上，我们可以这么简单理解。</p>
<p>当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为BLOCKED。</p>
<p>我们再强调下，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。比如，对于Counter中的两个实例方法getCount和incr，对同一个Counter对象，一个线程执行getCount，另一个执行incr，它们是不能同时执行的，会被synchronized同步顺序执行。</p>
<p>此外，需要说明的是，synchronized方法不能防止非synchronized方法被同时执行。比如，如果给Counter类增加一个非synchronized方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span>&#123;</span><br><span class="line">    count --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则该方法可以和synchronized的incr方法同时执行，这通常会出现非期望的结果，所以，<strong>一般在保护变量时，需要在所有访问该变量的方法上加上synchronized</strong>。</p>
<h5 id="2．静态方法"><a href="#2．静态方法" class="headerlink" title="2．静态方法"></a>2．静态方法</h5><p>synchronized同样可以用于静态方法，如代码清单15-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们说，synchronized保护的是对象，对实例方法，保护的是当前实例对象this，对静态方法，保护的是哪个对象呢？是类对象，这里是StaticCounter.class。实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。</p>
<p>synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以一个执行synchronized静态方法，另一个执行synchronized实例方法。</p>
<h5 id="3．代码块"><a href="#3．代码块" class="headerlink" title="3．代码块"></a>3．代码块</h5><p>除了用于修饰方法外，synchronized还可以用于包装代码块，比如对于实例方法的 Counter类，等价的代码如代码清单15-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized括号里面的就是保护的对象，对于实例方法，就是this, {}里面是同步执行的代码。对于前面静态方法的StaticCounter类，等价的代码如代码清单15-8所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(StaticCounter.class)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(StaticCounter.class)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。比如，Counter类的等价代码还可以如代码清单15-9所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-2-进一步理解synchronized"><a href="#15-2-2-进一步理解synchronized" class="headerlink" title="15.2.2 进一步理解synchronized"></a>15.2.2 进一步理解synchronized</h4><p>介绍了synchronized的基本用法和原理之后，我们再从下面几个角度来进一步介绍synchronized：</p>
<p>❑ 可重入性。</p>
<p>❑ 内存可见性。</p>
<p>❑ 死锁。</p>
<h5 id="1．可重入性"><a href="#1．可重入性" class="headerlink" title="1．可重入性"></a>1．可重入性</h5><p>synchronized有一个重要的特征，它是<strong>可重入的</strong>，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用。比如，在一个syn-chronized实例方法内，可以直接调用其他synchronized实例方法。可重入是一个非常自然的属性，应该是很容易理解的，之所以强调，是因为并不是所有锁都是可重入的，后续章节我们会看到不可重入的锁。</p>
<p><strong>可重入是通过记录锁的持有线程和持有数量来实现的，</strong>当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。</p>
<h5 id="2．内存可见性-1"><a href="#2．内存可见性-1" class="headerlink" title="2．内存可见性"></a>2．内存可见性</h5><p>对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件，但对于明显的本来就是原子的操作方法，也需要加synchronized吗？比如，下面的开关类Switcher只有一个boolean变量on和对应的setter/getter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> on;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多线程同时访问同一个Switcher对象时，会有问题吗？没有竞态条件问题，但正如上节所说，有内存可见性问题，而加上synchronized可以解决这个问题。</p>
<p>synchronized除了保证<strong>原子操作</strong>外，它还有一个重要的作用，就是<strong>保证内存可见性</strong>，<strong>在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。</strong></p>
<p>不过，如果只是为了保证内存可见性，使用synchronized的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符volatile，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> on;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了volatile之后，Java会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。</p>
<h5 id="3．死锁"><a href="#3．死锁" class="headerlink" title="3．死锁"></a>3．死锁</h5><p>使用synchronized或者其他锁，要注意死锁。所谓死锁就是类似这种现象，比如，有a、b两个线程，a持有锁A，在等待锁B，而b持有锁B，在等待锁A, a和b陷入了互相等待，最后谁都执行不下去，如代码清单15-10所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThreadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">aThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              aThread.start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThreadB</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                      <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              bThread.start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              startThreadA();</span><br><span class="line">              startThreadB();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>运行后aThread和bThread陷入了相互等待。怎么解决呢？首先，<strong>应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁</strong>。比如，对于上面的例子，可以约定都先申请lockA，再申请lockB。</p>
<p>不过，在复杂的项目代码中，这种约定可能难以做到。还有一种方法是使用后续章节介绍的<strong>显式锁接口Lock</strong>，它支持尝试获取锁（tryLock）和带时间限制的获取锁方法，<strong>使用这些方法可以在获取不到锁的时候释放已经持有的锁</strong>，然后再次尝试获取锁或干脆放弃，以避免死锁。</p>
<p>如果还是出现了死锁，怎么办呢？Java不会主动处理，不过，借助一些工具，我们可以发现运行中的死锁，比如，Java自带的jstack命令会报告发现的死锁。对于上面的程序，在笔者的计算机中，jstack会生成图15-1所示的报告。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310072326756.png" alt="image-20231007232639624"></p>
<h4 id="15-2-3-同步容器及其注意事项"><a href="#15-2-3-同步容器及其注意事项" class="headerlink" title="15.2.3 同步容器及其注意事项"></a>15.2.3 同步容器及其注意事项</h4><p>我们知道，类Collection中有一些方法，可以返回线程安全的同步容器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K, V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>它们是给所有容器方法都加上synchronized来实现安全的，比如Synchronized-Collection，其部分代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;   <span class="comment">//Backing Collection</span></span><br><span class="line">    <span class="keyword">final</span> Object mutex;      <span class="comment">//Object on which to synchronize</span></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        mutex = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里线程安全针对的是容器对象，指的是当多个线程并发访问同一个容器对象时，不需要额外的同步操作，也不会出现错误的结果。</p>
<p>加了synchronized，所有方法调用变成了原子操作，客户端在调用时，是不是就绝对安全了呢？不是的，至少有以下情况需要注意：</p>
<p>❑ 复合操作，比如先检查再更新。</p>
<p>❑ 伪同步。</p>
<p>❑ 迭代。</p>
<h5 id="1．复合操作"><a href="#1．复合操作" class="headerlink" title="1．复合操作"></a>1．复合操作</h5><p>先来看复合操作，我们看段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span> &lt;K, V&gt; &#123;</span><br><span class="line">    Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">          <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnhancedMap是一个装饰类，接受一个Map对象，调用synchronizedMap转换为了同步容器对象map，增加了一个方法putIfAbsent，该方法只有在原Map中没有对应键的时候才添加（在Java 8之后，Map接口增加了putIfAbsent默认方法，这是针对Java 8之前的Map接口演示概念）。</p>
<p>map的每个方法都是安全的，但这个复合方法putIfAbsent是安全的吗？显然是否定的，这是一个检查然后再更新的复合操作，在多线程的情况下，可能有多个线程都执行完了检查这一步，都发现Map中没有对应的键，然后就会都调用put，这就破坏了putIf-Absent方法期望保持的语义。</p>
<h5 id="2．伪同步"><a href="#2．伪同步" class="headerlink" title="2．伪同步"></a>2．伪同步</h5><p>那给该方法加上synchronized就能实现安全吗？如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是否定的！为什么呢？<strong>同步错对象了</strong>。putIfAbsent同步使用的是EnhancedMap对象，而其他方法（如代码中的put方法）使用的是Collections.synchronizedMap返回的对象map，两者是不同的对象。要解决这个问题，<strong>所有方法必须使用相同的锁</strong>，可以使用EnhancedMap的对象锁，也可以使用map。使用EnhancedMap对象作为锁，则Enhanced-Map中的所有方法都需要加上synchronized。使用map作为锁，putIfAbsent方法可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map)&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">          <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3．迭代"><a href="#3．迭代" class="headerlink" title="3．迭代"></a>3．迭代</h5><p>对于同步容器对象，虽然单个操作是安全的，但迭代并不是。我们看个例子，创建一个同步List对象，一个线程修改List，另一个遍历，看看会发生什么，如代码清单15-11所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startModifyThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">modifyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;item &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    modifyThread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startIteratorThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">iteratorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    iteratorThread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; list = Collections</span><br><span class="line">            .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    startIteratorThread(list);</span><br><span class="line">    startModifyThread(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，程序抛出并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-0&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">    at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">831</span>)</span><br></pre></td></tr></table></figure>
<p>我们之前介绍过这个异常，如果在遍历的同时容器发生了结构性变化，就会抛出该异常。同步容器并没有解决这个问题，如果要避免这个异常，<strong>需要在遍历的时候给整个容器对象加锁</strong>。比如，上面的代码startIteratorThread可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startIteratorThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">iteratorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    iteratorThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4．并发容器"><a href="#4．并发容器" class="headerlink" title="4．并发容器"></a>4．并发容器</h5><p>除了以上这些注意事项，同步容器的性能也是比较低的，当并发访问量比较大的时候性能比较差。所幸的是，Java中还有很多专为并发设计的容器类，比如：</p>
<p>❑ CopyOnWriteArrayList。</p>
<p>❑ ConcurrentHashMap。</p>
<p>❑ ConcurrentLinkedQueue。</p>
<p>❑ ConcurrentSkipListSet。</p>
<p>这些容器类都是线程安全的，但都没有使用synchronized，没有迭代问题，直接支持一些复合操作，性能也高得多，它们能解决什么问题？怎么使用？实现原理是什么？我们后续章节介绍。</p>
<h3 id="15-3-线程的基本协作机制-（看到这里）"><a href="#15-3-线程的基本协作机制-（看到这里）" class="headerlink" title="15.3 线程的基本协作机制  （看到这里）"></a>15.3 线程的基本协作机制  （看到这里）</h3><p>多线程之间除了竞争访问同一个资源外，也经常需要相互协作，怎么协作呢？本节就来介绍Java中多线程协作的基本机制wait/notify。都有哪些场景需要协作？wait/notify是什么？如何使用？实现原理是什么？协作的核心是什么？如何实现各种典型的协作场景？本节进行详细讨论，我们先来看看都有哪些协作的场景。</p>
<h4 id="15-3-1-协作的场景"><a href="#15-3-1-协作的场景" class="headerlink" title="15.3.1 协作的场景"></a>15.3.1 协作的场景</h4><p>多线程之间需要协作的场景有很多，比如：生产者/消费者协作模式</p>
<h4 id="15-3-2-wait-notify"><a href="#15-3-2-wait-notify" class="headerlink" title="15.3.2 wait/notify"></a>15.3.2 wait/notify</h4><p>我们知道，Java的根父类是Object, Java在<strong>Object类而非Thread类</strong>中定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法，这些方法有两类，一类是wait，另一类是notify。</p>
<p>主要有两个wait方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>一个带时间参数，单位是毫秒，表示最多等待这么长时间，参数为0表示无限期等待；一个不带时间参数，表示无限期等待，实际就是调用wait(0)。在等待期间都可以被中断，如果被中断，会抛出InterruptedException。关于中断及中断处理，我们在下节介绍，本节暂时忽略该异常。</p>
<p>wait实际上做了什么呢？它在等待什么？上节我们说过，每个对象都有一把锁和等待队列，一个线程在进入synchronized代码块时，会尝试获取锁，如果获取不到则会把当前线程加入等待队列中，其实，<strong>除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作</strong>。调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用Object的notify方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，它会移除条件队列中所有的线程并全部唤醒。</p>
<p>我们来看个简单的例子，一个线程启动后，在执行一项操作前，它需要等待主线程给它指令，收到指令后才执行，如代码清单15-12所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span>(! fire) &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">                waitThread.start();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码中有两个线程，一个是主线程，一个是WaitThread，协作的条件变量是fire, WaitThread等待该变量变为true，在不为true的时候调用wait，主线程设置该变量并调用notify。</p>
<p>两个线程都要访问协作的变量fire，容易出现竞态条件，所以相关代码都需要被synchronized保护。实际上，wait/notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出异常java.lang.IllegalMonitor-StateException。</p>
<p>你可能会有疑问，如果wait必须被synchronized保护，那一个线程在wait时，另一个线程怎么可能调用同样被synchronized保护的notify方法呢？它不需要等待锁吗？我们需要进一步理解wait的内部过程，<strong>虽然是在synchronized方法内，但调用wait时，线程会释放对象锁</strong>。wait的具体过程是：</p>
<p>1）把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING。</p>
<p>2）等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁：</p>
<p>​    ❑ 如果能够获得锁，线程状态变为RUNNABLE，并从wait调用中返回。</p>
<p>​    ❑ 否则，该线程加入对象锁等待队列，线程状态变为BLOCKED，只有在获得锁后才会从wait调用中返回。</p>
<p>线程从wait调用中返回后，不代表其等待的条件就一定成立了，它需要<strong>重新检查其等待的条件</strong>，一般的调用模式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)</span><br><span class="line">        obj.wait();</span><br><span class="line">    …<span class="comment">//执行条件满足后的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，上例中的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(! fire) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。</p>
<p>简单总结一下，wait/notify方法看上去很简单，但往往难以理解wait等的到底是什么，而notify通知的又是什么，我们需要知道，<strong>它们被不同的线程调用，但共享相同的锁和条件等待队列（相同对象的synchronized代码块内），它们围绕一个共享的条件变量进行协作</strong>，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改了条件变量后调用notify，调用wait的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用wait的线程角度看，它阻塞等待一个条件的成立。我<strong>们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心</strong>。接下来，我们通过一些场景进一步理解wait/notify的应用。</p>
<h3 id="15-4-线程的中断"><a href="#15-4-线程的中断" class="headerlink" title="15.4 线程的中断"></a>15.4 线程的中断</h3><p>本节主要讨论一个问题，如何在Java中取消或关闭一个线程？</p>
<h4 id="15-4-1-取消-关闭的场景"><a href="#15-4-1-取消-关闭的场景" class="headerlink" title="15.4.1 取消/关闭的场景"></a>15.4.1 取消/关闭的场景</h4><p>我们知道，通过线程的start方法启动一个线程后，线程开始执行run方法，run方法运行结束后线程退出，那为什么还需要结束一个线程呢？有多种情况，比如:</p>
<p>1）很多线程的运行模式是死循环，比如在生产者/消费者模式中，消费者主体就是一个死循环，它不停地从队列中接受任务，执行任务，在停止程序时，我们需要一种“优雅”的方法以关闭该线程。  </p>
<p>2）在一些图形用户界面程序中，线程是用户启动的，完成一些任务，比如从远程服务器上下载一个文件，在下载过程中，用户可能会希望取消该任务。</p>
<p>3）在一些场景中，比如从第三方服务器查询一个结果，我们希望在限定的时间内得到结果，如果得不到，我们会希望取消该任务。</p>
<p>4）有时，我们会启动多个线程做同一件事，比如类似抢火车票，我们可能会让多个好友帮忙从多个渠道买火车票，只要有一个渠道买到了，我们会通知取消其他渠道。</p>
<h4 id="15-4-2-取消-关闭的机制"><a href="#15-4-2-取消-关闭的机制" class="headerlink" title="15.4.2 取消/关闭的机制"></a>15.4.2 取消/关闭的机制</h4><p>Java的Thread类定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个方法看上去就可以停止线程，但这个方法被标记为了过时，简单地说，我们不应该使用它，可以忽略它。</p>
<p>在Java中，<strong>停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出</strong>。本节我们主要就是来理解Java的中断机制。</p>
<p>Thread类定义了如下关于中断的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这三个方法名字类似，比较容易混淆，我们解释一下。isInterrupted()和interrupt()是实例方法，调用它们需要通过线程对象；interrupted()是静态方法，实际会调用Thread. currentThread()操作当前线程。</p>
<p>每个线程都有一个<strong>标志位</strong>，表示该线程是否被中断了。</p>
<p>1）isInterrupted：返回对应线程的中断标志位是否为true。</p>
<p>2）interrupted：返回当前线程的中断标志位是否为true，<strong>但它还有一个重要的副作用，就是清空中断标志位</strong>，也就是说，连续两次调用interrupted()，第一次返回的结果为true，第二次一般就是false（除非同时又发生了一次中断）。</p>
<p>3）interrupt：表示中断对应的线程。中断具体意味着什么呢？下面我们进一步来说明。</p>
<h4 id="15-4-3-线程对中断的反应"><a href="#15-4-3-线程对中断的反应" class="headerlink" title="15.4.3 线程对中断的反应"></a>15.4.3 线程对中断的反应</h4><p>interrupt()对线程的影响与线程的状态和在进行的IO操作有关。我们主要考虑线程的状态，IO操作的影响和具体IO以及操作系统有关，我们就不讨论了。线程状态有：</p>
<p>❑ RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度。</p>
<p>❑ WAITING/TIMED_WAITING：线程在等待某个条件或超时。</p>
<p>❑ BLOCKED：线程在等待锁，试图进入同步块。</p>
<p>❑ NEW/TERMINATED：线程还未启动或已结束。</p>
<h5 id="1-RUNNABLE"><a href="#1-RUNNABLE" class="headerlink" title="1. RUNNABLE"></a>1. RUNNABLE</h5><p>如果线程在运行中，且没有执行IO操作，interrupt()只是会设置线程的中断标志位，没有任何其他作用。线程应该在运行过程中合适的位置检查中断标志位，比如，如果主体代码是一个循环，可以在循环开始处进行检查，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptRunnableDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">//…单次循环代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-WAITING-TIMED-WAITING"><a href="#2-WAITING-TIMED-WAITING" class="headerlink" title="2. WAITING/TIMED_WAITING"></a>2. WAITING/TIMED_WAITING</h5><p>线程调用join/wait/sleep方法会进入WAITING或TIMED_WAITING状态，在这些状态时，对线程对象调用interrupt()会使得该线程抛出InterruptedException。需要注意的是，<strong>抛出异常后，中断标志位会被清空，而不是被设置</strong>。比如，执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<p>程序的输出为false。</p>
<p>InterruptedException是一个受检异常，线程必须进行处理。我们在异常处理中介绍过，处理异常的基本思路是：如果知道怎么处理，就进行处理，如果不知道，就应该向上传递，通常情况下不应该捕获异常然后忽略。</p>
<p>捕获到InterruptedException，通常表示希望结束该线程，线程大致有两种处理方式：</p>
<p>​    1）向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理；</p>
<p>​    2）有些情况，不能向上传递异常，比如Thread的run方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用Thread的interrupt方法设置中断标志位，使得其他代码有办法知道它发生了中断。</p>
<p>第一种方式的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interruptibleMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">//…包含wait, join 或 sleep 方法</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptWaitingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟任务代码</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">//…清理操作</span></span><br><span class="line">                        <span class="comment">//重设中断标志位</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-BLOCKED"><a href="#3-BLOCKED" class="headerlink" title="3. BLOCKED"></a>3. BLOCKED</h5><p>如果线程在等待锁，对线程对象调用interrupt()只是会设置线程的中断标志位，线程依然会处于BLOCKED状态，也就是说，<strong>interrupt()并不能使一个在等待锁的线程真正“中断”</strong>。我们看段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptSynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            a.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test方法在持有锁lock的情况下启动线程a，而线程a也去尝试获得锁lock，所以会进入锁等待队列，随后test调用线程a的interrupt方法并调用join等待线程线程a结束，线程a会结束吗？不会，interrupt方法只会设置线程的中断标志，而并不会使它从锁等待队列中出来。</p>
<p>在使用synchronized关键字<strong>获取锁的过程中不响应中断请求</strong>，这是synchronized的局限性。如果这对程序是一个问题，应该使用显式锁。第16章会介绍显式锁Lock接口，它支持以响应中断的方式获取锁。</p>
<h5 id="4-NEW-TERMINATE"><a href="#4-NEW-TERMINATE" class="headerlink" title="4. NEW/TERMINATE"></a>4. NEW/TERMINATE</h5><p>如果线程尚未启动（NEW），或者已经结束（TERMINATED），则调用interrupt()对它没有任何效果，<strong>中断标志位也不会被设置</strong>。</p>
<h4 id="15-4-4-如何正确地取消-关闭线程"><a href="#15-4-4-如何正确地取消-关闭线程" class="headerlink" title="15.4.4 如何正确地取消/关闭线程"></a>15.4.4 如何正确地取消/关闭线程</h4><p>interrupt方法不一定会真正“中断”线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然地调用线程的interrupt方法，以为这样就能取消线程。</p>
<p>对于以线程提供服务的程序模块而言，<strong>它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用interrupt。</strong>Java并发库的一些代码就提供了单独的取消/关闭方法，比如，Future接口提供了如下方法以取消任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>
<p>再如，ExecutorService提供了如下两个关闭方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第16章-并发包的基石"><a href="#第16章-并发包的基石" class="headerlink" title="第16章 并发包的基石"></a>第16章 并发包的基石</h2><p>15章介绍了线程的基本内容，在Java中还有一套并发工具包，位于包java.util.concurrent下，里面包括很多易用且高性能的并发开发工具。从本章开始，我们就来探讨Java并发工具包。本章主要介绍并发包的一些基础内容，分为3个小节：16.1节介绍最基本的原子变量及其背后的原理和思维；16.2节介绍可以替代synchronized的显式锁；16.3节介绍可以替代wait/notify的显式条件。</p>
<h3 id="16-1-原子变量和CAS"><a href="#16-1-原子变量和CAS" class="headerlink" title="16.1 原子变量和CAS"></a>16.1 原子变量和CAS</h3><p>什么是原子变量？为什么需要它们呢？我们从synchronized说起。在15.2节，我们介绍过Counter类，使用synchronized关键字保证原子更新操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于count++这种操作来说，使用synchronized成本太高了，需要先获取锁，最后需要释放锁，获取不到锁的情况下需要等待，还会有线程的上下文切换，这些都需要成本。</p>
<p>对于这种情况，完全可以使用原子变量代替，Java并发包中的基本原子变量类型有以下几种。</p>
<p>​    ❑ AtomicBoolean：原子Boolean类型，常用来在程序中表示一个标志位。</p>
<p>​    ❑ AtomicInteger：原子Integer类型。</p>
<p>​    ❑ AtomicLong：原子Long类型，常用来在程序中生成唯一序列号。</p>
<p>​    ❑ AtomicReference：原子引用类型，用来以原子方式更新复杂类型。</p>
<p>限于篇幅，我们主要介绍AtomicInteger。除了这4个类，还有一些其他类，如针对数组类型的类AtomicLongArray、AtomicReferenceArray，以及用于以原子方式更新对象中的字段的类，如AtomicIntegerFieldUpdater、AtomicReferenceFieldUpdater等。Java 8增加了几个类，在高并发统计汇总的场景中更为适合，包括LongAdder、LongAccumulator、Double-Adder和DoubleAccumulator，具体可参见API文档，我们就不介绍了。</p>
<h4 id="16-1-1-AtomicInteger"><a href="#16-1-1-AtomicInteger" class="headerlink" title="16.1.1 AtomicInteger"></a>16.1.1 AtomicInteger</h4><h5 id="1．基本用法"><a href="#1．基本用法" class="headerlink" title="1．基本用法"></a>1．基本用法</h5><p>AtomicInteger有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>第一个构造方法给定了一个初始值，第二个构造方法的初始值为0。</p>
<p>可以直接获取或设置AtomicInteger中的值，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>
<p>之所以称为原子变量，是因为它包含一些以原子方式实现组合操作的方法，部分方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式获取旧值并设置新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值加1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值加delta</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span></span><br><span class="line"><span class="comment">//以原子方式给当前值加1并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式给当前值减1并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">decrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式给当前值加delta并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span></span><br></pre></td></tr></table></figure>
<p>这些方法的实现都依赖另一个public方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>compareAndSet<strong>是一个非常重要的方法，比较并设置，我们以后将简称为CAS</strong>。该方法有两个参数expect和update，以原子方式实现了如下功能：如果当前值等于expect，则更新为update，否则不更新，如果更新成功，返回true，否则返回false。</p>
<p>AtomicInteger可以在程序中用作一个计数器，多个线程并发更新，也总能实现正确性。我们看个例子，如代码清单16-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Visitor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Visitor</span>();</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出总是正确的，为1000000。</p>
<h5 id="2．基本原理和思维"><a href="#2．基本原理和思维" class="headerlink" title="2．基本原理和思维"></a>2．基本原理和思维</h5><p>AtomicInteger的使用方法是简单直接的，它是怎么实现的呢？它的主要内部成员是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>它的声明带有volatile，这是必需的，以保证内存可见性。</strong></p>
<p>它的大部分更新方法实现都类似，我们看一个方法incrementAndGet，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(; ; ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码主体是个死循环，先获取当前值current，计算期望的值next，然后调用CAS方法进行更新，如果更新没有成功，说明value被别的线程改了，则再去取最新值并尝试更新直到成功为止。</p>
<p><strong>与synchronized锁相比</strong>，这种原子更新方式代表一种不同的思维方式。synchronized是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用CAS更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。synchronized代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。对于大部分比较简单的操作，无论是在低并发还是高并发情况下，这种乐观非阻塞方式的性能都远高于悲观阻塞式方式。</p>
<p>原子变量相对比较简单，但对于复杂一些的数据结构和算法，非阻塞方式往往难于实现和理解，幸运的是，Java并发包中已经提供了一些非阻塞容器，我们只需要会使用就可以了，比如：</p>
<p>​    ❑ ConcurrentLinkedQueue和ConcurrentLinkedDeque：非阻塞并发队列。</p>
<p>​    ❑ ConcurrentSkipListMap和ConcurrentSkipListSet：非阻塞并发Map和Set。</p>
<p>这些容器我们在后续章节介绍。</p>
<h5 id="3．实现锁"><a href="#3．实现锁" class="headerlink" title="3．实现锁"></a>3．实现锁</h5><p>基于CAS，除了可以实现乐观非阻塞算法之外，还可以实现悲观阻塞式算法，比如锁。实际上，Java并发包中的所有阻塞式工具、容器、算法也都是基于CAS的（不过，也需要一些别的支持）。怎么实现锁呢？我们演示一个简单的例子，用AtomicInteger实现一个锁MyLock，如代码清单16-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! status.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        status.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MyLock中，使用status表示锁的状态，0表示未锁定，1表示锁定，lock()、unlock()使用CAS方法更新，lock()只有在更新成功后才退出，实现了阻塞的效果，不过一般而言，这种阻塞方式过于消耗CPU，我们后续章节介绍更为高效的方式。MyLock只是用于演示基本概念，实际开发中应该使用Java并发包中的类，如ReentrantLock。</p>
<h4 id="16-1-2-ABA问题"><a href="#16-1-2-ABA问题" class="headerlink" title="16.1.2 ABA问题"></a>16.1.2 ABA问题</h4><p>使用CAS方式更新有一个ABA问题。该问题是指，假设当前值为A，如果另一个线程先将A修改成B，再修改回成A，当前线程的CAS操作无法分辨当前值发生过变化。</p>
<p>ABA是不是一个问题与程序的逻辑有关，一般不是问题。而如果确实有问题，解决方法是使用AtomicStampedReference，在修改值的同时附加一个时间戳，只有值和时间戳都相同才进行修改，其CAS方法声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params">    V expectedReference, V newReference, <span class="type">int</span> expectedStamp, <span class="type">int</span> newStamp)</span></span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">AtomicStampedReference&lt;Pair&gt; pairRef = <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">AtomicStampedReference</span>&lt;Pair&gt;(pair, stamp);</span><br><span class="line"><span class="type">int</span> <span class="variable">newStamp</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">pairRef.compareAndSet(pair, <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">200</span>, <span class="number">200</span>), stamp, newStamp);</span><br></pre></td></tr></table></figure>
<p>AtomicStampedReference在compareAndSet中要同时修改两个值：一个是引用，另一个是时间戳。它怎么实现原子性呢？实际上，内部AtomicStampedReference会将两个值组合为一个对象，修改的是一个值，我们看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V    expectedReference, V    newReference,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> expectedStamp, <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">          expectedReference == current.reference &amp;&amp;</span><br><span class="line">          expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">          ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Pair是AtomicStampedReference的一个内部类，成员包括引用和时间戳，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> stamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reference = reference;</span><br><span class="line">        <span class="built_in">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AtomicStampedReference将对引用值和时间戳的组合比较和修改转换为了对这个内部类Pair单个值的比较和修改。</p>
<h3 id="16-2-显式锁"><a href="#16-2-显式锁" class="headerlink" title="16.2 显式锁"></a>16.2 显式锁</h3><p>15.2节介绍了利用synchronized实现锁，我们提到了synchronized的一些局限性，本节探讨Java并发包中的显式锁，它可以解决synchronized的限制。</p>
<p>Java并发包中的显式锁接口和类位于包java.util.concurrent.locks下，主要接口和类有：</p>
<p>​    ❑ 锁接口Lock，主要实现类是ReentrantLock；</p>
<p>​    ❑ 读写锁接口ReadWriteLock，主要实现类是ReentrantReadWriteLock。</p>
<p>本节主要介绍接口Lock和实现类ReentrantLock，关于读写锁，我们后续章节介绍。</p>
<h4 id="16-2-1-接口Lock"><a href="#16-2-1-接口Lock" class="headerlink" title="16.2.1 接口Lock"></a>16.2.1 接口Lock</h4><p>显式锁接口Lock的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）lock()/unlock()：就是普通的获取锁和释放锁方法，lock()会阻塞直到成功。</p>
<p>2）lockInterruptibly()：与lock()的不同是，它可以响应中断，如果被其他线程中断了，则抛出InterruptedException。</p>
<p>3）tryLock()：只是尝试获取锁，立即返回，不阻塞，如果获取成功，返回true，否则返回false。</p>
<p>4）tryLock(long time, TimeUnit unit)：先尝试获取锁，如果能成功则立即返回true，否则阻塞等待，但等待的最长时间由指定的参数设置，在等待的同时响应中断，如果发生了中断，抛出InterruptedException，如果在等待的时间内获得了锁，返回true，否则返回false。</p>
<p>5）newCondition：新建一个条件，一个Lock可以关联多个条件，关于条件，我们留待16.3节介绍。</p>
<p>可以看出，<strong>相比synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时</strong>，这使得它灵活得多。</p>
<h4 id="16-2-2-可重入锁ReentrantLock"><a href="#16-2-2-可重入锁ReentrantLock" class="headerlink" title="16.2.2 可重入锁ReentrantLock"></a>16.2.2 可重入锁ReentrantLock</h4><p>下面，先介绍ReentrantLock的基本用法，然后重点介绍如何使用tryLock避免死锁。</p>
<h5 id="1．基本用法-1"><a href="#1．基本用法-1" class="headerlink" title="1．基本用法"></a>1．基本用法</h5><p>Lock接口的主要实现类是ReentrantLock，它的基本用法lock/unlock实现了与syn-chronized一样的语义，包括：</p>
<p>​    ❑ 可重入，一个线程在持有一个锁的前提下，可以继续获得该锁；</p>
<p>​    ❑ 可以解决竞态条件问题；</p>
<p>​    ❑ 可以保证内存可见性。</p>
<p>ReentrantLock有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>参数fair表示是否保证公平，不指定的情况下，默认为false，表示不保证公平。所谓公平是指，等待时间最长的线程优先获得锁。<strong>保证公平会影响性能，一般也不需要，所以默认不保证</strong>，synchronized锁也是不保证公平的，16.2.3节还会再分析实现细节。</p>
<p>使用显式锁，一定要记得调用unlock。一般而言，应该将lock之后的代码包装到try语句内，在finally语句内释放锁。比如，使用ReentrantLock实现Counter，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2．使用tryLock避免死锁"><a href="#2．使用tryLock避免死锁" class="headerlink" title="2．使用tryLock避免死锁"></a>2．使用tryLock避免死锁</h5><p><strong>使用tryLock()，可以避免死锁</strong>。在持有一个锁获取另一个锁而获取不到的时候，可以释放已持有的锁，给其他线程获取锁的机会，然后重试获取所有锁。</p>
<p>我们来看个例子，银行账户之间转账，用类Account表示账户，如代码清单16-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">double</span> initialMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = initialMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money += money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> money;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Account里的money表示当前余额，add/reduce用于修改余额。在账户之间转账，需要两个账户都锁定，如果不使用tryLock，而直接使用lock，则代码如代码清单27-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountMgr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NoEnoughMoneyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">            <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">        from.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            to.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(from.getMoney() &gt;= money) &#123;</span><br><span class="line">                    from.reduce(money);</span><br><span class="line">                    to.add(money);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughMoneyException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                to.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            from.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这么写是有问题的，如果两个账户都同时给对方转账，都先获取了第一个锁，则会发生死锁。我们写段代码来模拟这个过程，如代码清单16-5所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simulateDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">accountNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> Account[] accounts = <span class="keyword">new</span> <span class="title class_">Account</span>[accountNum];</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accountNum; i++) &#123;</span><br><span class="line">          accounts[i] = <span class="keyword">new</span> <span class="title class_">Account</span>(rnd.nextInt(<span class="number">10000</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadNum];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">          threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; loopNum; k++) &#123;</span><br><span class="line">                      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rnd.nextInt(accountNum);</span><br><span class="line">                      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rnd.nextInt(accountNum);</span><br><span class="line">                      <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> rnd.nextInt(<span class="number">10</span>);</span><br><span class="line">                      <span class="keyword">if</span>(i ! = j) &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                                transfer(accounts[i], accounts[j], money);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (NoEnoughMoneyException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了10个账户，100个线程，每个线程执行100次循环，在每次循环中，随机挑选两个账户进行转账。在笔者的计算机中，每次执行该段代码都会发生死锁。读者可以更改这些数值进行试验。</p>
<p>我们使用tryLock来进行修改，先定义一个tryTransfer方法，如代码清单16-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">                <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">            <span class="keyword">if</span>(from.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(to.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(from.getMoney() &gt;= money) &#123;</span><br><span class="line">                                  from.reduce(money);</span><br><span class="line">                                  to.add(money);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughMoneyException</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            to.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        from.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个锁都能够获得，且转账成功，则返回true，否则返回false。不管怎样，结束都会释放所有锁。transfer方法可以循环调用该方法以避免死锁，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">        <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        success = tryTransfer(from, to, money);</span><br><span class="line">        <span class="keyword">if</span>(! success) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (! success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了实现Lock接口中的方法，ReentrantLock还有一些其他方法，通过它们，可以获取关于锁的一些信息，这些信息可以用于监控和调试目的，具体可参看API文档，就不介绍了。</p>
<h4 id="16-2-3-ReentrantLock的实现原理"><a href="#16-2-3-ReentrantLock的实现原理" class="headerlink" title="16.2.3 ReentrantLock的实现原理"></a>16.2.3 ReentrantLock的实现原理</h4><p>ReentrantLock的用法是比较简单的，它是怎么实现的呢？在最底层，它依赖于16.1节介绍的CAS方法，另外，它依赖于类LockSupport中的一些方法。我们先介绍Lock-Support。</p>
<h5 id="1-LockSupport"><a href="#1-LockSupport" class="headerlink" title="1. LockSupport"></a>1. LockSupport</h5><p>类LockSupport也位于包java.util.concurrent.locks下，它的基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span></span><br></pre></td></tr></table></figure>
<p>park使得当前线程放弃CPU，进入等待状态（WAITING），操作系统不再对它进行调度，什么时候再调度呢？有其他线程对它调用了unpark, unpark使参数指定的线程恢复可运行状态。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            LockSupport.park();     <span class="comment">//放弃CPU</span></span><br><span class="line">                System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();     <span class="comment">//启动子线程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);     <span class="comment">//睡眠1秒确保子线程先运行</span></span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，主线程启动子线程t，线程t启动后调用park，放弃CPU，主线程睡眠1秒以确保子线程已执行LockSupport.park()，调用unpark，线程t恢复运行，输出exit。</p>
<p>park不同于Thread.yield(), yield只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而park会放弃调度资格，使线程进入WAITING状态。</p>
<p>需要说明的是，park<strong>是响应中断</strong>的，当有中断发生时，park会返回，线程的中断状态会被设置。另外还需要说明，park可能会无缘无故地返回，程序应该重新检查park等待的条件是否满足。</p>
<p>park有两个变体：</p>
<p>​    ❑ parkNanos：可以指定等待的最长时间，参数是相对于当前时间的纳秒数；</p>
<p>​    ❑ parkUntil：可以指定最长等到什么时候，参数是绝对时间，是相对于纪元时的毫秒数。</p>
<p>当等待超时的时候，它们也会返回。</p>
<p>这些park方法还有一些变体，可以指定一个对象，表示是由于该对象而进行等待的，以便于调试，通常传递的值是this，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span></span><br></pre></td></tr></table></figure>
<p>LockSupport有一个方法，可以返回一个线程的blocker对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBlocker</span><span class="params">(Thread t)</span></span><br></pre></td></tr></table></figure>
<p>这些park/unpark方法是怎么实现的呢？与CAS方法一样，它们也调用了Unsafe类中的对应方法。Unsafe类最终调用了操作系统的API，从程序员的角度，我们可以认为Lock-Support中的这些方法就是基本操作。</p>
<h5 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h5><p>利用CAS和LockSupport提供的基本方法，就可以用来实现ReentrantLock了。但Java中还有很多其他并发工具，如ReentrantReadWriteLock、Semaphore、CountDownLatch，它们的实现有很多类似的地方，<strong>为了复用代码，Java提供了一个抽象类AbstractQueued-Synchronizer</strong>，简称AQS，它简化了并发工具的实现。AQS的整体实现比较复杂，我们主要以ReentrantLock的使用为例进行简要介绍。</p>
<p>AQS封装了一个状态，给子类提供了查询和设置状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>用于实现锁时，AQS可以保存锁的当前持有线程，提供了方法进行查询和设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread t)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</p>
<p>下面，我们以ReentrantLock的使用为例简要介绍AQS的原理。</p>
<h5 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h5><p>ReentrantLock内部使用AQS，有三个内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br></pre></td></tr></table></figure>
<p>Sync是抽象类，NonfairSync是fair为false时使用的类，FairSync是fire为true时使用的类。ReentrantLock内部有一个Sync成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure>
<p>在构造方法中sync被赋值，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看ReentrantLock中的基本方法lock/unlock的实现。先看lock方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-2-4-对比ReentrantLock和synchronized"><a href="#16-2-4-对比ReentrantLock和synchronized" class="headerlink" title="16.2.4 对比ReentrantLock和synchronized"></a>16.2.4 对比ReentrantLock和synchronized</h4><p>相比synchronized, ReentrantLock可以实现与synchronized相同的语义，而且支持以非阻塞方式获取锁，可以响应中断，可以限时，更为灵活。不过，synchronized的使用更为简单，写的代码更少，也更不容易出错。</p>
<p>synchronized代表一种<strong>声明式编程思维</strong>，程序员更多的是表达一种同步声明，由Java系统负责具体实现，程序员不知道其实现细节；显式锁代表一种<strong>命令式编程</strong>思维，程序员实现所有细节。</p>
<p>声明式编程的好处除了简单，还在于性能，在较新版本的JVM上，ReentrantLock和synchronized的性能是接近的，但Java编译器和虚拟机可以不断优化synchronized的实现，比如自动分析synchronized的使用，对于没有锁竞争的场景，自动省略对锁获取/释放的调用。</p>
<p>简单总结下，能用synchronized就用synchronized，不满足要求时再考虑ReentrantLock。</p>
<h3 id="16-3-显式条件"><a href="#16-3-显式条件" class="headerlink" title="16.3 显式条件"></a>16.3 显式条件</h3><p>16.2节我们介绍了显式锁，本节介绍关联的显式条件，介绍其用法和原理。显式条件在不同上下文中也可以被称为条件变量、<strong>条件队列</strong>、或条件，后文我们可能会交替使用。</p>
<h4 id="16-3-1-用法"><a href="#16-3-1-用法" class="headerlink" title="16.3.1 用法"></a>16.3.1 用法</h4><p>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，而显式条件与wait/notify相对应。wait/notify与synchronized配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，</p>
<p>Lock接口定义了创建方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Condition表示条件变量，是一个接口，它的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await对应于Object的wait, signal对应于notify, signalAll对应于notifyAll，语义也是一样的。</p>
<p>与Object的wait方法类似，await也有几个限定等待时间的方法，但功能更多一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待时间是相对时间，如果由于等待超时返回，返回值为false，否则为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//等待时间也是相对时间，但参数单位是纳秒，返回值是nanosTimeout减去实际等待的时间</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//等待时间是绝对时间，如果由于等待超时返回，返回值为false，否则为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>这些await方法都是响应中断的，如果发生了中断，会抛出InterruptedException，但中断标志位会被清空。Condition还定义了一个不响应中断的等待方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>该方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。</p>
<p>一般而言，与Object的wait方法一样，<strong>调用await方法前需要先获取锁</strong>，如果没有锁，会抛出异常IllegalMonitorStateException。</p>
<p>await<strong>在进入等待队列后，会释放锁，释放CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从await方法中退出。</strong></p>
<p>另外，与Object的wait方法一样，await返回后，不代表其等待的条件就一定满足了，通常要将await的调用放到一个循环内，只有条件满足后才退出。</p>
<p>一般而言，signal/signalAll与notify/notifyAll一样，调用它们需要先获取锁，如果没有锁，会抛出异常IllegalMonitorStateException。signal与notify一样，挑选一个线程进行唤醒，signalAll与notifyAll一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从await调用中返回。</p>
<p>ReentrantLock实现了newCondition方法，通过它，我们来看下条件的基本用法。我们实现与15.3节类似的例子WaitThread，一个线程启动后，在执行一项操作前，等待主线程给它指令，收到指令后才执行，示例代码如代码清单16-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (! fire) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        waitThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，<strong>不要将</strong>signal/signalAll与notify/notifyAll混淆，notify/notifyAll是Object中定义的方法，Condition对象也有，稍不注意就会误用。比如，对上面例子中的fire方法，可能会写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">        condition.notify();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写成这样，编译器不会报错，但运行时会抛出IllegalMonitorStateException，因为notify的调用不在synchronized语句内。同样，避免将锁与synchronized混用，那样非常令人混淆，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，显式条件与显式锁配合，wait/notify与synchronized配合。</p>
<h2 id="第17章-并发容器"><a href="#第17章-并发容器" class="headerlink" title="第17章 并发容器"></a>第17章 并发容器</h2><p>本章，我们探讨Java并发包中的容器类，具体包括：</p>
<p>❑ 写时复制的List和Set；</p>
<p>❑ ConcurrentHashMap；</p>
<p>❑ 基于SkipList的Map和Set；</p>
<p>❑ 各种并发队列。</p>
<p>它们都有什么用？如何使用？与普通容器类相比，有哪些特点？是如何实现的？本章进行详细讨论。</p>
<h3 id="17-1-写时复制的List和Set"><a href="#17-1-写时复制的List和Set" class="headerlink" title="17.1 写时复制的List和Set"></a>17.1 写时复制的List和Set</h3><p>本节先介绍两个简单的类：CopyOnWriteArrayList和CopyOnWriteArraySet，讨论它们的用法和实现原理。它们的用法比较简单，我们需要理解的是它们的实现机制。Copy-On-Write即<strong>写时复制</strong>，或称<strong>写时拷贝</strong>，这是解决并发问题的一种重要思路。</p>
<h4 id="17-1-1-CopyOnWriteArrayList"><a href="#17-1-1-CopyOnWriteArrayList" class="headerlink" title="17.1.1 CopyOnWriteArrayList"></a>17.1.1 CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList实现了List接口，它的用法与其他List（如ArrayList）基本是一样的。CopyOnWriteArrayList的特点如下：</p>
<p>❑ 它是线程安全的，可以被多个线程并发访问；</p>
<p>❑ 它的迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</p>
<p>❑ 它以原子方式支持一些复合操作。</p>
<p>我们在15.2.3节提到过基于synchronized的同步容器的几个问题。迭代时，需要对整个列表对象加锁，否则会抛出ConcurrentModificationException,CopyOnWriteArrayList没有这个问题，<strong>迭代时不需要加锁</strong>。</p>
<p>基于synchronized的同步容器的另一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而CopyOnWriteArrayList直接支持两个原子方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不存在才添加，如果添加了，返回true，否则返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">//批量添加c中的非重复元素，不存在才添加，返回实际添加的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时复制。</p>
<p>所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。</p>
<p>换句话说，数组内容是只读的，写操作都是通过新建数组，然后原子性地修改数组引用来实现的。下面我们通过代码具体介绍（基于Java 7），包括内部组成、构造方法、add方法和indexOf方法。</p>
<p>内部数组声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br></pre></td></tr></table></figure>
<p>注意：它声明为了volatile，这是必需的，以保证内存可见性，即保证在写操作更改之后读操作能看到。有两个方法用来访问/设置该数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CopyOnWriteArrayList中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁。CopyOnWriteArrayList内部使用Reentrant-Lock，成员声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
<p>默认构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是设置了一个空数组。</p>
<p>add方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码也容易理解，add方法是修改操作，整个过程需要被锁保护，先获取当前数组elements，然后复制出一个长度加1的新数组newElements，在新数组中添加元素，最后调用setArray原子性地修改内部数组引用。</p>
<p>查找元素indexOf的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先获取当前数组elements，然后调用另一个indexOf进行查找，具体代码就不列举了。这个indexOf方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题。</p>
<p>每次修改都要创建一个新数组，然后复制所有内容，这听上去是一个难以令人接受的方案，如果数组比较大，修改操作又比较频繁，可以想象，CopyOnWriteArrayList的性能是很低的。事实确实如此，CopyOnWriteArrayList不适用于数组很大且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时牺牲了写的性能。</p>
<p>之前我们<strong>介绍了保证线程安全的两种思路：一种是锁，使用synchronized或Reentrant-Lock；另外一种是循环CAS</strong>，写时复制体现了保证线程安全的另一种思路。锁和循环CAS都是控制对同一个资源的访问冲突，而写时复制通过复制资源减少冲突。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，写时复制就是一种很好的解决方案。</p>
<p>写时复制是一种重要的思维，用于各种计算机程序中，比如操作系统内部的进程管理和内存管理。在进程管理中，子进程经常共享父进程的资源，只有在写时才复制。在内存管理中，当多个程序同时访问同一个文件时，操作系统在内存中可能只会加载一份，只有程序要写时才会复制，分配自己的内存，复制可能也不会全部复制，只会复制写的位置所在的[插图]。</p>
<h4 id="17-1-2-CopyOnWriteArraySet"><a href="#17-1-2-CopyOnWriteArraySet" class="headerlink" title="17.1.2 CopyOnWriteArraySet"></a>17.1.2 CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet实现了Set接口，不包含重复元素，使用比较简单，我们就不赘述了。下面，主要介绍其内部组成，以及add与contains方法的代码。CopyOnWriteArraySet内部是通过CopyOnWriteArrayList实现的，其成员声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>
<p>由于CopyOnWriteArraySet是基于CopyOnWriteArrayList实现的，所以与之前介绍过的Set的实现类如HashSet/TreeSet相比，它的性能比较低，不适用于元素个数特别多的集合。如果元素个数比较多，可以考虑ConcurrentHashMap或ConcurrentSkipListSet这两个类，我们稍后介绍。</p>
<p>简单总结下，CopyOnWriteArrayList和CopyOnWriteArraySet适用于读远多于写、集合不太大的场合，它们采用了写时复制，这是计算机程序中一种重要的思维和技术。</p>
<h3 id="17-2-ConcurrentHashMap"><a href="#17-2-ConcurrentHashMap" class="headerlink" title="17.2 ConcurrentHashMap"></a>17.2 ConcurrentHashMap</h3><p>本节介绍一个常用的并发容器ConcurrentHashMap，它是HashMap的并发版本，与HashMap相比，它有如下特点：</p>
<p>❑ 并发安全；</p>
<p>❑ 直接支持一些原子复合操作；</p>
<p>❑ 支持高并发，读操作完全并行，写操作支持一定程度的并行；</p>
<p>❑ 与同步容器Collections.synchronizedMap相比，迭代不用加锁，不会抛出Concurre ntModificationException；</p>
<p>❑ 弱一致性。</p>
<p>下面我们分别介绍。</p>
<h4 id="17-2-1-并发安全"><a href="#17-2-1-并发安全" class="headerlink" title="17.2.1 并发安全"></a>17.2.1 并发安全</h4><p>需要了解的是，HashMap不是并发安全的，在并发更新的情况下，HashMap可能出现死循环，占满CPU。我们看个例子，如代码清单17-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unsafeConcurrentUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    map.put(rnd.nextInt(), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，在笔者的计算机中，无论是Java 7还是Java 8环境，每次都会出现死循环，占满CPU。</p>
<p>为什么会出现死循环呢？死循环出现在多个线程同时扩容哈希表的时候。</p>
<p>使用Collections.synchronizedMap方法可以生成一个同步容器，以避免产生死循环，替换第一行代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;());</span><br></pre></td></tr></table></figure>
<p>同步容器有几个问题：</p>
<p>❑ 每个方法都需要同步，支持的并发度比较低；</p>
<p>❑ 对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。</p>
<p>ConcurrentHashMap没有这些问题，它同样实现了Map接口，也是基于哈希表实现的，上面的代码替换第一行即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="17-2-2-原子复合操作"><a href="#17-2-2-原子复合操作" class="headerlink" title="17.2.2 原子复合操作"></a>17.2.2 原子复合操作</h4><p>除了Map接口，ConcurrentHashMap还实现了一个接口ConcurrentMap，接口定义了一些条件更新操作，Java 7中的具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">//条件更新，如果Map中没有key，设置key为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果没有，返回null</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">//条件删除，如果Map中有key，且对应的值为value，则删除，如果删除了，返回true，</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，且对应的值为oldValue，则替换为newValue，</span></span><br><span class="line">    <span class="comment">//如果替换了，返回ture，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，则替换值为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果原来没有，返回null</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;        <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">//条件更新，如果Map中没有key，设置key为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果没有，返回null</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">//条件删除，如果Map中有key，且对应的值为value，则删除，如果删除了，返回true，</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，且对应的值为oldValue，则替换为newValue，</span></span><br><span class="line">    <span class="comment">//如果替换了，返回ture，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，则替换值为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果原来没有，返回null</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8增加了几个默认方法，包括getOrDefault、forEach、computeIfAbsent、merge等，具体可参见API文档，我们就不介绍了。如果使用同步容器，调用方必须加锁，而Concurrent-HashMap将它们实现为了原子操作。实际上，使用ConcurrentHashMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用synchronized。</p>
<h4 id="17-2-3-高并发的基本机制"><a href="#17-2-3-高并发的基本机制" class="headerlink" title="17.2.3 高并发的基本机制"></a>17.2.3 高并发的基本机制</h4><p>ConcurrentHashMap是为高并发设计的，它是怎么做的呢？具体实现比较复杂，我们简要介绍其思路，在Java 7中，主要有两点：</p>
<p>❑ 分段锁；❑ 读不需要锁。</p>
<p>同步容器使用synchronized，所有方法竞争同一个锁；<strong>而ConcurrentHashMap采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁</strong>，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。</p>
<p>采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是16个，不过，这个数字可以通过构造方法进行设置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span></span><br></pre></td></tr></table></figure>
<p>在对每个段的数据进行读写时，ConcurrentHashMap也不是简单地使用锁进行同步，内部使用了CAS。对一些写采用原子方式的方法，实现比较复杂，我们就不介绍了。实现的效果是，<strong>对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读</strong>，这使得ConcurrentHashMap的并行度远高于同步容器。</p>
<p>Java 8对ConcurrentHashMap的实现进一步做了优化。首先，与HashMap的改进类似，在哈希冲突比较严重的时候，会将单向链表转化为平衡的排序二叉树，提高查找的效率；其次，锁的粒度进一步细化了，以提高并行性，哈希表数组中的每个位置（指向一个单链表或树）都有一个单独的锁，具体比较复杂，我们就不介绍了。</p>
<h4 id="17-2-4-迭代安全"><a href="#17-2-4-迭代安全" class="headerlink" title="17.2.4 迭代安全"></a>17.2.4 迭代安全</h4><p>我们在15.2.3节介绍过，使用同步容器，在迭代中需要加锁，否则可能会抛出Concurrent-ModificationException。ConcurrentHashMap没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。</p>
<p>问题是，迭代会反映其他线程的修改吗？还是像CopyOnWriteArrayList一样，反映的是创建时的副本？答案是，都不是！我们看个例子，如代码清单17-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapIteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; map =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(entry.getKey() + <span class="string">&quot;, &quot;</span> + entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 确保线程t1启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          test();</span><br><span class="line">      &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>t1启动后，创建迭代器，但在迭代输出每个元素前，先睡眠1秒，主线程启动t1后，先睡眠一下，确保t1先运行，然后给map增加了一个元素，程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, <span class="keyword">abstract</span></span><br><span class="line">b, basic</span><br><span class="line">c, call</span><br></pre></td></tr></table></figure>
<p>上述代码说明迭代器反映了最新的更新。将添加语句更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>会发现程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, <span class="keyword">abstract</span></span><br><span class="line">b, basic</span><br></pre></td></tr></table></figure>
<p>这说明迭代器没有反映最新的更新。需要说明的是，这是Java 7的输出，Java 8和Java 9的实现不太一样，输出也不太一样，但也有相同的问题。到底是怎么回事呢？这需要我们理解ConcurrentHashMap的弱一致性。</p>
<h4 id="17-2-5-弱一致性"><a href="#17-2-5-弱一致性" class="headerlink" title="17.2.5 弱一致性"></a>17.2.5 弱一致性</h4><p>ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<p>类似的情况还会出现在ConcurrentHashMap的另一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加m中的键值对到当前Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>该方法并非原子操作，而是调用put方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。</p>
<h3 id="17-3-基于跳表的Map和Set"><a href="#17-3-基于跳表的Map和Set" class="headerlink" title="17.3 基于跳表的Map和Set"></a>17.3 基于跳表的Map和Set</h3><p>Java并发包中与TreeMap/TreeSet对应的并发版本是ConcurrentSkipListMap和Concurrent-SkipListSet，本节就来简要探讨这两个类，先介绍基本概念，然后介绍基本实现原理。</p>
<h4 id="17-3-1-基本概念"><a href="#17-3-1-基本概念" class="headerlink" title="17.3.1 基本概念"></a>17.3.1 基本概念</h4><p>我们知道，TreeSet是基于TreeMap实现的，与此类似，ConcurrentSkipListSet也是基于ConcurrentSkipListMap实现的，所以我们主要介绍ConcurrentSkipListMap。</p>
<p>ConcurrentSkipListMap是基于SkipList实现的，SkipList称为跳跃表或跳表，是一种数据结构，稍后我们会进一步介绍。并发版本为什么采用跳表而不是树呢？原因也很简单，因为跳表更易于实现高效并发算法。ConcurrentSkipListMap有如下特点。</p>
<p>1）没有使用锁，所有操作都是无阻塞的，所有操作都可以并行，包括写，多线程可以同时写。</p>
<p>2）与ConcurrentHashMap类似，迭代器不会抛出ConcurrentModificationException，是弱一致的，迭代可能反映最新修改也可能不反映，一些方法如putAll、clear不是原子的。</p>
<p>3）与ConcurrentHashMap类似，同样实现了ConcurrentMap接口，支持一些原子复合操作。</p>
<p>4）与TreeMap一样，可排序，默认按键的自然顺序，也可以传递比较器自定义排序，实现了SortedMap和NavigableMap接口</p>
<p>看段简单的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;(</span><br><span class="line">            Collections.reverseOrder());</span><br><span class="line">    map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;c=call, b=basic, a=<span class="keyword">abstract</span>&#125;</span><br></pre></td></tr></table></figure>
<p>表示是有序的。</p>
<p>我们之前介绍过ConcurrentSkipListMap的大部分方法，有序的方法与TreeMap是类似的，原子复合操作与ConcurrentHashMap是类似的，此处不再赘述。</p>
<p>需要说明的是ConcurrentSkipListMa的size方法，与大多数容器实现不同，这个方法不是常量操作，它需要遍历所有元素，复杂度为O(N)，而且遍历结束后，元素个数可能已经变了。一般而言，在并发应用中，这个方法用处不大。下面我们主要介绍其基本实现原理。</p>
<h4 id="17-3-2-基本实现原理"><a href="#17-3-2-基本实现原理" class="headerlink" title="17.3.2 基本实现原理"></a>17.3.2 基本实现原理</h4><p>我们先来介绍跳表的结构，<strong>跳表是基于链表的，在链表的基础上加了多层索引结构</strong>。我们通过一个简单的例子来说明。假定容器中包含如下元素：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3, 6, 7, 9, 12, 17, 19, 21, 25, 26</span><br></pre></td></tr></table></figure>
<p>对Map来说，这些值可以视为键。ConcurrentSkipListMap会构造类似图17-1所示的跳表结构。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310081945063.png" alt="image-20231008194535879"></p>
<p>最下面一层就是最基本的单向链表，这个链表是有序的。虽然是有序的，但我们知道，与数组不同，链表不能根据索引直接定位，不能进行二分查找。</p>
<p>为了快速查找，跳表有多层索引结构，这个例子中有两层，第一层有5个节点，第二层有2个节点。<strong>高层的索引节点一定同时是低层的索引节点</strong>，比如9和21。高层的索引节点少，低层的多。统计概率上，第一层索引节点是实际元素数的1/2，第二层是第一层的1/2，逐层减半，但这不是绝对的，有随机性，只是大致如此。每个索引节点有两个指针：一个向右，指向下一个同层的索引节点；另一个向下，指向下一层的索引节点或基本链表节点。</p>
<p><strong>有了这个结构，就可以实现类似二分查找了</strong>。查找元素总是从最高层开始，将待查值与下一个索引节点的值进行比较，如果大于索引节点，就向右移动，继续比较，如果小于索引节点，则向下移动到下一层进行比较。图17-2所示的两条线展示了查找值19和8的过程。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310081948549.png" alt="image-20231008194843437"></p>
<p>对于值19，查找过程是：</p>
<p>1）与9相比，大于9；</p>
<p>2）向右与21相比，小于21；</p>
<p>3）向下与17相比，大于17；</p>
<p>4）向右与21相比，小于21；</p>
<p>5）向下与19相比，找到。</p>
<p>对于值8，查找过程是：</p>
<p>1）与9相比，小于9；</p>
<p>2）向下与6相比，大于6；</p>
<p>3）向右与9相比，小于9；</p>
<p>4）向下与7相比，大于7；</p>
<p>5）向右与9相比，小于9，不能再向下，没找到。</p>
<p>这个结构是有序的，查找的性能与二叉树类似，复杂度是O(log(N))。不过，这个结构是如何构建起来的呢？与二叉树类似，这个结构是在更新过程中进行保持的，保存元素的基本思路是：</p>
<p>1）先保存到基本链表，找到待插入的位置，找到位置后，插入基本链表；2）更新索引层。</p>
<p>略</p>
<h3 id="17-4-并发队列"><a href="#17-4-并发队列" class="headerlink" title="17.4 并发队列"></a>17.4 并发队列</h3><p>本节，我们介绍Java并发包中的各种队列。Java并发包提供了丰富的队列类，可以简单分为以下几种。</p>
<p>❑ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque。</p>
<p>❑ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque。</p>
<p>❑ 优先级阻塞队列：PriorityBlockingQueue。</p>
<p>❑ 延时阻塞队列：DelayQueue。</p>
<p>❑ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue。</p>
<p>无锁非阻塞是指，这些队列不使用锁，所有操作总是可以立即执行，主要通过循环CAS实现并发安全。阻塞队列是指，这些队列使用锁和条件，很多操作都需要先获取锁或满足特定条件，获取不到锁或等待条件时，会等待（即阻塞），获取到锁或条件满足再返回。</p>
<p>这些队列迭代都不会抛出ConcurrentModificationException，都是弱一致的，后面就不单独强调了。下面，我们来简要介绍每类队列的用途、用法和基本实现原理。</p>
<h4 id="17-4-1-无锁非阻塞并发队列"><a href="#17-4-1-无锁非阻塞并发队列" class="headerlink" title="17.4.1 无锁非阻塞并发队列"></a>17.4.1 无锁非阻塞并发队列</h4><p>有两个无锁非阻塞队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque，它们适用于多个线程并发使用一个队列的场合，都是基于链表实现的，都没有限制大小，是无界的，与ConcurrentSkipListMap类似，它们的size方法不是一个常量运算，不过这个方法在并发应用中用处也不大。</p>
<p>ConcurrentLinkedQueue实现了Queue接口，表示一个先进先出的队列，从尾部入队，从头部出队，内部是一个单向链表。ConcurrentLinkedDeque实现了Deque接口，表示一个双端队列，在两端都可以入队和出队，内部是一个双向链表。它们的用法类似于Linked-List，我们就不赘述了。</p>
<p>这两个类最基础的原理是循环CAS, ConcurrentLinkedQueue的算法基于一篇论文《Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithm》（<a target="_blank" rel="noopener" href="https://www.research.ibm.com/people/m/michael/podc-1996.pdf）。ConcurrentLinkedDeque扩展了Con-currentLinkedQueue的技术，但它们的具体实现都非常复杂，我们就不探讨了。">https://www.research.ibm.com/people/m/michael/podc-1996.pdf）。ConcurrentLinkedDeque扩展了Con-currentLinkedQueue的技术，但它们的具体实现都非常复杂，我们就不探讨了。</a></p>
<h4 id="17-4-2-普通阻塞队列"><a href="#17-4-2-普通阻塞队列" class="headerlink" title="17.4.2 普通阻塞队列"></a>17.4.2 普通阻塞队列</h4><p>除了刚介绍的两个队列，其他队列都是阻塞队列，都实现了接口BlockingQueue，在入队/出队时可能等待，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队，如果队列满，等待直到队列有空间</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//出队，如果队列空，等待直到队列不为空，返回头部元素</span></span><br><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//入队，如果队列满，最多等待指定的时间，如果超时还是满，返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//出队，如果队列空，最多等待指定的时间，如果超时还是空，返回null</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>普通阻塞队列是<strong>常用的队列</strong>，常用于生产者/消费者模式。</p>
<p>ArrayBlockingQueue和LinkedBlockingQueue都实现了Queue接口，表示先进先出的队列，尾部进，头部出，而LinkedBlockingDeque实现了Deque接口，是一个双端队列。</p>
<p>ArrayBlockingQueue是基于循环数组实现的，有界，创建时需要指定大小，且在运行过程中不会改变，这与我们在容器类中介绍的ArrayDeque是不同的，ArrayDeque也是基于循环数组实现的，但是是无界的，会自动扩展。</p>
<p>LinkedBlockingQueue是基于单向链表实现的，在创建时可以指定最大长度，也可以不指定，默认是无限的，节点都是动态创建的。LinkedBlockingDeque与LinkedBlocking-Queue一样，最大长度也是在创建时可选的，默认无限，不过，它是基于双向链表实现的。</p>
<p>内部，它们都是使用显式锁ReentrantLock和显式条件Condition实现的。</p>
<p>ArrayBlockingQueue的实现很直接，有一个数组存储元素，有两个索引表示头和尾，有一个变量表示当前元素个数，有一个锁保护所有访问，有“不满”和“不空”两个条件用于协作，实现思路与我们在15.3.3节实现的类似，就不赘述了。</p>
<p>与ArrayBlockingQueue类似，LinkedBlockingDeque也是使用一个锁和两个条件，使用锁保护所有操作，使用“不满”和“不空”两个条件。LinkedBlockingQueue稍微不同，因为它使用链表，且只从头部出队、从尾部入队，它做了一些优化，使用了两个锁，一个保护头部，一个保护尾部，每个锁关联一个条件。</p>
<h4 id="17-4-3-优先级阻塞队列"><a href="#17-4-3-优先级阻塞队列" class="headerlink" title="17.4.3 优先级阻塞队列"></a>17.4.3 优先级阻塞队列</h4><p>普通阻塞队列是先进先出的，而优先级队列是按优先级出队的，优先级高的先出，我们在容器类中介绍过优先级队列PriorityQueue及其背后的数据结构堆。Priority-BlockingQueue是PriorityQueue的并发版本，与PriorityQueue一样，它没有大小限制，是无界的，内部的数组大小会动态扩展，要求元素要么实现Comparable接口，要么创建Priority-BlockingQueue时提供一个Comparator对象。</p>
<p>与PriorityQueue的区别是，PriorityBlockingQueue实现了BlockingQueue接口，在队列为空时，take方法会阻塞等待。另外，PriorityBlockingQueue是线程安全的，它的基本实现原理与PriorityQueue是一样的，也是基于堆，但它使用了一个锁ReentrantLock保护所有访问，使用了一个条件协调阻塞等待。</p>
<h4 id="17-4-4-延时阻塞队列"><a href="#17-4-4-延时阻塞队列" class="headerlink" title="17.4.4 延时阻塞队列"></a>17.4.4 延时阻塞队列</h4><p>延时阻塞队列DelayQueue是一种特殊的优先级队列，它是无界的。它要求每个元素都实现Delayed接口，该接口的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delayed扩展了Comparable接口，也就是说，DelayQueue的每个元素都是可比较的，它有一个额外方法getDelay返回一个给定时间单位unit的整数，表示再延迟多长时间，如果小于等于0，则表示不再延迟。</p>
<p>DelayQueue可以用于实现定时任务，它按元素的延时时间出队。它的特殊之处在于，只有当元素的延时过期之后才能被从队列中拿走，也就是说，take方法总是返回第一个过期的元素，如果没有，则阻塞等待。</p>
<p>DelayQueue是基于PriorityQueue实现的，它使用一个锁ReentrantLock保护所有访问，使用一个条件available表示头部是否有元素，当头部元素的延时未到时，take操作会根据延时计算需睡眠的时间，然后睡眠，如果在此过程中有新的元素入队，且成为头部元素，则阻塞睡眠的线程会被提前唤醒然后重新检查。这是基本思路，DelayQueue的实现有一些优化，以减少不必要的唤醒，具体我们就不探讨了。</p>
<h4 id="17-4-5-其他阻塞队列"><a href="#17-4-5-其他阻塞队列" class="headerlink" title="17.4.5 其他阻塞队列"></a>17.4.5 其他阻塞队列</h4><p>Java并发包中还有两个特殊的阻塞队列：SynchronousQueue和LinkedTransferQueue。</p>
<p>SynchronousQueue与一般的队列不同，它不算一种真正的队列，没有存储元素的空间，连存储一个元素的空间都没有。它的入队操作要等待另一个线程的出队操作，反之亦然。如果没有其他线程在等待从队列中接收元素，put操作就会等待。take操作需要等待其他线程往队列中放元素，如果没有，也会等待。SynchronousQueue适用于两个线程之间直接传递信息、事件或任务。</p>
<p>LinkedTransferQueue实现了TransferQueue接口，TransferQueue是BlockingQueue的子接口，但增加了一些额外功能，生产者在往队列中放元素时，可以等待消费者接收后再返回，适用于一些消息传递类型的应用中。TransferQueue的接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransferQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//如果有消费者在等待(执行take或限时的poll)，直接转给消费者，</span></span><br><span class="line">    <span class="comment">//返回true，否则返回false，不入队</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//如果有消费者在等待，直接转给消费者，否则入队，阻塞等待直到被消费者接收后再返回</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//如果有消费者在等待，直接转给消费者，返回true</span></span><br><span class="line">    <span class="comment">//否则入队，阻塞等待限定的时间，如果最后被消费者接收，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//是否有消费者在等待</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasWaitingConsumer</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//等待的消费者个数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getWaitingConsumerCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedTransferQueue是基于链表实现的、无界的TransferQueue，具体实现比较复杂，我们就不探讨了。</p>
<p>Java并发包中还提供了一种方便的任务执行服务，使用它，可以将要执行的并发任务与线程的管理相分离，大大简化并发任务和线程的管理，让我们下一章来探讨。</p>
<h2 id="第18章-异步任务执行服务"><a href="#第18章-异步任务执行服务" class="headerlink" title="第18章 异步任务执行服务"></a>第18章 异步任务执行服务</h2><p>在之前的介绍中，线程Thread既表示要执行的任务，又表示执行的机制。Java并发包提供了一套框架，大大简化了执行异步任务所需的开发。这套框架引入了一个“执行服务”的概念，它将“任务的提交”和“任务的执行”相分离，“执行服务”封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。</p>
<p>本章我们就来探讨这套框架，具体分为3个小节：18.1节介绍基本概念和原理；18.2节介绍任务执行服务的主要实现机制：线程池；18.3节介绍定时任务的执行服务。</p>
<h3 id="18-1-基本概念和原理"><a href="#18-1-基本概念和原理" class="headerlink" title="18.1 基本概念和原理"></a>18.1 基本概念和原理</h3><p>下面，我们来看异步任务执行服务的基本接口、用法和实现原理。</p>
<h4 id="18-1-1-基本接口"><a href="#18-1-1-基本接口" class="headerlink" title="18.1.1 基本接口"></a>18.1.1 基本接口</h4><p>首先，我们来看任务执行服务涉及的基本接口：</p>
<p>❑ Runnable和Callable：表示要执行的异步任务。</p>
<p>❑ Executor和ExecutorService：表示执行服务。</p>
<p>❑ Future：表示异步任务的结果。</p>
<p>关于Runnable和Callable，我们在前面章节都已经了解了，都表示任务，Runnable没有返回结果，而Callable有，Runnable不会抛出异常，而Callable会。</p>
<p>Executor表示最简单的执行服务，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是可以执行一个Runnable，没有返回结果。接口没有限定任务如何执行，可能是创建一个新线程，可能是复用线程池中的某个线程，也可能是在调用者线程中执行。</p>
<p>ExecutorService扩展了Executor，定义了更多服务，基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">    Future&lt;? &gt; submit(Runnable task);</span><br><span class="line">    <span class="comment">//... 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个submit都表示提交一个任务，返回值类型都是Future，返回后，只是表示任务已提交，不代表已执行，通过Future可以查询异步任务的状态、获取最终结果、取消任务等。我们知道，对于Callable，任务最终有个返回值，而对于Runnable是没有返回值的；第二个提交Runnable的方法可以同时提供一个结果，在异步任务结束时返回；第三个方法异步任务的最终返回值为null。</p>
<p>我们来看Future接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">        ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待，另一个get方法可以限定阻塞等待的时间，如果超时任务还未结束，会抛出TimeoutException。</p>
<p>cancel用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消， cancel返回false，否则返回true。如果任务还未开始，则不再运行。但如果任务已经在运行，则不一定能取消，参数mayInterruptIfRunning表示，如果任务正在执行，是否调用interrupt方法中断线程，如果为false就不会，如果为true，就会尝试中断线程，但我们从15.4节知道，中断不一定能取消线程。</p>
<p>isDone和isCancelled用于查询任务状态。isCancelled表示任务是否被取消，只要cancel方法返回了true，随后的isCancelled方法都会返回true，即使执行任务的线程还未真正结束。isDone表示任务是否结束，不管什么原因都算，可能是任务正常结束，可能是任务抛出了异常，也可能是任务被取消。</p>
<p>我们再来看下get方法，任务最终大概有三种结果：</p>
<p>1）正常完成，get方法会返回其执行结果，如果任务是Runnable且没有提供结果，返回null。</p>
<p>2）任务执行抛出了异常，get方法会将异常包装为ExecutionException重新抛出，通过异常的getCause方法可以获取原异常。</p>
<p>3）任务被取消了，get方法会抛出异常CancellationException。</p>
<p>如果调用get方法的线程被中断了，get方法会抛出InterruptedException。</p>
<p>Future<strong>是一个重要的概念，是实现“任务的提交”与“任务的执行”相分离的关键，是其中的“纽带”，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。</strong></p>
<h4 id="18-1-2-基本用法"><a href="#18-1-2-基本用法" class="headerlink" title="18.1.2 基本用法"></a>18.1.2 基本用法</h4><p>说了这么多接口，具体怎么用呢？我们看个简单的例子，如代码清单18-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sleepSeconds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">            Thread.sleep(sleepSeconds);</span><br><span class="line">            <span class="keyword">return</span> sleepSeconds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="comment">//模拟执行其他任务</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用工厂类Executors创建了一个任务执行服务。Executors有多个静态方法，可以用来创建ExecutorService，这里使用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>表示使用一个线程执行所有服务，后续我们会详细介绍Executors，注意与Executor相区别，后者是单数，是接口。</p>
<p>不管ExecutorService是如何创建的，对使用者而言，用法都一样，例子提交了一个任务，提交后，可以继续执行其他事情，随后可以通过Future获取最终结果或处理任务执行的异常。</p>
<p>最后，我们调用了ExecutorService的shutdown方法，它会关闭任务执行服务。</p>
<p>前面我们只是介绍了ExecutorService的三个submit方法，其实它还有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个关闭方法：shutdown和shutdownNow。区别是，shutdown表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行；shutdownNow不仅不接受新任务，而且会终止已提交但尚未执行的任务，对于正在执行的任务，一般会调用线程的interrupt方法尝试中断，不过，线程可能不响应中断，shutdownNow会返回已提交但尚未执行的任务列表。</p>
<p>shutdown和shutdownNow不会阻塞等待，它们返回后不代表所有任务都已结束，不过isShutdown方法会返回true。调用者可以通过awaitTermination等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即isTerminated方法返回true，则返回true，否则返回false。</p>
<p>ExecutorService有两组批量提交任务的方法：invokeAll和invokeAny，它们都有两个版本，其中一个限定等待时间。</p>
<p>invokeAll等待所有任务完成，返回的Future列表中，每个Future的isDone方法都返回true，不过isDone为true不代表任务就执行成功了，可能是被取消了。invokeAll可以指定等待时间，如果超时后有的任务没完成，就会被取消。</p>
<p>而对于invokeAny，只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消；如果没有任务能在限时内成功返回，抛出TimeoutException；如果限时内所有任务都结束了，但都发生了异常，抛出ExecutionException。</p>
<p>使用ExecutorService，编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。</p>
<h2 id="第19章-同步和协作工具类"><a href="#第19章-同步和协作工具类" class="headerlink" title="第19章 同步和协作工具类"></a>第19章 同步和协作工具类</h2><p>我们在15.3节实现了线程的一些基本协作机制，那是利用基本的wait/notify实现的。我们提到，Java并发包中有一些专门的同步和协作工具类，本章，我们就来探讨它们。具体工具类包括：</p>
<p>❑ 读写锁ReentrantReadWriteLock。❑ 信号量Semaphore。❑ 倒计时门栓CountDownLatch。❑ 循环栅栏CyclicBarrier。</p>
<p>此外，有一个实现线程安全的特殊概念：线程本地变量ThreadLocal，本章也会进行介绍。</p>
<p>与第15章介绍的显式锁和显式条件类似，除了ThreadLocal外，这些同步和协作类都是基于AQS实现的。在一些特定的同步协作场景中，相比使用最基本的wait/notify以及显式锁/条件，它们更为方便，效率更高。下面，我们就来探讨它们的基本概念、用法、用途和基本原理。</p>
<h3 id="19-1-读写锁ReentrantReadWriteLock"><a href="#19-1-读写锁ReentrantReadWriteLock" class="headerlink" title="19.1 读写锁ReentrantReadWriteLock"></a>19.1 读写锁ReentrantReadWriteLock</h3><p>之前章节我们介绍了两种锁：synchronized和显式锁ReentrantLock，对于同一受保护对象的访问，无论是读还是写，它们都要求获得相同的锁。在一些场景中，这是没有必要的，多个线程的读操作完全可以并行，在读多写少的场景中，让读操作并行可以明显提高性能。</p>
<p>怎么让读操作能够并行，又不影响一致性呢？答案是使用读写锁。在Java并发包中，接口ReadWriteLock表示读写锁，主要实现类是可重入读写锁ReentrantReadWriteLock。ReadWriteLock的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个ReadWriteLock产生两个锁：一个读锁，一个写锁。读操作使用读锁，写操作使用写锁。需要注意的是，<strong>只有“读-读”操作是可以并行的，“读-写”和“写-写”都不可以。</strong>只有一个线程可以进行写操作，在获取写锁时，只有没有任何线程持有任何锁才可以获取到，在持有写锁时，其他任何线程都获取不到任何锁。在没有其他线程持有写锁的情况下，多个线程可以获取和持有读锁。</p>
<p>ReentrantReadWriteLock是可重入的读写锁，它有两个构造方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>fair表示是否公平，如果不传递则是false，含义与16.2节介绍的类似，就不赘述了。</p>
<p>我们看个读写锁的应用，使用ReentrantReadWriteLock实现一个缓存类MyCache，如代码清单19-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    map.clear();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    writeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。读写锁是怎么实现的呢？读锁和写锁看上去是两个锁，它们是怎么协调的？具体实现比较复杂，我们简述下其思路。</p>
<p>内部，它们使用同一个整数变量表示锁的状态，16位给读锁用，16位给写锁用，使用一个变量便于进行CAS操作，锁的等待队列其实也只有一个。</p>
<p>使用一个变量便于进行CAS操作，<strong>锁的等待队列其实也只有一个</strong>。</p>
<p>写锁的获取，就是确保当前没有其他线程持有任何锁，否则就等待。写锁释放后，也就是将等待队列中的第一个线程唤醒，唤醒的可能是等待读锁的，也可能是等待写锁的。</p>
<p>读锁的获取不太一样，首先，只要写锁没有被持有，就可以获取到读锁，此外，在获取到读锁后，它会检查等待队列，逐个唤醒最前面的等待读锁的线程，直到第一个等待写锁的线程。如果有其他线程持有写锁，获取读锁会等待。读锁释放后，检查读锁和写锁数是否都变为了0，如果是，唤醒等待队列中的下一个线程。</p>
<h3 id="19-2-信号量Semaphore"><a href="#19-2-信号量Semaphore" class="headerlink" title="19.2 信号量Semaphore"></a>19.2 信号量Semaphore</h3><p>之前介绍的锁都是限制只有一个线程可以同时访问一个资源。现实中，资源往往有多个，但每个同时只能被一个线程访问，比如，饭店的饭桌、火车上的卫生间。有的单个资源即使可以被并发访问，但并发访问数多了可能影响性能，所以希望限制并发访问的线程数。还有的情况，与软件的授权和计费有关，对不同等级的账户，限制不同的最大并发访问数。</p>
<p>信号量类Semaphore就是用来解决这类问题的，它可以限制对资源的并发访问数，它有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>fair表示公平，含义与之前介绍的是类似的，permits表示许可数量。</p>
<p>Semaphore的方法与锁是类似的，主要的方法有两类，获取许可和释放许可，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞获取许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//阻塞获取许可，不响应中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">//批量获取多个许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">//尝试获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span></span><br><span class="line"><span class="comment">//限定等待时间获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> timeout,</span></span><br><span class="line"><span class="params">    TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//释放许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>我们看个简单的示例，限制并发访问的用户数不超过100，如代码清单19-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessControlService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLimitException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PERMITS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(MAX_PERMITS, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(! permits.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">//同时登录用户数超过限制</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentLimitException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//…其他验证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        permits.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。需要说明的是，如果我们将permits的值设为1，你可能会认为它就变成了一般的锁，不过，它与一般的锁是不同的。一般锁只能由持有锁的线程释放，而Semaphore表示的只是一个许可数，任意线程都可以调用其release方法。主要的锁实现类ReentrantLock是可重入的，而Semaphore不是，每一次的acquire调用都会消耗一个许可，比如，看下面的代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">permits.acquire();</span><br><span class="line">permits.acquire();</span><br><span class="line">System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>程序会阻塞在第二个acquire调用，永远都不会输出“acquired”。</p>
<p>信号量的基本原理比较简单，也是基于AQS实现的，permits表示共享的锁个数，acquire方法就是检查锁个数是否大于0，大于则减一，获取成功，否则就等待，release就是将锁个数加一，唤醒第一个等待的线程。</p>
<h3 id="19-3-倒计时门栓CountDownLatch"><a href="#19-3-倒计时门栓CountDownLatch" class="headerlink" title="19.3 倒计时门栓CountDownLatch"></a>19.3 倒计时门栓CountDownLatch</h3><p>我们在15.3.5节使用wait/notify实现了一个简单的门栓MyLatch，我们提到，Java并发包中已经提供了类似工具，就是CountDownLatch。它相当于是一个门栓，一开始是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过，它是一次性的，打开后就不能再关上了。</p>
<p>CountDownLatch里有一个计数，这个计数通过构造方法进行传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<p>多个线程可以基于这个计数进行协作，它的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>await检查计数是否为0，如果大于0，就等待，await可以被中断，也可以设置最长等待时间。countDown检查计数，如果已经为0，直接返回，否则减少计数，如果新的计数变为0，则唤醒所有等待的线程。</p>
<p>之前，我们介绍了门栓的两种应用场景：一种是同时开始，另一种是主从协作。它们都有两类线程，互相需要同步，我们使用CountDownLatch重新演示。</p>
<p>在同时开始场景中，运行员线程等待主裁判线程发出开始指令的信号，一旦发出后，所有运动员线程同时开始，计数初始为1，运动员线程调用await，主线程调用countDown，如代码清单19-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RacerWithCountDownLatch</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                CountDownLatch latch;</span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.latch.await();</span><br><span class="line">                        System.out.println(getName()</span><br><span class="line">                                  + <span class="string">&quot; start run &quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        Thread[] racers = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            racers[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(latch);</span><br><span class="line">            racers[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。在主从协作模式中，主线程依赖工作线程的结果，需要等待工作线程结束，这时，计数初始值为工作线程的个数，工作线程结束后调用countDown，主线程调用await进行等待，如代码清单19-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterWorkerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟执行任务</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() ＊ <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//模拟异常情况</span></span><br><span class="line">                <span class="keyword">if</span>(Math.random() &lt; <span class="number">0.02</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bad luck&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerNum);</span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[workerNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerNum; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(latch);</span><br><span class="line">            workers[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;collect worker results&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要强调的是，在这里，countDown的调用应该放到finally语句中，确保在工作线程发生异常的情况下也会被调用，使主线程能够从await调用中返回。</p>
<h3 id="19-4-循环栅栏CyclicBarrier"><a href="#19-4-循环栅栏CyclicBarrier" class="headerlink" title="19.4 循环栅栏CyclicBarrier"></a>19.4 循环栅栏CyclicBarrier</h3><p>我们在15.3.7节使用wait/notify实现了一个简单的集合点AssemblePoint，我们提到， Java并发包中已经提供了类似工具，就是CyclicBarrier。它相当于是一个栅栏，所有线程在到达该栅栏后都需要等待其他线程，等所有线程都到达后再一起通过，它是循环的，可以用作重复的同步。</p>
<p>CyclicBarrier特别适用于并行迭代计算，每个线程负责一部分计算，然后在栅栏处等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。</p>
<p>与CountDownLatch类似，它也有一个数字，但表示的是参与的线程个数，这个数字通过构造方法进行传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span></span><br></pre></td></tr></table></figure>
<p>它还有一个构造方法，接受一个Runnable参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span></span><br></pre></td></tr></table></figure>
<p>这个参数表示栅栏动作，当所有线程到达栅栏后，在所有线程执行下一步动作前，运行参数中的动作，这个动作由最后一个到达栅栏的线程执行。</p>
<p>CyclicBarrier的主要方法就是await：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span><br></pre></td></tr></table></figure>
<p>await在等待其他线程到达栅栏，调用await后，表示自己已经到达，如果自己是最后一个到达的，就执行可选的命令，执行后，唤醒所有等待的线程，然后重置内部的同步计数，以循环使用。</p>
<p>await可以被中断，可以限定最长等待时间，中断或超时后会抛出异常。需要说明的是异常BrokenBarrierException，它表示栅栏被破坏了，什么意思呢？在CyclicBarrier中，参与的线程是互相影响的，只要其中一个线程在调用await时被中断了，或者超时了，栅栏就会被破坏。此外，如果栅栏动作抛出了异常，栅栏也会被破坏。被破坏后，所有在调用await的线程就会退出，抛出BrokenBarrierException。</p>
<p>我们看一个简单的例子，多个游客线程分别在集合点A和B同步，如代码清单19-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tourist</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tourist</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟先各自独立运行</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//集合点A</span></span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; arrived A &quot;</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">                <span class="comment">//集合后模拟再各自独立运行</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//集合点B</span></span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; arrived B &quot;</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        Tourist[] threads = <span class="keyword">new</span> <span class="title class_">Tourist</span>[num];</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(num, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;all arrived &quot;</span> + System.currentTimeMillis()</span><br><span class="line">                        + <span class="string">&quot; executed by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Tourist</span>(barrier);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在笔者的计算机中的一次输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all arrived <span class="number">1490053578552</span> executed by Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">Thread-<span class="number">2</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">Thread-<span class="number">0</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">all arrived <span class="number">1490053578889</span> executed by Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> arrived B <span class="number">1490053578890</span></span><br><span class="line">Thread-<span class="number">2</span> arrived B <span class="number">1490053578890</span></span><br><span class="line">Thread-<span class="number">1</span> arrived B <span class="number">1490053578890</span></span><br></pre></td></tr></table></figure>
<p>多个线程到达A和B的时间是一样的，使用CyclicBarrier，达到了重复同步的目的。CyclicBarrier与CountDownLatch可能容易混淆，我们强调下它们的区别。</p>
<p>1）CountDownLatch的参与线程是有不同角色的，有的负责倒计时，有的在等待倒计时变为0，负责倒计时和等待倒计时的线程都可以有多个，用于不同角色线程间的同步。</p>
<p>2）CyclicBarrier的参与线程角色是一样的，用于同一角色线程间的协调一致。</p>
<p>3）CountDownLatch是一次性的，而CyclicBarrier是可以重复利用的。</p>
<h3 id="19-5-理解ThreadLocal"><a href="#19-5-理解ThreadLocal" class="headerlink" title="19.5 理解ThreadLocal"></a>19.5 理解ThreadLocal</h3><p>本节，我们来探讨一个特殊的概念：线程本地变量。在Java中的实现是ThreadLocal类，它是什么？有什么用？实现原理是什么？让我们接下来逐步探讨。</p>
<h4 id="19-5-1-基本概念和用法"><a href="#19-5-1-基本概念和用法" class="headerlink" title="19.5.1 基本概念和用法"></a>19.5.1 基本概念和用法</h4><p>线程本地变量是说，<strong>每个线程都有同一个变量的独有拷贝</strong>。这个概念听上去比较难以理解，我们先直接来看类TheadLocal的用法。ThreadLocal是一个泛型类，接受一个类型参数T，它只有一个空的构造方法，有两个主要的public方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>
<p>set就是设置值，get就是获取值，如果没有值，返回null，看上去，ThreadLocal就是一个单一对象的容器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    local.set(<span class="number">100</span>);</span><br><span class="line">    System.out.println(local.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为100。那ThreadLocal有什么特殊的呢？特殊发生在有多个线程的时候，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalBasic</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;child thread initial: &quot;</span> + local.get());</span><br><span class="line">                        local.set(<span class="number">200</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;child thread final: &quot;</span> + local.get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                local.set(<span class="number">100</span>);</span><br><span class="line">                child.start();</span><br><span class="line">                child.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread final: &quot;</span> + local.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>local是一个静态变量，main方法创建了一个子线程child, main和child都访问了local，程序的输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child thread initial: <span class="literal">null</span></span><br><span class="line">child thread <span class="keyword">final</span>: <span class="number">200</span></span><br><span class="line">main thread <span class="keyword">final</span>: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>这说明，main线程对local变量的设置对child线程不起作用，child线程对local变量的改变也不会影响main线程，<strong>它们访问的虽然是同一个变量local，但每个线程都有自己的独立的值，这就是线程本地变量的含义</strong>。</p>
<p>除了get/set, ThreadLocal还有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>initialValue用于提供初始值，这是一个受保护方法，可以通过匿名内部类的方式提供，当调用get方法时，如果之前没有设置过，会调用该方法获取初始值，默认实现是返回null。remove删掉当前线程对应的值，如果删掉后，再次调用get，会再调用initialValue获取初始值。看个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalInit</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(local.get());</span><br><span class="line">        local.set(<span class="number">200</span>);</span><br><span class="line">        local.remove();</span><br><span class="line">        System.out.println(local.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出值都是100。</p>
<h4 id="19-5-2-使用场景"><a href="#19-5-2-使用场景" class="headerlink" title="19.5.2 使用场景"></a>19.5.2 使用场景</h4><p>ThreadLocal有什么用呢？我们来看三个例子：日期处理、随机数和上下文信息。</p>
<h5 id="1．日期处理"><a href="#1．日期处理" class="headerlink" title="1．日期处理"></a>1．日期处理</h5><p>ThreadLocal是实现线程安全的一种方案，比如对于DateFormat/SimpleDateFormat，我们在介绍日期和时间操作的时候，提到它们是非线程安全的，实现安全的一种方式是使用锁，另一种方式是每次都创建一个新的对象，更好的方式就是使用ThreadLocal，每个线程使用自己的DateFormat，就不存在安全问题了，在线程的整个使用过程中，只需要创建一次，又避免了频繁创建的开销，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; sdf = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date2String</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">string2Date</span><span class="params">(String str)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.get().parse(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，ThreadLocal对象一般都定义为static，以便于引用。</p>
<h5 id="2．随机数"><a href="#2．随机数" class="headerlink" title="2．随机数"></a>2．随机数</h5><p>即使对象是线程安全的，使用ThreadLocal也可以减少竞争，比如，我们在介绍Random类的时候提到，Random是线程安全的，但如果并发访问竞争激烈的话，性能会下降，所以Java并发包提供了类ThreadLocalRandom，它是Random的子类，利用了ThreadLocal，它没有public的构造方法，通过静态方法current获取对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalRandom</span> <span class="variable">rnd</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line">    System.out.println(rnd.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>current方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title function_">current</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> localRandom.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>localRandom就是一个ThreadLocal变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> ThreadLocalRandom <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalRandom</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="3．上下文信息"><a href="#3．上下文信息" class="headerlink" title="3．上下文信息"></a>3．上下文信息</h5><p>ThreadLocal的典型用途是提供上下文信息，比如在一个Web服务器中，一个线程执行用户的请求，在执行过程中，很多代码都会访问一些共同的信息，比如请求信息、用户身份信息、数据库连接、当前事务等，它们是线程执行过程中的全局信息，如果作为参数在不同代码间传递，代码会很烦琐，这时，使用ThreadLocal就很方便，所以它被用于各种框架如Spring中。我们看个简单的示例，如代码清单19-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123; <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localUserId = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Request&gt; localRequest = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localUserId.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        localUserId.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title function_">getCurrentRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localRequest.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        localRequest.set(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在首次获取到信息时，调用set方法如setCurrentRequest/setCurrentUserId进行设置，然后就可以在代码的任意其他地方调用get相关方法进行获取了。</p>
<h4 id="19-5-3-基本实现原理"><a href="#19-5-3-基本实现原理" class="headerlink" title="19.5.3 基本实现原理"></a>19.5.3 基本实现原理</h4><p>ThreadLocal是怎么实现的呢？为什么对同一个对象的get/set，每个线程都能有自己独立的值呢？我们直接来看代码（基于Java 7）。set方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了getMap, getMap的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回线程的实例变量threadLocals，它的初始值为null，在null时，set调用createMap初始化，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出，每个线程都有一个Map，类型为ThreadLocalMap，调用set实际上是在线程自己的Map里设置了一个条目，键为当前的ThreadLocal对象，值为value。ThreadLocalMap是一个内部类，它是专门用于ThreadLocal的，与一般的Map不同，它的键类型为WeakReference<ThreadLocal>。我们没有提过WeakReference，它与Java的垃圾回收机制有关，使用它，便于回收内存，具体我们就不探讨了。</p>
<p>get方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(e ! = <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过线程访问到Map，以ThreadLocal对象为键从Map中获取到条目，取其value，如果Map中没有，则调用setInitialValue，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initialValue()就是之前提到的提供初始值的方法，默认实现就是返回null。</p>
<p>remove方法的代码也很直接，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span>(m ! = <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结下，<strong>每个线程都有一个Map，对于每个ThreadLocal对象，调用其get/set实际上就是以ThreadLocal对象为键读写当前线程的Map</strong>，这样，就实现了每个线程都有自己的独立副本的效果。</p>
<h1 id="第六部分-动态与函数式编程"><a href="#第六部分-动态与函数式编程" class="headerlink" title="第六部分 动态与函数式编程"></a>第六部分 动态与函数式编程</h1><h2 id="第21章-反射"><a href="#第21章-反射" class="headerlink" title="第21章 反射"></a>第21章 反射</h2><p>从本章开始，我们来探讨Java中的一些动态特性，包括反射、注解、动态代理、类加载器等。利用这些特性，可以优雅地实现一些灵活通用的功能，它们经常用于各种框架、库和系统程序中，比如：</p>
<p>1）14.5节介绍的Jackson，利用反射和注解实现了通用的序列化机制。</p>
<p>2）有多种库（如Spring MVC、Jersey）用于处理Web请求，利用反射和注解，能方便地将用户的请求参数和内容转换为Java对象，将Java对象转变为响应内容。3）有多种库（如Spring、Guice）利用这些特性实现了对象管理容器，方便程序员管理对象的生命周期以及其中复杂的依赖关系。</p>
<p>4）应用服务器（如Tomcat）利用类加载器实现不同应用之间的隔离，JSP技术利用类加载器实现修改代码不用重启就能生效的特性。</p>
<p>5）面向方面的编程AOP（Aspect Oriented Programming）将编程中通用的关注点（如日志记录、安全检查等）与业务的主体逻辑相分离，减少冗余代码，提高程序的可维护性， AOP需要依赖上面的这些特性来实现。</p>
<p>本章主要介绍反射机制，后续章节介绍其他内容。</p>
<p>在一般操作数据的时候，我们都是知道并且依赖于数据类型的，比如：</p>
<p>1）根据类型使用new创建对象。</p>
<p>2）根据类型定义变量，类型可能是基本类型、类、接口或数组。</p>
<p>3）将特定类型的对象传递给方法。</p>
<p>4）根据类型访问对象的属性，调用对象的方法。</p>
<p>编译器也是根据类型进行代码的检查编译的。</p>
<p>反射不一样，它是<strong>在运行时，而非编译时</strong>，动态获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等。这么说比较抽象，下面我们会具体说明。<strong>反射的入口是名称为Class的类</strong>，我们先介绍Class类，随后举例说明反射的应用，接着讨论反射与泛型，最后进行总结。</p>
<h3 id="21-1-Class类"><a href="#21-1-Class类" class="headerlink" title="21.1 Class类"></a>21.1 Class类</h3><p>在介绍类和继承的实现原理时，我们提到，每个已加载的类在内存都有一份类信息，每个对象都有指向它所属类信息的引用。Java中，类信息对应的类就是java.lang.Class。注意不是小写的class, class是定义类的关键字。所有类的根父类Object有一个方法，可以获取对象的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;? &gt; getClass()</span><br></pre></td></tr></table></figure>
<p>Class是一个泛型类，有一个类型参数，getClass()并不知道具体的类型，所以返回Class&lt;?&gt;。</p>
<p>获取Class对象不一定需要实例对象，如果在写程序时就知道类名，可以使用&lt;类名&gt;.class获取Class对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Date&gt; cls = Date.class;</span><br></pre></td></tr></table></figure>
<p>接口也有Class对象，且这种方式对于接口也是适用的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Comparable&gt; cls = Comparable.class;</span><br></pre></td></tr></table></figure>
<p>基本类型没有getClass方法，但也都有对应的Class对象，类型参数为对应的包装类型，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; intCls = <span class="type">int</span>.class;</span><br><span class="line">Class&lt;Byte&gt; byteCls = <span class="type">byte</span>.class;</span><br><span class="line">Class&lt;Character&gt; charCls = <span class="type">char</span>.class;</span><br><span class="line">Class&lt;Double&gt; doubleCls = <span class="type">double</span>.class;</span><br></pre></td></tr></table></figure>
<p>void作为特殊的返回类型，也有对应的Class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Void&gt; voidCls = <span class="keyword">void</span>.class;</span><br></pre></td></tr></table></figure>
<p>对于数组，每种类型都有对应数组类型的Class对象，每个维度都有一个，即一维数组有一个，二维数组有一个不同的类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[][] twoDimArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span>[] oneDimArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>[]&gt; strArrCls = strArr.getClass();</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[][]&gt; twoDimArrCls = twoDimArr.getClass();</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; oneDimArrCls = oneDimArr.getClass();</span><br></pre></td></tr></table></figure>
<p>枚举类型也有对应的Class，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;Size&gt; cls = Size.class;</span><br></pre></td></tr></table></figure>
<p>Class有一个静态方法forName，可以根据类名直接加载Class，获取Class对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;? &gt; cls = Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>);</span><br><span class="line">    System.out.println(cls.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意forName可能抛出异常ClassNotFoundException。</p>
<p>有了Class对象后，我们就可以了解到关于类型的很多信息，并基于这些信息采取一些行动。Class的方法很多，大部分比较简单直接，容易理解，下面，我们分为若干组，包括名称信息、字段信息、方法信息、创建对象和构造方法、类型信息等，进行简要介绍。</p>
<h4 id="1．名称信息"><a href="#1．名称信息" class="headerlink" title="1．名称信息"></a>1．名称信息</h4><p>Class有如下方法，可以获取与名称有关的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSimpleName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getCanonicalName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Package <span class="title function_">getPackage</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>getSimpleName返回的名称不带包信息，getName返回的是Java内部使用的真正的名称，getCanonicalName返回的名称更为友好，getPackage返回的是包信息，它们的不同如表格21-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310082112096.png" alt="image-20231008211227859"></p>
<p>需要说明的是数组类型的getName返回值，它使用前缀[表示数组，有几个[表示是几维数组；数组的类型用一个字符表示，I表示int, L表示类或接口，其他类型与字符的对应关系为：boolean(Z)、byte(B)、char(C)、double(D)、float(F)、long(J)、short(S)。对于引用类型的数组，注意最后有一个分号；。</p>
<h4 id="2．字段信息"><a href="#2．字段信息" class="headerlink" title="2．字段信息"></a>2．字段信息</h4><p>类中定义的静态和实例变量都被称为字段，用类Field表示，位于包java.lang.reflect下，后文涉及的反射相关的类都位于该包下。Class有4个获取字段信息的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回所有的public字段，包括其父类的，如果没有字段，返回空数组</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br><span class="line"><span class="comment">//返回本类声明的所有字段，包括非public的，但不包括父类的</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br><span class="line"><span class="comment">//返回本类或父类中指定名称的public字段，找不到抛出异常NoSuchFieldException</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String name)</span></span><br><span class="line"><span class="comment">//返回本类中声明的指定名称的字段，找不到抛出异常NoSuchFieldException</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>
<p>Field也有很多方法，可以获取字段的信息，也可以通过Field访问和操作指定对象中该字段的值，基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字段的名称</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"><span class="comment">//判断当前程序是否有该字段的访问权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccessible</span><span class="params">()</span></span><br><span class="line"><span class="comment">//flag设为true表示忽略Java的访问检查机制，以允许读写非public的字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span></span><br><span class="line"><span class="comment">//获取指定对象obj中该字段的值</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">//将指定对象obj中该字段的值设为value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj, Object value)</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/">https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot从入门到实战</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript高级程序设计（第三版）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div><div><a href="/2022/11/10/SpringMVC%E5%9F%BA%E7%A1%80/" title="SpringMVC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">SpringMVC基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">第二部分 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">第3章 类的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1 类的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%87%BD%E6%95%B0%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">3.1.1 函数容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">3.1.2 自定义数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">1．类变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">2．实例变量和实例方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%AE%9A%E4%B9%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3.1.3 定义第一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">3.1.4 使用第一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">3.1.5 变量默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-private%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">3.1.6 private变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">3.1.7 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.7.1.</span> <span class="toc-text">1．默认构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.7.2.</span> <span class="toc-text">2．私有构造方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">3.1.8 类和对象的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.2 类的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-String%E5%92%8CDate"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">3.2.1 String和Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%9B%BE%E5%BD%A2%E7%B1%BB"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">3.2.2 图形类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E7%94%A8%E7%B1%BB%E6%8F%8F%E8%BF%B0%E7%94%B5%E5%95%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3.2.3 用类描述电商概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E7%94%A8%E7%B1%BB%E6%8F%8F%E8%BF%B0%E4%BA%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">3.2.4 用类描述人之间的血缘关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">3.2.5 目录和文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">3.2.6 一些说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%84%E7%BB%87%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.3 代码的组织机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.3.1 包的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%A3%B0%E6%98%8E%E7%B1%BB%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%85"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">1．声明类所在的包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%80%9A%E8%BF%87%E5%8C%85%E4%BD%BF%E7%94%A8%E7%B1%BB"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">2．通过包使用类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E5%8C%85%E8%8C%83%E5%9B%B4%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">3．包范围可见性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-jar%E5%8C%85"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.3.2 jar包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3.3 程序的编译与链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.</span> <span class="toc-text">第4章 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%A0%B9%E7%88%B6%E7%B1%BBObject"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">4.1.1 根父类Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">4.1.2 方法重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E5%9B%BE%E5%BD%A2%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">4.1.3 图形类继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9B%BE%E5%BD%A2"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">1．图形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9C%86"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">2．圆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E7%9B%B4%E7%BA%BF"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">3．直线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E5%B8%A6%E7%AE%AD%E5%A4%B4%E7%9B%B4%E7%BA%BF"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">4．带箭头直线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.2.1.3.5.</span> <span class="toc-text">5．图形管理器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2 继承的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">4.2.1 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E9%87%8D%E5%90%8D%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">4.2.2 重名与静态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">4.2.3 重载和重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E7%88%B6%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.2.4 父子类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90protected"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">4.2.5 继承访问权限protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E5%8F%AF%E8%A7%81%E6%80%A7%E9%87%8D%E5%86%99"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">4.2.6 可见性重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-%E9%98%B2%E6%AD%A2%E7%BB%A7%E6%89%BFfinal"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">4.2.7 防止继承final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">4.3 继承实现的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">4.3.1 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">4.3.2 类加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">4.3.3 对象创建的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4.3.4 方法调用的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">4.3.5 变量访问的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%BB%A7%E6%89%BF%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.4 为什么说继承是把双刃剑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%BB%A7%E6%89%BF%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.4.1 继承破坏封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E5%B0%81%E8%A3%85%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">4.4.2 封装是如何被破坏的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E7%BB%A7%E6%89%BF%E6%B2%A1%E6%9C%89%E5%8F%8D%E6%98%A0is-a%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">4.4.3 继承没有反映is-a关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%80%A7"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.4.4 如何应对继承的双面性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E4%BD%BF%E7%94%A8final%E9%81%BF%E5%85%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">1．使用final避免继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">2．优先使用组合而非继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.4.4.3.</span> <span class="toc-text">3．正确使用继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text">第5章 类的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">5.3 内部类的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">5.3.1 静态内部类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">第三部分 泛型与容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">第8章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">8.1 基本概念和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">8.1.1 一个简单泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text">1．基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text">2．基本原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.1.1.1.3.</span> <span class="toc-text">3．泛型的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">8.1.2 容器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">8.1.3 泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">8.1.4 泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%99%90%E5%AE%9A"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">8.1.5 类型参数的限定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E4%B8%8A%E7%95%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="toc-number">2.1.1.5.1.</span> <span class="toc-text">1．上界为某个具体类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%B8%8A%E7%95%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.1.5.2.</span> <span class="toc-text">2．上界为某个接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E4%B8%8A%E7%95%8C%E4%B8%BA%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.1.5.3.</span> <span class="toc-text">3．上界为其他类型参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E8%A7%A3%E6%9E%90%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.1.2.</span> <span class="toc-text">8.2 解析通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">8.2.1 更简洁的参数类型限定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E7%90%86%E8%A7%A3%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">8.2.2 理解通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E8%B6%85%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">8.2.3 超类型通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">8.2.4 通配符比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%BB%86%E8%8A%82%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">8.3 细节和局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">8.3.1 使用泛型类、方法和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">8.3.2 定义泛型类、方法和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">8.3.3 泛型与数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">第9章 列表和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E5%88%A8%E6%9E%90ArrayList"><span class="toc-number">2.2.1.</span> <span class="toc-text">9.1刨析ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">9.1.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">9.1.2 基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">9.1.3 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text">1．迭代器接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ListIterator"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text">2. ListIterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E8%BF%AD%E4%BB%A3%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">2.2.1.3.3.</span> <span class="toc-text">3．迭代的陷阱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.3.4.</span> <span class="toc-text">4．迭代器实现的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.2.1.3.5.</span> <span class="toc-text">5．迭代器的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-ArrayList%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">9.1.4 ArrayList实现的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Collection"><span class="toc-number">2.2.1.4.1.</span> <span class="toc-text">1. Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-List"><span class="toc-number">2.2.1.4.2.</span> <span class="toc-text">2. List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-RandomAccess"><span class="toc-number">2.2.1.4.3.</span> <span class="toc-text">3. RandomAccess</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%89%96%E6%9E%90LinkedList"><span class="toc-number">2.2.2.</span> <span class="toc-text">9.2 剖析LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">9.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">9.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%89%96%E6%9E%90ArrayDeque"><span class="toc-number">2.2.3.</span> <span class="toc-text">9.3 剖析ArrayDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">9.3.1 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text">1．循环数组</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-Map%E5%92%8CSet"><span class="toc-number">2.3.</span> <span class="toc-text">第10章 Map和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%89%96%E6%9E%90HashMap"><span class="toc-number">2.3.1.</span> <span class="toc-text">10.1 剖析HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">10.1.1 Map接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-HashMap"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">10.1.2 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">10.1.3 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="toc-number">2.3.1.3.1.</span> <span class="toc-text">1．内部组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.3.2.</span> <span class="toc-text">2．默认构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.1.3.3.</span> <span class="toc-text">6．实现原理小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%89%96%E6%9E%90HashSet"><span class="toc-number">2.3.2.</span> <span class="toc-text">10.2 剖析HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">10.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">10.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">10.3 排序二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">10.3.3 平衡的排序二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%89%96%E6%9E%90TreeMap"><span class="toc-number">2.3.4.</span> <span class="toc-text">10.4 剖析TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">10.4.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">10.4.2 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-1"><span class="toc-number">2.3.4.2.1.</span> <span class="toc-text">1．内部组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%89%96%E6%9E%90TreeSet"><span class="toc-number">2.3.5.</span> <span class="toc-text">10.5 剖析TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">10.5.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">10.5.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E5%89%96%E6%9E%90LinkedHashMap"><span class="toc-number">2.3.6.</span> <span class="toc-text">10.6 剖析LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">10.6.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">10.6.2 实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-3-LinkedHashSet"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">10.6.3 LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E5%89%96%E6%9E%90EnumMap"><span class="toc-number">2.3.7.</span> <span class="toc-text">10.7 剖析EnumMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-%E5%89%96%E6%9E%90EnumSet"><span class="toc-number">2.3.8.</span> <span class="toc-text">10.8 剖析EnumSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.8.1.</span> <span class="toc-text">10.8.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.8.2.</span> <span class="toc-text">10.8.2 应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">第11章 堆与优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">11.1 堆的概念与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">11.1.1 基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%89%96%E6%9E%90PriorityQueue"><span class="toc-number">2.4.2.</span> <span class="toc-text">11.2 剖析PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">第12章 通用容器类和总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%8A%BD%E8%B1%A1%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">2.5.1.</span> <span class="toc-text">12.1 抽象容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Collections"><span class="toc-number">2.5.2.</span> <span class="toc-text">12.2 Collections</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">第四部分 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.</span> <span class="toc-text">第13章 文件基本技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">第五部分 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">第15章 并发基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">15.1 线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">15.1.1 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%BB%A7%E6%89%BFThread"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text">1．继承Thread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.1.1.2.</span> <span class="toc-text">2．实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">15.1.2 线程的基本属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-id%E5%92%8Cname"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">1. id和name</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">2．优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text">3．状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E6%98%AF%E5%90%A6daemon%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.2.4.</span> <span class="toc-text">4．是否daemon线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.5.</span> <span class="toc-text">5. sleep方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-yield%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.6.</span> <span class="toc-text">6. yield方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-join%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.7.</span> <span class="toc-text">7. join方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%8E%E8%BF%87%E6%97%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.8.</span> <span class="toc-text">8．过时方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8F%8A%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">15.1.3 共享内存及可能存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.1.1.3.1.</span> <span class="toc-text">1．竞态条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.1.1.3.2.</span> <span class="toc-text">2．内存可见性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E6%88%90%E6%9C%AC"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">15.1.4 线程的优点及成本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E7%90%86%E8%A7%A3synchronized"><span class="toc-number">4.1.2.</span> <span class="toc-text">15.2 理解synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-1-%E7%94%A8%E6%B3%95%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">15.2.1 用法和基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.1.1.</span> <span class="toc-text">1．实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.1.2.</span> <span class="toc-text">2．静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.1.2.1.3.</span> <span class="toc-text">3．代码块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3synchronized"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">15.2.2 进一步理解synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">1．可重入性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7-1"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">2．内存可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%AD%BB%E9%94%81"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">3．死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-3-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">15.2.3 同步容器及其注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.3.1.</span> <span class="toc-text">1．复合操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%AA%E5%90%8C%E6%AD%A5"><span class="toc-number">4.1.2.3.2.</span> <span class="toc-text">2．伪同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.1.2.3.3.</span> <span class="toc-text">3．迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.2.3.4.</span> <span class="toc-text">4．并发容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6-%EF%BC%88%E7%9C%8B%E5%88%B0%E8%BF%99%E9%87%8C%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">15.3 线程的基本协作机制  （看到这里）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-1-%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">15.3.1 协作的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-2-wait-notify"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">15.3.2 wait&#x2F;notify</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">4.1.4.</span> <span class="toc-text">15.4 线程的中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-1-%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">15.4.1 取消&#x2F;关闭的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-2-%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">15.4.2 取消&#x2F;关闭的机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-3-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8F%8D%E5%BA%94"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">15.4.3 线程对中断的反应</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RUNNABLE"><span class="toc-number">4.1.4.3.1.</span> <span class="toc-text">1. RUNNABLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-WAITING-TIMED-WAITING"><span class="toc-number">4.1.4.3.2.</span> <span class="toc-text">2. WAITING&#x2F;TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-BLOCKED"><span class="toc-number">4.1.4.3.3.</span> <span class="toc-text">3. BLOCKED</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-NEW-TERMINATE"><span class="toc-number">4.1.4.3.4.</span> <span class="toc-text">4. NEW&#x2F;TERMINATE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.4.4.</span> <span class="toc-text">15.4.4 如何正确地取消&#x2F;关闭线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">4.2.</span> <span class="toc-text">第16章 并发包的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E5%92%8CCAS"><span class="toc-number">4.2.1.</span> <span class="toc-text">16.1 原子变量和CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-1-AtomicInteger"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">16.1.1 AtomicInteger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">1．基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E6%80%9D%E7%BB%B4"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">2．基本原理和思维</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E5%AE%9E%E7%8E%B0%E9%94%81"><span class="toc-number">4.2.1.1.3.</span> <span class="toc-text">3．实现锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-2-ABA%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">16.1.2 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">16.2 显式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1-%E6%8E%A5%E5%8F%A3Lock"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">16.2.1 接口Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">16.2.2 可重入锁ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">1．基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BD%BF%E7%94%A8tryLock%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.2.2.2.2.</span> <span class="toc-text">2．使用tryLock避免死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">16.2.3 ReentrantLock的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-LockSupport"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">1. LockSupport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AQS"><span class="toc-number">4.2.2.3.2.</span> <span class="toc-text">2. AQS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ReentrantLock"><span class="toc-number">4.2.2.3.3.</span> <span class="toc-text">3. ReentrantLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-4-%E5%AF%B9%E6%AF%94ReentrantLock%E5%92%8Csynchronized"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">16.2.4 对比ReentrantLock和synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E6%98%BE%E5%BC%8F%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text">16.3 显式条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1-%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">16.3.1 用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">第17章 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84List%E5%92%8CSet"><span class="toc-number">4.3.1.</span> <span class="toc-text">17.1 写时复制的List和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-1-CopyOnWriteArrayList"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">17.1.1 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-2-CopyOnWriteArraySet"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">17.1.2 CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-ConcurrentHashMap"><span class="toc-number">4.3.2.</span> <span class="toc-text">17.2 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-1-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">17.2.1 并发安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-2-%E5%8E%9F%E5%AD%90%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">17.2.2 原子复合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-3-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">17.2.3 高并发的基本机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-4-%E8%BF%AD%E4%BB%A3%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">17.2.4 迭代安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-5-%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">17.2.5 弱一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84Map%E5%92%8CSet"><span class="toc-number">4.3.3.</span> <span class="toc-text">17.3 基于跳表的Map和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">17.3.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-2-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">17.3.2 基本实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.</span> <span class="toc-text">17.4 并发队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-%E6%97%A0%E9%94%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">17.4.1 无锁非阻塞并发队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-2-%E6%99%AE%E9%80%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">17.4.2 普通阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-3-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">17.4.3 优先级阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-4-%E5%BB%B6%E6%97%B6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">17.4.4 延时阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-5-%E5%85%B6%E4%BB%96%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">17.4.5 其他阻塞队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.4.</span> <span class="toc-text">第18章 异步任务执行服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">18.1 基本概念和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-1-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">18.1.1 基本接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">18.1.2 基本用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">第19章 同步和协作工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock"><span class="toc-number">4.5.1.</span> <span class="toc-text">19.1 读写锁ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore"><span class="toc-number">4.5.2.</span> <span class="toc-text">19.2 信号量Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E6%A0%93CountDownLatch"><span class="toc-number">4.5.3.</span> <span class="toc-text">19.3 倒计时门栓CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8FCyclicBarrier"><span class="toc-number">4.5.4.</span> <span class="toc-text">19.4 循环栅栏CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-%E7%90%86%E8%A7%A3ThreadLocal"><span class="toc-number">4.5.5.</span> <span class="toc-text">19.5 理解ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">19.5.1 基本概念和用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">19.5.2 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">4.5.5.2.1.</span> <span class="toc-text">1．日期处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">4.5.5.2.2.</span> <span class="toc-text">2．随机数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="toc-number">4.5.5.2.3.</span> <span class="toc-text">3．上下文信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-3-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">19.5.3 基本实现原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第六部分 动态与函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%8F%8D%E5%B0%84"><span class="toc-number">5.1.</span> <span class="toc-text">第21章 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-Class%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">21.1 Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1．名称信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">2．字段信息</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/02/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%BF%83%E5%BE%97/" title="华为云服务器部署心得"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为云服务器部署心得"/></a><div class="content"><a class="title" href="/2023/11/02/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%BF%83%E5%BE%97/" title="华为云服务器部署心得">华为云服务器部署心得</a><time datetime="2023-11-02T15:56:36.000Z" title="发表于 2023-11-02 23:56:36">2023-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/" title="超级搜索技术"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超级搜索技术"/></a><div class="content"><a class="title" href="/2023/10/29/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/" title="超级搜索技术">超级搜索技术</a><time datetime="2023-10-29T15:50:10.000Z" title="发表于 2023-10-29 23:50:10">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/28/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" title="每天5分钟玩转Docker容器技术"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="每天5分钟玩转Docker容器技术"/></a><div class="content"><a class="title" href="/2023/10/28/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" title="每天5分钟玩转Docker容器技术">每天5分钟玩转Docker容器技术</a><time datetime="2023-10-28T05:38:35.000Z" title="发表于 2023-10-28 13:38:35">2023-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/27/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%9A%84%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/" title="基于数据科学的恶意软件分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于数据科学的恶意软件分析"/></a><div class="content"><a class="title" href="/2023/10/27/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%9A%84%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/" title="基于数据科学的恶意软件分析">基于数据科学的恶意软件分析</a><time datetime="2023-10-27T09:01:58.000Z" title="发表于 2023-10-27 17:01:58">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/27/A-review-of-research-on-malicious-code-visual-detection-technology/" title="A review of research on malicious code visual detection technology"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A review of research on malicious code visual detection technology"/></a><div class="content"><a class="title" href="/2023/10/27/A-review-of-research-on-malicious-code-visual-detection-technology/" title="A review of research on malicious code visual detection technology">A review of research on malicious code visual detection technology</a><time datetime="2023-10-27T00:43:59.000Z" title="发表于 2023-10-27 08:43:59">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>