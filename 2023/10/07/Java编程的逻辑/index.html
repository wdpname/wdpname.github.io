<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java编程的逻辑 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第二部分 面向对象第5章 类的扩展5.3 内部类的本质5.3.1 静态内部类静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。 第三部分 泛型与容器第9章 列表和队列9.1刨析ArrayList9.1.1 基本用法12ArrayList&lt;Integer&gt; i">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程的逻辑">
<meta property="og:url" content="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第二部分 面向对象第5章 类的扩展5.3 内部类的本质5.3.1 静态内部类静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。 第三部分 泛型与容器第9章 列表和队列9.1刨析ArrayList9.1.1 基本用法12ArrayList&lt;Integer&gt; i">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-07T08:55:18.000Z">
<meta property="article:modified_time" content="2023-10-09T07:05:40.029Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java编程的逻辑',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-09 15:05:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java编程的逻辑</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T07:05:40.029Z" title="更新于 2023-10-09 15:05:40">2023-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java编程的逻辑"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第二部分-面向对象"><a href="#第二部分-面向对象" class="headerlink" title="第二部分 面向对象"></a>第二部分 面向对象</h1><h2 id="第5章-类的扩展"><a href="#第5章-类的扩展" class="headerlink" title="第5章 类的扩展"></a>第5章 类的扩展</h2><h3 id="5-3-内部类的本质"><a href="#5-3-内部类的本质" class="headerlink" title="5.3 内部类的本质"></a>5.3 内部类的本质</h3><h4 id="5-3-1-静态内部类"><a href="#5-3-1-静态内部类" class="headerlink" title="5.3.1 静态内部类"></a>5.3.1 静态内部类</h4><p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<h1 id="第三部分-泛型与容器"><a href="#第三部分-泛型与容器" class="headerlink" title="第三部分 泛型与容器"></a>第三部分 泛型与容器</h1><h2 id="第9章-列表和队列"><a href="#第9章-列表和队列" class="headerlink" title="第9章 列表和队列"></a>第9章 列表和队列</h2><h3 id="9-1刨析ArrayList"><a href="#9-1刨析ArrayList" class="headerlink" title="9.1刨析ArrayList"></a>9.1刨析ArrayList</h3><h4 id="9-1-1-基本用法"><a href="#9-1-1-基本用法" class="headerlink" title="9.1.1 基本用法"></a>9.1.1 基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-基本原理"><a href="#9-1-2-基本原理" class="headerlink" title="9.1.2 基本原理"></a>9.1.2 基本原理</h4><p>内部有一个数组elementData，一般会有一些预留的空间，有一个整数size记录实际的元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p>各种public方法内部操作的基本都是这个数组和这个整数，elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数。</p>
<p><strong>默认</strong>容量：DEFAULT_CAPACITY的值为10</p>
<p><strong>增容</strong>：newCapacity相当于oldCapacity的1.5倍，如果扩展1.5倍还是小于minCapacity，就扩展为minCapacity  </p>
<h4 id="9-1-3-迭代"><a href="#9-1-3-迭代" class="headerlink" title="9.1.3 迭代"></a>9.1.3 迭代</h4><p>ArrayList支持foreach语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line">intList.add(<span class="number">456</span>);</span><br><span class="line">intList.add(<span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer a : intList)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当然，这种循环也可以使用如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;intList.size(); i++)&#123;</span><br><span class="line">    System.out.println(intList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，foreach看上去更为简洁，而且它适用于各种容器，更为通用。</p>
<p>这种foreach语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = intList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1．迭代器接口"><a href="#1．迭代器接口" class="headerlink" title="1．迭代器接口"></a>1．迭代器接口</h5><p>ArrayList实现了Iterable接口，Iterable表示可迭代，Java 7中的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义很简单，就是要求实现iterator方法。iterator方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>它返回一个实现了Iterator接口的对象，Java 7中Iterator接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要对象实现了Iterable接口，就可以使用foreach语法，编译器会转换为调用Iterable和Iterator接口的方法。初次见到<strong>Iterable</strong>和<strong>Iterator</strong>，可能会比较容易混淆，我们再澄清一下：</p>
<p>❑ Iterable表示对象可以被迭代，它有一个方法iterator()，返回Iterator对象，实际通过Iterator接口的方法进行遍历；</p>
<p>❑ 如果对象实现了Iterable，就可以使用foreach语法；</p>
<p>❑ 类可以不实现Iterable，也可以创建Iterator对象。</p>
<h5 id="2-ListIterator"><a href="#2-ListIterator" class="headerlink" title="2. ListIterator"></a>2. ListIterator</h5><p>除了iterator(), ArrayList还提供了两个返回Iterator接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<h5 id="3．迭代的陷阱"><a href="#3．迭代的陷阱" class="headerlink" title="3．迭代的陷阱"></a>3．迭代的陷阱</h5><p>关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。比如，要删除一个整数ArrayList中所有小于100的数，直觉上，代码可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer a : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            list.remove(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但运行时会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>发生了并发修改异常，为什么呢？因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p>
<p>如何避免异常呢？可以使用迭代器的remove方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.next()&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器如何知道发生了结构性变化，并抛出异常？它自己的remove方法为何又可以使用呢？我们需要看下迭代器实现的原理。</p>
<h5 id="4．迭代器实现的原理"><a href="#4．迭代器实现的原理" class="headerlink" title="4．迭代器实现的原理"></a>4．迭代器实现的原理</h5><p>我们来看下ArrayList中iterator方法的实现，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了一个Itr对象，Itr是一个成员内部类，实现了Iterator接口，声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>它有三个实例成员变量，为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;        <span class="comment">//下一个要返回的元素位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//最后一个返回的索引位置，如果没有，为-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>
<p>cursor表示下一个要返回的元素位置，lastRet表示最后一个返回的索引位置，expected-ModCount表示期望的修改次数，初始化为外部类当前的修改次数modCount，回顾一下，成员内部类可以直接访问外部类的实例变量。每次发生结构性变化的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。</p>
<h5 id="5．迭代器的好处"><a href="#5．迭代器的好处" class="headerlink" title="5．迭代器的好处"></a>5．迭代器的好处</h5><p>​    为什么要通过迭代器这种方式访问元素呢？直接使用size()/get(index)语法不也可以吗？在一些场景下，确实没有什么差别，两者都可以。不过，foreach语法更为简洁一些，更重要的是，迭代器语法更为通用，它适用于各种容器类。此外，迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供Iterator接口的代码了解数据的组织方式，可以提供高效的实现。在ArrayList中， size/get(index)语法与迭代器性能是差不多的，但在后续介绍的其他容器中，则不一定，比如LinkedList，迭代器性能就要高很多。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口</p>
<h4 id="9-1-4-ArrayList实现的接口"><a href="#9-1-4-ArrayList实现的接口" class="headerlink" title="9.1.4 ArrayList实现的接口"></a>9.1.4 ArrayList实现的接口</h4><h5 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h5><p>Collection表示一个数据集合，数据间没有位置或顺序的概念</p>
<h5 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h5><p>List表示有顺序或位置的数据集合，它扩展了Collection</p>
<h5 id="3-RandomAccess"><a href="#3-RandomAccess" class="headerlink" title="3. RandomAccess"></a>3. RandomAccess</h5><p>RandomAccess的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有定义任何代码。这有什么用呢？这种没有任何代码的接口在Java中被称为<strong>标记接口</strong>，用于声明类的一种属性。</p>
<p>这里，实现了RandomAccess接口的类表示可以<strong>随机访问</strong>，可随机访问就是具备类似<strong>数组</strong>那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。下节我们会介绍LinkedList，它就不能随机访问</p>
<h3 id="9-2-剖析LinkedList"><a href="#9-2-剖析LinkedList" class="headerlink" title="9.2 剖析LinkedList"></a>9.2 剖析LinkedList</h3><h4 id="9-2-1-用法"><a href="#9-2-1-用法" class="headerlink" title="9.2.1 用法"></a>9.2.1 用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>Java中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口Deque中</p>
<p>Java中有一个类Stack，单词意思是栈，它也实现了栈的一些方法，如push/pop/peek等，但它没有实现Deque接口，它是Vector的子类(所以不推荐使用，推荐使用Deque)，它增加的这些方法也通过synchronized实现了线程安全，具体就不介绍了。不需要线程安全的情况下，推荐使用LinkedList或下节介绍的ArrayDeque</p>
<p>简单总结下：LinkedList的用法是比较简单的，与ArrayList用法类似，支持List接口，只是，LinkedList增加了一个接口Deque，可以把它看作队列、栈、双端队列，方便地在两端进行操作。如果只是用作List，那应该用ArrayList还是LinkedList呢？我们需要了解LinkedList的实现原理。</p>
<h4 id="9-2-2-实现原理"><a href="#9-2-2-实现原理" class="headerlink" title="9.2.2 实现原理"></a>9.2.2 实现原理</h4><p>​    我们知道，ArrayList内部是数组，元素在内存是连续存放的，但LinkedList不是。LinkedList直译就是链表，确切地说，它的内部实现是<strong>双向链表</strong>，每个元素在内存都是单独存放的，元素之间通过链接连在一起，类似于小朋友之间手拉手一样。</p>
<p>​    为了表示链接关系，需要一个节点的概念。节点包括实际的元素，但同时有两个链接，分别指向前一个节点（前驱）和后一个节点（后继）。节点是一个内部类，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedList内部组成就是如下三个实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-剖析ArrayDeque"><a href="#9-3-剖析ArrayDeque" class="headerlink" title="9.3 剖析ArrayDeque"></a>9.3 剖析ArrayDeque</h3><p>LinkedList实现了队列接口Queue和双端队列接口Deque, Java容器类中还有一个双端队列的实现类ArrayDeque，它是基于数组实现的。我们知道，一般而言，由于需要移动元素，数组的插入和删除效率比较低，但ArrayDeque的效率却非常高，它是怎么实现的呢？本节就来详细探讨。</p>
<p>ArrayDeque有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>numElements表示元素个数，初始分配的空间会至少容纳这么多元素，但空间不是正好numElements这么大，待会我们会介绍其实现细节。</p>
<p>ArrayDeque实现了Deque接口，同LinkedList一样，它的队列长度也是没有限制的， Deque扩展了Queue，有队列的所有方法，还可以看作栈，有栈的基本方法push/pop/peek，还有明确的操作两端的方法如addFirst/removeLast等，具体用法与LinkedList一节介绍的类似，就不赘述了，下面看其实现原理（基于Java 7）。</p>
<h4 id="9-3-1-实现原理"><a href="#9-3-1-实现原理" class="headerlink" title="9.3.1 实现原理"></a>9.3.1 实现原理</h4><p>ArrayDeque内部主要有如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>elements就是存储元素的数组。ArrayDeque的高效来源于head和tail这两个变量，它们使得物理上简单的从头到尾的数组变为了一个逻辑上循环的数组，避免了在头尾操作时的移动。我们来解释下循环数组的概念。</p>
<h5 id="1．循环数组"><a href="#1．循环数组" class="headerlink" title="1．循环数组"></a>1．循环数组</h5><p>对于一般数组，比如arr，第一个元素为arr[0]，最后一个为arr[arr.length-1]。但对于ArrayDeque中的数组，它是一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始，数组的长度、第一个和最后一个元素都与head和tail这两个变量有关，具体来说：</p>
<p>1）如果head和tail相同，则数组为空，长度为0。</p>
<p>2）如果tail大于head，则第一个元素为elements[head]，最后一个为elements[tail-1]，长度为tail-head，元素索引从head到tail-1。</p>
<p>3）如果tail小于head，且为0，则第一个元素为elements[head]，最后一个为elements [elements.length-1]，元素索引从head到elements.length-1。</p>
<p>4）如果tail小于head，且大于0，则会形成循环，第一个元素为elements[head]，最后一个是elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1。</p>
<h2 id="第10章-Map和Set"><a href="#第10章-Map和Set" class="headerlink" title="第10章 Map和Set"></a>第10章 Map和Set</h2><h3 id="10-1-剖析HashMap"><a href="#10-1-剖析HashMap" class="headerlink" title="10.1 剖析HashMap"></a>10.1 剖析HashMap</h3><p>​    字面上看，HashMap由Hash和Map两个单词组成，这里Map不是地图的意思，而是表示映射关系，是一个接口，实现Map接口有多种方式，HashMap实现的方式利用了哈希（Hash）。下面先来看Map接口，接着看HashMap的用法，然后看实现原理，最后总结分析HashMap的特点。</p>
<h4 id="10-1-1-Map接口"><a href="#10-1-1-Map接口" class="headerlink" title="10.1.1 Map接口"></a>10.1.1 Map接口</h4><p>​    Map有键和值的概念。一个键映射到一个值，Map按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用Map可以方便地处理需要根据键访问对象的场景。</p>
<p>Map中的键是没有重复的，所以ketSet()返回了一个Set。keySet()、values()、entrySet()有一个共同的特点，它们返回的都是视图，不是复制的值，基于返回值的修改会直接修改Map自身，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.keySet().clear();</span><br></pre></td></tr></table></figure>
<p>会删除所有键值对。</p>
<p>​    Set是一个接口，表示的是数学中的集合概念，即没有重复的元素集合.它扩展了Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保Set的语义约束，即不能有重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-2-HashMap"><a href="#10-1-2-HashMap" class="headerlink" title="10.1.2 HashMap"></a>10.1.2 HashMap</h4><p>HashMap还有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>最后一个以一个已有的Map构造，复制其中的所有键值对到当前Map。前两个涉及参数initialCapacity和loadFactor，它们是什么意思呢？我们需要看下HashMap的实现原理。</p>
<h4 id="10-1-3-实现原理"><a href="#10-1-3-实现原理" class="headerlink" title="10.1.3 实现原理"></a>10.1.3 实现原理</h4><h5 id="1．内部组成"><a href="#1．内部组成" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>HashMap内部有如下几个主要的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K, V&gt;[] table = (Entry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>size表示实际键值对的个数。table是一个Entry类型的数组，称为哈希表或哈希桶，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对。Entry是一个内部类，它的实例变量和构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K, V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，key和value分别表示键和值，next指向下一个Entry节点，hash是key的hash值，待会我们会介绍其计算方法。直接存储hash值是为了在比较的时候加快计算，待会我们看代码。</p>
<p>table的初始值为EMPTY_TABLE，是一个空表，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;? , ? &gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>当添加键值对后，table就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于ArrayList。添加第一个元素时，默认分配的大小为<strong>16</strong>，不过，并不是size大于16时再进行扩展，下次什么时候扩展与threshold有关。</p>
<p>threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。threshold是怎么算出来的呢？一般而言，threshold等于table.length乘以loadFactor。比如，如果table. length为16, loadFactor为0.75，则threshold为12。loadFactor是负载因子，表示整体上table被占用的程度，是一个浮点数，默认为0.75，可以通过构造方法进行修改。</p>
<h5 id="2．默认构造方法"><a href="#2．默认构造方法" class="headerlink" title="2．默认构造方法"></a>2．默认构造方法</h5><p>默认构造方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DEFAULT_INITIAL_CAPACITY为16, DEFAULT_LOAD_FACTOR为0.75，默认构造方法调用的构造方法主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是设置loadFactor和threshold的初始值。</p>
<h5 id="6．实现原理小结"><a href="#6．实现原理小结" class="headerlink" title="6．实现原理小结"></a>6．实现原理小结</h5><p>需要说明的是，Java 8对HashMap的实现进行了优化，在哈希冲突比较严重的情况下，即大量元素映射到同一个链表的情况下（具体是至少8个元素，且总的键值对个数至少是64）, <strong>Java 8会将该链表转换为一个平衡的排序二叉树，以提高查询的效率</strong>，关于排序二叉树我们在10.3节介绍，Java 8的具体代码就不介绍了。</p>
<h3 id="10-2-剖析HashSet"><a href="#10-2-剖析HashSet" class="headerlink" title="10.2 剖析HashSet"></a>10.2 剖析HashSet</h3><p>10.1节提到了Set接口，Map接口的两个方法keySet和entrySet返回的都是Set，本节介绍Set接口的一个重要实现类HashSet。与HashMap类似，字面上看，HashSet由两个单词组成：Hash和Set。其中，Set表示接口，实现Set接口也有多种方式，各有特点，Hash-Set实现的方式利用了Hash</p>
<h4 id="10-2-1-用法"><a href="#10-2-1-用法" class="headerlink" title="10.2.1 用法"></a>10.2.1 用法</h4><p>与HashMap类似，HashSet的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>initialCapacity和loadFactor的含义与HashMap中的是一样的。</p>
<p>HashSet的使用也很简单，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">set.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;老马&quot;</span>&#125;));</span><br><span class="line"><span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">    System.out.print(s+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 老马 world</span><br></pre></td></tr></table></figure>
<p>“hello”被添加了两次，但只会保存一份，输出也没有什么特别的顺序。</p>
<p>与HashMap类似，HashSet要求元素重写hashCode和equals方法，且对于两个对象，如果equals相同，则hashCode也必须相同，如果元素是自定义的类，需要注意这一点。比如，有一个表示规格的类Spec，有大小和颜色两个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spec</span> &#123;</span><br><span class="line">    String size;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Spec</span><span class="params">(String size, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[size=&quot;</span> + size + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spec的Set为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Spec&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Spec&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Spec</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;red&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[size=M, color=red], [size=M, color=red]]</span><br></pre></td></tr></table></figure>
<p>同一个规格输出了两次，为避免这一点，需要为Spec重写hashCode和equals方法。</p>
<h4 id="10-2-2-实现原理"><a href="#10-2-2-实现原理" class="headerlink" title="10.2.2 实现原理"></a>10.2.2 实现原理</h4><p>HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>我们知道，Map有键和值，HashSet相当于只有键，值都是相同的固定值，这个值的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h3 id="10-3-排序二叉树"><a href="#10-3-排序二叉树" class="headerlink" title="10.3 排序二叉树"></a>10.3 排序二叉树</h3><p>​    HashMap和HashSet的共同实现机制是哈希表，一个共同的限制是<strong>没有顺序</strong>，我们提到，它们都有一个能保持顺序的对应类<strong>TreeMap</strong>和<strong>TreeSet</strong>，这两个类的共同实现基础是排序二叉树。为了更好地理解TreeMap和TreeSet，</p>
<h4 id="10-3-3-平衡的排序二叉树"><a href="#10-3-3-平衡的排序二叉树" class="headerlink" title="10.3.3 平衡的排序二叉树"></a>10.3.3 平衡的排序二叉树</h4><p>在TreeMap的实现中，用的并不是AVL树，而是<strong>红黑树</strong>，与AVL树类似，红黑树也是一种平衡的排序二叉树，也是在插入和删除节点时通过旋转操作来平衡的，但它并不是高度平衡的，而是大致平衡的。所谓大致是指，它确保任意一条从根到叶子节点的路径，没有任何一条路径的长度会比其他路径长过两倍红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树。</p>
<p>为什么叫红黑树呢？因为它对每个节点进行着色，颜色或黑或红，并对节点的着色有一些约束，满足这个约束即可以确保树是大致平衡的。</p>
<p>对AVL树和红黑树，它们保持平衡的细节都是比较复杂的，我们就不介绍了，需要知道的是，它们都是排序二叉树，都通过在插入和删除时执行开销不大的旋转操作保持了树的高度平衡或大致平衡，从而保证了树的查找效率。</p>
<h3 id="10-4-剖析TreeMap"><a href="#10-4-剖析TreeMap" class="headerlink" title="10.4 剖析TreeMap"></a>10.4 剖析TreeMap</h3><p>​    在介绍HashMap时，我们提到，HashMap有一个重要局限，键值对之间没有特定的顺序，我们还提到，Map接口有另一个重要的实现类TreeMap，在TreeMap中，键值对之间按键有序，TreeMap的实现基础是<strong>排序二叉树</strong></p>
<h4 id="10-4-1-基本用法"><a href="#10-4-1-基本用法" class="headerlink" title="10.4.1 基本用法"></a>10.4.1 基本用法</h4><p>​    TreeMap有两个基本构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个为默认构造方法，如果使用默认构造方法，要求Map中的键实现Comparabe接口，TreeMap内部进行各种比较时会调用键的Comparable接口中的compareTo方法。</p>
<p>第二个接受一个比较器对象comparator，如果comparator不为null，在TreeMap内部进行比较时会调用这个comparator的compare方法，而不再调用键的compareTo方法，也不再要求键实现Comparable接口。</p>
<p>应该用哪一个呢？第一个更为简单，但要求键实现Comparable接口，且期望的排序和键的比较结果是一致的；第二个更为灵活，不要求键实现Comparable接口，比较器可以用灵活复杂的方式进行实现。</p>
<p>需要强调的是，TreeMap是按键而不是按值有序，无论哪一种，都是对键而非值进行比较。</p>
<p>看段简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个TreeMap，但只是当作Map使用，不过迭代时，其输出却是按键排序的，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=tree a=<span class="keyword">abstract</span> b=basic c=call</span><br></pre></td></tr></table></figure>
<p>T排在最前面，是因为大写字母的ASCII码都小于小写字母。如果希望忽略大小写呢？可以传递一个比较器，String类有一个静态成员CASE_INSENSITIVE_ORDER，它就是一个忽略大小写的Comparator对象，替换第一行代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure>
<p>输出就会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">abstract</span> b=basic c=call T=tree</span><br></pre></td></tr></table></figure>
<p>正常排序是从小到大，如果希望逆序呢？可以传递一个不同的Comparator对象，第一行代码可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=call b=basic a=<span class="keyword">abstract</span> T=tree</span><br></pre></td></tr></table></figure>
<p>为什么这样就可以逆序呢？正常排序中，compare方法内是o1.compareTo(o2)，两个对象翻过来，自然就是逆序了，Collections类有一个静态方法reverseOrder()可以返回一个逆序比较器，也就是说，上面的代码也可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p>如果希望逆序且忽略大小写呢？第一行可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">        Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>需要说明的是，TreeMap使用键的比较结果对键进行排重，即使键实际上不同，但只要比较结果相同，它们就会被认为相同，键只会保存一份。比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;tree&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;try&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.print(kv.getKey()+<span class="string">&quot;=&quot;</span>+kv.getValue()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去有两个不同的键”T”和”t”，但因为比较器忽略大小写，所以只会有一个，输出会是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="keyword">try</span></span><br></pre></td></tr></table></figure>
<p>键为第一次put时的，这里即”T”，而值为最后一次put时的，这里即”try”。</p>
<p>我们再来看一个例子，键为字符串形式的日期，值为一个统计数字，希望按照日期输出，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;2016-7-3&quot;</span>, <span class="number">100</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-7-10&quot;</span>, <span class="number">120</span>);</span><br><span class="line">map.put(<span class="string">&quot;2016-8-1&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; kv : map.entrySet())&#123;</span><br><span class="line">    System.out.println(kv.getKey()+<span class="string">&quot;, &quot;</span>+kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>7月10号的排在了7月3号的前面，与期望的不符，这是因为，它们是按照字符串比较的，按字符串，2016-7-10就是小于2016-7-3，因为第一个不同之处1小于3。</p>
<p>怎么解决呢？可以使用一个自定义的比较器，将字符串转换为日期，按日期进行比较，第一行代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map   = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(o1).compareTo(sdf.parse(o2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，输出就符合期望了，会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">3</span>,<span class="number">100</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">7</span>-<span class="number">10</span>,<span class="number">120</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">8</span>-<span class="number">1</span>,<span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>以上就是TreeMap的基本用法，与HashMap相比：相同的是，它们都实现了Map接口，都可以按Map进行操作。不同的是，迭代时，TreeMap按键有序，为了实现有序，它要求要么键实现Comparable接口，要么创建TreeMap时传递一个Comparator对象。</p>
<h4 id="10-4-2-实现原理"><a href="#10-4-2-实现原理" class="headerlink" title="10.4.2 实现原理"></a>10.4.2 实现原理</h4><p>TreeMap内部是用红黑树实现的，红黑树是一种大致平衡的排序二叉树</p>
<h5 id="1．内部组成-1"><a href="#1．内部组成-1" class="headerlink" title="1．内部组成"></a>1．内部组成</h5><p>TreeMap内部主要有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>comparator就是比较器，在构造方法中传递，如果没传，就是null。size为当前键值对个数。root指向树的根节点，从根节点可以访问到每个节点，节点的类型为Entry。Entry是TreeMap的一个内部类，其内部成员和构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; left = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; right = <span class="literal">null</span>;</span><br><span class="line">    Entry&lt;K, V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K, V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点除了键（key）和值（value）之外，还有三个引用，分别指向其左孩子（left）、右孩子（right）和父节点（parent），对于根节点，父节点为null，对于叶子节点，孩子节点都为null，还有一个成员color表示颜色，TreeMap是用红黑树实现的，每个节点都有一个颜色，非黑即红。</p>
<h3 id="10-5-剖析TreeSet"><a href="#10-5-剖析TreeSet" class="headerlink" title="10.5 剖析TreeSet"></a>10.5 剖析TreeSet</h3><p>在介绍HashSet时，我们提到，HashSet有一个重要局限，元素之间没有特定的顺序，我们还提到，Set接口还有另一个重要的实现类TreeSet，它是有序的，与HashSet和HashMap的关系一样，TreeSet是基于TreeMap的</p>
<h4 id="10-5-1-基本用法"><a href="#10-5-1-基本用法" class="headerlink" title="10.5.1 基本用法"></a>10.5.1 基本用法</h4><p>TreeSet的基本构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个是默认构造方法，假定元素实现了Comparable接口；第二个使用传入的比较器，不要求元素实现Comparable。TreeSet经常也只是当作Set使用，只是希望迭代输出有序，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">    System.out.print(w+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash map tree</span><br></pre></td></tr></table></figure>
<p>TreeSet实现了两点：排重和有序。如果希望不同的排序，可以传递一个Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">words.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;hash&quot;</span>, <span class="string">&quot;Map&quot;</span>,</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>
<p>忽略大小写进行比较，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hash, map, tree]</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Set是排重的，排重是基于比较结果的，结果为0即视为相同，”map”和”Map”虽然不同，但比较结果为0，所以只会保留第一个元素。</p>
<h4 id="10-5-2-实现原理"><a href="#10-5-2-实现原理" class="headerlink" title="10.5.2 实现原理"></a>10.5.2 实现原理</h4><p>之前章节介绍过，HashSet是基于HashMap实现的，元素就是HashMap中的键，值是一个固定的值，TreeSet是类似的，它是基于TreeMap实现的。</p>
<p>TreeSet的内部有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E, Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>m就是背后的那个TreeMap，这里用的是更为通用的接口类型NavigableMap,PRESENT就是那个固定的共享值。TreeSet的方法实现主要就是调用m的方法，我们具体来看下。</p>
<p>TreeSet的实现代码都比较简单，主要就是调用内部NavigatableMap的方法。</p>
<h3 id="10-6-剖析LinkedHashMap"><a href="#10-6-剖析LinkedHashMap" class="headerlink" title="10.6 剖析LinkedHashMap"></a>10.6 剖析LinkedHashMap</h3><p>前面我们介绍了Map接口的两个实现类HashMap和TreeMap，本节介绍另一个实现类LinkedHashMap。它是HashMap的子类，但可以保持元素按插入或访问有序，这与TreeMap按键排序不同。按插入有序容易理解，按访问有序是什么意思呢？这两个有序有什么用呢？内部是怎么实现的？本节就来探讨这些问题，从用法开始。</p>
<h4 id="10-6-1-基本用法"><a href="#10-6-1-基本用法" class="headerlink" title="10.6.1 基本用法"></a>10.6.1 基本用法</h4><p>LinkedHashMap是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。LinkedHashMap支持两种顺序：一种是插入顺序；另外一种是访问顺序。</p>
<p>插入顺序容易理解，先添加的在前面，后添加的在后面，修改操作不影响顺序。访问顺序是什么意思呢？所谓访问是指get/put操作，对一个键执行get/put操作后，其对应的键值对会移到链表末尾，所以，最末尾的是最近访问的，最开始的最久没被访问的，这种顺序就是访问顺序。</p>
<p>LinkedHashMap有5个构造方法，其中4个都是按插入顺序，只有一个构造方法可以指定按访问顺序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> accessOrder)</span></span><br></pre></td></tr></table></figure>
<p>其中参数accessOrder就是用来指定是否按访问顺序，如果为true，就是访问顺序。默认情况下，LinkedHashMap是按插入有序的，我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; seqMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">seqMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">seqMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : seqMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>键是按照”c”、”d”、”a”的顺序插入的，修改”d”的值不会修改顺序，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br><span class="line">a <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望保持插入顺序呢？</p>
<p>Map经常用来处理一些数据，其处理模式是：接收一些键值对作为输入，处理，然后输出，输出时希望保持原来的顺序。比如一个配置文件，其中有一些键值对形式的配置项，但其中有一些键是重复的，希望保留最后一个值，但还是按原来的键顺序输出， LinkedHashMap就是一个合适的数据结构。</p>
<p>再如，希望的数据模型可能就是一个Map，但希望保持添加的顺序，如一个购物车，键为购买项目，值为购买数量，按用户添加的顺序保存。</p>
<p>另外一种常见的场景是：希望Map能够按键有序，但在添加到Map前，键已经通过其他方式排好序了，这时，就没有必要使用TreeMap了，毕竟TreeMap的开销要大一些。比如，在从数据库查询数据放到内存时，可以使用SQL的order by语句让数据库对数据排序。</p>
<p>我们来看按访问有序的例子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; accessMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">200</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">500</span>);</span><br><span class="line">accessMap.get(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">accessMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : accessMap.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次访问都会将该键值对移到末尾，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">500</span></span><br><span class="line">c <span class="number">100</span></span><br><span class="line">d <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>什么时候希望按访问有序呢？一种典型的应用是LRU缓存。</p>
<p>使用LinkedHashMap，可以非常容易地实现LRU缓存，默认情况下，LinkedHashMap没有对容量做限制，但它可以容易地做到，它有一个protected方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加元素到LinkedHashMap后，LinkedHashMap会调用这个方法，传递的参数是最久没被访问的键值对，如果这个方法返回true，则这个最久的键值对就会被删除。Linked-HashMap的实现总是返回false，所有容量没有限制，但子类可以重写该方法，在满足一定条件的情况，返回true。</p>
<p>代码清单如下就是一个简单的LRU缓存的实现，它有一个容量限制，这个限制在构造方法中传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxEntries;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> maxEntries)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个缓存可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">System.out.println(cache);</span><br></pre></td></tr></table></figure>
<p>限定缓存容量为3，先后添加了4个键值对，最久没被访问的键是”b”，会被删除，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;c=call, a=<span class="keyword">abstract</span>, d=call&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-6-2-实现原理"><a href="#10-6-2-实现原理" class="headerlink" title="10.6.2 实现原理"></a>10.6.2 实现原理</h4><p>理解了LinkedHashMap的用法，下面我们来看其实现代码（基于Java 7）。先来看内部组成，再看一些主要方法的实现。LinkedHashMap是HashMap的子类，内部增加了如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; header;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>accessOrder表示是按访问顺序还是插入顺序。header表示双向链表的头，它的类型Entry是一个内部类，这个类是HashMap.Entry的子类，增加了两个变量before和after，指向链表中的前驱和后继.Entry的完整定义如代码清单如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    Entry&lt;K, V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">          before.after = after;</span><br><span class="line">          after.before = before;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K, V&gt; existingEntry)</span> &#123;</span><br><span class="line">          after   = existingEntry;</span><br><span class="line">          before = existingEntry.before;</span><br><span class="line">          before.after = <span class="built_in">this</span>;</span><br><span class="line">          after.before = <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          LinkedHashMap&lt;K, V&gt; lm = (LinkedHashMap&lt;K, V&gt;)m;</span><br><span class="line">          <span class="keyword">if</span>(lm.accessOrder) &#123;</span><br><span class="line">              lm.modCount++;</span><br><span class="line">              remove();</span><br><span class="line">              addBefore(lm.header);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">recordRemoval</span><span class="params">(HashMap&lt;K, V&gt; m)</span> &#123;</span><br><span class="line">          remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>recordAccess和recordRemoval是HashMap.Entry中定义的方法，在HashMap中，这两个方法的实现为空，它们就是被设计用来被子类重写的。在put被调用且键存在时，HashMap会调用Entry的recordAccess方法；在键被删除时，HashMap会调用Entry的recordRemoval方法。</p>
<p>LinkedHashMap.Entry重写了这两个方法。在recordAccess方法中，如果是按访问顺序的，则将该节点移到链表的末尾；在recordRemoval方法中，将该节点从链表中移除。</p>
<h4 id="10-6-3-LinkedHashSet"><a href="#10-6-3-LinkedHashSet" class="headerlink" title="10.6.3 LinkedHashSet"></a>10.6.3 LinkedHashSet</h4><p>之前介绍的Map接口的实现类都有一个对应的Set接口的实现类，比如HashMap有HashSet, TreeMap有TreeSet, LinkedHashMap也不例外，它也有一个对应的Set接口的实现类LinkedHashSet。LinkedHashSet是HashSet的子类，它内部的Map的实现类是LinkedHashMap,所以它也可以保持插入顺序,比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b, c, a]</span><br></pre></td></tr></table></figure>
<p>LinkedHashSet的实现比较简单.</p>
<h3 id="10-7-剖析EnumMap"><a href="#10-7-剖析EnumMap" class="headerlink" title="10.7 剖析EnumMap"></a>10.7 剖析EnumMap</h3><p>如果需要一个Map的实现类，并且键的类型为<strong>枚举类型</strong>，可以使用HashMap，但应该使用一个专门的实现类<strong>EnumMap</strong>。为什么要有一个专门的类呢？我们之前介绍过枚举的本质，主要是因为枚举类型有两个特征：一是它可能的值是有限的且预先定义的；二是枚举值都有一个顺序，这两个特征使得可以更为高效地实现Map接口。我们先来看EnumMap的用法，然后看它到底是怎么实现的。</p>
<h3 id="10-8-剖析EnumSet"><a href="#10-8-剖析EnumSet" class="headerlink" title="10.8 剖析EnumSet"></a>10.8 剖析EnumSet</h3><p>本节介绍同样针对枚举类型的Set接口的实现类EnumSet。与EnumMap类似，之所以会有一个专门的针对枚举类型的实现类，主要是因为它可以非常高效地实现Set接口。</p>
<p>之前介绍的Set接口的实现类HashSet/TreeSet，它们内部都是用对应的HashMap/TreeMap实现的，但EnumSet不是，<strong>它的实现与EnumMap没有任何关系</strong>，而是用极为精简和高效的位向量实现的。位向量是计算机程序中解决问题的一种常用方式，我们有必要理解和掌握</p>
<p>除了实现机制，EnumSet的用法也有一些不同。EnumSet可以说是<strong>处理枚举类型数据的一把利器</strong>，在一些应用领域，它非常方便和高效。</p>
<h4 id="10-8-1-基本用法"><a href="#10-8-1-基本用法" class="headerlink" title="10.8.1 基本用法"></a>10.8.1 基本用法</h4><p>与TreeSet/HashSet不同，EnumSet是一个抽象类，不能直接通过new新建</p>
<p>不过，EnumSet提供了若干静态工厂方法，可以创建EnumSet类型的对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br></pre></td></tr></table></figure>
<p>noneOf方法会创建一个指定枚举类型的EnumSet，不含任何元素。创建的EnumSet对象的实际类型是EnumSet的子类，待会我们再分析其具体实现。</p>
<p>为方便举例，我们定义一个表示星期几的枚举类Day，值从周一到周日，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这么用noneOf方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; weekend = EnumSet.noneOf(Day.class);</span><br><span class="line">weekend.add(Day.SATURDAY);</span><br><span class="line">weekend.add(Day.SUNDAY);</span><br><span class="line">System.out.println(weekend);</span><br></pre></td></tr></table></figure>
<p>weekend表示休息日，noneOf返回的Set为空，添加了周六和周日，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SATURDAY, SUNDAY]</span><br></pre></td></tr></table></figure>
<h4 id="10-8-2-应用场景"><a href="#10-8-2-应用场景" class="headerlink" title="10.8.2 应用场景"></a>10.8.2 应用场景</h4><p>下面，我们通过一个场景来看EnumSet的应用。想象一个场景，在一些工作中（如医生、客服），不是每个工作人员每天都在的，每个人可工作的时间是不一样的，比如张三可能是周一和周三，李四可能是周四和周六，给定每个人可工作的时间，我们可能有一些问题需要回答。比如：</p>
<p>❑ 有没有哪天一个人都不会来？</p>
<p>❑ 有哪些天至少会有一个人来？</p>
<p>❑ 有哪些天至少会有两个人来？</p>
<p>❑ 有哪些天所有人都会来，以便开会？</p>
<p>❑ 哪些人周一和周二都会来？</p>
<p>使用EnumSet，可以方便高效地回答这些问题，怎么做呢？我们先来定义一个表示工作人员的类Worker，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Set&lt;Day&gt; availableDays;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, Set&lt;Day&gt; availableDays)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.availableDays = availableDays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为演示方便，将所有工作人员的信息放到一个数组workers中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.FRIDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李四&quot;</span>, EnumSet.of(</span><br><span class="line">                Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;王五&quot;</span>, EnumSet.of(Day.TUESDAY, Day.THURSDAY)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个工作人员的可工作时间用一个EnumSet表示。有了这个信息，我们就可以回答以上的问题了。哪些天一个人都不会来？代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.removeAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>days初始化为所有值，然后遍历workers，从days中删除可工作的所有时间，最终剩下的就是一个人都不会来的时间，这实际是在求worker时间并集的补集，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SUNDAY]</span><br></pre></td></tr></table></figure>
<p>有哪些天至少会有一个人来？就是求worker时间的并集，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line"><span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">    days.addAll(w.getAvailableDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]</span><br></pre></td></tr></table></figure>
<h2 id="第11章-堆与优先级队列"><a href="#第11章-堆与优先级队列" class="headerlink" title="第11章 堆与优先级队列"></a>第11章 堆与优先级队列</h2><p>前面两章介绍了Java中的基本容器类，每个容器类背后都有一种数据结构，ArrayList是动态数组，LinkedList是链表，HashMap/HashSet是哈希表，TreeMap/TreeSet是红黑树，本章介绍另一种数据结构：堆。之前我们提到过堆，那里，堆指的是内存中的区域，保存动态分配的对象，与栈相对应。这里的堆是一种数据结构，与内存区域和分配无关。</p>
<p>堆到底是什么结构呢？这个待会再细看。我们先来说明，堆有什么用？为什么要介绍它？<strong>堆可以非常高效方便地解决很多问题</strong>。比如：</p>
<p>1）优先级队列，我们之前介绍的队列实现类LinkedList是按添加顺序排列的，但现实中，经常需要按优先级来，每次都应该处理当前队列中优先级最高的，高优先级的即使来得晚，也应该被优先处理。</p>
<p>2）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。</p>
<p>3）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，甚至源源不断到来。</p>
<h3 id="11-1-堆的概念与算法"><a href="#11-1-堆的概念与算法" class="headerlink" title="11.1 堆的概念与算法"></a>11.1 堆的概念与算法</h3><p>我们先来了解堆的概念，然后介绍堆的一些主要算法。</p>
<h4 id="11-1-1-基本概念"><a href="#11-1-1-基本概念" class="headerlink" title="11.1.1 基本概念"></a>11.1.1 基本概念</h4><p>堆首先是一棵二叉树，但它是<strong>完全二叉树</strong>。</p>
<h3 id="11-2-剖析PriorityQueue"><a href="#11-2-剖析PriorityQueue" class="headerlink" title="11.2 剖析PriorityQueue"></a>11.2 剖析PriorityQueue</h3><p>节探讨堆在Java中的具体实现类：PriorityQueue。顾名思义，PriorityQueue是优先级队列，它首先实现了队列接口（Queue），与LinkedList类似，它的队列长度也没有限制，与一般队列的区别是，它有优先级的概念，每个元素都有优先级，队头的元素永远都是优先级最高的。</p>
<p>PriorityQueue内部是用堆实现的，内部元素不是完全有序的，不过，逐个出队会得到有序的输出。虽然名字叫优先级队列，但也可以将PriorityQueue看作一种比较通用的实现了堆的性质的数据结构，可以用PriorityQueue来解决适合用堆解决的问题，下一小节我们会来看一些具体的例子。下面，我们先介绍其用法，接着分析实现代码，最后总结分析其特点。</p>
<h2 id="第12章-通用容器类和总结"><a href="#第12章-通用容器类和总结" class="headerlink" title="第12章 通用容器类和总结"></a>第12章 通用容器类和总结</h2><p>之前的章节中，我们介绍的都是具体的容器类，本章介绍一些抽象容器类、一些通用的算法和功能，并对整个容器类体系进行梳理总结。</p>
<p>之前介绍的具体容器类其实都不是从头构建的，它们都继承了一些抽象容器类。这些抽象类提供了容器接口的部分实现，方便了Java具体容器类的实现。此外，通过继承抽象类，自定义的类也可以更为容易地实现容器接口。为什么需要实现容器接口呢？至少有两个原因。</p>
<p>1）容器类是一个大家庭，它们之间可以方便地协作，比如很多方法的参数和返回值都是容器接口对象，实现了容器接口，就可以方便地参与这种协作。</p>
<p>2）Java有一个类Collections，提供了很多针对容器接口的通用算法和功能，实现了容器接口，可以直接利用Collections中的算法和功能。</p>
<h3 id="12-1-抽象容器类"><a href="#12-1-抽象容器类" class="headerlink" title="12.1 抽象容器类"></a>12.1 抽象容器类</h3><p>抽象容器类与之前介绍的接口和具体容器类的关系如图12-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310072039878.png" alt="image-20231007203919721"></p>
<p>虚线框表示接口，有Collection、List、Set、Queue、Deque和Map。有6个抽象容器类。</p>
<p>1）AbstractCollection：实现了Collection接口，被抽象类AbstractList、AbstractSet、AbstractQueue继承，ArrayDeque也继承自AbstractCollection（图中未画出）。</p>
<p>2）AbstractList：父类是AbstractCollection，实现了List接口，被ArrayList、Abstract-SequentialList继承。</p>
<p>3）AbstractSequentialList：父类是AbstractList，被LinkedList继承。</p>
<p>4）AbstractMap：实现了Map接口，被TreeMap、HashMap、EnumMap继承。</p>
<p>5）AbstractSet：父类是AbstractCollection，实现了Set接口，被HashSet、TreeSet和EnumSet继承。</p>
<p>6）AbstractQueue：父类是AbstractCollection，实现了Queue接口，被PriorityQueue继承。</p>
<h3 id="12-2-Collections"><a href="#12-2-Collections" class="headerlink" title="12.2 Collections"></a>12.2 Collections</h3><p>类Collections以静态方法的方式提供了很多通用算法和功能，这些功能大概可以分为两类。</p>
<p>1）对容器接口对象进行操作。</p>
<p>2）返回一个容器接口对象。</p>
<h1 id="第四部分-文件"><a href="#第四部分-文件" class="headerlink" title="第四部分 文件"></a>第四部分 文件</h1><h2 id="第13章-文件基本技术"><a href="#第13章-文件基本技术" class="headerlink" title="第13章 文件基本技术"></a>第13章 文件基本技术</h2><h1 id="第五部分-并发"><a href="#第五部分-并发" class="headerlink" title="第五部分 并发"></a>第五部分 并发</h1><h2 id="第15章-并发基础知识"><a href="#第15章-并发基础知识" class="headerlink" title="第15章 并发基础知识"></a>第15章 并发基础知识</h2><h3 id="15-1-线程的基本概念"><a href="#15-1-线程的基本概念" class="headerlink" title="15.1 线程的基本概念"></a>15.1 线程的基本概念</h3><p>本节，我们介绍Java中线程的一些基本概念，包括创建线程、线程的基本属性和方法、共享内存及问题、线程的优点及成本。</p>
<h4 id="15-1-1-创建线程"><a href="#15-1-1-创建线程" class="headerlink" title="15.1.1 创建线程"></a>15.1.1 创建线程</h4><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。下面，我们通过创建线程来对线程建立一个直观感受。在Java中创建线程有两种方式：一种是继承Thread；另外一种是实现Runnable接口。</p>
<h5 id="1．继承Thread"><a href="#1．继承Thread" class="headerlink" title="1．继承Thread"></a>1．继承Thread</h5><p>Java中java.lang.Thread这个类表示线程，一个类可以继承Thread并重写其run方法来实现一个线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloThread这个类继承了Thread，并重写了run方法。run方法的方法签名是固定的， public，没有参数，没有返回值，不能抛出受检异常。<strong>run方法类似于单线程程序中的main方法</strong>，线程从run方法的第一条语句开始执行直到结束。</p>
<p>定义了这个类不代表代码就会开始执行，线程需要被启动，启动需要先创建一个HelloThread对象，然后调用Thread的start方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在main方法中创建了一个线程对象，并调用了其start方法，调用start方法后， HelloThread的run方法就会开始执行，屏幕输出为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>为什么调用的是start，执行的却是run方法呢？start表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源，每个线程会有单独的程序执行计数器和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行，执行的起点就是run方法。</p>
<p>调用start后，就有了两条执行流，新的一条执行run方法，旧的一条继续执行main方法，两条执行流并发执行，操作系统负责调度，在单CPU的机器上，同一时刻只能有一个线程在执行，在多CPU的机器上，同一时刻可以有多个线程同时执行，但操作系统给我们屏蔽了这种差异，给程序员的感觉就是多个线程并发执行，但哪条语句先执行哪条后执行是不一定的。当所有线程都执行完毕的时候，程序退出。</p>
<h5 id="2．实现Runnable接口"><a href="#2．实现Runnable接口" class="headerlink" title="2．实现Runnable接口"></a>2．实现Runnable接口</h5><p>通过继承Thread来实现线程虽然比较简单，但Java中只支持单继承，每个类最多只能有一个父类，如果类已经有父类了，就不能再继承Thread，这时，可以通过实现java.lang. Runnable接口来实现线程。Runnable接口的定义很简单，只有一个run方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以实现该接口，并实现run方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅实现Runnable是不够的，要启动线程，还是要创建一个Thread对象，但传递一个Runnable对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">helloThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>());</span><br><span class="line">    helloThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是通过继承Thead还是实现Runnable接口来创建线程，启动线程都是调用start方法。</p>
<h4 id="15-1-2-线程的基本属性和方法"><a href="#15-1-2-线程的基本属性和方法" class="headerlink" title="15.1.2 线程的基本属性和方法"></a>15.1.2 线程的基本属性和方法</h4><p>线程有一些基本属性和方法，包括id、name、优先级、状态、是否daemo线程、sleep方法、yield方法、join方法、过时方法等，我们简要介绍。</p>
<h5 id="1-id和name"><a href="#1-id和name" class="headerlink" title="1. id和name"></a>1. id和name</h5><p>​    前面我们提到，每个线程都有一个id和name。id是一个递增的整数，每创建一个线程就加一。name的默认值是Thread-后跟一个编号，name可以在Thread的构造方法中进行指定，也可以通过setName方法进行设置，给Thread设置一个友好的名字，可以方便调试。</p>
<h5 id="2．优先级"><a href="#2．优先级" class="headerlink" title="2．优先级"></a>2．优先级</h5><p>线程有一个优先级的概念，在Java中，优先级从1到10，默认为5，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个优先级会被映射到操作系统中线程的优先级，不过，因为操作系统各不相同，不一定都是10个优先级，Java中不同的优先级可能会被映射到操作系统中相同的优先级。另外，优先级对操作系统而言主要是一种建议和提示，而非强制。简单地说，在编程中，不要过于依赖优先级。</p>
<h5 id="3．状态"><a href="#3．状态" class="headerlink" title="3．状态"></a>3．状态</h5><p>线程有一个状态的概念，Thread有一个方法用于获取线程的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>返回值类型为Thread.State，它是一个枚举类型，有如下值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITING,</span><br><span class="line">  TIMED_WAITING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这些状态，我们简单解释下：</p>
<p>1）NEW：没有调用start的线程状态为NEW。</p>
<p>2）TERMINATED：线程运行结束后状态为TERMINATED。</p>
<p>3）RUNNABLE：调用start后线程在执行run方法且没有阻塞时状态为RUNNABLE，不过，RUNNABLE不代表CPU一定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只是它没有在等待其他条件。</p>
<p>4）BLOCKED、WAITING、TIMED_WAITING：都表示线程被阻塞了，在等待一些条件，其中的区别我们在后续章节再介绍。</p>
<p>Thread还有一个方法，返回线程是否活着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>线程被启动后，run方法运行结束前，返回值都是true。</p>
<h5 id="4．是否daemon线程"><a href="#4．是否daemon线程" class="headerlink" title="4．是否daemon线程"></a>4．是否daemon线程</h5><p>Thread有一个是否daemon线程的属性，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>前面我们提到，启动线程会启动一条单独的执行流，整个程序只有在所有线程都结束的时候才退出，但daemon线程是例外，当整个程序中剩下的都是daemon线程的时候，程序就会退出。</p>
<p>daemon线程有什么用呢？它一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。在我们运行一个即使最简单的”hello world”类型的程序时，实际上，Java也会创建多个线程，除了main线程外，至少还有一个负责垃圾回收的线程，这个线程就是daemon线程，在main线程结束的时候，垃圾回收线程也会退出。</p>
<h5 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5. sleep方法"></a>5. sleep方法</h5><p>Thread有一个静态的sleep方法，调用该方法会让当前线程睡眠指定的时间，单位是毫秒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>睡眠期间，该线程会让出CPU，但睡眠的时间不一定是确切的给定毫秒数，可能有一定的偏差，偏差与系统定时器和操作系统调度器的准确度和精度有关。睡眠期间，线程可以被中断，如果被中断，sleep会抛出InterruptedException，关于中断以及中断处理，我们在15.4节介绍。</p>
<h5 id="6-yield方法"><a href="#6-yield方法" class="headerlink" title="6. yield方法"></a>6. yield方法</h5><p>Thread还有一个让出CPU的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这也是一个静态方法，调用该方法，是告诉操作系统的调度器：我现在不着急占用CPU，你可以先让其他线程运行。不过，这对调度器也仅仅是建议，调度器如何处理是不一定的，它可能完全忽略该调用。</p>
<h5 id="7-join方法"><a href="#7-join方法" class="headerlink" title="7. join方法"></a>7. join方法</h5><p>在前面HelloThread的例子中，HelloThread没执行完，main线程可能就执行完了， Thread有一个join方法，可以让调用join的线程优先执行，当前线程被阻塞，join方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<p>在等待线程结束的过程中，这个等待可能被中断，如果被中断，会抛出Interrupted-Exception。</p>
<p>join方法还有一个变体，可以限定等待的最长时间，单位为毫秒，如果为0，表示无期限等待：</p>
<p>在前面HelloThread示例中，如果希望main线程在子线程结束后再退出，main方法可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="8．过时方法"><a href="#8．过时方法" class="headerlink" title="8．过时方法"></a>8．过时方法</h5><p>Thread类中还有一些看上去可以控制线程生命周期的方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法因为各种原因已被标记为了过时，我们不应该在程序中使用它们。</p>
<h4 id="15-1-3-共享内存及可能存在的问题"><a href="#15-1-3-共享内存及可能存在的问题" class="headerlink" title="15.1.3 共享内存及可能存在的问题"></a>15.1.3 共享内存及可能存在的问题</h4><p>前面我们提到，每个线程表示一条单独的执行流，有自己的程序计数器，有自己的栈，但线程之间可以共享内存，它们可以访问和操作相同的对象。我们看个例子，如代码清单15-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareMemoryDemo</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incrShared</span><span class="params">()</span>&#123;</span><br><span class="line">                shared ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChildThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                List&lt;String&gt; list;</span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">ChildThread</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.list = list;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    incrShared();</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildThread</span>(list);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildThread</span>(list);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(shared);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，定义了一个静态变量shared和静态内部类ChildThread，在main方法中，创建并启动了两个ChildThread对象，传递了相同的list对象，ChildThread的run方法访问了共享的变量shared和list, main方法最后输出了共享的shared和list的值，大部分情况下，会输出期望的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">[Thread-<span class="number">0</span>, Thread-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>通过这个例子，我们想强调说明执行流、内存和程序代码之间的关系。</p>
<p>1）该例中有三条执行流，一条执行main方法，另外两条执行ChildThread的run方法。</p>
<p>2）不同执行流可以访问和操作相同的变量，如本例中的shared和list变量。</p>
<p>3）不同执行流可以执行相同的程序代码，如本例中incrShared方法，ChildThread的run方法，被两条ChildThread执行流执行，incrShared方法是在外部定义的，但被ChildThread的执行流执行。在分析代码执行过程时，理解代码在被哪个线程执行是很重要的。</p>
<p>4）当多条执行流执行相同的程序代码时，每条执行流都有单独的栈，方法中的参数和局部变量都有自己的一份。</p>
<p>当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果，包括<strong>竞态条件</strong>和<strong>内存可见性</strong>，我们来看下。</p>
<h5 id="1．竞态条件"><a href="#1．竞态条件" class="headerlink" title="1．竞态条件"></a>1．竞态条件</h5><p>所谓竞态条件（race condition）是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。我们看一个例子，如代码清单15-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">          Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">              threads[i] = <span class="keyword">new</span> <span class="title class_">CounterThread</span>();</span><br><span class="line">              threads[i].start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">              threads[i].join();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(counter);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码容易理解，有一个共享静态变量counter，初始值为0，在main方法中创建了1000个线程，每个线程对counter循环加1000次，main线程等待所有线程结束后输出counter的值。</p>
<p>期望的结果是100万，但实际执行，发现每次输出的结果都不一样，一般都不是100万，经常是99万多。为什么会这样呢？<strong>因为counter++这个操作不是原子操作</strong>，它分为三个步骤：</p>
<p>1）取counter的当前值；</p>
<p>2）在当前值基础上加1；</p>
<p>3）将新值重新赋值给counter。</p>
<p>两个线程可能同时执行第一步，取到了相同的counter值，比如都取到了100，第一个线程执行完后counter变为101，而第二个线程执行完后还是101，最终的结果就与期望不符。</p>
<p>怎么解决这个问题呢？有多种方法：</p>
<p>❑ 使用synchronized关键字；</p>
<p>❑ 使用显式锁；</p>
<p>❑ 使用原子变量。</p>
<p>关于这些方法，我们在后续章节会逐步介绍。</p>
<h5 id="2．内存可见性"><a href="#2．内存可见性" class="headerlink" title="2．内存可见性"></a>2．内存可见性</h5><p>多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到。这可能有悖直觉，我们来看一个例子，如代码清单15-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityDemo</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! shutdown)&#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;exit hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HelloThread</span>().start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    shutdown = <span class="literal">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;exit main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，有一个共享的boolean变量shutdown，初始为false, HelloThread在shutdown不为true的情况下一直死循环，当shutdown为true时退出并输出”exit hello”, main线程启动HelloThread后休息了一会儿，然后设置shutdown为true，最后输出”exit main”。</p>
<p>期望的结果是两个线程都退出，但实际执行时，很可能会发现HelloThread永远都不会退出，也就是说，在HelloThread执行流看来，shutdown永远为false，即使main线程已经更改为了true。</p>
<p>这是怎么回事呢？这就是内存可见性问题。在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。在单线程的程序中，这一般不是问题，但在多线程的程序中，尤其是在有多CPU的情况下，这就是严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。</p>
<p>怎么解决这个问题呢？有多种方法：</p>
<p>❑ 使用volatile关键字。</p>
<p>❑ 使用synchronized关键字或显式锁同步。</p>
<p>关于这些方法，我们在后续章节会逐步介绍。</p>
<h4 id="15-1-4-线程的优点及成本"><a href="#15-1-4-线程的优点及成本" class="headerlink" title="15.1.4 线程的优点及成本"></a>15.1.4 线程的优点及成本</h4><p>为什么要创建单独的执行流？或者说线程有什么优点呢？至少有以下几点：</p>
<p>1）充分利用多CPU的计算能力，单线程只能利用一个CPU，使用多线程可以利用多CPU的计算能力。</p>
<p>2）充分利用硬件资源，CPU和硬盘、网络是可以同时工作的，一个线程在等待网络IO的同时，另一个线程完全可以利用CPU，对于多个独立的网络请求，完全可以使用多个线程同时请求。</p>
<p>3）在用户界面（GUI）应用程序中，保持程序的响应性，界面和后台任务通常是不同的线程，否则，如果所有事情都是一个线程来执行，当执行一个很慢的任务时，整个界面将停止响应，也无法取消该任务。</p>
<p>4）简化建模及IO处理，比如，在服务器应用程序中，对每个用户请求使用一个单独的线程进行处理，相比使用一个线程，处理来自各种用户的各种请求，以及各种网络和文件IO事件，建模和编写程序要容易得多。</p>
<p>关于线程，我们需要知道，它是有成本的。创建线程需要消耗操作系统的资源，操作系统会为每个线程创建必要的数据结构、栈、程序计数器等，创建也需要一定的时间。</p>
<p>此外，线程调度和切换也是有成本的，当有大量可运行线程的时候，操作系统会忙于调度，为一个线程分配一段时间，执行完后，再让另一个线程执行，一个线程被切换出去后，操作系统需要保存它的当前上下文状态到内存，上下文状态包括当前CPU寄存器的值、程序计数器的值等，而一个线程被切换回来后，操作系统需要恢复它原来的上下文状态，整个过程称为上下文切换，这个切换不仅耗时，而且使CPU中的很多缓存失效。</p>
<p>当然，这些成本是相对而言的，如果线程中实际执行的事情比较多，这些成本是可以接受的；但如果只是执行本节示例中的counter++，那相对成本就太高了。</p>
<p>另外，如果执行的任务都是CPU密集型的，即主要消耗的都是CPU，那创建超过CPU数量的线程就是没有必要的，并不会加快程序的执行。</p>
<h3 id="15-2-理解synchronized"><a href="#15-2-理解synchronized" class="headerlink" title="15.2 理解synchronized"></a>15.2 理解synchronized</h3><p>上一节，我们提到，共享内存有两个重要问题，一个是竞态条件，另一个是内存可见性，解决这两个问题的一个方案是使用synchronized关键字</p>
<h4 id="15-2-1-用法和基本原理"><a href="#15-2-1-用法和基本原理" class="headerlink" title="15.2.1 用法和基本原理"></a>15.2.1 用法和基本原理</h4><p>synchronized可以用于修饰类的实例方法、静态方法和代码块，我们分别介绍。</p>
<h5 id="1．实例方法"><a href="#1．实例方法" class="headerlink" title="1．实例方法"></a>1．实例方法</h5><p>上节我们介绍了一个计数的例子，当多个线程并发执行counter++的时候，由于该语句不是原子操作，出现了意料之外的结果，这个问题可以用synchronized解决，如代码清单15-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Counter是一个简单的计数器类，incr方法和getCount方法都加了synchronized修饰。加了synchronized后，方法内的代码就变成了原子操作，当多个线程并发更新同一个Counter对象的时候，也不会出现问题。使用的代码如代码清单15-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter.incr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上节类似，我们创建了1000个线程，传递了相同的counter对象，每个线程主要就是调用Counter的incr方法1000次，main线程等待子线程结束后输出counter的值，这次，不论运行多少次，结果都是正确的100万。</p>
<p>这里，synchronized到底做了什么呢？看上去，synchronized使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的即可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">counter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(counter2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>这里，t1和t2两个线程是可以同时执行Counter的incr方法的，因为它们访问的是不同的Counter对象，一个是counter1，另一个是counter2。</p>
<p>所以，synchronized实例方法实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行。再具体来说，synchronized实例方法保护的是当前实例对象，即this, this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待。执行synchronized实例方法的过程大致如下:</p>
<p>1）尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒。</p>
<p>2）执行实例方法体代码。</p>
<p>3）释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性。</p>
<p>synchronized的实际执行过程比这要复杂得多，而且Java虚拟机采用了多种优化方式以提高性能，但从概念上，我们可以这么简单理解。</p>
<p>当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为BLOCKED。</p>
<p>我们再强调下，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。比如，对于Counter中的两个实例方法getCount和incr，对同一个Counter对象，一个线程执行getCount，另一个执行incr，它们是不能同时执行的，会被synchronized同步顺序执行。</p>
<p>此外，需要说明的是，synchronized方法不能防止非synchronized方法被同时执行。比如，如果给Counter类增加一个非synchronized方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span>&#123;</span><br><span class="line">    count --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则该方法可以和synchronized的incr方法同时执行，这通常会出现非期望的结果，所以，<strong>一般在保护变量时，需要在所有访问该变量的方法上加上synchronized</strong>。</p>
<h5 id="2．静态方法"><a href="#2．静态方法" class="headerlink" title="2．静态方法"></a>2．静态方法</h5><p>synchronized同样可以用于静态方法，如代码清单15-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们说，synchronized保护的是对象，对实例方法，保护的是当前实例对象this，对静态方法，保护的是哪个对象呢？是类对象，这里是StaticCounter.class。实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。</p>
<p>synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以一个执行synchronized静态方法，另一个执行synchronized实例方法。</p>
<h5 id="3．代码块"><a href="#3．代码块" class="headerlink" title="3．代码块"></a>3．代码块</h5><p>除了用于修饰方法外，synchronized还可以用于包装代码块，比如对于实例方法的 Counter类，等价的代码如代码清单15-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized括号里面的就是保护的对象，对于实例方法，就是this, {}里面是同步执行的代码。对于前面静态方法的StaticCounter类，等价的代码如代码清单15-8所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(StaticCounter.class)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(StaticCounter.class)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。比如，Counter类的等价代码还可以如代码清单15-9所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-2-进一步理解synchronized"><a href="#15-2-2-进一步理解synchronized" class="headerlink" title="15.2.2 进一步理解synchronized"></a>15.2.2 进一步理解synchronized</h4><p>介绍了synchronized的基本用法和原理之后，我们再从下面几个角度来进一步介绍synchronized：</p>
<p>❑ 可重入性。</p>
<p>❑ 内存可见性。</p>
<p>❑ 死锁。</p>
<h5 id="1．可重入性"><a href="#1．可重入性" class="headerlink" title="1．可重入性"></a>1．可重入性</h5><p>synchronized有一个重要的特征，它是<strong>可重入的</strong>，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用。比如，在一个syn-chronized实例方法内，可以直接调用其他synchronized实例方法。可重入是一个非常自然的属性，应该是很容易理解的，之所以强调，是因为并不是所有锁都是可重入的，后续章节我们会看到不可重入的锁。</p>
<p><strong>可重入是通过记录锁的持有线程和持有数量来实现的，</strong>当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。</p>
<h5 id="2．内存可见性-1"><a href="#2．内存可见性-1" class="headerlink" title="2．内存可见性"></a>2．内存可见性</h5><p>对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件，但对于明显的本来就是原子的操作方法，也需要加synchronized吗？比如，下面的开关类Switcher只有一个boolean变量on和对应的setter/getter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> on;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多线程同时访问同一个Switcher对象时，会有问题吗？没有竞态条件问题，但正如上节所说，有内存可见性问题，而加上synchronized可以解决这个问题。</p>
<p>synchronized除了保证<strong>原子操作</strong>外，它还有一个重要的作用，就是<strong>保证内存可见性</strong>，<strong>在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。</strong></p>
<p>不过，如果只是为了保证内存可见性，使用synchronized的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符volatile，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> on;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了volatile之后，Java会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。</p>
<h5 id="3．死锁"><a href="#3．死锁" class="headerlink" title="3．死锁"></a>3．死锁</h5><p>使用synchronized或者其他锁，要注意死锁。所谓死锁就是类似这种现象，比如，有a、b两个线程，a持有锁A，在等待锁B，而b持有锁B，在等待锁A, a和b陷入了互相等待，最后谁都执行不下去，如代码清单15-10所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThreadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">aThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              aThread.start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThreadB</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                      <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              bThread.start();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              startThreadA();</span><br><span class="line">              startThreadB();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>运行后aThread和bThread陷入了相互等待。怎么解决呢？首先，<strong>应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁</strong>。比如，对于上面的例子，可以约定都先申请lockA，再申请lockB。</p>
<p>不过，在复杂的项目代码中，这种约定可能难以做到。还有一种方法是使用后续章节介绍的<strong>显式锁接口Lock</strong>，它支持尝试获取锁（tryLock）和带时间限制的获取锁方法，<strong>使用这些方法可以在获取不到锁的时候释放已经持有的锁</strong>，然后再次尝试获取锁或干脆放弃，以避免死锁。</p>
<p>如果还是出现了死锁，怎么办呢？Java不会主动处理，不过，借助一些工具，我们可以发现运行中的死锁，比如，Java自带的jstack命令会报告发现的死锁。对于上面的程序，在笔者的计算机中，jstack会生成图15-1所示的报告。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310072326756.png" alt="image-20231007232639624"></p>
<h4 id="15-2-3-同步容器及其注意事项"><a href="#15-2-3-同步容器及其注意事项" class="headerlink" title="15.2.3 同步容器及其注意事项"></a>15.2.3 同步容器及其注意事项</h4><p>我们知道，类Collection中有一些方法，可以返回线程安全的同步容器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K, V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>它们是给所有容器方法都加上synchronized来实现安全的，比如Synchronized-Collection，其部分代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;   <span class="comment">//Backing Collection</span></span><br><span class="line">    <span class="keyword">final</span> Object mutex;      <span class="comment">//Object on which to synchronize</span></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        mutex = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里线程安全针对的是容器对象，指的是当多个线程并发访问同一个容器对象时，不需要额外的同步操作，也不会出现错误的结果。</p>
<p>加了synchronized，所有方法调用变成了原子操作，客户端在调用时，是不是就绝对安全了呢？不是的，至少有以下情况需要注意：</p>
<p>❑ 复合操作，比如先检查再更新。</p>
<p>❑ 伪同步。</p>
<p>❑ 迭代。</p>
<h5 id="1．复合操作"><a href="#1．复合操作" class="headerlink" title="1．复合操作"></a>1．复合操作</h5><p>先来看复合操作，我们看段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span> &lt;K, V&gt; &#123;</span><br><span class="line">    Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">          <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnhancedMap是一个装饰类，接受一个Map对象，调用synchronizedMap转换为了同步容器对象map，增加了一个方法putIfAbsent，该方法只有在原Map中没有对应键的时候才添加（在Java 8之后，Map接口增加了putIfAbsent默认方法，这是针对Java 8之前的Map接口演示概念）。</p>
<p>map的每个方法都是安全的，但这个复合方法putIfAbsent是安全的吗？显然是否定的，这是一个检查然后再更新的复合操作，在多线程的情况下，可能有多个线程都执行完了检查这一步，都发现Map中没有对应的键，然后就会都调用put，这就破坏了putIf-Absent方法期望保持的语义。</p>
<h5 id="2．伪同步"><a href="#2．伪同步" class="headerlink" title="2．伪同步"></a>2．伪同步</h5><p>那给该方法加上synchronized就能实现安全吗？如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是否定的！为什么呢？<strong>同步错对象了</strong>。putIfAbsent同步使用的是EnhancedMap对象，而其他方法（如代码中的put方法）使用的是Collections.synchronizedMap返回的对象map，两者是不同的对象。要解决这个问题，<strong>所有方法必须使用相同的锁</strong>，可以使用EnhancedMap的对象锁，也可以使用map。使用EnhancedMap对象作为锁，则Enhanced-Map中的所有方法都需要加上synchronized。使用map作为锁，putIfAbsent方法可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map)&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">          <span class="keyword">if</span>(old! =<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3．迭代"><a href="#3．迭代" class="headerlink" title="3．迭代"></a>3．迭代</h5><p>对于同步容器对象，虽然单个操作是安全的，但迭代并不是。我们看个例子，创建一个同步List对象，一个线程修改List，另一个遍历，看看会发生什么，如代码清单15-11所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startModifyThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">modifyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;item &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    modifyThread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startIteratorThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">iteratorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    iteratorThread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; list = Collections</span><br><span class="line">            .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    startIteratorThread(list);</span><br><span class="line">    startModifyThread(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，程序抛出并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-0&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">    at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">831</span>)</span><br></pre></td></tr></table></figure>
<p>我们之前介绍过这个异常，如果在遍历的同时容器发生了结构性变化，就会抛出该异常。同步容器并没有解决这个问题，如果要避免这个异常，<strong>需要在遍历的时候给整个容器对象加锁</strong>。比如，上面的代码startIteratorThread可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startIteratorThread</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">iteratorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    iteratorThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4．并发容器"><a href="#4．并发容器" class="headerlink" title="4．并发容器"></a>4．并发容器</h5><p>除了以上这些注意事项，同步容器的性能也是比较低的，当并发访问量比较大的时候性能比较差。所幸的是，Java中还有很多专为并发设计的容器类，比如：</p>
<p>❑ CopyOnWriteArrayList。</p>
<p>❑ ConcurrentHashMap。</p>
<p>❑ ConcurrentLinkedQueue。</p>
<p>❑ ConcurrentSkipListSet。</p>
<p>这些容器类都是线程安全的，但都没有使用synchronized，没有迭代问题，直接支持一些复合操作，性能也高得多，它们能解决什么问题？怎么使用？实现原理是什么？我们后续章节介绍。</p>
<h3 id="15-3-线程的基本协作机制-（看到这里）"><a href="#15-3-线程的基本协作机制-（看到这里）" class="headerlink" title="15.3 线程的基本协作机制  （看到这里）"></a>15.3 线程的基本协作机制  （看到这里）</h3><p>多线程之间除了竞争访问同一个资源外，也经常需要相互协作，怎么协作呢？本节就来介绍Java中多线程协作的基本机制wait/notify。都有哪些场景需要协作？wait/notify是什么？如何使用？实现原理是什么？协作的核心是什么？如何实现各种典型的协作场景？本节进行详细讨论，我们先来看看都有哪些协作的场景。</p>
<h4 id="15-3-1-协作的场景"><a href="#15-3-1-协作的场景" class="headerlink" title="15.3.1 协作的场景"></a>15.3.1 协作的场景</h4><p>多线程之间需要协作的场景有很多，比如：生产者/消费者协作模式</p>
<h4 id="15-3-2-wait-notify"><a href="#15-3-2-wait-notify" class="headerlink" title="15.3.2 wait/notify"></a>15.3.2 wait/notify</h4><p>我们知道，Java的根父类是Object, Java在<strong>Object类而非Thread类</strong>中定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法，这些方法有两类，一类是wait，另一类是notify。</p>
<p>主要有两个wait方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>一个带时间参数，单位是毫秒，表示最多等待这么长时间，参数为0表示无限期等待；一个不带时间参数，表示无限期等待，实际就是调用wait(0)。在等待期间都可以被中断，如果被中断，会抛出InterruptedException。关于中断及中断处理，我们在下节介绍，本节暂时忽略该异常。</p>
<p>wait实际上做了什么呢？它在等待什么？上节我们说过，每个对象都有一把锁和等待队列，一个线程在进入synchronized代码块时，会尝试获取锁，如果获取不到则会把当前线程加入等待队列中，其实，<strong>除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作</strong>。调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用Object的notify方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，它会移除条件队列中所有的线程并全部唤醒。</p>
<p>我们来看个简单的例子，一个线程启动后，在执行一项操作前，它需要等待主线程给它指令，收到指令后才执行，如代码清单15-12所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span>(! fire) &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">                waitThread.start();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码中有两个线程，一个是主线程，一个是WaitThread，协作的条件变量是fire, WaitThread等待该变量变为true，在不为true的时候调用wait，主线程设置该变量并调用notify。</p>
<p>两个线程都要访问协作的变量fire，容易出现竞态条件，所以相关代码都需要被synchronized保护。实际上，wait/notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出异常java.lang.IllegalMonitor-StateException。</p>
<p>你可能会有疑问，如果wait必须被synchronized保护，那一个线程在wait时，另一个线程怎么可能调用同样被synchronized保护的notify方法呢？它不需要等待锁吗？我们需要进一步理解wait的内部过程，<strong>虽然是在synchronized方法内，但调用wait时，线程会释放对象锁</strong>。wait的具体过程是：</p>
<p>1）把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING。</p>
<p>2）等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁：</p>
<p>​    ❑ 如果能够获得锁，线程状态变为RUNNABLE，并从wait调用中返回。</p>
<p>​    ❑ 否则，该线程加入对象锁等待队列，线程状态变为BLOCKED，只有在获得锁后才会从wait调用中返回。</p>
<p>线程从wait调用中返回后，不代表其等待的条件就一定成立了，它需要<strong>重新检查其等待的条件</strong>，一般的调用模式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)</span><br><span class="line">        obj.wait();</span><br><span class="line">    …<span class="comment">//执行条件满足后的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，上例中的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(! fire) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。</p>
<p>简单总结一下，wait/notify方法看上去很简单，但往往难以理解wait等的到底是什么，而notify通知的又是什么，我们需要知道，<strong>它们被不同的线程调用，但共享相同的锁和条件等待队列（相同对象的synchronized代码块内），它们围绕一个共享的条件变量进行协作</strong>，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改了条件变量后调用notify，调用wait的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用wait的线程角度看，它阻塞等待一个条件的成立。我<strong>们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心</strong>。接下来，我们通过一些场景进一步理解wait/notify的应用。</p>
<h3 id="15-4-线程的中断"><a href="#15-4-线程的中断" class="headerlink" title="15.4 线程的中断"></a>15.4 线程的中断</h3><p>本节主要讨论一个问题，如何在Java中取消或关闭一个线程？</p>
<h4 id="15-4-1-取消-关闭的场景"><a href="#15-4-1-取消-关闭的场景" class="headerlink" title="15.4.1 取消/关闭的场景"></a>15.4.1 取消/关闭的场景</h4><p>我们知道，通过线程的start方法启动一个线程后，线程开始执行run方法，run方法运行结束后线程退出，那为什么还需要结束一个线程呢？有多种情况，比如:</p>
<p>1）很多线程的运行模式是死循环，比如在生产者/消费者模式中，消费者主体就是一个死循环，它不停地从队列中接受任务，执行任务，在停止程序时，我们需要一种“优雅”的方法以关闭该线程。  </p>
<p>2）在一些图形用户界面程序中，线程是用户启动的，完成一些任务，比如从远程服务器上下载一个文件，在下载过程中，用户可能会希望取消该任务。</p>
<p>3）在一些场景中，比如从第三方服务器查询一个结果，我们希望在限定的时间内得到结果，如果得不到，我们会希望取消该任务。</p>
<p>4）有时，我们会启动多个线程做同一件事，比如类似抢火车票，我们可能会让多个好友帮忙从多个渠道买火车票，只要有一个渠道买到了，我们会通知取消其他渠道。</p>
<h4 id="15-4-2-取消-关闭的机制"><a href="#15-4-2-取消-关闭的机制" class="headerlink" title="15.4.2 取消/关闭的机制"></a>15.4.2 取消/关闭的机制</h4><p>Java的Thread类定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个方法看上去就可以停止线程，但这个方法被标记为了过时，简单地说，我们不应该使用它，可以忽略它。</p>
<p>在Java中，<strong>停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出</strong>。本节我们主要就是来理解Java的中断机制。</p>
<p>Thread类定义了如下关于中断的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这三个方法名字类似，比较容易混淆，我们解释一下。isInterrupted()和interrupt()是实例方法，调用它们需要通过线程对象；interrupted()是静态方法，实际会调用Thread. currentThread()操作当前线程。</p>
<p>每个线程都有一个<strong>标志位</strong>，表示该线程是否被中断了。</p>
<p>1）isInterrupted：返回对应线程的中断标志位是否为true。</p>
<p>2）interrupted：返回当前线程的中断标志位是否为true，<strong>但它还有一个重要的副作用，就是清空中断标志位</strong>，也就是说，连续两次调用interrupted()，第一次返回的结果为true，第二次一般就是false（除非同时又发生了一次中断）。</p>
<p>3）interrupt：表示中断对应的线程。中断具体意味着什么呢？下面我们进一步来说明。</p>
<h4 id="15-4-3-线程对中断的反应"><a href="#15-4-3-线程对中断的反应" class="headerlink" title="15.4.3 线程对中断的反应"></a>15.4.3 线程对中断的反应</h4><p>interrupt()对线程的影响与线程的状态和在进行的IO操作有关。我们主要考虑线程的状态，IO操作的影响和具体IO以及操作系统有关，我们就不讨论了。线程状态有：</p>
<p>❑ RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度。</p>
<p>❑ WAITING/TIMED_WAITING：线程在等待某个条件或超时。</p>
<p>❑ BLOCKED：线程在等待锁，试图进入同步块。</p>
<p>❑ NEW/TERMINATED：线程还未启动或已结束。</p>
<h5 id="1-RUNNABLE"><a href="#1-RUNNABLE" class="headerlink" title="1. RUNNABLE"></a>1. RUNNABLE</h5><p>如果线程在运行中，且没有执行IO操作，interrupt()只是会设置线程的中断标志位，没有任何其他作用。线程应该在运行过程中合适的位置检查中断标志位，比如，如果主体代码是一个循环，可以在循环开始处进行检查，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptRunnableDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">//…单次循环代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-WAITING-TIMED-WAITING"><a href="#2-WAITING-TIMED-WAITING" class="headerlink" title="2. WAITING/TIMED_WAITING"></a>2. WAITING/TIMED_WAITING</h5><p>线程调用join/wait/sleep方法会进入WAITING或TIMED_WAITING状态，在这些状态时，对线程对象调用interrupt()会使得该线程抛出InterruptedException。需要注意的是，<strong>抛出异常后，中断标志位会被清空，而不是被设置</strong>。比如，执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<p>程序的输出为false。</p>
<p>InterruptedException是一个受检异常，线程必须进行处理。我们在异常处理中介绍过，处理异常的基本思路是：如果知道怎么处理，就进行处理，如果不知道，就应该向上传递，通常情况下不应该捕获异常然后忽略。</p>
<p>捕获到InterruptedException，通常表示希望结束该线程，线程大致有两种处理方式：</p>
<p>​    1）向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理；</p>
<p>​    2）有些情况，不能向上传递异常，比如Thread的run方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用Thread的interrupt方法设置中断标志位，使得其他代码有办法知道它发生了中断。</p>
<p>第一种方式的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interruptibleMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">//…包含wait, join 或 sleep 方法</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptWaitingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟任务代码</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">//…清理操作</span></span><br><span class="line">                        <span class="comment">//重设中断标志位</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-BLOCKED"><a href="#3-BLOCKED" class="headerlink" title="3. BLOCKED"></a>3. BLOCKED</h5><p>如果线程在等待锁，对线程对象调用interrupt()只是会设置线程的中断标志位，线程依然会处于BLOCKED状态，也就是说，<strong>interrupt()并不能使一个在等待锁的线程真正“中断”</strong>。我们看段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptSynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (! Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            a.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test方法在持有锁lock的情况下启动线程a，而线程a也去尝试获得锁lock，所以会进入锁等待队列，随后test调用线程a的interrupt方法并调用join等待线程线程a结束，线程a会结束吗？不会，interrupt方法只会设置线程的中断标志，而并不会使它从锁等待队列中出来。</p>
<p>在使用synchronized关键字<strong>获取锁的过程中不响应中断请求</strong>，这是synchronized的局限性。如果这对程序是一个问题，应该使用显式锁。第16章会介绍显式锁Lock接口，它支持以响应中断的方式获取锁。</p>
<h5 id="4-NEW-TERMINATE"><a href="#4-NEW-TERMINATE" class="headerlink" title="4. NEW/TERMINATE"></a>4. NEW/TERMINATE</h5><p>如果线程尚未启动（NEW），或者已经结束（TERMINATED），则调用interrupt()对它没有任何效果，<strong>中断标志位也不会被设置</strong>。</p>
<h4 id="15-4-4-如何正确地取消-关闭线程"><a href="#15-4-4-如何正确地取消-关闭线程" class="headerlink" title="15.4.4 如何正确地取消/关闭线程"></a>15.4.4 如何正确地取消/关闭线程</h4><p>interrupt方法不一定会真正“中断”线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然地调用线程的interrupt方法，以为这样就能取消线程。</p>
<p>对于以线程提供服务的程序模块而言，<strong>它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用interrupt。</strong>Java并发库的一些代码就提供了单独的取消/关闭方法，比如，Future接口提供了如下方法以取消任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>
<p>再如，ExecutorService提供了如下两个关闭方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第16章-并发包的基石"><a href="#第16章-并发包的基石" class="headerlink" title="第16章 并发包的基石"></a>第16章 并发包的基石</h2><p>15章介绍了线程的基本内容，在Java中还有一套并发工具包，位于包java.util.concurrent下，里面包括很多易用且高性能的并发开发工具。从本章开始，我们就来探讨Java并发工具包。本章主要介绍并发包的一些基础内容，分为3个小节：16.1节介绍最基本的原子变量及其背后的原理和思维；16.2节介绍可以替代synchronized的显式锁；16.3节介绍可以替代wait/notify的显式条件。</p>
<h3 id="16-1-原子变量和CAS"><a href="#16-1-原子变量和CAS" class="headerlink" title="16.1 原子变量和CAS"></a>16.1 原子变量和CAS</h3><p>什么是原子变量？为什么需要它们呢？我们从synchronized说起。在15.2节，我们介绍过Counter类，使用synchronized关键字保证原子更新操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于count++这种操作来说，使用synchronized成本太高了，需要先获取锁，最后需要释放锁，获取不到锁的情况下需要等待，还会有线程的上下文切换，这些都需要成本。</p>
<p>对于这种情况，完全可以使用原子变量代替，Java并发包中的基本原子变量类型有以下几种。</p>
<p>​    ❑ AtomicBoolean：原子Boolean类型，常用来在程序中表示一个标志位。</p>
<p>​    ❑ AtomicInteger：原子Integer类型。</p>
<p>​    ❑ AtomicLong：原子Long类型，常用来在程序中生成唯一序列号。</p>
<p>​    ❑ AtomicReference：原子引用类型，用来以原子方式更新复杂类型。</p>
<p>限于篇幅，我们主要介绍AtomicInteger。除了这4个类，还有一些其他类，如针对数组类型的类AtomicLongArray、AtomicReferenceArray，以及用于以原子方式更新对象中的字段的类，如AtomicIntegerFieldUpdater、AtomicReferenceFieldUpdater等。Java 8增加了几个类，在高并发统计汇总的场景中更为适合，包括LongAdder、LongAccumulator、Double-Adder和DoubleAccumulator，具体可参见API文档，我们就不介绍了。</p>
<h4 id="16-1-1-AtomicInteger"><a href="#16-1-1-AtomicInteger" class="headerlink" title="16.1.1 AtomicInteger"></a>16.1.1 AtomicInteger</h4><h5 id="1．基本用法"><a href="#1．基本用法" class="headerlink" title="1．基本用法"></a>1．基本用法</h5><p>AtomicInteger有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>第一个构造方法给定了一个初始值，第二个构造方法的初始值为0。</p>
<p>可以直接获取或设置AtomicInteger中的值，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>
<p>之所以称为原子变量，是因为它包含一些以原子方式实现组合操作的方法，部分方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式获取旧值并设置新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值加1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式获取旧值并给当前值加delta</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span></span><br><span class="line"><span class="comment">//以原子方式给当前值加1并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式给当前值减1并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">decrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以原子方式给当前值加delta并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span></span><br></pre></td></tr></table></figure>
<p>这些方法的实现都依赖另一个public方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>compareAndSet<strong>是一个非常重要的方法，比较并设置，我们以后将简称为CAS</strong>。该方法有两个参数expect和update，以原子方式实现了如下功能：如果当前值等于expect，则更新为update，否则不更新，如果更新成功，返回true，否则返回false。</p>
<p>AtomicInteger可以在程序中用作一个计数器，多个线程并发更新，也总能实现正确性。我们看个例子，如代码清单16-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Visitor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Visitor</span>();</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出总是正确的，为1000000。</p>
<h5 id="2．基本原理和思维"><a href="#2．基本原理和思维" class="headerlink" title="2．基本原理和思维"></a>2．基本原理和思维</h5><p>AtomicInteger的使用方法是简单直接的，它是怎么实现的呢？它的主要内部成员是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>它的声明带有volatile，这是必需的，以保证内存可见性。</strong></p>
<p>它的大部分更新方法实现都类似，我们看一个方法incrementAndGet，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(; ; ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码主体是个死循环，先获取当前值current，计算期望的值next，然后调用CAS方法进行更新，如果更新没有成功，说明value被别的线程改了，则再去取最新值并尝试更新直到成功为止。</p>
<p><strong>与synchronized锁相比</strong>，这种原子更新方式代表一种不同的思维方式。synchronized是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用CAS更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。synchronized代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。对于大部分比较简单的操作，无论是在低并发还是高并发情况下，这种乐观非阻塞方式的性能都远高于悲观阻塞式方式。</p>
<p>原子变量相对比较简单，但对于复杂一些的数据结构和算法，非阻塞方式往往难于实现和理解，幸运的是，Java并发包中已经提供了一些非阻塞容器，我们只需要会使用就可以了，比如：</p>
<p>​    ❑ ConcurrentLinkedQueue和ConcurrentLinkedDeque：非阻塞并发队列。</p>
<p>​    ❑ ConcurrentSkipListMap和ConcurrentSkipListSet：非阻塞并发Map和Set。</p>
<p>这些容器我们在后续章节介绍。</p>
<h5 id="3．实现锁"><a href="#3．实现锁" class="headerlink" title="3．实现锁"></a>3．实现锁</h5><p>基于CAS，除了可以实现乐观非阻塞算法之外，还可以实现悲观阻塞式算法，比如锁。实际上，Java并发包中的所有阻塞式工具、容器、算法也都是基于CAS的（不过，也需要一些别的支持）。怎么实现锁呢？我们演示一个简单的例子，用AtomicInteger实现一个锁MyLock，如代码清单16-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(! status.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        status.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MyLock中，使用status表示锁的状态，0表示未锁定，1表示锁定，lock()、unlock()使用CAS方法更新，lock()只有在更新成功后才退出，实现了阻塞的效果，不过一般而言，这种阻塞方式过于消耗CPU，我们后续章节介绍更为高效的方式。MyLock只是用于演示基本概念，实际开发中应该使用Java并发包中的类，如ReentrantLock。</p>
<h4 id="16-1-2-ABA问题"><a href="#16-1-2-ABA问题" class="headerlink" title="16.1.2 ABA问题"></a>16.1.2 ABA问题</h4><p>使用CAS方式更新有一个ABA问题。该问题是指，假设当前值为A，如果另一个线程先将A修改成B，再修改回成A，当前线程的CAS操作无法分辨当前值发生过变化。</p>
<p>ABA是不是一个问题与程序的逻辑有关，一般不是问题。而如果确实有问题，解决方法是使用AtomicStampedReference，在修改值的同时附加一个时间戳，只有值和时间戳都相同才进行修改，其CAS方法声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params">    V expectedReference, V newReference, <span class="type">int</span> expectedStamp, <span class="type">int</span> newStamp)</span></span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">AtomicStampedReference&lt;Pair&gt; pairRef = <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">AtomicStampedReference</span>&lt;Pair&gt;(pair, stamp);</span><br><span class="line"><span class="type">int</span> <span class="variable">newStamp</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">pairRef.compareAndSet(pair, <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">200</span>, <span class="number">200</span>), stamp, newStamp);</span><br></pre></td></tr></table></figure>
<p>AtomicStampedReference在compareAndSet中要同时修改两个值：一个是引用，另一个是时间戳。它怎么实现原子性呢？实际上，内部AtomicStampedReference会将两个值组合为一个对象，修改的是一个值，我们看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V    expectedReference, V    newReference,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> expectedStamp, <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">          expectedReference == current.reference &amp;&amp;</span><br><span class="line">          expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">          ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Pair是AtomicStampedReference的一个内部类，成员包括引用和时间戳，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> stamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reference = reference;</span><br><span class="line">        <span class="built_in">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AtomicStampedReference将对引用值和时间戳的组合比较和修改转换为了对这个内部类Pair单个值的比较和修改。</p>
<h3 id="16-2-显式锁"><a href="#16-2-显式锁" class="headerlink" title="16.2 显式锁"></a>16.2 显式锁</h3><p>15.2节介绍了利用synchronized实现锁，我们提到了synchronized的一些局限性，本节探讨Java并发包中的显式锁，它可以解决synchronized的限制。</p>
<p>Java并发包中的显式锁接口和类位于包java.util.concurrent.locks下，主要接口和类有：</p>
<p>​    ❑ 锁接口Lock，主要实现类是ReentrantLock；</p>
<p>​    ❑ 读写锁接口ReadWriteLock，主要实现类是ReentrantReadWriteLock。</p>
<p>本节主要介绍接口Lock和实现类ReentrantLock，关于读写锁，我们后续章节介绍。</p>
<h4 id="16-2-1-接口Lock"><a href="#16-2-1-接口Lock" class="headerlink" title="16.2.1 接口Lock"></a>16.2.1 接口Lock</h4><p>显式锁接口Lock的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）lock()/unlock()：就是普通的获取锁和释放锁方法，lock()会阻塞直到成功。</p>
<p>2）lockInterruptibly()：与lock()的不同是，它可以响应中断，如果被其他线程中断了，则抛出InterruptedException。</p>
<p>3）tryLock()：只是尝试获取锁，立即返回，不阻塞，如果获取成功，返回true，否则返回false。</p>
<p>4）tryLock(long time, TimeUnit unit)：先尝试获取锁，如果能成功则立即返回true，否则阻塞等待，但等待的最长时间由指定的参数设置，在等待的同时响应中断，如果发生了中断，抛出InterruptedException，如果在等待的时间内获得了锁，返回true，否则返回false。</p>
<p>5）newCondition：新建一个条件，一个Lock可以关联多个条件，关于条件，我们留待16.3节介绍。</p>
<p>可以看出，<strong>相比synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时</strong>，这使得它灵活得多。</p>
<h4 id="16-2-2-可重入锁ReentrantLock"><a href="#16-2-2-可重入锁ReentrantLock" class="headerlink" title="16.2.2 可重入锁ReentrantLock"></a>16.2.2 可重入锁ReentrantLock</h4><p>下面，先介绍ReentrantLock的基本用法，然后重点介绍如何使用tryLock避免死锁。</p>
<h5 id="1．基本用法-1"><a href="#1．基本用法-1" class="headerlink" title="1．基本用法"></a>1．基本用法</h5><p>Lock接口的主要实现类是ReentrantLock，它的基本用法lock/unlock实现了与syn-chronized一样的语义，包括：</p>
<p>​    ❑ 可重入，一个线程在持有一个锁的前提下，可以继续获得该锁；</p>
<p>​    ❑ 可以解决竞态条件问题；</p>
<p>​    ❑ 可以保证内存可见性。</p>
<p>ReentrantLock有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>参数fair表示是否保证公平，不指定的情况下，默认为false，表示不保证公平。所谓公平是指，等待时间最长的线程优先获得锁。<strong>保证公平会影响性能，一般也不需要，所以默认不保证</strong>，synchronized锁也是不保证公平的，16.2.3节还会再分析实现细节。</p>
<p>使用显式锁，一定要记得调用unlock。一般而言，应该将lock之后的代码包装到try语句内，在finally语句内释放锁。比如，使用ReentrantLock实现Counter，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2．使用tryLock避免死锁"><a href="#2．使用tryLock避免死锁" class="headerlink" title="2．使用tryLock避免死锁"></a>2．使用tryLock避免死锁</h5><p><strong>使用tryLock()，可以避免死锁</strong>。在持有一个锁获取另一个锁而获取不到的时候，可以释放已持有的锁，给其他线程获取锁的机会，然后重试获取所有锁。</p>
<p>我们来看个例子，银行账户之间转账，用类Account表示账户，如代码清单16-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">double</span> initialMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = initialMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money += money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> money;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Account里的money表示当前余额，add/reduce用于修改余额。在账户之间转账，需要两个账户都锁定，如果不使用tryLock，而直接使用lock，则代码如代码清单27-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountMgr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NoEnoughMoneyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">            <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">        from.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            to.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(from.getMoney() &gt;= money) &#123;</span><br><span class="line">                    from.reduce(money);</span><br><span class="line">                    to.add(money);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughMoneyException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                to.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            from.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这么写是有问题的，如果两个账户都同时给对方转账，都先获取了第一个锁，则会发生死锁。我们写段代码来模拟这个过程，如代码清单16-5所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simulateDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">accountNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> Account[] accounts = <span class="keyword">new</span> <span class="title class_">Account</span>[accountNum];</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accountNum; i++) &#123;</span><br><span class="line">          accounts[i] = <span class="keyword">new</span> <span class="title class_">Account</span>(rnd.nextInt(<span class="number">10000</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadNum];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">          threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; loopNum; k++) &#123;</span><br><span class="line">                      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rnd.nextInt(accountNum);</span><br><span class="line">                      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rnd.nextInt(accountNum);</span><br><span class="line">                      <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> rnd.nextInt(<span class="number">10</span>);</span><br><span class="line">                      <span class="keyword">if</span>(i ! = j) &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                                transfer(accounts[i], accounts[j], money);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (NoEnoughMoneyException e) &#123;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了10个账户，100个线程，每个线程执行100次循环，在每次循环中，随机挑选两个账户进行转账。在笔者的计算机中，每次执行该段代码都会发生死锁。读者可以更改这些数值进行试验。</p>
<p>我们使用tryLock来进行修改，先定义一个tryTransfer方法，如代码清单16-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">                <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">            <span class="keyword">if</span>(from.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(to.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(from.getMoney() &gt;= money) &#123;</span><br><span class="line">                                  from.reduce(money);</span><br><span class="line">                                  to.add(money);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoEnoughMoneyException</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            to.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        from.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个锁都能够获得，且转账成功，则返回true，否则返回false。不管怎样，结束都会释放所有锁。transfer方法可以循环调用该方法以避免死锁，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span></span><br><span class="line">        <span class="keyword">throws</span> NoEnoughMoneyException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        success = tryTransfer(from, to, money);</span><br><span class="line">        <span class="keyword">if</span>(! success) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (! success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了实现Lock接口中的方法，ReentrantLock还有一些其他方法，通过它们，可以获取关于锁的一些信息，这些信息可以用于监控和调试目的，具体可参看API文档，就不介绍了。</p>
<h4 id="16-2-3-ReentrantLock的实现原理"><a href="#16-2-3-ReentrantLock的实现原理" class="headerlink" title="16.2.3 ReentrantLock的实现原理"></a>16.2.3 ReentrantLock的实现原理</h4><p>ReentrantLock的用法是比较简单的，它是怎么实现的呢？在最底层，它依赖于16.1节介绍的CAS方法，另外，它依赖于类LockSupport中的一些方法。我们先介绍Lock-Support。</p>
<h5 id="1-LockSupport"><a href="#1-LockSupport" class="headerlink" title="1. LockSupport"></a>1. LockSupport</h5><p>类LockSupport也位于包java.util.concurrent.locks下，它的基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span></span><br></pre></td></tr></table></figure>
<p>park使得当前线程放弃CPU，进入等待状态（WAITING），操作系统不再对它进行调度，什么时候再调度呢？有其他线程对它调用了unpark, unpark使参数指定的线程恢复可运行状态。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            LockSupport.park();     <span class="comment">//放弃CPU</span></span><br><span class="line">                System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();     <span class="comment">//启动子线程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);     <span class="comment">//睡眠1秒确保子线程先运行</span></span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，主线程启动子线程t，线程t启动后调用park，放弃CPU，主线程睡眠1秒以确保子线程已执行LockSupport.park()，调用unpark，线程t恢复运行，输出exit。</p>
<p>park不同于Thread.yield(), yield只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而park会放弃调度资格，使线程进入WAITING状态。</p>
<p>需要说明的是，park<strong>是响应中断</strong>的，当有中断发生时，park会返回，线程的中断状态会被设置。另外还需要说明，park可能会无缘无故地返回，程序应该重新检查park等待的条件是否满足。</p>
<p>park有两个变体：</p>
<p>​    ❑ parkNanos：可以指定等待的最长时间，参数是相对于当前时间的纳秒数；</p>
<p>​    ❑ parkUntil：可以指定最长等到什么时候，参数是绝对时间，是相对于纪元时的毫秒数。</p>
<p>当等待超时的时候，它们也会返回。</p>
<p>这些park方法还有一些变体，可以指定一个对象，表示是由于该对象而进行等待的，以便于调试，通常传递的值是this，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span></span><br></pre></td></tr></table></figure>
<p>LockSupport有一个方法，可以返回一个线程的blocker对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBlocker</span><span class="params">(Thread t)</span></span><br></pre></td></tr></table></figure>
<p>这些park/unpark方法是怎么实现的呢？与CAS方法一样，它们也调用了Unsafe类中的对应方法。Unsafe类最终调用了操作系统的API，从程序员的角度，我们可以认为Lock-Support中的这些方法就是基本操作。</p>
<h5 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h5><p>利用CAS和LockSupport提供的基本方法，就可以用来实现ReentrantLock了。但Java中还有很多其他并发工具，如ReentrantReadWriteLock、Semaphore、CountDownLatch，它们的实现有很多类似的地方，<strong>为了复用代码，Java提供了一个抽象类AbstractQueued-Synchronizer</strong>，简称AQS，它简化了并发工具的实现。AQS的整体实现比较复杂，我们主要以ReentrantLock的使用为例进行简要介绍。</p>
<p>AQS封装了一个状态，给子类提供了查询和设置状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>用于实现锁时，AQS可以保存锁的当前持有线程，提供了方法进行查询和设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread t)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</p>
<p>下面，我们以ReentrantLock的使用为例简要介绍AQS的原理。</p>
<h5 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h5><p>ReentrantLock内部使用AQS，有三个内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br></pre></td></tr></table></figure>
<p>Sync是抽象类，NonfairSync是fair为false时使用的类，FairSync是fire为true时使用的类。ReentrantLock内部有一个Sync成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure>
<p>在构造方法中sync被赋值，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看ReentrantLock中的基本方法lock/unlock的实现。先看lock方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-2-4-对比ReentrantLock和synchronized"><a href="#16-2-4-对比ReentrantLock和synchronized" class="headerlink" title="16.2.4 对比ReentrantLock和synchronized"></a>16.2.4 对比ReentrantLock和synchronized</h4><p>相比synchronized, ReentrantLock可以实现与synchronized相同的语义，而且支持以非阻塞方式获取锁，可以响应中断，可以限时，更为灵活。不过，synchronized的使用更为简单，写的代码更少，也更不容易出错。</p>
<p>synchronized代表一种<strong>声明式编程思维</strong>，程序员更多的是表达一种同步声明，由Java系统负责具体实现，程序员不知道其实现细节；显式锁代表一种<strong>命令式编程</strong>思维，程序员实现所有细节。</p>
<p>声明式编程的好处除了简单，还在于性能，在较新版本的JVM上，ReentrantLock和synchronized的性能是接近的，但Java编译器和虚拟机可以不断优化synchronized的实现，比如自动分析synchronized的使用，对于没有锁竞争的场景，自动省略对锁获取/释放的调用。</p>
<p>简单总结下，能用synchronized就用synchronized，不满足要求时再考虑ReentrantLock。</p>
<h3 id="16-3-显式条件"><a href="#16-3-显式条件" class="headerlink" title="16.3 显式条件"></a>16.3 显式条件</h3><p>16.2节我们介绍了显式锁，本节介绍关联的显式条件，介绍其用法和原理。显式条件在不同上下文中也可以被称为条件变量、<strong>条件队列</strong>、或条件，后文我们可能会交替使用。</p>
<h4 id="16-3-1-用法"><a href="#16-3-1-用法" class="headerlink" title="16.3.1 用法"></a>16.3.1 用法</h4><p>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，而显式条件与wait/notify相对应。wait/notify与synchronized配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，</p>
<p>Lock接口定义了创建方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Condition表示条件变量，是一个接口，它的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await对应于Object的wait, signal对应于notify, signalAll对应于notifyAll，语义也是一样的。</p>
<p>与Object的wait方法类似，await也有几个限定等待时间的方法，但功能更多一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待时间是相对时间，如果由于等待超时返回，返回值为false，否则为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//等待时间也是相对时间，但参数单位是纳秒，返回值是nanosTimeout减去实际等待的时间</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//等待时间是绝对时间，如果由于等待超时返回，返回值为false，否则为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>这些await方法都是响应中断的，如果发生了中断，会抛出InterruptedException，但中断标志位会被清空。Condition还定义了一个不响应中断的等待方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>该方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。</p>
<p>一般而言，与Object的wait方法一样，<strong>调用await方法前需要先获取锁</strong>，如果没有锁，会抛出异常IllegalMonitorStateException。</p>
<p>await<strong>在进入等待队列后，会释放锁，释放CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从await方法中退出。</strong></p>
<p>另外，与Object的wait方法一样，await返回后，不代表其等待的条件就一定满足了，通常要将await的调用放到一个循环内，只有条件满足后才退出。</p>
<p>一般而言，signal/signalAll与notify/notifyAll一样，调用它们需要先获取锁，如果没有锁，会抛出异常IllegalMonitorStateException。signal与notify一样，挑选一个线程进行唤醒，signalAll与notifyAll一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从await调用中返回。</p>
<p>ReentrantLock实现了newCondition方法，通过它，我们来看下条件的基本用法。我们实现与15.3节类似的例子WaitThread，一个线程启动后，在执行一项操作前，等待主线程给它指令，收到指令后才执行，示例代码如代码清单16-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (! fire) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        waitThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，<strong>不要将</strong>signal/signalAll与notify/notifyAll混淆，notify/notifyAll是Object中定义的方法，Condition对象也有，稍不注意就会误用。比如，对上面例子中的fire方法，可能会写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">        condition.notify();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写成这样，编译器不会报错，但运行时会抛出IllegalMonitorStateException，因为notify的调用不在synchronized语句内。同样，避免将锁与synchronized混用，那样非常令人混淆，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，显式条件与显式锁配合，wait/notify与synchronized配合。</p>
<h2 id="第17章-并发容器"><a href="#第17章-并发容器" class="headerlink" title="第17章 并发容器"></a>第17章 并发容器</h2><p>本章，我们探讨Java并发包中的容器类，具体包括：</p>
<p>❑ 写时复制的List和Set；</p>
<p>❑ ConcurrentHashMap；</p>
<p>❑ 基于SkipList的Map和Set；</p>
<p>❑ 各种并发队列。</p>
<p>它们都有什么用？如何使用？与普通容器类相比，有哪些特点？是如何实现的？本章进行详细讨论。</p>
<h3 id="17-1-写时复制的List和Set"><a href="#17-1-写时复制的List和Set" class="headerlink" title="17.1 写时复制的List和Set"></a>17.1 写时复制的List和Set</h3><p>本节先介绍两个简单的类：CopyOnWriteArrayList和CopyOnWriteArraySet，讨论它们的用法和实现原理。它们的用法比较简单，我们需要理解的是它们的实现机制。Copy-On-Write即<strong>写时复制</strong>，或称<strong>写时拷贝</strong>，这是解决并发问题的一种重要思路。</p>
<h4 id="17-1-1-CopyOnWriteArrayList"><a href="#17-1-1-CopyOnWriteArrayList" class="headerlink" title="17.1.1 CopyOnWriteArrayList"></a>17.1.1 CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList实现了List接口，它的用法与其他List（如ArrayList）基本是一样的。CopyOnWriteArrayList的特点如下：</p>
<p>❑ 它是线程安全的，可以被多个线程并发访问；</p>
<p>❑ 它的迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</p>
<p>❑ 它以原子方式支持一些复合操作。</p>
<p>我们在15.2.3节提到过基于synchronized的同步容器的几个问题。迭代时，需要对整个列表对象加锁，否则会抛出ConcurrentModificationException,CopyOnWriteArrayList没有这个问题，<strong>迭代时不需要加锁</strong>。</p>
<p>基于synchronized的同步容器的另一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而CopyOnWriteArrayList直接支持两个原子方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不存在才添加，如果添加了，返回true，否则返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">//批量添加c中的非重复元素，不存在才添加，返回实际添加的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时复制。</p>
<p>所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。</p>
<p>换句话说，数组内容是只读的，写操作都是通过新建数组，然后原子性地修改数组引用来实现的。下面我们通过代码具体介绍（基于Java 7），包括内部组成、构造方法、add方法和indexOf方法。</p>
<p>内部数组声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br></pre></td></tr></table></figure>
<p>注意：它声明为了volatile，这是必需的，以保证内存可见性，即保证在写操作更改之后读操作能看到。有两个方法用来访问/设置该数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CopyOnWriteArrayList中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁。CopyOnWriteArrayList内部使用Reentrant-Lock，成员声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
<p>默认构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是设置了一个空数组。</p>
<p>add方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码也容易理解，add方法是修改操作，整个过程需要被锁保护，先获取当前数组elements，然后复制出一个长度加1的新数组newElements，在新数组中添加元素，最后调用setArray原子性地修改内部数组引用。</p>
<p>查找元素indexOf的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先获取当前数组elements，然后调用另一个indexOf进行查找，具体代码就不列举了。这个indexOf方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题。</p>
<p>每次修改都要创建一个新数组，然后复制所有内容，这听上去是一个难以令人接受的方案，如果数组比较大，修改操作又比较频繁，可以想象，CopyOnWriteArrayList的性能是很低的。事实确实如此，CopyOnWriteArrayList不适用于数组很大且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时牺牲了写的性能。</p>
<p>之前我们<strong>介绍了保证线程安全的两种思路：一种是锁，使用synchronized或Reentrant-Lock；另外一种是循环CAS</strong>，写时复制体现了保证线程安全的另一种思路。锁和循环CAS都是控制对同一个资源的访问冲突，而写时复制通过复制资源减少冲突。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，写时复制就是一种很好的解决方案。</p>
<p>写时复制是一种重要的思维，用于各种计算机程序中，比如操作系统内部的进程管理和内存管理。在进程管理中，子进程经常共享父进程的资源，只有在写时才复制。在内存管理中，当多个程序同时访问同一个文件时，操作系统在内存中可能只会加载一份，只有程序要写时才会复制，分配自己的内存，复制可能也不会全部复制，只会复制写的位置所在的[插图]。</p>
<h4 id="17-1-2-CopyOnWriteArraySet"><a href="#17-1-2-CopyOnWriteArraySet" class="headerlink" title="17.1.2 CopyOnWriteArraySet"></a>17.1.2 CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet实现了Set接口，不包含重复元素，使用比较简单，我们就不赘述了。下面，主要介绍其内部组成，以及add与contains方法的代码。CopyOnWriteArraySet内部是通过CopyOnWriteArrayList实现的，其成员声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>
<p>由于CopyOnWriteArraySet是基于CopyOnWriteArrayList实现的，所以与之前介绍过的Set的实现类如HashSet/TreeSet相比，它的性能比较低，不适用于元素个数特别多的集合。如果元素个数比较多，可以考虑ConcurrentHashMap或ConcurrentSkipListSet这两个类，我们稍后介绍。</p>
<p>简单总结下，CopyOnWriteArrayList和CopyOnWriteArraySet适用于读远多于写、集合不太大的场合，它们采用了写时复制，这是计算机程序中一种重要的思维和技术。</p>
<h3 id="17-2-ConcurrentHashMap"><a href="#17-2-ConcurrentHashMap" class="headerlink" title="17.2 ConcurrentHashMap"></a>17.2 ConcurrentHashMap</h3><p>本节介绍一个常用的并发容器ConcurrentHashMap，它是HashMap的并发版本，与HashMap相比，它有如下特点：</p>
<p>❑ 并发安全；</p>
<p>❑ 直接支持一些原子复合操作；</p>
<p>❑ 支持高并发，读操作完全并行，写操作支持一定程度的并行；</p>
<p>❑ 与同步容器Collections.synchronizedMap相比，迭代不用加锁，不会抛出Concurre ntModificationException；</p>
<p>❑ 弱一致性。</p>
<p>下面我们分别介绍。</p>
<h4 id="17-2-1-并发安全"><a href="#17-2-1-并发安全" class="headerlink" title="17.2.1 并发安全"></a>17.2.1 并发安全</h4><p>需要了解的是，HashMap不是并发安全的，在并发更新的情况下，HashMap可能出现死循环，占满CPU。我们看个例子，如代码清单17-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unsafeConcurrentUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    map.put(rnd.nextInt(), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，在笔者的计算机中，无论是Java 7还是Java 8环境，每次都会出现死循环，占满CPU。</p>
<p>为什么会出现死循环呢？死循环出现在多个线程同时扩容哈希表的时候。</p>
<p>使用Collections.synchronizedMap方法可以生成一个同步容器，以避免产生死循环，替换第一行代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;());</span><br></pre></td></tr></table></figure>
<p>同步容器有几个问题：</p>
<p>❑ 每个方法都需要同步，支持的并发度比较低；</p>
<p>❑ 对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。</p>
<p>ConcurrentHashMap没有这些问题，它同样实现了Map接口，也是基于哈希表实现的，上面的代码替换第一行即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="17-2-2-原子复合操作"><a href="#17-2-2-原子复合操作" class="headerlink" title="17.2.2 原子复合操作"></a>17.2.2 原子复合操作</h4><p>除了Map接口，ConcurrentHashMap还实现了一个接口ConcurrentMap，接口定义了一些条件更新操作，Java 7中的具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">//条件更新，如果Map中没有key，设置key为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果没有，返回null</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">//条件删除，如果Map中有key，且对应的值为value，则删除，如果删除了，返回true，</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，且对应的值为oldValue，则替换为newValue，</span></span><br><span class="line">    <span class="comment">//如果替换了，返回ture，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，则替换值为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果原来没有，返回null</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;        <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">//条件更新，如果Map中没有key，设置key为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果没有，返回null</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">//条件删除，如果Map中有key，且对应的值为value，则删除，如果删除了，返回true，</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，且对应的值为oldValue，则替换为newValue，</span></span><br><span class="line">    <span class="comment">//如果替换了，返回ture，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">//条件替换，如果Map中有key，则替换值为value，返回原来key对应的值，</span></span><br><span class="line">    <span class="comment">//如果原来没有，返回null</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8增加了几个默认方法，包括getOrDefault、forEach、computeIfAbsent、merge等，具体可参见API文档，我们就不介绍了。如果使用同步容器，调用方必须加锁，而Concurrent-HashMap将它们实现为了原子操作。实际上，使用ConcurrentHashMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用synchronized。</p>
<h4 id="17-2-3-高并发的基本机制"><a href="#17-2-3-高并发的基本机制" class="headerlink" title="17.2.3 高并发的基本机制"></a>17.2.3 高并发的基本机制</h4><p>ConcurrentHashMap是为高并发设计的，它是怎么做的呢？具体实现比较复杂，我们简要介绍其思路，在Java 7中，主要有两点：</p>
<p>❑ 分段锁；❑ 读不需要锁。</p>
<p>同步容器使用synchronized，所有方法竞争同一个锁；<strong>而ConcurrentHashMap采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁</strong>，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。</p>
<p>采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是16个，不过，这个数字可以通过构造方法进行设置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span></span><br></pre></td></tr></table></figure>
<p>在对每个段的数据进行读写时，ConcurrentHashMap也不是简单地使用锁进行同步，内部使用了CAS。对一些写采用原子方式的方法，实现比较复杂，我们就不介绍了。实现的效果是，<strong>对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读</strong>，这使得ConcurrentHashMap的并行度远高于同步容器。</p>
<p>Java 8对ConcurrentHashMap的实现进一步做了优化。首先，与HashMap的改进类似，在哈希冲突比较严重的时候，会将单向链表转化为平衡的排序二叉树，提高查找的效率；其次，锁的粒度进一步细化了，以提高并行性，哈希表数组中的每个位置（指向一个单链表或树）都有一个单独的锁，具体比较复杂，我们就不介绍了。</p>
<h4 id="17-2-4-迭代安全"><a href="#17-2-4-迭代安全" class="headerlink" title="17.2.4 迭代安全"></a>17.2.4 迭代安全</h4><p>我们在15.2.3节介绍过，使用同步容器，在迭代中需要加锁，否则可能会抛出Concurrent-ModificationException。ConcurrentHashMap没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。</p>
<p>问题是，迭代会反映其他线程的修改吗？还是像CopyOnWriteArrayList一样，反映的是创建时的副本？答案是，都不是！我们看个例子，如代码清单17-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapIteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; map =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(entry.getKey() + <span class="string">&quot;, &quot;</span> + entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 确保线程t1启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          test();</span><br><span class="line">      &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>t1启动后，创建迭代器，但在迭代输出每个元素前，先睡眠1秒，主线程启动t1后，先睡眠一下，确保t1先运行，然后给map增加了一个元素，程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, <span class="keyword">abstract</span></span><br><span class="line">b, basic</span><br><span class="line">c, call</span><br></pre></td></tr></table></figure>
<p>上述代码说明迭代器反映了最新的更新。将添加语句更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>会发现程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, <span class="keyword">abstract</span></span><br><span class="line">b, basic</span><br></pre></td></tr></table></figure>
<p>这说明迭代器没有反映最新的更新。需要说明的是，这是Java 7的输出，Java 8和Java 9的实现不太一样，输出也不太一样，但也有相同的问题。到底是怎么回事呢？这需要我们理解ConcurrentHashMap的弱一致性。</p>
<h4 id="17-2-5-弱一致性"><a href="#17-2-5-弱一致性" class="headerlink" title="17.2.5 弱一致性"></a>17.2.5 弱一致性</h4><p>ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<p>类似的情况还会出现在ConcurrentHashMap的另一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加m中的键值对到当前Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>该方法并非原子操作，而是调用put方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。</p>
<h3 id="17-3-基于跳表的Map和Set"><a href="#17-3-基于跳表的Map和Set" class="headerlink" title="17.3 基于跳表的Map和Set"></a>17.3 基于跳表的Map和Set</h3><p>Java并发包中与TreeMap/TreeSet对应的并发版本是ConcurrentSkipListMap和Concurrent-SkipListSet，本节就来简要探讨这两个类，先介绍基本概念，然后介绍基本实现原理。</p>
<h4 id="17-3-1-基本概念"><a href="#17-3-1-基本概念" class="headerlink" title="17.3.1 基本概念"></a>17.3.1 基本概念</h4><p>我们知道，TreeSet是基于TreeMap实现的，与此类似，ConcurrentSkipListSet也是基于ConcurrentSkipListMap实现的，所以我们主要介绍ConcurrentSkipListMap。</p>
<p>ConcurrentSkipListMap是基于SkipList实现的，SkipList称为跳跃表或跳表，是一种数据结构，稍后我们会进一步介绍。并发版本为什么采用跳表而不是树呢？原因也很简单，因为跳表更易于实现高效并发算法。ConcurrentSkipListMap有如下特点。</p>
<p>1）没有使用锁，所有操作都是无阻塞的，所有操作都可以并行，包括写，多线程可以同时写。</p>
<p>2）与ConcurrentHashMap类似，迭代器不会抛出ConcurrentModificationException，是弱一致的，迭代可能反映最新修改也可能不反映，一些方法如putAll、clear不是原子的。</p>
<p>3）与ConcurrentHashMap类似，同样实现了ConcurrentMap接口，支持一些原子复合操作。</p>
<p>4）与TreeMap一样，可排序，默认按键的自然顺序，也可以传递比较器自定义排序，实现了SortedMap和NavigableMap接口</p>
<p>看段简单的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;(</span><br><span class="line">            Collections.reverseOrder());</span><br><span class="line">    map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;c=call, b=basic, a=<span class="keyword">abstract</span>&#125;</span><br></pre></td></tr></table></figure>
<p>表示是有序的。</p>
<p>我们之前介绍过ConcurrentSkipListMap的大部分方法，有序的方法与TreeMap是类似的，原子复合操作与ConcurrentHashMap是类似的，此处不再赘述。</p>
<p>需要说明的是ConcurrentSkipListMa的size方法，与大多数容器实现不同，这个方法不是常量操作，它需要遍历所有元素，复杂度为O(N)，而且遍历结束后，元素个数可能已经变了。一般而言，在并发应用中，这个方法用处不大。下面我们主要介绍其基本实现原理。</p>
<h4 id="17-3-2-基本实现原理"><a href="#17-3-2-基本实现原理" class="headerlink" title="17.3.2 基本实现原理"></a>17.3.2 基本实现原理</h4><p>我们先来介绍跳表的结构，<strong>跳表是基于链表的，在链表的基础上加了多层索引结构</strong>。我们通过一个简单的例子来说明。假定容器中包含如下元素：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3, 6, 7, 9, 12, 17, 19, 21, 25, 26</span><br></pre></td></tr></table></figure>
<p>对Map来说，这些值可以视为键。ConcurrentSkipListMap会构造类似图17-1所示的跳表结构。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310081945063.png" alt="image-20231008194535879"></p>
<p>最下面一层就是最基本的单向链表，这个链表是有序的。虽然是有序的，但我们知道，与数组不同，链表不能根据索引直接定位，不能进行二分查找。</p>
<p>为了快速查找，跳表有多层索引结构，这个例子中有两层，第一层有5个节点，第二层有2个节点。<strong>高层的索引节点一定同时是低层的索引节点</strong>，比如9和21。高层的索引节点少，低层的多。统计概率上，第一层索引节点是实际元素数的1/2，第二层是第一层的1/2，逐层减半，但这不是绝对的，有随机性，只是大致如此。每个索引节点有两个指针：一个向右，指向下一个同层的索引节点；另一个向下，指向下一层的索引节点或基本链表节点。</p>
<p><strong>有了这个结构，就可以实现类似二分查找了</strong>。查找元素总是从最高层开始，将待查值与下一个索引节点的值进行比较，如果大于索引节点，就向右移动，继续比较，如果小于索引节点，则向下移动到下一层进行比较。图17-2所示的两条线展示了查找值19和8的过程。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310081948549.png" alt="image-20231008194843437"></p>
<p>对于值19，查找过程是：</p>
<p>1）与9相比，大于9；</p>
<p>2）向右与21相比，小于21；</p>
<p>3）向下与17相比，大于17；</p>
<p>4）向右与21相比，小于21；</p>
<p>5）向下与19相比，找到。</p>
<p>对于值8，查找过程是：</p>
<p>1）与9相比，小于9；</p>
<p>2）向下与6相比，大于6；</p>
<p>3）向右与9相比，小于9；</p>
<p>4）向下与7相比，大于7；</p>
<p>5）向右与9相比，小于9，不能再向下，没找到。</p>
<p>这个结构是有序的，查找的性能与二叉树类似，复杂度是O(log(N))。不过，这个结构是如何构建起来的呢？与二叉树类似，这个结构是在更新过程中进行保持的，保存元素的基本思路是：</p>
<p>1）先保存到基本链表，找到待插入的位置，找到位置后，插入基本链表；2）更新索引层。</p>
<p>略</p>
<h3 id="17-4-并发队列"><a href="#17-4-并发队列" class="headerlink" title="17.4 并发队列"></a>17.4 并发队列</h3><p>本节，我们介绍Java并发包中的各种队列。Java并发包提供了丰富的队列类，可以简单分为以下几种。</p>
<p>❑ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque。</p>
<p>❑ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque。</p>
<p>❑ 优先级阻塞队列：PriorityBlockingQueue。</p>
<p>❑ 延时阻塞队列：DelayQueue。</p>
<p>❑ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue。</p>
<p>无锁非阻塞是指，这些队列不使用锁，所有操作总是可以立即执行，主要通过循环CAS实现并发安全。阻塞队列是指，这些队列使用锁和条件，很多操作都需要先获取锁或满足特定条件，获取不到锁或等待条件时，会等待（即阻塞），获取到锁或条件满足再返回。</p>
<p>这些队列迭代都不会抛出ConcurrentModificationException，都是弱一致的，后面就不单独强调了。下面，我们来简要介绍每类队列的用途、用法和基本实现原理。</p>
<h4 id="17-4-1-无锁非阻塞并发队列"><a href="#17-4-1-无锁非阻塞并发队列" class="headerlink" title="17.4.1 无锁非阻塞并发队列"></a>17.4.1 无锁非阻塞并发队列</h4><p>有两个无锁非阻塞队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque，它们适用于多个线程并发使用一个队列的场合，都是基于链表实现的，都没有限制大小，是无界的，与ConcurrentSkipListMap类似，它们的size方法不是一个常量运算，不过这个方法在并发应用中用处也不大。</p>
<p>ConcurrentLinkedQueue实现了Queue接口，表示一个先进先出的队列，从尾部入队，从头部出队，内部是一个单向链表。ConcurrentLinkedDeque实现了Deque接口，表示一个双端队列，在两端都可以入队和出队，内部是一个双向链表。它们的用法类似于Linked-List，我们就不赘述了。</p>
<p>这两个类最基础的原理是循环CAS, ConcurrentLinkedQueue的算法基于一篇论文《Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithm》（<a target="_blank" rel="noopener" href="https://www.research.ibm.com/people/m/michael/podc-1996.pdf）。ConcurrentLinkedDeque扩展了Con-currentLinkedQueue的技术，但它们的具体实现都非常复杂，我们就不探讨了。">https://www.research.ibm.com/people/m/michael/podc-1996.pdf）。ConcurrentLinkedDeque扩展了Con-currentLinkedQueue的技术，但它们的具体实现都非常复杂，我们就不探讨了。</a></p>
<h4 id="17-4-2-普通阻塞队列"><a href="#17-4-2-普通阻塞队列" class="headerlink" title="17.4.2 普通阻塞队列"></a>17.4.2 普通阻塞队列</h4><p>除了刚介绍的两个队列，其他队列都是阻塞队列，都实现了接口BlockingQueue，在入队/出队时可能等待，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队，如果队列满，等待直到队列有空间</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//出队，如果队列空，等待直到队列不为空，返回头部元素</span></span><br><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//入队，如果队列满，最多等待指定的时间，如果超时还是满，返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//出队，如果队列空，最多等待指定的时间，如果超时还是空，返回null</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>普通阻塞队列是<strong>常用的队列</strong>，常用于生产者/消费者模式。</p>
<p>ArrayBlockingQueue和LinkedBlockingQueue都实现了Queue接口，表示先进先出的队列，尾部进，头部出，而LinkedBlockingDeque实现了Deque接口，是一个双端队列。</p>
<p>ArrayBlockingQueue是基于循环数组实现的，有界，创建时需要指定大小，且在运行过程中不会改变，这与我们在容器类中介绍的ArrayDeque是不同的，ArrayDeque也是基于循环数组实现的，但是是无界的，会自动扩展。</p>
<p>LinkedBlockingQueue是基于单向链表实现的，在创建时可以指定最大长度，也可以不指定，默认是无限的，节点都是动态创建的。LinkedBlockingDeque与LinkedBlocking-Queue一样，最大长度也是在创建时可选的，默认无限，不过，它是基于双向链表实现的。</p>
<p>内部，它们都是使用显式锁ReentrantLock和显式条件Condition实现的。</p>
<p>ArrayBlockingQueue的实现很直接，有一个数组存储元素，有两个索引表示头和尾，有一个变量表示当前元素个数，有一个锁保护所有访问，有“不满”和“不空”两个条件用于协作，实现思路与我们在15.3.3节实现的类似，就不赘述了。</p>
<p>与ArrayBlockingQueue类似，LinkedBlockingDeque也是使用一个锁和两个条件，使用锁保护所有操作，使用“不满”和“不空”两个条件。LinkedBlockingQueue稍微不同，因为它使用链表，且只从头部出队、从尾部入队，它做了一些优化，使用了两个锁，一个保护头部，一个保护尾部，每个锁关联一个条件。</p>
<h4 id="17-4-3-优先级阻塞队列"><a href="#17-4-3-优先级阻塞队列" class="headerlink" title="17.4.3 优先级阻塞队列"></a>17.4.3 优先级阻塞队列</h4><p>普通阻塞队列是先进先出的，而优先级队列是按优先级出队的，优先级高的先出，我们在容器类中介绍过优先级队列PriorityQueue及其背后的数据结构堆。Priority-BlockingQueue是PriorityQueue的并发版本，与PriorityQueue一样，它没有大小限制，是无界的，内部的数组大小会动态扩展，要求元素要么实现Comparable接口，要么创建Priority-BlockingQueue时提供一个Comparator对象。</p>
<p>与PriorityQueue的区别是，PriorityBlockingQueue实现了BlockingQueue接口，在队列为空时，take方法会阻塞等待。另外，PriorityBlockingQueue是线程安全的，它的基本实现原理与PriorityQueue是一样的，也是基于堆，但它使用了一个锁ReentrantLock保护所有访问，使用了一个条件协调阻塞等待。</p>
<h4 id="17-4-4-延时阻塞队列"><a href="#17-4-4-延时阻塞队列" class="headerlink" title="17.4.4 延时阻塞队列"></a>17.4.4 延时阻塞队列</h4><p>延时阻塞队列DelayQueue是一种特殊的优先级队列，它是无界的。它要求每个元素都实现Delayed接口，该接口的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delayed扩展了Comparable接口，也就是说，DelayQueue的每个元素都是可比较的，它有一个额外方法getDelay返回一个给定时间单位unit的整数，表示再延迟多长时间，如果小于等于0，则表示不再延迟。</p>
<p>DelayQueue可以用于实现定时任务，它按元素的延时时间出队。它的特殊之处在于，只有当元素的延时过期之后才能被从队列中拿走，也就是说，take方法总是返回第一个过期的元素，如果没有，则阻塞等待。</p>
<p>DelayQueue是基于PriorityQueue实现的，它使用一个锁ReentrantLock保护所有访问，使用一个条件available表示头部是否有元素，当头部元素的延时未到时，take操作会根据延时计算需睡眠的时间，然后睡眠，如果在此过程中有新的元素入队，且成为头部元素，则阻塞睡眠的线程会被提前唤醒然后重新检查。这是基本思路，DelayQueue的实现有一些优化，以减少不必要的唤醒，具体我们就不探讨了。</p>
<h4 id="17-4-5-其他阻塞队列"><a href="#17-4-5-其他阻塞队列" class="headerlink" title="17.4.5 其他阻塞队列"></a>17.4.5 其他阻塞队列</h4><p>Java并发包中还有两个特殊的阻塞队列：SynchronousQueue和LinkedTransferQueue。</p>
<p>SynchronousQueue与一般的队列不同，它不算一种真正的队列，没有存储元素的空间，连存储一个元素的空间都没有。它的入队操作要等待另一个线程的出队操作，反之亦然。如果没有其他线程在等待从队列中接收元素，put操作就会等待。take操作需要等待其他线程往队列中放元素，如果没有，也会等待。SynchronousQueue适用于两个线程之间直接传递信息、事件或任务。</p>
<p>LinkedTransferQueue实现了TransferQueue接口，TransferQueue是BlockingQueue的子接口，但增加了一些额外功能，生产者在往队列中放元素时，可以等待消费者接收后再返回，适用于一些消息传递类型的应用中。TransferQueue的接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransferQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//如果有消费者在等待(执行take或限时的poll)，直接转给消费者，</span></span><br><span class="line">    <span class="comment">//返回true，否则返回false，不入队</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//如果有消费者在等待，直接转给消费者，否则入队，阻塞等待直到被消费者接收后再返回</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//如果有消费者在等待，直接转给消费者，返回true</span></span><br><span class="line">    <span class="comment">//否则入队，阻塞等待限定的时间，如果最后被消费者接收，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//是否有消费者在等待</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasWaitingConsumer</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//等待的消费者个数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getWaitingConsumerCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedTransferQueue是基于链表实现的、无界的TransferQueue，具体实现比较复杂，我们就不探讨了。</p>
<p>Java并发包中还提供了一种方便的任务执行服务，使用它，可以将要执行的并发任务与线程的管理相分离，大大简化并发任务和线程的管理，让我们下一章来探讨。</p>
<h2 id="第18章-异步任务执行服务"><a href="#第18章-异步任务执行服务" class="headerlink" title="第18章 异步任务执行服务"></a>第18章 异步任务执行服务</h2><p>在之前的介绍中，线程Thread既表示要执行的任务，又表示执行的机制。Java并发包提供了一套框架，大大简化了执行异步任务所需的开发。这套框架引入了一个“执行服务”的概念，它将“任务的提交”和“任务的执行”相分离，“执行服务”封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。</p>
<p>本章我们就来探讨这套框架，具体分为3个小节：18.1节介绍基本概念和原理；18.2节介绍任务执行服务的主要实现机制：线程池；18.3节介绍定时任务的执行服务。</p>
<h3 id="18-1-基本概念和原理"><a href="#18-1-基本概念和原理" class="headerlink" title="18.1 基本概念和原理"></a>18.1 基本概念和原理</h3><p>下面，我们来看异步任务执行服务的基本接口、用法和实现原理。</p>
<h4 id="18-1-1-基本接口"><a href="#18-1-1-基本接口" class="headerlink" title="18.1.1 基本接口"></a>18.1.1 基本接口</h4><p>首先，我们来看任务执行服务涉及的基本接口：</p>
<p>❑ Runnable和Callable：表示要执行的异步任务。</p>
<p>❑ Executor和ExecutorService：表示执行服务。</p>
<p>❑ Future：表示异步任务的结果。</p>
<p>关于Runnable和Callable，我们在前面章节都已经了解了，都表示任务，Runnable没有返回结果，而Callable有，Runnable不会抛出异常，而Callable会。</p>
<p>Executor表示最简单的执行服务，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是可以执行一个Runnable，没有返回结果。接口没有限定任务如何执行，可能是创建一个新线程，可能是复用线程池中的某个线程，也可能是在调用者线程中执行。</p>
<p>ExecutorService扩展了Executor，定义了更多服务，基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">    Future&lt;? &gt; submit(Runnable task);</span><br><span class="line">    <span class="comment">//... 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个submit都表示提交一个任务，返回值类型都是Future，返回后，只是表示任务已提交，不代表已执行，通过Future可以查询异步任务的状态、获取最终结果、取消任务等。我们知道，对于Callable，任务最终有个返回值，而对于Runnable是没有返回值的；第二个提交Runnable的方法可以同时提供一个结果，在异步任务结束时返回；第三个方法异步任务的最终返回值为null。</p>
<p>我们来看Future接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">        ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待，另一个get方法可以限定阻塞等待的时间，如果超时任务还未结束，会抛出TimeoutException。</p>
<p>cancel用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消， cancel返回false，否则返回true。如果任务还未开始，则不再运行。但如果任务已经在运行，则不一定能取消，参数mayInterruptIfRunning表示，如果任务正在执行，是否调用interrupt方法中断线程，如果为false就不会，如果为true，就会尝试中断线程，但我们从15.4节知道，中断不一定能取消线程。</p>
<p>isDone和isCancelled用于查询任务状态。isCancelled表示任务是否被取消，只要cancel方法返回了true，随后的isCancelled方法都会返回true，即使执行任务的线程还未真正结束。isDone表示任务是否结束，不管什么原因都算，可能是任务正常结束，可能是任务抛出了异常，也可能是任务被取消。</p>
<p>我们再来看下get方法，任务最终大概有三种结果：</p>
<p>1）正常完成，get方法会返回其执行结果，如果任务是Runnable且没有提供结果，返回null。</p>
<p>2）任务执行抛出了异常，get方法会将异常包装为ExecutionException重新抛出，通过异常的getCause方法可以获取原异常。</p>
<p>3）任务被取消了，get方法会抛出异常CancellationException。</p>
<p>如果调用get方法的线程被中断了，get方法会抛出InterruptedException。</p>
<p>Future<strong>是一个重要的概念，是实现“任务的提交”与“任务的执行”相分离的关键，是其中的“纽带”，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。</strong></p>
<h4 id="18-1-2-基本用法"><a href="#18-1-2-基本用法" class="headerlink" title="18.1.2 基本用法"></a>18.1.2 基本用法</h4><p>说了这么多接口，具体怎么用呢？我们看个简单的例子，如代码清单18-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sleepSeconds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">            Thread.sleep(sleepSeconds);</span><br><span class="line">            <span class="keyword">return</span> sleepSeconds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="comment">//模拟执行其他任务</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用工厂类Executors创建了一个任务执行服务。Executors有多个静态方法，可以用来创建ExecutorService，这里使用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>表示使用一个线程执行所有服务，后续我们会详细介绍Executors，注意与Executor相区别，后者是单数，是接口。</p>
<p>不管ExecutorService是如何创建的，对使用者而言，用法都一样，例子提交了一个任务，提交后，可以继续执行其他事情，随后可以通过Future获取最终结果或处理任务执行的异常。</p>
<p>最后，我们调用了ExecutorService的shutdown方法，它会关闭任务执行服务。</p>
<p>前面我们只是介绍了ExecutorService的三个submit方法，其实它还有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个关闭方法：shutdown和shutdownNow。区别是，shutdown表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行；shutdownNow不仅不接受新任务，而且会终止已提交但尚未执行的任务，对于正在执行的任务，一般会调用线程的interrupt方法尝试中断，不过，线程可能不响应中断，shutdownNow会返回已提交但尚未执行的任务列表。</p>
<p>shutdown和shutdownNow不会阻塞等待，它们返回后不代表所有任务都已结束，不过isShutdown方法会返回true。调用者可以通过awaitTermination等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即isTerminated方法返回true，则返回true，否则返回false。</p>
<p>ExecutorService有两组批量提交任务的方法：invokeAll和invokeAny，它们都有两个版本，其中一个限定等待时间。</p>
<p>invokeAll等待所有任务完成，返回的Future列表中，每个Future的isDone方法都返回true，不过isDone为true不代表任务就执行成功了，可能是被取消了。invokeAll可以指定等待时间，如果超时后有的任务没完成，就会被取消。</p>
<p>而对于invokeAny，只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消；如果没有任务能在限时内成功返回，抛出TimeoutException；如果限时内所有任务都结束了，但都发生了异常，抛出ExecutionException。</p>
<p>使用ExecutorService，编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。</p>
<h2 id="第19章-同步和协作工具类"><a href="#第19章-同步和协作工具类" class="headerlink" title="第19章 同步和协作工具类"></a>第19章 同步和协作工具类</h2><p>我们在15.3节实现了线程的一些基本协作机制，那是利用基本的wait/notify实现的。我们提到，Java并发包中有一些专门的同步和协作工具类，本章，我们就来探讨它们。具体工具类包括：</p>
<p>❑ 读写锁ReentrantReadWriteLock。❑ 信号量Semaphore。❑ 倒计时门栓CountDownLatch。❑ 循环栅栏CyclicBarrier。</p>
<p>此外，有一个实现线程安全的特殊概念：线程本地变量ThreadLocal，本章也会进行介绍。</p>
<p>与第15章介绍的显式锁和显式条件类似，除了ThreadLocal外，这些同步和协作类都是基于AQS实现的。在一些特定的同步协作场景中，相比使用最基本的wait/notify以及显式锁/条件，它们更为方便，效率更高。下面，我们就来探讨它们的基本概念、用法、用途和基本原理。</p>
<h3 id="19-1-读写锁ReentrantReadWriteLock"><a href="#19-1-读写锁ReentrantReadWriteLock" class="headerlink" title="19.1 读写锁ReentrantReadWriteLock"></a>19.1 读写锁ReentrantReadWriteLock</h3><p>之前章节我们介绍了两种锁：synchronized和显式锁ReentrantLock，对于同一受保护对象的访问，无论是读还是写，它们都要求获得相同的锁。在一些场景中，这是没有必要的，多个线程的读操作完全可以并行，在读多写少的场景中，让读操作并行可以明显提高性能。</p>
<p>怎么让读操作能够并行，又不影响一致性呢？答案是使用读写锁。在Java并发包中，接口ReadWriteLock表示读写锁，主要实现类是可重入读写锁ReentrantReadWriteLock。ReadWriteLock的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个ReadWriteLock产生两个锁：一个读锁，一个写锁。读操作使用读锁，写操作使用写锁。需要注意的是，<strong>只有“读-读”操作是可以并行的，“读-写”和“写-写”都不可以。</strong>只有一个线程可以进行写操作，在获取写锁时，只有没有任何线程持有任何锁才可以获取到，在持有写锁时，其他任何线程都获取不到任何锁。在没有其他线程持有写锁的情况下，多个线程可以获取和持有读锁。</p>
<p>ReentrantReadWriteLock是可重入的读写锁，它有两个构造方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>fair表示是否公平，如果不传递则是false，含义与16.2节介绍的类似，就不赘述了。</p>
<p>我们看个读写锁的应用，使用ReentrantReadWriteLock实现一个缓存类MyCache，如代码清单19-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    map.clear();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    writeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。读写锁是怎么实现的呢？读锁和写锁看上去是两个锁，它们是怎么协调的？具体实现比较复杂，我们简述下其思路。</p>
<p>内部，它们使用同一个整数变量表示锁的状态，16位给读锁用，16位给写锁用，使用一个变量便于进行CAS操作，锁的等待队列其实也只有一个。</p>
<p>使用一个变量便于进行CAS操作，<strong>锁的等待队列其实也只有一个</strong>。</p>
<p>写锁的获取，就是确保当前没有其他线程持有任何锁，否则就等待。写锁释放后，也就是将等待队列中的第一个线程唤醒，唤醒的可能是等待读锁的，也可能是等待写锁的。</p>
<p>读锁的获取不太一样，首先，只要写锁没有被持有，就可以获取到读锁，此外，在获取到读锁后，它会检查等待队列，逐个唤醒最前面的等待读锁的线程，直到第一个等待写锁的线程。如果有其他线程持有写锁，获取读锁会等待。读锁释放后，检查读锁和写锁数是否都变为了0，如果是，唤醒等待队列中的下一个线程。</p>
<h3 id="19-2-信号量Semaphore"><a href="#19-2-信号量Semaphore" class="headerlink" title="19.2 信号量Semaphore"></a>19.2 信号量Semaphore</h3><p>之前介绍的锁都是限制只有一个线程可以同时访问一个资源。现实中，资源往往有多个，但每个同时只能被一个线程访问，比如，饭店的饭桌、火车上的卫生间。有的单个资源即使可以被并发访问，但并发访问数多了可能影响性能，所以希望限制并发访问的线程数。还有的情况，与软件的授权和计费有关，对不同等级的账户，限制不同的最大并发访问数。</p>
<p>信号量类Semaphore就是用来解决这类问题的，它可以限制对资源的并发访问数，它有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>fair表示公平，含义与之前介绍的是类似的，permits表示许可数量。</p>
<p>Semaphore的方法与锁是类似的，主要的方法有两类，获取许可和释放许可，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞获取许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//阻塞获取许可，不响应中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">//批量获取多个许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="comment">//尝试获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span></span><br><span class="line"><span class="comment">//限定等待时间获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> timeout,</span></span><br><span class="line"><span class="params">    TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//释放许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>我们看个简单的示例，限制并发访问的用户数不超过100，如代码清单19-2所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessControlService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLimitException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PERMITS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(MAX_PERMITS, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(! permits.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">//同时登录用户数超过限制</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentLimitException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//…其他验证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        permits.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。需要说明的是，如果我们将permits的值设为1，你可能会认为它就变成了一般的锁，不过，它与一般的锁是不同的。一般锁只能由持有锁的线程释放，而Semaphore表示的只是一个许可数，任意线程都可以调用其release方法。主要的锁实现类ReentrantLock是可重入的，而Semaphore不是，每一次的acquire调用都会消耗一个许可，比如，看下面的代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">permits.acquire();</span><br><span class="line">permits.acquire();</span><br><span class="line">System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>程序会阻塞在第二个acquire调用，永远都不会输出“acquired”。</p>
<p>信号量的基本原理比较简单，也是基于AQS实现的，permits表示共享的锁个数，acquire方法就是检查锁个数是否大于0，大于则减一，获取成功，否则就等待，release就是将锁个数加一，唤醒第一个等待的线程。</p>
<h3 id="19-3-倒计时门栓CountDownLatch"><a href="#19-3-倒计时门栓CountDownLatch" class="headerlink" title="19.3 倒计时门栓CountDownLatch"></a>19.3 倒计时门栓CountDownLatch</h3><p>我们在15.3.5节使用wait/notify实现了一个简单的门栓MyLatch，我们提到，Java并发包中已经提供了类似工具，就是CountDownLatch。它相当于是一个门栓，一开始是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过，它是一次性的，打开后就不能再关上了。</p>
<p>CountDownLatch里有一个计数，这个计数通过构造方法进行传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<p>多个线程可以基于这个计数进行协作，它的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>await检查计数是否为0，如果大于0，就等待，await可以被中断，也可以设置最长等待时间。countDown检查计数，如果已经为0，直接返回，否则减少计数，如果新的计数变为0，则唤醒所有等待的线程。</p>
<p>之前，我们介绍了门栓的两种应用场景：一种是同时开始，另一种是主从协作。它们都有两类线程，互相需要同步，我们使用CountDownLatch重新演示。</p>
<p>在同时开始场景中，运行员线程等待主裁判线程发出开始指令的信号，一旦发出后，所有运动员线程同时开始，计数初始为1，运动员线程调用await，主线程调用countDown，如代码清单19-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RacerWithCountDownLatch</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">                CountDownLatch latch;</span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.latch.await();</span><br><span class="line">                        System.out.println(getName()</span><br><span class="line">                                  + <span class="string">&quot; start run &quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        Thread[] racers = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            racers[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(latch);</span><br><span class="line">            racers[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不赘述了。在主从协作模式中，主线程依赖工作线程的结果，需要等待工作线程结束，这时，计数初始值为工作线程的个数，工作线程结束后调用countDown，主线程调用await进行等待，如代码清单19-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterWorkerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟执行任务</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() ＊ <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//模拟异常情况</span></span><br><span class="line">                <span class="keyword">if</span>(Math.random() &lt; <span class="number">0.02</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bad luck&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerNum);</span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[workerNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerNum; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(latch);</span><br><span class="line">            workers[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;collect worker results&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要强调的是，在这里，countDown的调用应该放到finally语句中，确保在工作线程发生异常的情况下也会被调用，使主线程能够从await调用中返回。</p>
<h3 id="19-4-循环栅栏CyclicBarrier"><a href="#19-4-循环栅栏CyclicBarrier" class="headerlink" title="19.4 循环栅栏CyclicBarrier"></a>19.4 循环栅栏CyclicBarrier</h3><p>我们在15.3.7节使用wait/notify实现了一个简单的集合点AssemblePoint，我们提到， Java并发包中已经提供了类似工具，就是CyclicBarrier。它相当于是一个栅栏，所有线程在到达该栅栏后都需要等待其他线程，等所有线程都到达后再一起通过，它是循环的，可以用作重复的同步。</p>
<p>CyclicBarrier特别适用于并行迭代计算，每个线程负责一部分计算，然后在栅栏处等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。</p>
<p>与CountDownLatch类似，它也有一个数字，但表示的是参与的线程个数，这个数字通过构造方法进行传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span></span><br></pre></td></tr></table></figure>
<p>它还有一个构造方法，接受一个Runnable参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span></span><br></pre></td></tr></table></figure>
<p>这个参数表示栅栏动作，当所有线程到达栅栏后，在所有线程执行下一步动作前，运行参数中的动作，这个动作由最后一个到达栅栏的线程执行。</p>
<p>CyclicBarrier的主要方法就是await：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span><br></pre></td></tr></table></figure>
<p>await在等待其他线程到达栅栏，调用await后，表示自己已经到达，如果自己是最后一个到达的，就执行可选的命令，执行后，唤醒所有等待的线程，然后重置内部的同步计数，以循环使用。</p>
<p>await可以被中断，可以限定最长等待时间，中断或超时后会抛出异常。需要说明的是异常BrokenBarrierException，它表示栅栏被破坏了，什么意思呢？在CyclicBarrier中，参与的线程是互相影响的，只要其中一个线程在调用await时被中断了，或者超时了，栅栏就会被破坏。此外，如果栅栏动作抛出了异常，栅栏也会被破坏。被破坏后，所有在调用await的线程就会退出，抛出BrokenBarrierException。</p>
<p>我们看一个简单的例子，多个游客线程分别在集合点A和B同步，如代码清单19-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tourist</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tourist</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟先各自独立运行</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//集合点A</span></span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; arrived A &quot;</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">                <span class="comment">//集合后模拟再各自独立运行</span></span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                <span class="comment">//集合点B</span></span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; arrived B &quot;</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        Tourist[] threads = <span class="keyword">new</span> <span class="title class_">Tourist</span>[num];</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(num, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;all arrived &quot;</span> + System.currentTimeMillis()</span><br><span class="line">                        + <span class="string">&quot; executed by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Tourist</span>(barrier);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在笔者的计算机中的一次输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all arrived <span class="number">1490053578552</span> executed by Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">Thread-<span class="number">2</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">Thread-<span class="number">0</span> arrived A <span class="number">1490053578555</span></span><br><span class="line">all arrived <span class="number">1490053578889</span> executed by Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> arrived B <span class="number">1490053578890</span></span><br><span class="line">Thread-<span class="number">2</span> arrived B <span class="number">1490053578890</span></span><br><span class="line">Thread-<span class="number">1</span> arrived B <span class="number">1490053578890</span></span><br></pre></td></tr></table></figure>
<p>多个线程到达A和B的时间是一样的，使用CyclicBarrier，达到了重复同步的目的。CyclicBarrier与CountDownLatch可能容易混淆，我们强调下它们的区别。</p>
<p>1）CountDownLatch的参与线程是有不同角色的，有的负责倒计时，有的在等待倒计时变为0，负责倒计时和等待倒计时的线程都可以有多个，用于不同角色线程间的同步。</p>
<p>2）CyclicBarrier的参与线程角色是一样的，用于同一角色线程间的协调一致。</p>
<p>3）CountDownLatch是一次性的，而CyclicBarrier是可以重复利用的。</p>
<h3 id="19-5-理解ThreadLocal"><a href="#19-5-理解ThreadLocal" class="headerlink" title="19.5 理解ThreadLocal"></a>19.5 理解ThreadLocal</h3><p>本节，我们来探讨一个特殊的概念：线程本地变量。在Java中的实现是ThreadLocal类，它是什么？有什么用？实现原理是什么？让我们接下来逐步探讨。</p>
<h4 id="19-5-1-基本概念和用法"><a href="#19-5-1-基本概念和用法" class="headerlink" title="19.5.1 基本概念和用法"></a>19.5.1 基本概念和用法</h4><p>线程本地变量是说，<strong>每个线程都有同一个变量的独有拷贝</strong>。这个概念听上去比较难以理解，我们先直接来看类TheadLocal的用法。ThreadLocal是一个泛型类，接受一个类型参数T，它只有一个空的构造方法，有两个主要的public方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>
<p>set就是设置值，get就是获取值，如果没有值，返回null，看上去，ThreadLocal就是一个单一对象的容器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    local.set(<span class="number">100</span>);</span><br><span class="line">    System.out.println(local.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为100。那ThreadLocal有什么特殊的呢？特殊发生在有多个线程的时候，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalBasic</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;child thread initial: &quot;</span> + local.get());</span><br><span class="line">                        local.set(<span class="number">200</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;child thread final: &quot;</span> + local.get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                local.set(<span class="number">100</span>);</span><br><span class="line">                child.start();</span><br><span class="line">                child.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread final: &quot;</span> + local.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>local是一个静态变量，main方法创建了一个子线程child, main和child都访问了local，程序的输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child thread initial: <span class="literal">null</span></span><br><span class="line">child thread <span class="keyword">final</span>: <span class="number">200</span></span><br><span class="line">main thread <span class="keyword">final</span>: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>这说明，main线程对local变量的设置对child线程不起作用，child线程对local变量的改变也不会影响main线程，<strong>它们访问的虽然是同一个变量local，但每个线程都有自己的独立的值，这就是线程本地变量的含义</strong>。</p>
<p>除了get/set, ThreadLocal还有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>initialValue用于提供初始值，这是一个受保护方法，可以通过匿名内部类的方式提供，当调用get方法时，如果之前没有设置过，会调用该方法获取初始值，默认实现是返回null。remove删掉当前线程对应的值，如果删掉后，再次调用get，会再调用initialValue获取初始值。看个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalInit</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(local.get());</span><br><span class="line">        local.set(<span class="number">200</span>);</span><br><span class="line">        local.remove();</span><br><span class="line">        System.out.println(local.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出值都是100。</p>
<h4 id="19-5-2-使用场景"><a href="#19-5-2-使用场景" class="headerlink" title="19.5.2 使用场景"></a>19.5.2 使用场景</h4><p>ThreadLocal有什么用呢？我们来看三个例子：日期处理、随机数和上下文信息。</p>
<h5 id="1．日期处理"><a href="#1．日期处理" class="headerlink" title="1．日期处理"></a>1．日期处理</h5><p>ThreadLocal是实现线程安全的一种方案，比如对于DateFormat/SimpleDateFormat，我们在介绍日期和时间操作的时候，提到它们是非线程安全的，实现安全的一种方式是使用锁，另一种方式是每次都创建一个新的对象，更好的方式就是使用ThreadLocal，每个线程使用自己的DateFormat，就不存在安全问题了，在线程的整个使用过程中，只需要创建一次，又避免了频繁创建的开销，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; sdf = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date2String</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">string2Date</span><span class="params">(String str)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.get().parse(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，ThreadLocal对象一般都定义为static，以便于引用。</p>
<h5 id="2．随机数"><a href="#2．随机数" class="headerlink" title="2．随机数"></a>2．随机数</h5><p>即使对象是线程安全的，使用ThreadLocal也可以减少竞争，比如，我们在介绍Random类的时候提到，Random是线程安全的，但如果并发访问竞争激烈的话，性能会下降，所以Java并发包提供了类ThreadLocalRandom，它是Random的子类，利用了ThreadLocal，它没有public的构造方法，通过静态方法current获取对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalRandom</span> <span class="variable">rnd</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line">    System.out.println(rnd.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>current方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title function_">current</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> localRandom.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>localRandom就是一个ThreadLocal变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> ThreadLocalRandom <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalRandom</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="3．上下文信息"><a href="#3．上下文信息" class="headerlink" title="3．上下文信息"></a>3．上下文信息</h5><p>ThreadLocal的典型用途是提供上下文信息，比如在一个Web服务器中，一个线程执行用户的请求，在执行过程中，很多代码都会访问一些共同的信息，比如请求信息、用户身份信息、数据库连接、当前事务等，它们是线程执行过程中的全局信息，如果作为参数在不同代码间传递，代码会很烦琐，这时，使用ThreadLocal就很方便，所以它被用于各种框架如Spring中。我们看个简单的示例，如代码清单19-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123; <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localUserId = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Request&gt; localRequest = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localUserId.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        localUserId.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title function_">getCurrentRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localRequest.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        localRequest.set(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在首次获取到信息时，调用set方法如setCurrentRequest/setCurrentUserId进行设置，然后就可以在代码的任意其他地方调用get相关方法进行获取了。</p>
<h4 id="19-5-3-基本实现原理"><a href="#19-5-3-基本实现原理" class="headerlink" title="19.5.3 基本实现原理"></a>19.5.3 基本实现原理</h4><p>ThreadLocal是怎么实现的呢？为什么对同一个对象的get/set，每个线程都能有自己独立的值呢？我们直接来看代码（基于Java 7）。set方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了getMap, getMap的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回线程的实例变量threadLocals，它的初始值为null，在null时，set调用createMap初始化，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出，每个线程都有一个Map，类型为ThreadLocalMap，调用set实际上是在线程自己的Map里设置了一个条目，键为当前的ThreadLocal对象，值为value。ThreadLocalMap是一个内部类，它是专门用于ThreadLocal的，与一般的Map不同，它的键类型为WeakReference<ThreadLocal>。我们没有提过WeakReference，它与Java的垃圾回收机制有关，使用它，便于回收内存，具体我们就不探讨了。</p>
<p>get方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(e ! = <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过线程访问到Map，以ThreadLocal对象为键从Map中获取到条目，取其value，如果Map中没有，则调用setInitialValue，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map ! = <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initialValue()就是之前提到的提供初始值的方法，默认实现就是返回null。</p>
<p>remove方法的代码也很直接，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span>(m ! = <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结下，<strong>每个线程都有一个Map，对于每个ThreadLocal对象，调用其get/set实际上就是以ThreadLocal对象为键读写当前线程的Map</strong>，这样，就实现了每个线程都有自己的独立副本的效果。</p>
<h1 id="第六部分-动态与函数式编程"><a href="#第六部分-动态与函数式编程" class="headerlink" title="第六部分 动态与函数式编程"></a>第六部分 动态与函数式编程</h1><h2 id="第21章-反射"><a href="#第21章-反射" class="headerlink" title="第21章 反射"></a>第21章 反射</h2><p>从本章开始，我们来探讨Java中的一些动态特性，包括反射、注解、动态代理、类加载器等。利用这些特性，可以优雅地实现一些灵活通用的功能，它们经常用于各种框架、库和系统程序中，比如：</p>
<p>1）14.5节介绍的Jackson，利用反射和注解实现了通用的序列化机制。</p>
<p>2）有多种库（如Spring MVC、Jersey）用于处理Web请求，利用反射和注解，能方便地将用户的请求参数和内容转换为Java对象，将Java对象转变为响应内容。3）有多种库（如Spring、Guice）利用这些特性实现了对象管理容器，方便程序员管理对象的生命周期以及其中复杂的依赖关系。</p>
<p>4）应用服务器（如Tomcat）利用类加载器实现不同应用之间的隔离，JSP技术利用类加载器实现修改代码不用重启就能生效的特性。</p>
<p>5）面向方面的编程AOP（Aspect Oriented Programming）将编程中通用的关注点（如日志记录、安全检查等）与业务的主体逻辑相分离，减少冗余代码，提高程序的可维护性， AOP需要依赖上面的这些特性来实现。</p>
<p>本章主要介绍反射机制，后续章节介绍其他内容。</p>
<p>在一般操作数据的时候，我们都是知道并且依赖于数据类型的，比如：</p>
<p>1）根据类型使用new创建对象。</p>
<p>2）根据类型定义变量，类型可能是基本类型、类、接口或数组。</p>
<p>3）将特定类型的对象传递给方法。</p>
<p>4）根据类型访问对象的属性，调用对象的方法。</p>
<p>编译器也是根据类型进行代码的检查编译的。</p>
<p>反射不一样，它是<strong>在运行时，而非编译时</strong>，动态获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等。这么说比较抽象，下面我们会具体说明。<strong>反射的入口是名称为Class的类</strong>，我们先介绍Class类，随后举例说明反射的应用，接着讨论反射与泛型，最后进行总结。</p>
<h3 id="21-1-Class类"><a href="#21-1-Class类" class="headerlink" title="21.1 Class类"></a>21.1 Class类</h3><p>在介绍类和继承的实现原理时，我们提到，每个已加载的类在内存都有一份类信息，每个对象都有指向它所属类信息的引用。Java中，类信息对应的类就是java.lang.Class。注意不是小写的class, class是定义类的关键字。所有类的根父类Object有一个方法，可以获取对象的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;? &gt; getClass()</span><br></pre></td></tr></table></figure>
<p>Class是一个泛型类，有一个类型参数，getClass()并不知道具体的类型，所以返回Class&lt;?&gt;。</p>
<p>获取Class对象不一定需要实例对象，如果在写程序时就知道类名，可以使用&lt;类名&gt;.class获取Class对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Date&gt; cls = Date.class;</span><br></pre></td></tr></table></figure>
<p>接口也有Class对象，且这种方式对于接口也是适用的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Comparable&gt; cls = Comparable.class;</span><br></pre></td></tr></table></figure>
<p>基本类型没有getClass方法，但也都有对应的Class对象，类型参数为对应的包装类型，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; intCls = <span class="type">int</span>.class;</span><br><span class="line">Class&lt;Byte&gt; byteCls = <span class="type">byte</span>.class;</span><br><span class="line">Class&lt;Character&gt; charCls = <span class="type">char</span>.class;</span><br><span class="line">Class&lt;Double&gt; doubleCls = <span class="type">double</span>.class;</span><br></pre></td></tr></table></figure>
<p>void作为特殊的返回类型，也有对应的Class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Void&gt; voidCls = <span class="keyword">void</span>.class;</span><br></pre></td></tr></table></figure>
<p>对于数组，每种类型都有对应数组类型的Class对象，每个维度都有一个，即一维数组有一个，二维数组有一个不同的类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[][] twoDimArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span>[] oneDimArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>[]&gt; strArrCls = strArr.getClass();</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[][]&gt; twoDimArrCls = twoDimArr.getClass();</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; oneDimArrCls = oneDimArr.getClass();</span><br></pre></td></tr></table></figure>
<p>枚举类型也有对应的Class，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;Size&gt; cls = Size.class;</span><br></pre></td></tr></table></figure>
<p>Class有一个静态方法forName，可以根据类名直接加载Class，获取Class对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;? &gt; cls = Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>);</span><br><span class="line">    System.out.println(cls.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意forName可能抛出异常ClassNotFoundException。</p>
<p>有了Class对象后，我们就可以了解到关于类型的很多信息，并基于这些信息采取一些行动。Class的方法很多，大部分比较简单直接，容易理解，下面，我们分为若干组，包括名称信息、字段信息、方法信息、创建对象和构造方法、类型信息等，进行简要介绍。</p>
<h4 id="1．名称信息"><a href="#1．名称信息" class="headerlink" title="1．名称信息"></a>1．名称信息</h4><p>Class有如下方法，可以获取与名称有关的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSimpleName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getCanonicalName</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Package <span class="title function_">getPackage</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>getSimpleName返回的名称不带包信息，getName返回的是Java内部使用的真正的名称，getCanonicalName返回的名称更为友好，getPackage返回的是包信息，它们的不同如表格21-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310082112096.png" alt="image-20231008211227859"></p>
<p>需要说明的是数组类型的getName返回值，它使用前缀[表示数组，有几个[表示是几维数组；数组的类型用一个字符表示，I表示int, L表示类或接口，其他类型与字符的对应关系为：boolean(Z)、byte(B)、char(C)、double(D)、float(F)、long(J)、short(S)。对于引用类型的数组，注意最后有一个分号；。</p>
<h4 id="2．字段信息"><a href="#2．字段信息" class="headerlink" title="2．字段信息"></a>2．字段信息</h4><p>类中定义的静态和实例变量都被称为字段，用类Field表示，位于包java.lang.reflect下，后文涉及的反射相关的类都位于该包下。Class有4个获取字段信息的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回所有的public字段，包括其父类的，如果没有字段，返回空数组</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br><span class="line"><span class="comment">//返回本类声明的所有字段，包括非public的，但不包括父类的</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br><span class="line"><span class="comment">//返回本类或父类中指定名称的public字段，找不到抛出异常NoSuchFieldException</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String name)</span></span><br><span class="line"><span class="comment">//返回本类中声明的指定名称的字段，找不到抛出异常NoSuchFieldException</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>
<p>Field也有很多方法，可以获取字段的信息，也可以通过Field访问和操作指定对象中该字段的值，基本方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字段的名称</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"><span class="comment">//判断当前程序是否有该字段的访问权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccessible</span><span class="params">()</span></span><br><span class="line"><span class="comment">//flag设为true表示忽略Java的访问检查机制，以允许读写非public的字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessible</span><span class="params">(<span class="type">boolean</span> flag)</span></span><br><span class="line"><span class="comment">//获取指定对象obj中该字段的值</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">//将指定对象obj中该字段的值设为value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj, Object value)</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/">https://wdpname.github.io/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot从入门到实战</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript高级程序设计（第三版）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div><div><a href="/2022/11/10/SpringMVC%E5%9F%BA%E7%A1%80/" title="SpringMVC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">SpringMVC基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">第二部分 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">第5章 类的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">5.3 内部类的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">5.3.1 静态内部类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">第三部分 泛型与容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">第9章 列表和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E5%88%A8%E6%9E%90ArrayList"><span class="toc-number">2.1.1.</span> <span class="toc-text">9.1刨析ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">9.1.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">9.1.2 基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">9.1.3 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.1.3.1.</span> <span class="toc-text">1．迭代器接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ListIterator"><span class="toc-number">2.1.1.3.2.</span> <span class="toc-text">2. ListIterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E8%BF%AD%E4%BB%A3%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">2.1.1.3.3.</span> <span class="toc-text">3．迭代的陷阱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.3.4.</span> <span class="toc-text">4．迭代器实现的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.1.1.3.5.</span> <span class="toc-text">5．迭代器的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-ArrayList%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">9.1.4 ArrayList实现的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Collection"><span class="toc-number">2.1.1.4.1.</span> <span class="toc-text">1. Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-List"><span class="toc-number">2.1.1.4.2.</span> <span class="toc-text">2. List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-RandomAccess"><span class="toc-number">2.1.1.4.3.</span> <span class="toc-text">3. RandomAccess</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%89%96%E6%9E%90LinkedList"><span class="toc-number">2.1.2.</span> <span class="toc-text">9.2 剖析LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">9.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">9.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%89%96%E6%9E%90ArrayDeque"><span class="toc-number">2.1.3.</span> <span class="toc-text">9.3 剖析ArrayDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">9.3.1 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">1．循环数组</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-Map%E5%92%8CSet"><span class="toc-number">2.2.</span> <span class="toc-text">第10章 Map和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%89%96%E6%9E%90HashMap"><span class="toc-number">2.2.1.</span> <span class="toc-text">10.1 剖析HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">10.1.1 Map接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-HashMap"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">10.1.2 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">10.1.3 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text">1．内部组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text">2．默认构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.1.3.3.</span> <span class="toc-text">6．实现原理小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%89%96%E6%9E%90HashSet"><span class="toc-number">2.2.2.</span> <span class="toc-text">10.2 剖析HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">10.2.1 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">10.2.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.3.</span> <span class="toc-text">10.3 排序二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">10.3.3 平衡的排序二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%89%96%E6%9E%90TreeMap"><span class="toc-number">2.2.4.</span> <span class="toc-text">10.4 剖析TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">10.4.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">10.4.2 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-1"><span class="toc-number">2.2.4.2.1.</span> <span class="toc-text">1．内部组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%89%96%E6%9E%90TreeSet"><span class="toc-number">2.2.5.</span> <span class="toc-text">10.5 剖析TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">10.5.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">10.5.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E5%89%96%E6%9E%90LinkedHashMap"><span class="toc-number">2.2.6.</span> <span class="toc-text">10.6 剖析LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">10.6.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">10.6.2 实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-3-LinkedHashSet"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">10.6.3 LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E5%89%96%E6%9E%90EnumMap"><span class="toc-number">2.2.7.</span> <span class="toc-text">10.7 剖析EnumMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-%E5%89%96%E6%9E%90EnumSet"><span class="toc-number">2.2.8.</span> <span class="toc-text">10.8 剖析EnumSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">10.8.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">10.8.2 应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">第11章 堆与优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">11.1 堆的概念与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">11.1.1 基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%89%96%E6%9E%90PriorityQueue"><span class="toc-number">2.3.2.</span> <span class="toc-text">11.2 剖析PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">第12章 通用容器类和总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%8A%BD%E8%B1%A1%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">2.4.1.</span> <span class="toc-text">12.1 抽象容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Collections"><span class="toc-number">2.4.2.</span> <span class="toc-text">12.2 Collections</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">第四部分 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.</span> <span class="toc-text">第13章 文件基本技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">第五部分 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">第15章 并发基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">15.1 线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">15.1.1 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%BB%A7%E6%89%BFThread"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text">1．继承Thread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.1.1.2.</span> <span class="toc-text">2．实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">15.1.2 线程的基本属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-id%E5%92%8Cname"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">1. id和name</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">2．优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text">3．状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E6%98%AF%E5%90%A6daemon%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.2.4.</span> <span class="toc-text">4．是否daemon线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.5.</span> <span class="toc-text">5. sleep方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-yield%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.6.</span> <span class="toc-text">6. yield方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-join%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.7.</span> <span class="toc-text">7. join方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%8E%E8%BF%87%E6%97%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.8.</span> <span class="toc-text">8．过时方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8F%8A%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">15.1.3 共享内存及可能存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.1.1.3.1.</span> <span class="toc-text">1．竞态条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.1.1.3.2.</span> <span class="toc-text">2．内存可见性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E6%88%90%E6%9C%AC"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">15.1.4 线程的优点及成本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E7%90%86%E8%A7%A3synchronized"><span class="toc-number">4.1.2.</span> <span class="toc-text">15.2 理解synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-1-%E7%94%A8%E6%B3%95%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">15.2.1 用法和基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.1.1.</span> <span class="toc-text">1．实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.1.2.</span> <span class="toc-text">2．静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.1.2.1.3.</span> <span class="toc-text">3．代码块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3synchronized"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">15.2.2 进一步理解synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">1．可重入性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7-1"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">2．内存可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%AD%BB%E9%94%81"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">3．死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-3-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">15.2.3 同步容器及其注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.3.1.</span> <span class="toc-text">1．复合操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%AA%E5%90%8C%E6%AD%A5"><span class="toc-number">4.1.2.3.2.</span> <span class="toc-text">2．伪同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.1.2.3.3.</span> <span class="toc-text">3．迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.2.3.4.</span> <span class="toc-text">4．并发容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6-%EF%BC%88%E7%9C%8B%E5%88%B0%E8%BF%99%E9%87%8C%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">15.3 线程的基本协作机制  （看到这里）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-1-%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">15.3.1 协作的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-2-wait-notify"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">15.3.2 wait&#x2F;notify</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">4.1.4.</span> <span class="toc-text">15.4 线程的中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-1-%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">15.4.1 取消&#x2F;关闭的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-2-%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">15.4.2 取消&#x2F;关闭的机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-3-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8F%8D%E5%BA%94"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">15.4.3 线程对中断的反应</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RUNNABLE"><span class="toc-number">4.1.4.3.1.</span> <span class="toc-text">1. RUNNABLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-WAITING-TIMED-WAITING"><span class="toc-number">4.1.4.3.2.</span> <span class="toc-text">2. WAITING&#x2F;TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-BLOCKED"><span class="toc-number">4.1.4.3.3.</span> <span class="toc-text">3. BLOCKED</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-NEW-TERMINATE"><span class="toc-number">4.1.4.3.4.</span> <span class="toc-text">4. NEW&#x2F;TERMINATE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%8F%96%E6%B6%88-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.4.4.</span> <span class="toc-text">15.4.4 如何正确地取消&#x2F;关闭线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">4.2.</span> <span class="toc-text">第16章 并发包的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E5%92%8CCAS"><span class="toc-number">4.2.1.</span> <span class="toc-text">16.1 原子变量和CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-1-AtomicInteger"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">16.1.1 AtomicInteger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">1．基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E6%80%9D%E7%BB%B4"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">2．基本原理和思维</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E5%AE%9E%E7%8E%B0%E9%94%81"><span class="toc-number">4.2.1.1.3.</span> <span class="toc-text">3．实现锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-2-ABA%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">16.1.2 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">16.2 显式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1-%E6%8E%A5%E5%8F%A3Lock"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">16.2.1 接口Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">16.2.2 可重入锁ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">1．基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E4%BD%BF%E7%94%A8tryLock%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.2.2.2.2.</span> <span class="toc-text">2．使用tryLock避免死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">16.2.3 ReentrantLock的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-LockSupport"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">1. LockSupport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AQS"><span class="toc-number">4.2.2.3.2.</span> <span class="toc-text">2. AQS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ReentrantLock"><span class="toc-number">4.2.2.3.3.</span> <span class="toc-text">3. ReentrantLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-4-%E5%AF%B9%E6%AF%94ReentrantLock%E5%92%8Csynchronized"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">16.2.4 对比ReentrantLock和synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E6%98%BE%E5%BC%8F%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text">16.3 显式条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1-%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">16.3.1 用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">第17章 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84List%E5%92%8CSet"><span class="toc-number">4.3.1.</span> <span class="toc-text">17.1 写时复制的List和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-1-CopyOnWriteArrayList"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">17.1.1 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-2-CopyOnWriteArraySet"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">17.1.2 CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-ConcurrentHashMap"><span class="toc-number">4.3.2.</span> <span class="toc-text">17.2 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-1-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">17.2.1 并发安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-2-%E5%8E%9F%E5%AD%90%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">17.2.2 原子复合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-3-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">17.2.3 高并发的基本机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-4-%E8%BF%AD%E4%BB%A3%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">17.2.4 迭代安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-5-%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">17.2.5 弱一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84Map%E5%92%8CSet"><span class="toc-number">4.3.3.</span> <span class="toc-text">17.3 基于跳表的Map和Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">17.3.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-2-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">17.3.2 基本实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.</span> <span class="toc-text">17.4 并发队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-%E6%97%A0%E9%94%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">17.4.1 无锁非阻塞并发队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-2-%E6%99%AE%E9%80%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">17.4.2 普通阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-3-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">17.4.3 优先级阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-4-%E5%BB%B6%E6%97%B6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">17.4.4 延时阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-5-%E5%85%B6%E4%BB%96%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">17.4.5 其他阻塞队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.4.</span> <span class="toc-text">第18章 异步任务执行服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">18.1 基本概念和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-1-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">18.1.1 基本接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">18.1.2 基本用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">第19章 同步和协作工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock"><span class="toc-number">4.5.1.</span> <span class="toc-text">19.1 读写锁ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore"><span class="toc-number">4.5.2.</span> <span class="toc-text">19.2 信号量Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E6%A0%93CountDownLatch"><span class="toc-number">4.5.3.</span> <span class="toc-text">19.3 倒计时门栓CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8FCyclicBarrier"><span class="toc-number">4.5.4.</span> <span class="toc-text">19.4 循环栅栏CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-%E7%90%86%E8%A7%A3ThreadLocal"><span class="toc-number">4.5.5.</span> <span class="toc-text">19.5 理解ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">19.5.1 基本概念和用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">19.5.2 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">4.5.5.2.1.</span> <span class="toc-text">1．日期处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">4.5.5.2.2.</span> <span class="toc-text">2．随机数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="toc-number">4.5.5.2.3.</span> <span class="toc-text">3．上下文信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5-3-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">19.5.3 基本实现原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第六部分 动态与函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%8F%8D%E5%B0%84"><span class="toc-number">5.1.</span> <span class="toc-text">第21章 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-Class%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">21.1 Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1．名称信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">2．字段信息</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程的逻辑"/></a><div class="content"><a class="title" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑">Java编程的逻辑</a><time datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript高级程序设计（第三版）"/></a><div class="content"><a class="title" href="/2023/10/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/" title="JavaScript高级程序设计（第三版）">JavaScript高级程序设计（第三版）</a><time datetime="2023-10-05T14:44:18.000Z" title="发表于 2023-10-05 22:44:18">2023-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树的技巧"/></a><div class="content"><a class="title" href="/2023/08/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/" title="二叉树的技巧">二叉树的技巧</a><time datetime="2023-08-15T04:23:33.000Z" title="发表于 2023-08-15 12:23:33">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表的技巧"/></a><div class="content"><a class="title" href="/2023/08/14/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="链表的技巧">链表的技巧</a><time datetime="2023-08-14T04:03:55.000Z" title="发表于 2023-08-14 12:03:55">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>