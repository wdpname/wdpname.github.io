<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Maven实战 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第1章　Maven实战1.1　何为MavenMaven这个词可以翻译为“知识的积累”，也可以翻译为“专家”或“内行”。本书将介绍Maven这一跨平台的项目管理工具。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。">
<meta property="og:type" content="article">
<meta property="og:title" content="Maven实战">
<meta property="og:url" content="https://wdpname.github.io/2023/10/15/Maven%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第1章　Maven实战1.1　何为MavenMaven这个词可以翻译为“知识的积累”，也可以翻译为“专家”或“内行”。本书将介绍Maven这一跨平台的项目管理工具。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-15T11:12:27.000Z">
<meta property="article:modified_time" content="2023-11-08T14:27:28.659Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/15/Maven%E5%AE%9E%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Maven实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-08 22:27:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Maven实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-15T11:12:27.000Z" title="发表于 2023-10-15 19:12:27">2023-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-08T14:27:28.659Z" title="更新于 2023-11-08 22:27:28">2023-11-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Maven实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第1章-Maven实战"><a href="#第1章-Maven实战" class="headerlink" title="第1章　Maven实战"></a>第1章　Maven实战</h1><h2 id="1-1-何为Maven"><a href="#1-1-何为Maven" class="headerlink" title="1.1　何为Maven"></a>1.1　何为Maven</h2><p>Maven这个词可以翻译为“知识的积累”，也可以翻译为“专家”或“内行”。本书将介绍Maven这一跨平台的项目管理工具。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。</p>
<h3 id="1-1-1-何为构建"><a href="#1-1-1-何为构建" class="headerlink" title="1.1.1　何为构建"></a>1.1.1　何为构建</h3><p>不管你是否意识到，构建（build）是每一位程序员每天都在做的工作。早上来到公司，我们做的第一件事情就是从源码库签出最新的源码，然后进行单元测试，如果发现失败的测试，会找相关的同事一起调试，修复错误代码。接着回到自己的工作上来，编写自己的单元测试及产品代码，我们会感激IDE随时报出的编译错误提示。</p>
<p>忙到午饭时间，代码编写得差不多了，测试也通过了，开心地享用午餐，然后休息。下午先在昏昏沉沉中开了个例会，会议结束后喝杯咖啡继续工作。刚才在会上经理要求看测试报告，于是找了相关工具集成进IDE，生成了像模像样的测试覆盖率报告，接着发了一封电子邮件给经理，松了口气。谁料QA小组又发过来了几个bug，没办法，先本地重现再说，于是熟练地用IDE生成了一个WAR包，部署到Web容器下，启动容器。看到熟悉的界面了，遵循bug报告，一步步重现了bug……快下班的时候，bug修好了，提交代码，通知QA小组，在愉快中结束了一天的工作。</p>
<p>仔细总结一下，我们会发现，除了编写源代码，我们每天有相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等烦琐且不起眼的工作上，这就是构建。如果我们现在还手工这样做，那成本也太高了，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有烦琐的步骤都能够自动完成，很快就能得到最终结果。</p>
<h3 id="1-1-2-Maven是优秀的构建工具"><a href="#1-1-2-Maven是优秀的构建工具" class="headerlink" title="1.1.2　Maven是优秀的构建工具"></a>1.1.2　Maven是优秀的构建工具</h3><p>前面介绍了Maven的用途之一是服务于构建，它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。我们不需要也不应该一遍又一遍地输入命令，一次又一次地点击鼠标，我们要做的是使用Maven配置好项目，然后输入简单的命令（如mvn clean install），Maven会帮我们处理那些烦琐的任务。</p>
<p>Maven是跨平台的，这意味着无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。</p>
<p>我们一直在不停地寻找避免重复的方法。设计的重复、编码的重复、文档的重复，当然还有构建的重复。Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要再去实现这些过程中的一些任务。最简单的例子是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例，当我们运行构建的时候，这些测试便会自动运行。</p>
<p>想象一下，Maven抽象了一个完整的<strong>构建生命周期模型</strong>，这个模型吸取了大量其他的构建脚本和构建工具的优点，总结了大量项目的实际需求。如果遵循这个模型，可以避免很多不必要的错误，可以直接使用大量成熟的Maven插件来完成我们的任务（很多时候我们可能都不知道自己在使用Maven插件）。此外，如果有非常特殊的需求，我们也可以轻松实现自己的插件。</p>
<p>Maven还有一个优点，它能帮助我们标准化构建过程。在Maven之前，十个项目可能有十种构建方式；有了Maven之后，所有项目的构建命令都是简单一致的，这极大地避免了不必要的学习成本，而且有利于促进项目团队的标准化。</p>
<p>综上所述，Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现；它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p>
<h3 id="1-1-3-Maven不仅仅是构建工具"><a href="#1-1-3-Maven不仅仅是构建工具" class="headerlink" title="1.1.3　Maven不仅仅是构建工具"></a>1.1.3　Maven不仅仅是构建工具</h3><p>Java不仅是一门编程语言，还是一个平台，通过JRuby和Jython，我们可以在Java平台上编写和运行Ruby和Python程序。我们也应该认识到，Maven不仅是构建工具，还是一个依赖管理工具和项目信息管理工具。它提供了中央仓库，能帮我们自动下载构件。</p>
<p>在这个开源的年代里，几乎任何Java应用都会借用一些第三方的开源类库，这些类库都可通过依赖的方式引入到项目中来。随着依赖的增多，版本不一致、版本冲突、依赖臃肿等问题都会接踵而来。手工解决这些问题是十分枯燥的，幸运的是Maven提供了一个优秀的解决方案，它通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。Maven给这个类库世界引入了经纬，让它们变得有秩序，于是我们可以借助它来有序地管理依赖，轻松地解决那些繁杂的依赖问题。</p>
<p>Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。这些微小的变化看起来很琐碎，并不起眼，但却在不知不觉中为我们节省了大量寻找信息的时间。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</p>
<p>Maven还为全世界的Java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源类库。通过一些Maven的衍生工具（如Nexus），我们还能对其进行快速地搜索。只要定位了坐标，Maven就能够帮我们自动下载，省去了手工劳动。</p>
<p>使用Maven还能享受一个额外的好处，即Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置（Convention Over Configuration）。</p>
<h2 id="1-2-为什么需要Maven"><a href="#1-2-为什么需要Maven" class="headerlink" title="1.2　为什么需要Maven"></a>1.2　为什么需要Maven</h2><p>Maven不是Java领域唯一的构建管理的解决方案。本节将通过一些简单的例子解释Maven的必要性，并介绍其他构建解决方案，如IDE、Make和Ant，并将它们与Maven进行比较。</p>
<h3 id="1-2-1-组装PC和品牌PC"><a href="#1-2-1-组装PC和品牌PC" class="headerlink" title="1.2.1　组装PC和品牌PC"></a>1.2.1　组装PC和品牌PC</h3><p>笔者初中时开始接触计算机，到了高中时更是梦寐以求希望拥有一台自己的计算机。我的第一台计算机是赛扬733的，选购是一个漫长的过程，我先阅读了大量的杂志以了解各类配件的优劣，CPU、内存、主板、显卡，甚至声卡，我都仔细地挑选，后来还跑了很多商家，调货、讨价还价，组装好后自己装操作系统和驱动程序……虽然这花费了我大量时间，但我很享受这个过程。可是事实证明，装出来的机器稳定性不怎么好。</p>
<p>一年前我需要配一台工作站，这时候我已经没有太多时间去研究电脑配件了。我选择了某知名PC供应商的在线商店，大概浏览了一下主流的机型，选择了我需要的配置，然后下单、付款。接着PC供应商帮我组装电脑、安装操作系统和驱动程序。一周后，物流公司将电脑送到我的家里，我接上显示器、电源、鼠标和键盘就能直接使用了。这为我节省了大量时间，而且这台电脑十分稳定，商家在把电脑发送给我之前已经进行了很好的测试。对了，我还能享受两年的售后服务。</p>
<p>使用脚本建立高度自定义的构建系统就像买组装PC，耗时费力，结果也不一定很好。当然，你可以享受从无到有的乐趣，但恐怕实际项目中无法给你那么多时间。使用Maven就像购买品牌PC，省时省力，并能得到成熟的构建系统，还能得到来自于Maven社区的大量支持。唯一与购买品牌PC不同的是，Maven是开源的，你无须为此付费。如果有兴趣，你还能去了解Maven是如何工作的，而我们无法知道那些PC巨头的商业秘密。</p>
<h3 id="1-2-2-IDE不是万能的"><a href="#1-2-2-IDE不是万能的" class="headerlink" title="1.2.2　IDE不是万能的"></a>1.2.2　IDE不是万能的</h3><p>当然，我们无法否认优秀的IDE能大大提高开发效率。当前主流的IDE如Eclipse和Net-Beans等都提供了强大的文本编辑、调试甚至重构功能。虽然使用简单的文本编辑器和命令行也能完成绝大部分开发工作，但很少有人愿意那样做。然而，IDE是有其天生缺陷的：</p>
<p>IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的，很难一键完成所有工作。手工劳动往往意味着低效，意味着容易出错。</p>
<p>很难在项目中统一所有的IDE配置，每个人都有自己的喜好。也正是由于这个原因，一个在机器A上可以成功运行的任务，到了机器B的IDE中可能就会失败。</p>
<p>我们应该合理利用IDE，而不是过多地依赖它。对于构建这样的任务，在IDE中一次次地点击鼠标是愚蠢的行为。Maven是这方面的专家，而且主流IDE都集成了Maven，我们可以在IDE中方便地运行Maven执行构建。</p>
<h3 id="1-2-3-Make"><a href="#1-2-3-Make" class="headerlink" title="1.2.3　Make"></a>1.2.3　Make</h3><p>Make也许是最早的构建工具，它由Stuart Feldman于1977年在Bell实验室创建。Stuart Feldman也因此于2003年获得了ACM国际计算机组织颁发的软件系统奖。目前Make有很多衍生实现，包括最流行的GNU Make和BSD Make，还有Windows平台的Microsoft nmake等。</p>
<p>Make由一个名为Makefile的脚本文件驱动，该文件使用Make自己定义的语法格式。其基本组成部分为一系列规则（Rules），而每一条规则又包括目标（Target）、依赖（Prerequisite）和命令（Command）。Makefile的基本结构如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET……:PREREQUISITE……</span><br><span class="line">COMMAND</span><br><span class="line">…….</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>Make通过一系列目标和依赖将整个构建过程串联起来，同时利用本地命令完成每个目标的实际行为。Make的强大之处在于它可以利用所有系统的本地命令，尤其是UNIX/Linux系统，丰富的功能、强大的命令能够帮助Make快速高效地完成任务。</p>
<p>但是，Make将自己和操作系统绑定在一起了。也就是说，使用Make，就不能实现（至少很难）跨平台的构建，这对于Java来说是非常不友好的。此外，Makefile的语法也成问题，很多人抱怨Make构建失败的原因往往是一个难以发现的空格或Tab使用错误。</p>
<h3 id="1-2-4-Ant"><a href="#1-2-4-Ant" class="headerlink" title="1.2.4　Ant"></a>1.2.4　Ant</h3><p>Ant不是指蚂蚁，而是意指“另一个整洁的工具”（Another Neat Tool），它最早用来构建著名的Tomcat，其作者James Duncan Davidson创作它的动机就是因为受不了Makefile的语法格式。我们可以将Ant看成是一个Java版本的Make，也正因为使用了Java,Ant是跨平台的。此外，Ant使用XML定义构建脚本，相对于Makefile来说，这也更加友好。</p>
<p>与Make类似，Ant有一个构建脚本build.xml，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">＜?xml version=&quot;1.0&quot;?＞</span><br><span class="line">＜project name=&quot;Hello&quot;default=&quot;compile&quot;＞</span><br><span class="line">＜target name=&quot;compile&quot;description=&quot;compile the Java source code to class files&quot;＞</span><br><span class="line">＜mkdir dir=&quot;classes&quot;/＞</span><br><span class="line">＜javac srcdir=&quot;.&quot;destdir=&quot;classes&quot;/＞＜/target＞</span><br><span class="line">＜target name=&quot;jar&quot;depends=&quot;compile&quot;description=&quot;create a Jar file&quot;＞</span><br><span class="line">＜jar destfile=&quot;hello.jar&quot;＞</span><br><span class="line">＜fileset dir=&quot;classes&quot;includes=&quot;**/*.class&quot;/＞</span><br><span class="line">＜manifest＞</span><br><span class="line">＜attribute name=&quot;Main-Class&quot;value=&quot;HelloProgram&quot;/＞</span><br><span class="line">＜/manifest＞</span><br><span class="line">＜/jar＞</span><br><span class="line">＜/target＞</span><br><span class="line">＜/project＞</span><br></pre></td></tr></table></figure>
<p>build.xml的基本结构也是目标（target）、依赖（depends），以及实现目标的任务。比如在上面的脚本中，jar目标用来创建应用程序jar文件，该目标依赖于compile目标，后者执行的任务是创建一个名为classes的文件夹，编译当前目录的java文件至classes目录。compile目标完成后，jar目标再执行自己的任务。Ant有大量内置的用Java实现的任务，这保证了其跨平台的特质，同时，Ant也有特殊的任务exec来执行本地命令。</p>
<p>和Make一样，Ant也都是过程式的，开发者显式地指定每一个目标，以及完成该目标所需要执行的任务。针对每一个项目，开发者都需要重新编写这一过程，这里其实隐含着很大的重复。Maven是声明式的，项目构建过程和过程各个阶段所需的工作都由插件实现，并且大部分插件都是现成的，开发者只需要声明项目的基本元素，Maven就执行内置的、完整的构建过程。这在很大程度上消除了重复。</p>
<p>Ant是没有依赖管理的，所以很长一段时间Ant用户都不得不手工管理依赖，这是一个令人头疼的问题。幸运的是，Ant用户现在可以借助Ivy管理依赖。而对于Maven用户来说，依赖管理是理所当然的，Maven不仅内置了依赖管理，更有一个可能拥有全世界最多Java开源软件包的中央仓库，Maven用户无须进行任何配置就可以直接享用。</p>
<h3 id="1-2-5-不重复发明轮子"><a href="#1-2-5-不重复发明轮子" class="headerlink" title="1.2.5　不重复发明轮子"></a>1.2.5　不重复发明轮子</h3><p>小张是一家小型民营软件公司的程序员，他所在的公司要开发一个新的Web项目。经过协商，决定使用Spring、iBatis和Tapstry。jar包去哪里找呢？公司里估计没有人能把Spring、iBatis和Tapstry所使用的jar包一个不少地找出来。大家的做法是，先到Spring的站点上去找一个spring-with-dependencies，然后去iBatis的网站上把所有列出来的jar包下载下来，对Tapstry、Apache commons等执行同样的操作。项目还没有开始，WEB-INF/lib下已经有近百个jar包了，带版本号的、不带版本号的、有用的、没用的、相冲突的，怎一个“乱”字了得！</p>
<p>在项目开发过程中，小张不时地发现版本错误和版本冲突问题，他只能硬着头皮逐一解决。项目开发到一半，经理发现最终部署的应用的体积实在太大了，要求小张去掉一些没用的jar包，于是小张只能加班加点地一个个删……</p>
<p>小张隐隐地觉得这些依赖需要一个框架或者系统来进行管理。</p>
<p>小张喜欢学习流行的技术，前几年Ant十分流行，他学了，并成为了公司这方面的专家。小张知道，Ant打包，无非就是创建目录，复制文件，编译源代码，使用一堆任务，如copydir、fileset、classpath、ref、target，然后再jar、zip、war，打包就成功了。</p>
<p>项目经理发话了：“兄弟们，新项目来了，小张，你来写Ant脚本！”</p>
<p>“是，保证完成任务！”接着，小张继续创建一个新的XML文件。target clean；target compile；target jar；……不知道他是否想过，在他写的这么多的Ant脚本中，有多少是重复劳动，有多少代码会在一个又一个项目中重现。既然都差不多，有些甚至完全相同，为什么每次都要重新编写？</p>
<p>终于有一天，小张意识到了这个问题，想复用Ant脚本，于是在开会时他说：“以后就都用我这个规范的Ant脚本吧，新的项目只要遵循我定义的目录结构就可以了。”经理听后觉得很有道理：“嗯，确实是个进步。</p>
<p>这时新来的研究生发言了：“经理，用Maven吧，这个在开源社区很流行，比Ant更方便。”小张一听很惊讶，Maven真比自己的“规范化Ant”强大？其实他不知道自己只是在重新发明轮子，Maven已经有一大把现成的插件，全世界都在用，你自己不用写任何代码！</p>
<p>为什么没有人说“我自己写的代码最灵活，所以我不用Spring，我自己实现IoC；我不用Hibernate，我自己封装JDBC”？</p>
<h2 id="1-3-Maven与极限编程"><a href="#1-3-Maven与极限编程" class="headerlink" title="1.3　Maven与极限编程"></a>1.3　Maven与极限编程</h2><p>极限编程（XP）是近些年在软件行业红得发紫的敏捷开发方法，它强调拥抱变化。该软件开发方法的创始人Kent Beck提出了XP所追求的价值、实施原则和推荐实践。下面看一下Maven是如何适应XP的。</p>
<p>首先看一下Maven如何帮助XP团队实现一些核心价值：</p>
<p>简单。Maven暴露了一组一致、简洁的操作接口，能帮助团队成员从原来的高度自定义的、复杂的构建系统中解脱出来，使用Maven现有的成熟的、稳定的组件也能简化构建系统的复杂度。</p>
<p>交流与反馈。与版本控制系统结合后，所有人都能执行最新的构建并快速得到反馈。此外，自动生成的项目报告也能帮助成员了解项目的状态，促进团队的交流。</p>
<p>此外，Maven更能无缝地支持或者融入到一些主要的XP实践中：</p>
<p>测试驱动开发（TDD）。TDD强调测试先行，所有产品都应该由测试用例覆盖。而测试是Maven生命周期的最重要的组成部分之一，并且Maven有现成的成熟插件支持业界流行的测试框架，如JUnit和TestNG。</p>
<p>十分钟构建。十分钟构建强调我们能够随时快速地从源码构建出最终的产品。这正是Maven所擅长的，只需要一些配置，之后用一条简单的命令就能让Maven帮你清理、编译、测试、打包、部署，然后得到最终的产品。</p>
<p>持续集成（CI）。CI强调项目以很短的周期（如15分钟）集成最新的代码。实际上，CI的前提是源码管理系统和构建系统。目前业界流行的CI服务器如Hudson和CruiseControl都能很好地和Maven进行集成。也就是说，使用Maven后，持续集成会变得更加方便。</p>
<p>富有信息的工作区。这条实践强调开发者能够快速方便地了解到项目的最新状态。当然，Maven并不会帮你把测试覆盖率报告贴到墙上，也不会在你的工作台上放个鸭子告诉你构建失败了。不过使用Maven发布的项目报告站点，并配置你需要的项目报告，如测试覆盖率报告，都能帮你把信息推送到开发者眼前。</p>
<p>上述这些实践并非只在XP中适用。事实上，除了其他敏捷开发方法如SCRUM之外，几乎任何软件开发方法都能借鉴这些实践。也就是说，Maven几乎能够很好地支持任何软件开发方法。</p>
<p>例如，在传统的瀑布模型开发中，项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。从设计和编码阶段开始，就可以使用Maven来建立项目的构建系统。在设计阶段，也完全可以针对设计开发测试用例，然后再编写代码来满足这些测试用例。然而，有了自动化构建系统，我们可以节省很多手动的测试时间。此外，尽早地使用构建系统集成团队的代码，对项目也是百利而无一害。最后，Maven还能帮助我们快速地发布项目。</p>
<h2 id="1-4-被误解的Maven"><a href="#1-4-被误解的Maven" class="headerlink" title="1.4　被误解的Maven"></a>1.4　被误解的Maven</h2><p>C++之父Bjarne Stroustrup说过一句话：“只有两类计算机语言，一类语言天天被人骂，还有一类没人用。”当然这话也不全对，大红大紫的Ruby不仅有人用，而且骂的人也少。用户最多的Java得到的骂声就不绝于耳了。Maven的用户也不少，它的邮件列表目前在Apache项目中排名第4（<a target="_blank" rel="noopener" href="http://www.nabble.com/Apache-f">http://www.nabble.com/Apache-f</a> 90.html）。</p>
<p>让我们看看Maven受到了哪些质疑，笔者将对这些质疑逐一解释。</p>
<p>“Maven对于IDE（如Eclipse和IDEA）的支持较差，bug多，而且不稳定。”</p>
<p>相对于JUnit和Ant来说，Maven比较年轻，IDE集成等衍生产品还不够全面和成熟。但是，我们一定要知道，使用Maven最高效的方式永远是命令行，IDE在自动化构建方面有天生的缺陷。此外，Eclipse的Maven插件——m2eclipse是一个比较优秀和成熟的工具，NetBeans也在积极地为更好地集成Maven而努力，自IntelliJ IDEA开源后，也有望看到其对Maven更好的集成。</p>
<p>“Maven采用了一个糟糕的插件系统来执行构建，新的、破损的插件会让你的构建莫名其妙地失败。”</p>
<p>自Maven 2.0.9开始，所有核心的插件都设定了稳定版本，这意味着日常使用Maven时几乎不会受到不稳定插件的影响。此外，Maven社区也提倡为你使用的任何插件设定稳定的版本。如果我们有好的实践不采纳，遇到了问题就抱怨，未免不够公允。从Maven 3开始，如果你使用插件时未设定版本，会看到警告信息。</p>
<p>“Maven过于复杂，它就是构建系统的EJB 2。”</p>
<p>不要指望Maven十分简单，这几乎是不可能的。Maven是用来管理项目的，清理、编译、测试、打包、发布，以及一些自定义的过程本身就是一件复杂的事情。目前在Java社区还有比Maven更强大、更简单的构建工具吗？答案是否定的。我们可以尝试去帮助Maven让它变得更简单，而不是抛弃它，然后自己实现一套更加复杂的构建系统。</p>
<p>“Maven的仓库十分混乱，当无法从仓库中得到需要的类库时，我需要手工下载复制到本地仓库中。”</p>
<p>Maven的中央仓库确实不完美，你也许会发现某个jar包出现在两个不同的路径下。这不是Maven的错，这是开源项目本身改变了自身的坐标。如果没有中央仓库，你将不得不去开源项目首页寻找下载链接，这不是更费事吗？现在有很多的Maven仓库搜索服务。无法从中央仓库找到你需要的类库？由于许可证等因素，这是完全有可能的，这时你需要做的是建立一个组织内部的仓库服务器，你会发现这会给你带来许多意想不到的好处。</p>
<p>“缺乏文档是理解和使用Maven的一个主要障碍！”</p>
<p>这是事实。Maven官方站点的文档十分凌乱，各种插件的文档更是需要费力寻找。So-natype编写的《Maven权威指南》很好地改善了这一状况，但由于该书的某些部分与国内的现状有些脱离，且翻译速度无法跟上原版的更新速度，于是笔者编写本书，目的也是帮助大家理解和使用Maven。</p>
<h1 id="第2章-Maven的安装和配置"><a href="#第2章-Maven的安装和配置" class="headerlink" title="第2章　Maven的安装和配置"></a>第2章　Maven的安装和配置</h1><p>本章内容</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Windows上安装Maven</span><br><span class="line">在基于UNIX的系统上安装Maven</span><br><span class="line">安装目录分析</span><br><span class="line">设置HTTP代理</span><br><span class="line">安装m2eclipse</span><br><span class="line">安装NelBeans Maven 插件</span><br><span class="line">%Maven安装最佳实践</span><br></pre></td></tr></table></figure>
<h2 id="2-1-在Windows上安装Maven"><a href="#2-1-在Windows上安装Maven" class="headerlink" title="2.1　在Windows上安装Maven"></a>2.1　在Windows上安装Maven</h2><h3 id="2-1-1-检查JDK安装"><a href="#2-1-1-检查JDK安装" class="headerlink" title="2.1.1　检查JDK安装"></a>2.1.1　检查JDK安装</h3><p>在安装Maven之前，首先要确认你已经正确安装了JDK。Maven可以运行在JDK 1.4及以上的版本上。本书的所有样例都基于JDK 5及以上版本。打开Windows的命令行，运行如下的命令来检查Java安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Juven Xu＞<span class="built_in">echo</span> %JAVA_HOME%</span><br><span class="line">C:\Users\Juven Xu＞java -version</span><br></pre></td></tr></table></figure>
<p>结果如图2-1所示：</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152003917.png" alt="image-20231015200335771"></p>
<p>上述命令首先检查环境变量JAVA_HOME是否指向了正确的JDK目录，接着尝试运行java命令。如果Windows无法执行java命令，或者无法找到JAVA_HOME环境变量，就需要检查Java是否安装了，或者环境变量是否设置正确。关于环境变量的设置，请参考2.1.3节。</p>
<h3 id="2-1-2-下载Maven"><a href="#2-1-2-下载Maven" class="headerlink" title="2.1.2　下载Maven"></a>2.1.2　下载Maven</h3><p>请访问Maven的下载页面：<a target="_blank" rel="noopener" href="http://maven.apache.org/download.html，其中包含针对不同平台的各种版本的Maven下载文件。对于首次接触Maven的读者来说，推荐使用Maven">http://maven.apache.org/download.html，其中包含针对不同平台的各种版本的Maven下载文件。对于首次接触Maven的读者来说，推荐使用Maven</a> 3.0，因此需要下载apache-maven-3.0-bin.zip。当然，如果你对Maven的源代码感兴趣并想自己构建Maven，还可以下载apache-maven-3.0-src.zip。该下载页面还提供了md5校验和（checksum）文件和asc数字签名文件，可以用来检验Maven分发包的正确性和安全性。</p>
<p>在编写本书的时候，Maven 2的最新版本是2.2.1，Maven 3基本完全兼容Maven 2，而且比Maven 2的性能更好，还对其中某些功能进行了改进。如果你之前一直使用Maven 2，现在正犹豫是否要升级，那就大可不必担心了，快点尝试一下Maven 3吧！</p>
<h3 id="2-1-3-本地安装"><a href="#2-1-3-本地安装" class="headerlink" title="2.1.3　本地安装"></a>2.1.3　本地安装</h3><p>将安装文件解压到指定的目录中，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\bin＞jar xvf<span class="string">&quot;C:\Users\Juven Xu\Downloads\apache-maven-3.0bin.zip&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里的Maven安装目录是D:\bin\apache-maven-3.0，接着需要设置环境变量，将Maven安装配置到操作系统环境中。</p>
<p>打开系统属性面板（在桌面上右击“我的电脑”→“属性”），单击高级系统设置，再单击环境变量，在系统变量中新建一个变量，变量名为M2_HOME，变量值为Maven的安装目录D:\bin\apache-maven-3.0。单击“确定”按钮，接着在系统变量中找到一个名为Path的变量，在变量值的末尾加上%M2_HOME%\bin；。注意：多个值之间需要有分号隔开，然后单击“确定”按钮。至此，环境变量设置完成。详细情况如图2-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152004887.png" alt="image-20231015200439829"></p>
<p>值得注意的是Path环境变量。当我们在cmd中输入命令时，Windows首先会在当前目录中寻找可执行文件或脚本，如果没有找到，Windows会接着遍历环境变量Path中定义的路径。由于将%M2_HOME%\bin添加到了Path中，而这里%M2_HOME%实际上是引用了前面定义的另一个变量，其值是Maven的安装目录。因此，Windows会在执行命令时搜索目录D:\bin\apache-maven-3.0\bin，而mvn执行脚本的位置就是这里。</p>
<p>了解环境变量的作用之后，现在打开一个新的cmd窗口（这里强调新的窗口是因为新的环境变量配置需要新的cmd窗口才能生效），运行如下命令检查Maven的安装情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Juven Xu＞<span class="built_in">echo</span> %M2_HOME%</span><br><span class="line">C:\Users\Juven Xu＞mvn -v</span><br></pre></td></tr></table></figure>
<p>运行结果如图2-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152006317.png" alt="image-20231015200621269"></p>
<p>第一条命令echo%M2_HOME%用来检查环境变量M2_HOME是否指向了正确的Maven安装目录；而mvn-v执行了第一条Maven命令，以检查Windows是否能够找到正确的mvn执行脚本。</p>
<h3 id="2-1-4-升级Maven"><a href="#2-1-4-升级Maven" class="headerlink" title="2.1.4　升级Maven"></a>2.1.4　升级Maven</h3><p>Maven更新比较频繁，因此用户往往会需要更新Maven安装以获得更多、更酷的新特性，并避免一些旧的bug。</p>
<p>在Windows上更新Maven非常简便，只需要下载新的Maven安装文件，解压至本地目录，然后更新M2_HOME环境变量即可。例如，假设Maven推出了新版本3.1，我们将其下载然后解压至目录D:\bin\apache-maven-3.1，接着遵照前一节描述的步骤编辑环境变量M2_HOME，更改其值为D:\bin\apache-maven-3.1。至此，更新就完成了。同理，如果需要使用某一个旧版本的Maven，也只需要编辑M2_HOME环境变量指向旧版本的安装目录。</p>
<h2 id="2-2-在基于UNIX的系统上安装Maven"><a href="#2-2-在基于UNIX的系统上安装Maven" class="headerlink" title="2.2　在基于UNIX的系统上安装Maven"></a>2.2　在基于UNIX的系统上安装Maven</h2><p>Maven是跨平台的，它可以在任何一种主流的操作系统上运行。本节将介绍如何在基于UNIX的系统（包括Linux、Mac OS以及FreeBSD等）上安装Maven。</p>
<h3 id="2-2-1-下载和安装"><a href="#2-2-1-下载和安装" class="headerlink" title="2.2.1　下载和安装"></a>2.2.1　下载和安装</h3><p>首先，与在Windows上安装Maven一样，需要检查JAVA_HOME环境变量以及Java命令，这里对细节不再赘述。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu：～<span class="variable">$echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line">juven@juven-ubuntu：～<span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
<p>运行结果如图2-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152008749.png" alt="image-20231015200828710"></p>
<p>接着到<a target="_blank" rel="noopener" href="http://maven.apache.org/download.html下载Maven安装文件，如apache-maven-3.0-bin.tar.gz，然后解压到本地目录：">http://maven.apache.org/download.html下载Maven安装文件，如apache-maven-3.0-bin.tar.gz，然后解压到本地目录：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu:bin<span class="variable">$tar</span> -xvzf apache-maven-3.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>现在已经创建好了一个Maven安装目录apache-maven-3.0。虽然直接使用该目录配置环境变量之后就能使用Maven了，但这里的推荐做法是，在安装目录旁平行地创建一个符号链接，以方便日后的升级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu:bin<span class="variable">$ln</span>-s apache-maven-3.0 apache-maven</span><br><span class="line">juven@juven-ubuntu:bin<span class="variable">$ls</span>-l</span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx 1 juven juven 18 2009-09-20 15：43 apache-maven-＞apache-maven-3.0</span><br><span class="line">drwxr-xr-x 6 juven juven 4096 2009-09-20 15：39 apache-maven-3.0</span><br></pre></td></tr></table></figure>
<p>接下来，需要设置M2_HOME环境变量指向符号链接apache-maven-，并且把Maven安装目录下的bin/文件夹添加到系统环境变量PATH中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu:bin<span class="variable">$export</span> M2_HOME=/home/juven/bin/apache-maven</span><br><span class="line">juven@juven-ubuntu:bin<span class="variable">$export</span> PATH=<span class="variable">$PATH</span>：<span class="variable">$M2_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>一般来说，需要将这两行命令加入到系统的登录shell脚本中去，以Ubuntu 8.10为例，编辑～/.bashrc文件，添加这两行命令。这样，每次启动一个终端，这些配置就能自动执行。</p>
<p>至此，安装完成。可以运行以下命令检查Maven安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu:bin$<span class="built_in">echo</span><span class="variable">$M2_HOME</span></span><br><span class="line">juven@juven-ubuntu:bin<span class="variable">$mvn</span>-v</span><br></pre></td></tr></table></figure>
<p>运行结果如图2-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152014088.png" alt="image-20231015201400051"></p>
<h3 id="2-2-2-升级Maven"><a href="#2-2-2-升级Maven" class="headerlink" title="2.2.2　升级Maven"></a>2.2.2　升级Maven</h3><p>在基于UNIX的系统上，可以利用符号链接这一工具来简化Maven的升级，不必像在Windows上那样，每次升级都必须更新环境变量。</p>
<p>前一小节中我们提到，解压Maven安装包到本地之后，平行地创建一个符号链接，然后在配置环境变量时引用该符号链接，这样做是为了方便升级。现在，假设需要升级到新的Maven 3.1版本，将安装包解压到与前一版本平行的目录下，然后更新符号链接指向3.1版的目录便可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">juven@juven-ubuntu:bin<span class="variable">$rm</span> apache-maven</span><br><span class="line">juven@juven-ubuntu:bin<span class="variable">$ln</span>-s apache-maven-3.1/apache-maven</span><br><span class="line">juven@juven-ubuntu:bin<span class="variable">$ls</span>-l</span><br><span class="line">total 8</span><br><span class="line">lrwxrwxrwx 1 juven juven 17 2009-09-20 16：13 apache-maven-＞apache-maven-3.1/</span><br><span class="line">drwxr-xr-x 6 juven juven 4096 2009-09-20 15：39 apache-maven-3.0</span><br><span class="line">drwxr-xr-x 2 juven juven 4096 2009-09-20 16：09 apache-maven-3.1</span><br></pre></td></tr></table></figure>
<p>同理，可以很方便地切换到Maven的任意一个版本。现在升级完成了，可以运行mvn-v进行检查。</p>
<h2 id="2-3-安装目录分析"><a href="#2-3-安装目录分析" class="headerlink" title="2.3　安装目录分析"></a>2.3　安装目录分析</h2><p>前面讲述了如何在各种操作系统中安装和升级Maven。现在来仔细分析一下Maven的安装文件。</p>
<h3 id="2-3-1-M2-HOME"><a href="#2-3-1-M2-HOME" class="headerlink" title="2.3.1　M2_HOME"></a>2.3.1　M2_HOME</h3><p>前面讲到设置M2_HOME环境变量指向Maven的安装目录，本书之后所有使用M2_HOME的地方都指代了该安装目录。下面看一下该目录的结构和内容：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">conf</span><br><span class="line">lib</span><br><span class="line">LICENSE.txt</span><br><span class="line">NOTICE.txt</span><br><span class="line">README.txt</span><br></pre></td></tr></table></figure>
<p>bin：该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。其中mvn是基于UNIX平台的shell脚本，mvn.bat是基于Windows平台的bat脚本。在命令行输入任何一条mvn命令时，实际上就是在调用这些脚本。该目录还包含了mvnDebug和mvnDebug.bat两个文件，同样，前者是UNIX平台的shell脚本，后者是Windows平台的bat脚本。那么mvn和mvnDebug有什么区别和关系呢？打开文件我们就可以看到，两者基本是一样的，只是mvnDebug多了一条MAVEN_DEBUG_OPTS配置，其作用就是在运行Maven时开启debug，以便调试Maven本身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件，后面会介绍classworlds。</p>
<p>boot：该目录只包含一个文件，以maven 3.0为例，该文件为plexus-classworlds-2.2.3.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。更多关于classworlds的信息请参考<a target="_blank" rel="noopener" href="http://classworlds.codehaus.org/。对于一般的Maven用户来说，不必关心该文件。">http://classworlds.codehaus.org/。对于一般的Maven用户来说，不必关心该文件。</a></p>
<p>conf：该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。一般情况下，我们更偏向于复制该文件至～/.m2/目录下（～表示用户目录），然后修改该文件，在用户范围定制Maven的行为。后面将会多次提到settings.xml，并逐步分析其中的各个元素。</p>
<p>lib：该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件。此外，这里还包含一些Maven用到的第三方依赖，如common-cli-1.2.jar、google-collection-1.0.jar等。对于Maven 2来说，该目录只包含一个如maven-2.2.1-uber.jar的文件，原本各为独立JAR文件的Maven模块和第三方类库都被拆解后重新合并到了这个JAR文件中。可以说，lib目录就是真正的Maven。关于该文件，还有一点值得一提的是，用户可以在这个目录中找到Maven内置的超级POM，这一点在8.5节详细解释。其他：LICENSE.txt记录了Maven使用的软件许可证Apache License Version 2.0；NOTICE.txt记录了Maven包含的第三方软件；而README.txt则包含了Maven的简要介绍，包括安装需求及如何安装的简要指令等。</p>
<h3 id="2-3-2-～-m2"><a href="#2-3-2-～-m2" class="headerlink" title="2.3.2　～/.m2"></a>2.3.2　～/.m2</h3><p>在讲述该小节之前，我们先运行一条简单的命令：mvn help:system。该命令会打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助。这里暂不解释help:system涉及的语法，运行这条命令的目的是让Maven执行一个真正的任务。我们可以从命令行输出看到Maven会下载maven-help-plugin，包括pom文件和jar文件。这些文件都被下载到了Maven本地仓库中。</p>
<p>现在打开用户目录，比如当前的用户目录是C:\Users\Juven Xu\，你可以在Vista和Windows7中找到类似的用户目录。如果是更早版本的Windows，该目录应该类似于C:\Document and Settings\Juven Xu\。在基于UNIX的系统上，直接输入cd回车，就可以转到用户目录。为了方便，本书统一使用符号～指代用户目录。</p>
<p>在用户目录下可以发现.m2文件夹。默认情况下，该文件夹下放置了Maven本地仓库.m2/repository。所有的Maven构件都被存储到该仓库中，以方便重用。可以到～/.m2/reposi-tory/org/apache/maven/plugins/maven-help-plugins/目录下找到刚才下载的maven-help-plugin的pom文件和jar文件。Maven根据一套规则来确定任何一个构件在仓库中的位置，这一点在第6章将会详细阐述。由于Maven仓库是通过简单文件系统透明地展示给Maven用户的，有些时候可以绕过Maven直接查看或修改仓库文件，在遇到疑难问题时，这往往十分有用。</p>
<p>默认情况下，～/.m2目录下除了repository仓库之外就没有其他目录和文件了，不过大多数Maven用户需要复制M2_HOME/conf/settings.xml文件到～/.m2/settings.xml。这是一条最佳实践，我们将在2.7小节详细解释。</p>
<h2 id="2-4-设置HTTP代理"><a href="#2-4-设置HTTP代理" class="headerlink" title="2.4　设置HTTP代理"></a>2.4　设置HTTP代理</h2><p>有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网。这种情况下，就需要为Maven配置HTTP代理，才能让它正常访问外部仓库，以下载所需要的资源。</p>
<p>首先确认自己无法直接访问公共的Maven中央仓库，直接运行命令ping repo1.maven.org可以检查网络。如果真的需要代理，先检查一下代理服务器是否畅通。比如现在有一个IP地址为218.14.227.197，端口为3128的代理服务，我们可以运行telnet 218.14.227.197 3128来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息；如果telnet连接正确，则输入ctrl+]，然后q，回车，退出即可</p>
<p>检查完毕之后，编辑～/.m2/settings.xml文件（如果没有该文件，则复制$M2_HOME/conf/settings.xml）。添加代理配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜settings＞……＜proxies＞＜proxy＞＜id＞my-proxy＜/id＞＜active＞true＜/active＞＜protocol＞http＜/protocol＞＜host＞218.14.227.197＜/host＞＜port＞3128＜/port＞＜！——＜username＞***＜/username＞＜password＞***＜/password＞＜nonProxyHosts＞repository.mycom.com|*.google.com＜/nonProxyHosts＞——＞＜/proxy＞＜/proxies＞……＜/settings＞</span><br></pre></td></tr></table></figure>
<p>这段配置十分简单，proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。这里声明了一个id为my-proxy的代理，active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。当然，最重要的是指定正确的主机名（host元素）和端口（port元素）。上述XML配置中注释掉了username、password、nonProxyHost几个元素。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机名不需要代理，可以使用“|”符号来分隔多个主机名。此外，该配置也支持通配符，如*.google.com表示所有以google.com结尾的域名访问都不要通过代理。</p>
<h2 id="2-7-Maven安装最佳实践"><a href="#2-7-Maven安装最佳实践" class="headerlink" title="2.7　Maven安装最佳实践"></a>2.7　Maven安装最佳实践</h2><p>本节介绍一些在安装Maven过程中不是必须的，但十分有用的实践。</p>
<h3 id="2-7-1-设置MAVEN-OPTS环境变量"><a href="#2-7-1-设置MAVEN-OPTS环境变量" class="headerlink" title="2.7.1　设置MAVEN_OPTS环境变量"></a>2.7.1　设置MAVEN_OPTS环境变量</h3><p>前面介绍Maven安装目录时我们了解到，运行mvn命令实际上是执行了Java命令，既然是运行Java，那么运行Java命令可用的参数当然也应该在运行mvn命令时可用。这个时候，MAVEN_OPTS环境变量就能派上用场。</p>
<p>通常需要设置MAVEN_OPTS的值为-Xms128m-Xmx512m，因为Java默认的最大可用内存往往不能够满足Maven运行的需要，比如在项目较大时，使用Maven生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到java.lang.OutOfMemeoryError。因此，一开始就配置该变量是推荐的做法。</p>
<p>关于如何设置环境变量，请参考前面设置M2_HOME环境变量的做法，尽量不要直接修改mvn.bat或者mvn这两个Maven执行脚本文件。因为如果修改了脚本文件，升级Maven时就不得不再次修改，一来麻烦，二来容易忘记。同理，应该尽可能地不去修改任何Maven安装目录下的文件。</p>
<h3 id="2-7-2-配置用户范围settings-xml"><a href="#2-7-2-配置用户范围settings-xml" class="headerlink" title="2.7.2　配置用户范围settings.xml"></a>2.7.2　配置用户范围settings.xml</h3><p>Maven用户可以选择配置$M2_HOME/conf/settings.xml或者～/.m2/settings.xml。前者是全局范围的，整台机器上的所有用户都会直接受到该配置的影响，而后者是用户范围的，只有当前用户才会受到该配置的影响。</p>
<p>推荐使用用户范围的settings.xml，主要是为了避免无意识地影响到系统中的其他用户。如果有切实的需求，需要统一系统中所有用户的settings.xml配置，当然应该使用全局范围的settings.xml。</p>
<p>除了影响范围这一因素，配置用户范围settings.xml文件还便于Maven升级。直接修改conf目录下的settings.xml会导致Maven升级不便，每次升级到新版本的Maven，都需要复制settings.xml文件。如果使用～/.m2目录下的settings.xml，就不会影响到Maven安装文件，升级时就不需要触动settings.xml文件。</p>
<h3 id="2-7-3-不要使用IDE内嵌的Maven"><a href="#2-7-3-不要使用IDE内嵌的Maven" class="headerlink" title="2.7.3　不要使用IDE内嵌的Maven"></a>2.7.3　不要使用IDE内嵌的Maven</h3><p>无论Eclipse还是NetBeans，当集成Maven时，都会安装上一个内嵌的Maven，这个内嵌的Maven通常会比较新，但不一定很稳定，而且往往也会和在命令行使用的Maven不是同一个版本。这里又会出现两个潜在的问题：首先，较新版本的Maven存在很多不稳定因素，容易造成一些难以理解的问题；其次，除了IDE，也经常还会使用命令行的Maven，如果版本不一致，容易造成构建行为的不一致，这是我们所不希望看到的。因此，应该在IDE中配置Maven插件时使用与命令行一致的Maven。</p>
<h1 id="第3章-Maven使用入门"><a href="#第3章-Maven使用入门" class="headerlink" title="第3章　Maven使用入门"></a>第3章　Maven使用入门</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">本章内容</span><br><span class="line">编写POM</span><br><span class="line">编写主代码</span><br><span class="line">编写测试代码</span><br><span class="line">打包和运行</span><br><span class="line">使用Archetype生成项目骨架</span><br><span class="line">m2eclipse简单使用</span><br><span class="line">NetBeans Maven插件简单使用</span><br></pre></td></tr></table></figure>
<h2 id="3-1-编写POM"><a href="#3-1-编写POM" class="headerlink" title="3.1　编写POM"></a>3.1　编写POM</h2><p>就像Make的Makefile、Ant的build.xml一样，Maven项目的核心是pom.xml。POM（Project Object Model，项目对象模型）定义了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。现在先为Hello World项目编写一个最简单的pom.xml。</p>
<p>首先创建一个名为hello-world的文件夹，打开该文件夹，新建一个名为pom.xml的文件，输入其内容，如代码清单3-1所示。</p>
<p>代码清单3-1　Hello World的POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?＞＜project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;＞＜modelVersion＞4.0.0＜/modelVersion＞＜groupId＞com.juvenxu.mvnbook＜/groupId＞＜artifactId＞hello-world＜/artifactId＞＜version＞1.0-SNAPSHOT＜/version＞＜name＞Maven Hello World Project＜/name＞＜/project＞</span><br></pre></td></tr></table></figure>
<p>代码的第一行是XML头，指定了该xml文档的版本和编码方式。紧接着是project元素，project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具（如IDE中的XML编辑器）帮助我们快速编辑POM。</p>
<p>根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven 2及Maven 3来说，它只能是4.0.0。</p>
<p>这段代码中最重要的是包含groupId、artifactId和version的三行。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者war都是以基于这些基本的坐标进行区分的。</p>
<p>groupId定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联。譬如在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp。本书中所有的代码都基于groupId com.juvenxu.mvnbook。</p>
<p>artifactId定义了当前Maven项目在组中唯一的ID，我们为这个Hello World项目定义artifactId为hello-world，本书其他章节代码会分配其他的artifactId。而在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目（模块）分配artifactId，如myapp-util、myapp-domain、myapp-web等。</p>
<p>顾名思义，version指定了Hello World项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等。6.5节会详细介绍SNAPSHOT，第13章会介绍如何使用Maven管理项目版本的升级发布。</p>
<p>最后一个name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name，以方便信息交流。</p>
<p>没有任何实际的Java代码，我们就能够定义一个Maven项目的POM，这体现了Maven的一大优点，它能让项目对象模型最大程度地与实际代码相独立，我们可以称之为解耦，或者正交性。这在很大程度上避免了Java代码和POM代码的相互影响。比如当项目需要升级版本时，只需要修改POM，而不需要更改Java代码；而在POM稳定之后，日常的Java代码开发工作基本不涉及POM的修改。</p>
<h2 id="3-2-编写主代码"><a href="#3-2-编写主代码" class="headerlink" title="3.2　编写主代码"></a>3.2　编写主代码</h2><p>项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（如jar），而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的约定，创建该目录，然后在该目录下创建文件com/juvenxu/mvnbook/helloworld/HelloWorld.java，其内容如代码清单3-2所示：</p>
<p>代码清单3-2　Hello World的主代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juvenxu.mvnbook.helloworld；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String sayHello（）&#123;</span><br><span class="line">            <span class="keyword">return</span><span class="string">&quot;Hello Maven&quot;</span>；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">            System.out.print（<span class="keyword">new</span> <span class="title class_">HelloWorld</span>（）.sayHello（））；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的Java类，它有一个sayHello（）方法，返回一个String。同时这个类还带有一个main方法，创建一个HelloWorld实例，调用sayHello（）方法，并将结果输出到控制台。</p>
<p>关于该Java代码有两点需要注意。首先，在绝大多数情况下，应该把项目主代码放到src/main/java/目录下（遵循Maven的约定），而无须额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，该Java类的包名是com.juvenxu.mvnbook.helloworld，这与之前在POM中定义的groupId和artifactId相吻合。一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者Java类。</p>
<p>代码编写完毕后，使用Maven进行编译，在项目根目录下运行命令mvn clean compile会得到如下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">INFO</span>] Scanning for projects…[<span class="string">INFO</span>]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[<span class="string">INFO</span>] Building Maven Hello World Project[<span class="string">INFO</span>]task-segment: [<span class="string">clean, compile</span>][<span class="symbol">INFO</span>]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[<span class="string">INFO</span>] [<span class="string">clean:clean &#123;execution: default-clean&#125;</span>][<span class="symbol">INFO</span>] Deleting directory D:＼code＼hello-world＼target[<span class="string">INFO</span>] [<span class="string">resources:resources &#123;execution: default-resources&#125;</span>][<span class="symbol">INFO</span>] skip non existing resourceDirectory D: ＼code ＼hello-world ＼src ＼main ＼resources</span><br><span class="line">[<span class="string">INFO</span>] [<span class="string">compiler:compile &#123;execution: default-compile&#125;</span>][<span class="symbol">INFO</span>] Compiling 1 source file to D: ＼code＼hello-world＼target＼classes[INFO]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[INFO] BUILD SUCCESSFUL[INFO]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[INFO] Total time: 1 second[INFO] Finished at: Fri Oct 09 02:08:09 CST 2009[INFO] Final Memory: 9M／16M[INFO]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</span><br></pre></td></tr></table></figure>
<p>clean告诉Maven清理输出目录target/，compile告诉Maven编译项目主代码，从输出中看到Maven首先执行了clean:clean任务，删除target/目录。默认情况下，Maven构建的所有输出都在target/目录中；接着执行resources:resources任务（未定义项目资源，暂且略过）；最后执行compiler:compile任务，将项目主代码编译至target/classes目录（编译好的类为com/juvenxu/mvnbook/helloworld/HelloWorld.Class）。</p>
<p>上文提到的clean:clean、resources:resources和compiler:compile对应了一些Maven插件及插件目标，比如clean:clean是clean插件的clean目标，compiler:compile是compiler插件的compile目标。后文会详细讲述Maven插件及其编写方法。</p>
<p>至此，Maven在没有任何额外的配置的情况下就执行了项目的清理和编译任务。接下来，编写一些单元测试代码并让Maven执行自动化测试。</p>
<h2 id="3-3-编写测试代码"><a href="#3-3-编写测试代码" class="headerlink" title="3.3　编写测试代码"></a>3.3　编写测试代码</h2><p>为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。3.2节讲过Maven项目中默认的主代码目录是src/main/java，对应地，Maven项目中默认的测试代码目录是src/test/java。因此，在编写测试用例之前，应当先创建该目录。</p>
<p>在Java世界中，由Kent Beck和Erich Gamma建立的JUnit是事实上的单元测试标准。要使用JUnit，首先需要为Hello World项目添加一个JUnit依赖，修改项目的POM如代码清单3-3所示：</p>
<p>代码清单3-3　为Hello World的POM添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?＞＜project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;＞＜modelVersion＞4.0.0＜/modelVersion＞＜groupId＞com.juvenxu.mvnbook＜/groupId＞＜artifactId＞hello-world＜/artifactId＞＜version＞1.0-SNAPSHOT＜/version＞＜name＞Maven Hello World Project＜/name＞＜dependencies＞＜dependency＞＜groupId＞junit＜/groupId＞＜artifactId＞junit＜/artifactId＞＜version＞4.7＜/version＞＜scope＞test＜/scope＞＜/dependency＞＜/dependencies＞＜/project＞</span><br></pre></td></tr></table></figure>
<p>代码中添加了dependencies元素，该元素下可以包含多个dependency元素以声明项目的依赖。这里添加了一个依赖——groupId是junit,artifactId是junit,version是4.7。前面提到groupId、artifactId和version是任何一个Maven项目最基本的坐标，JUnit也不例外，有了这段声明，Maven就能够自动下载junit-4.7.jar。也许你会问，Maven从哪里下载这个jar呢？在Maven之前，可以去JUnit的官方网站下载分发包，有了Maven，它会自动访问中央仓库（<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2/），下载需要的文件。读者也可以自己访问该仓库，打开路径junit/junit/4.7/，就能看到junit-4.7.pom和junit-4.7.jar。第6章会详细介绍Maven仓库及中央仓库。">http://repo1.maven.org/maven2/），下载需要的文件。读者也可以自己访问该仓库，打开路径junit/junit/4.7/，就能看到junit-4.7.pom和junit-4.7.jar。第6章会详细介绍Maven仓库及中央仓库。</a></p>
<p>上述POM代码中还有一个值为test的元素scope,scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效。换句话说，测试代码中的import JUnit代码是没有问题的，但是如果在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。</p>
<p>配置了测试依赖，接着就可以编写测试类。回顾一下前面的HelloWorld类，现在要测试该类的sayHello（）方法，检查其返回值是否为“Hello Maven”。在src/test/java目录下创建文件，其内容如代码清单3-4所示：</p>
<p>代码清单3-4　Hello World的测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juvenxu.mvnbook.helloworld；</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals；</span><br><span class="line"><span class="keyword">import</span> org.junit.Test；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span>&#123;</span><br><span class="line">    <span class="meta">@Testpublic</span> <span class="keyword">void</span> testSayHello（）&#123;</span><br><span class="line">        HelloWorld helloWorld=<span class="keyword">new</span> <span class="title class_">HelloWorld</span>（）；</span><br><span class="line">        String result=helloWorld.sayHello（）；</span><br><span class="line">        assertEquals（<span class="string">&quot;Hello Maven&quot;</span>，result）；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的单元测试包含三个步骤：①准备测试类及数据；②执行要测试的行为；③检查结果。上述样例首先初始化了一个要测试的HelloWorld实例，接着执行该实例的sayHello（）方法并保存结果到result变量中，最后使用JUnit框架的Assert类检查结果是否为我们期望的“Hello Maven”。在JUnit 3中，约定所有需要执行测试的方法都以test开头，这里使用了JUnit 4，但仍然遵循这一约定。在JUnit 4中，需要执行的测试方法都应该以@Test进行标注。</p>
<p>测试用例编写完毕之后就可以调用Maven执行测试。运行mvn clean test：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<p>不幸的是构建失败了，先耐心分析一下这段输出（为了本书的简洁，一些不重要的信息用省略号略去了）。命令行输入的是mvn clean test，而Maven实际执行的可不止这两个任务，还有clean:clean、resources:resources、compiler:compile、resources:testResources以及compiler:testCompile。暂时需要了解的是，在Maven执行测试（test）之前，它会先自动执行项目主资源处理、主代码编译、测试资源处理、测试代码编译等工作，这是Maven生命周期的一个特性。本书后续章节会详细解释Maven的生命周期。</p>
<p>从输出中还看到：Maven从中央仓库下载了junit-4.7.pom和junit-4.7.jar这两个文件到本地仓库（～/.m2/repository）中，供所有Maven项目使用。</p>
<p>构建在执行compiler:testCompile任务的时候失败了，Maven输出提示我们需要使用-source 5或更高版本以启动注释，也就是前面提到的JUnit 4的@Test注解。这是Maven初学者常常会遇到的一个问题。由于历史原因，Maven的核心插件之一——compiler插件默认只支持编译Java 1.3，因此需要配置该插件使其支持Java 5，见代码清单3-5。</p>
<p>代码清单3-5　配置maven-compiler-plugin支持Java 5</p>
<p>我们看到compiler:testCompile任务执行成功了，测试代码通过编译之后在target/test-classes下生成了二进制文件，紧接着surefire:test任务运行测试，surefire是Maven中负责执行测试的插件，这里它运行测试用例HelloWorldTest，并且输出测试报告，显示一共运行了多少测试，失败了多少，出错了多少，跳过了多少。显然，我们的测试通过了。</p>
<h2 id="3-4-打包和运行"><a href="#3-4-打包和运行" class="headerlink" title="3.4　打包和运行"></a>3.4　打包和运行</h2><p>将项目进行编译、测试之后，下一个重要步骤就是打包（package）。Hello World的POM中没有指定打包类型，使用默认打包类型jar。简单地执行命令mvn clean package进行打包，可以看到如下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0[<span class="string">INFO</span>] [<span class="string">jar:jar &#123;execution: default-jar&#125;</span>][<span class="symbol">INFO</span>] Building jar: D:＼code＼hello-world＼target＼hello-world-1.0-SNAPSHOT.jar[INFO]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[INFO] BUILD SUCCESSFUL…</span><br></pre></td></tr></table></figure>
<p>类似地，Maven会在打包之前执行编译、测试等操作。这里看到jar:jar任务负责打包，实际上就是jar插件的jar目标将项目主代码打包成一个名为hello-world-1.0-SNAP-SHOT.jar的文件。该文件也位于target/输出目录中，它是根据artifact-version.jar规则进行命名的，如有需要，还可以使用finalName来自定义该文件的名称，这里暂且不展开，后面会详细解释。</p>
<p>至此，我们得到了项目的输出，如果有需要的话，就可以复制这个jar文件到其他项目的Classpath中从而使用HelloWorld类。但是，如何才能让其他的Maven项目直接引用这个jar呢？还需要一个安装的步骤，执行mvn clean install：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">INFO</span>][<span class="symbol">jar:jar&#123;execution:default-jar&#125;</span>][<span class="string">INFO</span>] Building jar: D: ＼code＼hello-world＼target＼hello-world-1.0-SNAPSHOT.jar[<span class="string">INFO</span>] [<span class="string">install:install &#123;execution: default-install&#125;</span>][<span class="symbol">INFO</span>] Installing D:＼code＼hello-world ＼target ＼hello-world-1.0-SNAPSHOT.jar toC:＼Users＼juven ＼.m2 ＼repository ＼com ＼juvenxu ＼mvnbook ＼hello-world ＼1.0-SNAPSHOT ＼hello-world-1.0-SNAPSHOT.jar[INFO]－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－[INFO] BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>
<p>在打包之后，又执行了安装任务install:install。从输出可以看到该任务将项目输出的jar安装到了Maven本地仓库中，可以打开相应的文件夹看到Hello World项目的pom和jar。之前讲述JUnit的POM及jar的下载的时候，我们说只有构件被下载到本地仓库后，才能由所有Maven项目使用，这里是同样的道理，只有将Hello World的构件安装到本地仓库之后，其他Maven项目才能使用它。</p>
<p>我们已经体验了Maven最主要的命令：mvn clean compile、mvn clean test、mvn clean package、mvn clean install。执行test之前是会先执行compile的，执行package之前是会先执行test的，而类似地，install之前会执行package。可以在任何一个Maven项目中执行这些命令，而且我们已经清楚它们是用来做什么的。</p>
<p>到目前为止，还没有运行Hello World项目，不要忘了HelloWorld类可是有一个main方法的。默认打包生成的jar是不能够直接运行的，因为带有main方法的类信息不会添加到manifest中（打开jar文件中的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行）。为了生成可执行的jar文件，需要借助maven-shade-plugin，配置该插件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<p>plugin元素在POM中的相对位置应该在＜project＞＜build＞＜plugins＞下面。我们配置了mainClass为com.juvenxu.mvnbook.helloworld.HelloWorld，项目在打包时会将该信息放到MANIFEST中。现在执行mvn clean install，待构建完成之后打开target/目录，可以看到hel-lo-world-1.0-SNAPSHOT.jar和original-hello-world-1.0-SNAPSHOT.jar，前者是带有Main-Class信息的可运行jar，后者是原始的jar，打开hello-world-1.0-SNAPSHOT.jar的META-INF/MANIFEST.MF，可以看到它包含这样一行信息：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main-Class:com.juvenxu.mvnbook.helloworld.HelloWorld</span><br></pre></td></tr></table></figure>
<p>现在，在项目根目录中执行该jar文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\code\hello-world＞java -jar target\hello-world-1.0-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">Hello Maven</span><br></pre></td></tr></table></figure>
<p>控制台输出为Hello Maven，这正是我们所期望的。</p>
<p>本小节介绍了Hello World项目，侧重点是Maven而非Java代码本身，介绍了POM、Maven项目结构以及如何编译、测试、打包等。</p>
<h2 id="3-5-使用Archetype生成项目骨架"><a href="#3-5-使用Archetype生成项目骨架" class="headerlink" title="3.5　使用Archetype生成项目骨架"></a>3.5　使用Archetype生成项目骨架</h2><p>Hello World项目中有一些Maven的约定：在项目的根目录中放置pom.xml，在src/main/java目录中放置项目的主代码，在src/test/java中放置项目的测试代码。之所以一步一步地展示这些步骤，是为了能让可能是Maven初学者的你得到最实际的感受。我们称这些基本的目录结构和pom.xml文件内容称为项目的骨架，当第一次创建项目骨架的时候，你还会饶有兴趣地去体会这些默认约定背后的思想，第二次，第三次，你也许还会满意自己的熟练程度，但第四、第五次做同样的事情，你可能就会恼火了。为此Maven提供了Archetype以帮助我们快速勾勒出项目骨架。</p>
<p>还是以Hello World为例，我们使用maven archetype来创建该项目的骨架，离开当前的Maven项目目录。</p>
<p>如果是Maven 3，简单地运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>如果是Maven 2，最好运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn org.apache.maven.plugins:maven-archetype-plugin:2.0-alpha-5：generate</span><br></pre></td></tr></table></figure>
<p>很多资料会让你直接使用更为简单的mvn archetype:generate命令，但在Maven 2中这是不安全的，因为该命令没有指定Archetype插件的版本，于是Maven会自动去下载最新的版本，进而可能得到不稳定的SNAPSHOT版本，导致运行失败。然而在Maven 3中，即使用户没有指定版本，Maven也只会解析最新的稳定版本，因此这是安全的。具体内容见7.7节。</p>
<p>我们实际上是在运行插件maven-archetype-plugin，注意冒号的分隔，其格式为groupId:artifactId:version:goal,org.apache.maven.plugins是maven官方插件的groupId,maven-archetype-plugin是Archetype插件的artifactId，2.0-alpha-5是目前该插件最新的稳定版，generate是要使用的插件目标。</p>
<p>紧接着会看到一段长长的输出，有很多可用的Archetype供选择，包括著名的Appfuse项目的Archetype、JPA项目的Archetype等。每一个Archetype前面都会对应有一个编号，同时命令行会提示一个默认的编号，其对应的Archetype为maven-archetype-quickstart，直接回车以选择该Archetype，紧接着Maven会提示输入要创建项目的groupId、artifactId、version以及包名package。如下输入并确认：</p>
<p>Archetype插件将根据我们提供的信息创建项目骨架。在当前目录下，Archetype插件会创建一个名为hello-world（我们定义的artifactId）的子目录，从中可以看到项目的基本结构：基本的pom.xml已经被创建，里面包含了必要的信息以及一个junit依赖；主代码目录src/main/java已经被创建，在该目录下还有一个Java类com.juvenxu.mvnbook.helloworld.App，注意这里使用到了刚才定义的包名，而这个类也仅仅只有一个简单的输出Hello World！的main方法；测试代码目录src/test/java也被创建好了，并且包含了一个测试用例com.juvenxu.mvnbArchetype可以帮助我们迅速地构建起项目的骨架，在前面的例子中，我们完全可以在Archetype生成的骨架的基础上开发Hello World项目以节省大量时间。ok.helloworld.AppTest。</p>
<p>此外，这里仅仅是看到了一个最简单的Archetype，如果有很多项目拥有类似的自定义项目结构以及配置文件，则完全可以一劳永逸地开发自己的Archetype，然后在这些项目中使用自定义的Archetype来快速生成项目骨架。本书后面的章节会详细阐述如何开发Maven Archetype。</p>
<h1 id="第5章-坐标和依赖"><a href="#第5章-坐标和依赖" class="headerlink" title="第5章　坐标和依赖"></a>第5章　坐标和依赖</h1><p>正如第1章所述，Maven的一大功能是管理项目依赖。为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。本章将详细分析Maven坐标的作用，解释其每一个元素；在此基础上，再介绍如何配置Maven，以及相关的经验和技巧，以帮助我们管理项目依赖。</p>
<h2 id="5-1-何为Maven坐标"><a href="#5-1-何为Maven坐标" class="headerlink" title="5.1　何为Maven坐标"></a>5.1　何为Maven坐标</h2><p>关于坐标（Coordinate），大家最熟悉的定义应该来自于平面几何。在一个平面坐标系中，坐标（x,y）表示该平面上与x轴距离为y，与y轴距离为x的一点，任何一个坐标都能够唯一标识该平面中的一点。</p>
<p>在实际生活中，我们也可以将地址看成是一种坐标。省、市、区、街道等一系列信息同样可以唯一标识城市中的任一居住地址和工作地址。邮局和快递公司正是基于这样一种坐标进行日常工作的。</p>
<p>对应于平面中的点和城市中的地址，Maven的世界中拥有数量非常巨大的构件，也就是平时用的一些jar、war等文件。在Maven为这些构件引入坐标概念之前，我们无法使用任何一种方式来唯一标识所有这些构件。因此，当需要用到Spring Framework依赖的时候，大家会去Spring Framework网站寻找，当需要用到log4j依赖的时候，大家又会去Apache网站寻找。又因为各个项目的网站风格迥异，大量的时间花费在了搜索、浏览网页等工作上面。没有统一的规范、统一的法则，该工作就无法自动化。重复地搜索、浏览网页和下载类似的jar文件，这本就应该交给机器来做。而机器工作必须基于预定义的规则，Maven定义了这样一组规则：世界上任何一个构件都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupId、artifactId、version、packaging、classifier。现在，只要我们提供正确的坐标元素，Maven就能找到对应的构件。比如说，当需要使用Java5平台上TestNG的5.8版本时，就告诉Maven：“groupId=org.testng；artifactId=testng；version=5.8；classifier=jdk15”，Maven就会从仓库中寻找相应的构件供我们使用。也许你会奇怪，“Maven是从哪里下载构件的呢？”答案其实很简单，Maven内置了一个中央仓库的地址（<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2），该中央仓库包含了世界上大部分流行的开源项目构件，Maven会在需要的时候去那里下载。">http://repo1.maven.org/maven2），该中央仓库包含了世界上大部分流行的开源项目构件，Maven会在需要的时候去那里下载。</a></p>
<p>在我们开发自己项目的时候，也需要为其定义适当的坐标，这是Maven强制要求的。在这个基础上，其他Maven项目才能引用该项目生成的构件，见图5-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152203449.png" alt="image-20231015220342350"></p>
<p>​                                         图　5-1　坐标为构件引入秩序</p>
<h2 id="5-2-坐标详解"><a href="#5-2-坐标详解" class="headerlink" title="5.2　坐标详解"></a>5.2　坐标详解</h2><p>Maven坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，它们是groupId、artifactId、version、packaging、classifier。先看一组坐标定义，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＜groupId＞org.sonatype.nexus＜/groupId＞</span><br><span class="line">＜artifactId＞nexus-indexer＜/artifactId＞</span><br><span class="line">＜version＞2.0.0＜/version＞</span><br><span class="line">＜packaging＞jar＜/packaging＞</span><br></pre></td></tr></table></figure>
<p>这是nexus-indexer的坐标定义，nexus-indexer是一个对Maven仓库编纂索引并提供搜索功能的类库，它是Nexus项目的一个子模块。后面会详细介绍Nexus。上述代码片段中，其坐标分别为groupId:org.sonatype.nexus、artifactId:nexus-indexer、version:2.0.0、packaging:jar，没有classifier。下面详细解释一下各个坐标元素：</p>
<p>groupId：定义当前Maven项目隶属的实际项目。首先，Maven项目和实际项目不一定是一对一的关系。比如SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core、spring-context等。这是由于Maven中模块的概念，因此，一个实际项目往往会被划分成很多模块。其次，groupId不应该对应项目隶属的组织或公司。原因很简单，一个组织下会有很多实际项目，如果groupId只定义到组织级别，而后面我们会看到，artifactId只能定义Maven项目（模块），那么实际项目这个层将难以定义。最后，groupId的表示方式与Java包名的表示方式类似，通常与域名反向一一对应。上例中，groupId为org.sonatype.nexus,org.sonatype表示Sonatype公司建立的一个非盈利性组织，nexus表示Nexus这一实际项目，该groupId与域名nexus.sonatype.org对应。</p>
<p>artifactId：该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀。比如上例中的artifactId是nexus-indexer，使用了实际项目名nexus作为前缀，这样做的好处是方便寻找实际构件。在默认情况下，Maven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar，使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件。考虑有5个项目，每个项目都有一个core模块，如果没有前缀，我们会看到很多core-1.2.jar这样的文件，加上实际项目名前缀之后，便能很容易区分foo-core-1.2.jar、bar-core-1.2.jar……</p>
<p>version：该元素定义Maven项目当前所处的版本，如上例中nexus-indexer的版本是2.0.0。需要注意的是，Maven定义了一套完整的版本规范，以及快照（SNAPSHOT）的概念。第13章会详细讨论版本管理内容。</p>
<p>packaging：该元素定义Maven项目的打包方式。首先，打包方式通常与所生成构件的文件扩展名对应，如上例中packaging为jar，最终的文件名为nexus-indexer-2.0.0.jar，而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件，不过这不是绝对的。其次，打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令。最后，当不定义packaging的时候，Maven会使用默认值jar。</p>
<p>classifier：该元素用来帮助定义构建输出的一些附属构件。附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar，该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。这时候，javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。还有一个关于classifier的典型例子是TestNG,TestNG的主构件是基于Java 1.4平台的，而它又提供了一个classifier为jdk5的附属构件。注意，不能直接定义项目的classifier，因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成。</p>
<p>上述5个元素中，groupId、artifactId、version是必须定义的，packaging是可选的（默认为jar），而classifier是不能直接定义的。</p>
<p>同时，项目构件的文件名是与坐标相对应的，一般的规则为artifactId-version[-classifier].packaging，[-classifier]表示可选。比如上例nexus-indexer的主构件为nexus-indexer-2.0.0.jar，附属构件有nexus-indexer-2.0.0-javadoc.jar。这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。</p>
<p>此外，Maven仓库的布局也是基于Maven坐标，这一点会在介绍Maven仓库的时候详细解释。</p>
<p>理解清楚城市中地址的定义方式后，邮递员就能够开始工作了；同样地，理解清楚Maven坐标之后，我们就能开始讨论Maven的依赖管理了。</p>
<h2 id="5-4-依赖的配置"><a href="#5-4-依赖的配置" class="headerlink" title="5.4　依赖的配置"></a>5.4　依赖的配置</h2><p>其实一个依赖声明可以包含如下的一些元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜project＞……＜dependencies＞＜dependency＞＜groupId＞……＜/groupId＞＜artifactId＞……＜/artifactId＞＜version＞……＜/version＞＜type＞……＜/type＞＜scope＞……＜/scope＞＜optional＞……＜/optional＞＜exclusions＞＜exclusion＞……＜/exclusion＞……＜/exclusions＞＜/dependency＞……＜/dependencies＞……＜/project＞</span><br></pre></td></tr></table></figure>
<p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<p>groupId、artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</p>
<p>type：依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar。</p>
<p>scope：依赖的范围，见5.5节。</p>
<p>optional：标记依赖是否可选，见5.8节。</p>
<p>exclusions：用来排除传递性依赖，见5.9.1节。</p>
<p>大部分依赖声明只包含基本坐标，然而在一些特殊情况下，其他元素至关重要。本章下面的小节会对它们的原理和使用方式详细介绍。</p>
<h2 id="5-5-依赖范围"><a href="#5-5-依赖范围" class="headerlink" title="5.5　依赖范围"></a>5.5　依赖范围</h2><p>上一节提到，JUnit依赖的测试范围是test，测试范围用元素scope表示。本节将详细解释什么是测试范围，以及各种测试范围的效果和用途。</p>
<p>首先需要知道，Maven在编译项目主代码的时候需要使用一套classpath。在上例中，编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。其次，Maven在编译和执行测试的时候会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖范围是test。最后，实际运行Maven项目的时候，又会使用一套classpath，上例中的spring-core需要在该classpath中，而JUnit则不需要。</p>
<p>依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven有以下几种依赖范围：</p>
<p>compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。<br>test：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要。<br>provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试class-path有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。<br>runtime：运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行class-path有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</p>
<p>system：系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜dependency＞＜groupId＞javax.sql＜/groupId＞＜artifactId＞jdbc-stdext＜/artifactId＞＜version＞2.0＜/version＞＜scope＞system＜/scope＞＜systemPath＞$&#123;java.home&#125;/lib/rt.jar＜/systemPath＞＜/dependency＞</span><br></pre></td></tr></table></figure>
<p>import（Maven 2.0.9及以上）：导入依赖范围。该依赖范围不会对三种classpath产生实际的影响，本书将在8.3.3节介绍Maven依赖和dependencyManagement的时候详细介绍此依赖范围。</p>
<p>上述除import以外的各种依赖范围与三种classpath的关系如表5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152220073.png" alt="image-20231015222009037"></p>
<h2 id="5-6-传递性依赖"><a href="#5-6-传递性依赖" class="headerlink" title="5.6　传递性依赖"></a>5.6　传递性依赖</h2><h3 id="5-6-1-何为传递性依赖"><a href="#5-6-1-何为传递性依赖" class="headerlink" title="5.6.1　何为传递性依赖"></a>5.6.1　何为传递性依赖</h3><p>考虑一个基于Spring Framework的项目，如果不使用Maven，那么在项目中就需要手动下载相关依赖。由于Spring Framework又会依赖于其他开源类库，因此实际中往往会下载一个很大的如spring-framework-2.5.6-with-dependencies.zip的包，这里包含了所有Spring Framework的jar包，以及所有它依赖的其他jar包。这么做往往就引入了很多不必要的依赖。另一种做法是只下载spring-framework-2.5.6.zip这样一个包，这里不包含其他相关依赖，到实际使用的时候，再根据出错信息，或者查询相关文档，加入需要的其他依赖。很显然，这也是一件非常麻烦的事情。</p>
<p>Maven的传递性依赖机制可以很好地解决这一问题。以account-email项目为例，该项目有一个org.springframework:spring-core:2.5.6的依赖，而实际上spring-core也有它自己的依赖，我们可以直接访问位于中央仓库的该构件的POM:<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2/org/springframework/spring-core/2.5.6/spring-core-2.5.6.pom。该文件包含了一个commons-logging依赖，见代码清单5-6。">http://repo1.maven.org/maven2/org/springframework/spring-core/2.5.6/spring-core-2.5.6.pom。该文件包含了一个commons-logging依赖，见代码清单5-6。</a></p>
<p>代码清单5-6　spring-core的commons-logging依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜dependency＞＜groupId＞commons-logging＜/groupId＞＜artifactId＞commons-logging＜/artifactId＞＜version＞1.1.1＜/version＞＜/dependency＞</span><br></pre></td></tr></table></figure>
<p>该依赖没有声明依赖范围，那么其依赖范围就是默认的compile。同时回顾一下account-email,spring-core的依赖范围也是compile。</p>
<p>account-mail有一个compile范围的spring-core依赖，spring-core有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile范围依赖，commons-logging是account-email的一个传递性依赖，如图5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152223338.png" alt="image-20231015222343301"></p>
<p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p>
<h3 id="5-6-2-传递性依赖和依赖范围"><a href="#5-6-2-传递性依赖和依赖范围" class="headerlink" title="5.6.2　传递性依赖和依赖范围"></a>5.6.2　传递性依赖和依赖范围</h3><p>依赖范围不仅可以控制依赖与三种classpath的关系，还对传递性依赖产生影响。上面的例子中，account-email对于spring-core的依赖范围是compile,spring-core对于commons-logging的依赖范围是compile，那么account-email对于commons-logging这一传递性依赖的范围也就是compile。假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围，如表5-2所示，最左边一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递性依赖范围。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310152225741.png" alt="image-20231015222545702"></p>
<p>为了能够帮助读者更好地理解表5-2，这里再举个例子。account-email项目有一个com.icegreen:greenmail:1.3.1b的直接依赖，我们说这是第一直接依赖，其依赖范围是test；而greenmail又有一个javax.mail:mail:1.4的直接依赖，我们说这是第二直接依赖，其依赖范围是compile。显然javax.mail:mail:1.4是account-email的传递性依赖，对照表5-2可以知道，当第一直接依赖范围为test，第二直接依赖范围是compile的时候，传递性依赖的范围是test，因此javax.mail:mail:1.4是account-email的一个范围是test的传递性依赖。</p>
<p>仔细观察一下表5-2，可以发现这样的规律：当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；当第二直接依赖的范围是test的时候，依赖不会得以传递；当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。</p>
<h2 id="5-7-依赖调解"><a href="#5-7-依赖调解" class="headerlink" title="5.7　依赖调解"></a>5.7　依赖调解</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/15/Maven%E5%AE%9E%E6%88%98/">https://wdpname.github.io/2023/10/15/Maven%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">秒懂设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图解HTTP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div><div><a href="/2022/11/10/SpringMVC%E5%9F%BA%E7%A1%80/" title="SpringMVC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">SpringMVC基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-Maven%E5%AE%9E%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">第1章　Maven实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BD%95%E4%B8%BAMaven"><span class="toc-number">1.1.</span> <span class="toc-text">1.1　何为Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E4%BD%95%E4%B8%BA%E6%9E%84%E5%BB%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1　何为构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-Maven%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2　Maven是优秀的构建工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-Maven%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3　Maven不仅仅是构建工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Maven"><span class="toc-number">1.2.</span> <span class="toc-text">1.2　为什么需要Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%BB%84%E8%A3%85PC%E5%92%8C%E5%93%81%E7%89%8CPC"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1　组装PC和品牌PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-IDE%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2　IDE不是万能的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-Make"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3　Make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-Ant"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4　Ant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8F%91%E6%98%8E%E8%BD%AE%E5%AD%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.2.5　不重复发明轮子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Maven%E4%B8%8E%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3　Maven与极限编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84Maven"><span class="toc-number">1.4.</span> <span class="toc-text">1.4　被误解的Maven</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Maven%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">第2章　Maven的安装和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%85Maven"><span class="toc-number">2.1.</span> <span class="toc-text">2.1　在Windows上安装Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%A3%80%E6%9F%A5JDK%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1　检查JDK安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%B8%8B%E8%BD%BDMaven"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2　下载Maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3　本地安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E5%8D%87%E7%BA%A7Maven"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4　升级Maven</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%9C%A8%E5%9F%BA%E4%BA%8EUNIX%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85Maven"><span class="toc-number">2.2.</span> <span class="toc-text">2.2　在基于UNIX的系统上安装Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1　下载和安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%8D%87%E7%BA%A7Maven"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2　升级Maven</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">2.3　安装目录分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-M2-HOME"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1　M2_HOME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%EF%BD%9E-m2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2　～&#x2F;.m2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%AE%BE%E7%BD%AEHTTP%E4%BB%A3%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">2.4　设置HTTP代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Maven%E5%AE%89%E8%A3%85%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.</span> <span class="toc-text">2.7　Maven安装最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E8%AE%BE%E7%BD%AEMAVEN-OPTS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.7.1　设置MAVEN_OPTS环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%8C%83%E5%9B%B4settings-xml"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.7.2　配置用户范围settings.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8IDE%E5%86%85%E5%B5%8C%E7%9A%84Maven"><span class="toc-number">2.5.3.</span> <span class="toc-text">2.7.3　不要使用IDE内嵌的Maven</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Maven%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8"><span class="toc-number">3.</span> <span class="toc-text">第3章　Maven使用入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%BC%96%E5%86%99POM"><span class="toc-number">3.1.</span> <span class="toc-text">3.1　编写POM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BC%96%E5%86%99%E4%B8%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">3.2　编写主代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.3　编写测试代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%89%93%E5%8C%85%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">3.4.</span> <span class="toc-text">3.4　打包和运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E4%BD%BF%E7%94%A8Archetype%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E9%AA%A8%E6%9E%B6"><span class="toc-number">3.5.</span> <span class="toc-text">3.5　使用Archetype生成项目骨架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%9D%90%E6%A0%87%E5%92%8C%E4%BE%9D%E8%B5%96"><span class="toc-number">4.</span> <span class="toc-text">第5章　坐标和依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BD%95%E4%B8%BAMaven%E5%9D%90%E6%A0%87"><span class="toc-number">4.1.</span> <span class="toc-text">5.1　何为Maven坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%9D%90%E6%A0%87%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">5.2　坐标详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E4%BE%9D%E8%B5%96%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">5.4　依赖的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4"><span class="toc-number">4.4.</span> <span class="toc-text">5.5　依赖范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E4%BC%A0%E9%80%92%E6%80%A7%E4%BE%9D%E8%B5%96"><span class="toc-number">4.5.</span> <span class="toc-text">5.6　传递性依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E4%BD%95%E4%B8%BA%E4%BC%A0%E9%80%92%E6%80%A7%E4%BE%9D%E8%B5%96"><span class="toc-number">4.5.1.</span> <span class="toc-text">5.6.1　何为传递性依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-%E4%BC%A0%E9%80%92%E6%80%A7%E4%BE%9D%E8%B5%96%E5%92%8C%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4"><span class="toc-number">4.5.2.</span> <span class="toc-text">5.6.2　传递性依赖和依赖范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E4%BE%9D%E8%B5%96%E8%B0%83%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">5.7　依赖调解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="github搜索技巧"/></a><div class="content"><a class="title" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧">github搜索技巧</a><time datetime="2023-12-10T12:59:37.000Z" title="发表于 2023-12-10 20:59:37">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="伙伴匹配系统"/></a><div class="content"><a class="title" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统">伙伴匹配系统</a><time datetime="2023-12-10T05:50:00.000Z" title="发表于 2023-12-10 13:50:00">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码托管怎么搞"/></a><div class="content"><a class="title" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞">代码托管怎么搞</a><time datetime="2023-12-09T01:20:35.000Z" title="发表于 2023-12-09 09:20:35">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用户中心"/></a><div class="content"><a class="title" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心">用户中心</a><time datetime="2023-12-05T06:58:33.000Z" title="发表于 2023-12-05 14:58:33">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2023-12-04T15:23:36.000Z" title="发表于 2023-12-04 23:23:36">2023-12-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>