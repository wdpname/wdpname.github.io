<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>秒懂设计模式 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:type" content="article">
<meta property="og:title" content="秒懂设计模式">
<meta property="og:url" content="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-16T13:35:45.000Z">
<meta property="article:modified_time" content="2023-10-17T15:06:33.084Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '秒懂设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-17 23:06:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">秒懂设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-16T13:35:45.000Z" title="发表于 2023-10-16 21:35:45">2023-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-17T15:06:33.084Z" title="更新于 2023-10-17 23:06:33">2023-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="秒懂设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="创建篇"><a href="#创建篇" class="headerlink" title="创建篇"></a>创建篇</h1><h2 id="第2章-单例"><a href="#第2章-单例" class="headerlink" title="第2章　单例"></a>第2章　单例</h2><p>单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。</p>
<h3 id="2-1-孤独的太阳"><a href="#2-1-孤独的太阳" class="headerlink" title="2.1 孤独的太阳"></a>2.1 孤独的太阳</h3><p>盘古开天，造日月星辰。从“夸父逐日”到“后羿射日”，太阳对于我们的先祖一直具有着神秘的色彩与非凡的意义。随着科学的不断发展，我们逐渐揭开了太阳系的神秘面纱。我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳，如图2-1所示。</p>
<p>与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例，它持续提供给地球充足的阳光与能量，离开它地球就不会有今天的勃勃生机，但倘若天上有9个太阳，那么将会带来一场灾难。太阳东升西落，循环往复，不多不少仅此一例。</p>
<h3 id="2-2-饿汉造日"><a href="#2-2-饿汉造日" class="headerlink" title="2.2 饿汉造日"></a>2.2 饿汉造日</h3><p>既然太阳系里只有一个太阳，我们就需要严格把控太阳实例化的过程。我们从最简单的开始，先来写一个Sun类。请参看代码清单2-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162137499.png" alt="image-20231016213756320"></p>
<p>如代码清单2-1所示，太阳类Sun中目前什么都没有。接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。有些读者可能会疑惑，我们并没有写构造器，为什么太阳还可以被实例化呢？这是因为Java可以自动为其加上一个无参构造器。为防止太阳实例泛滥将世界再次带入灾难，我们必须禁止外部调用构造器，请参看代码清单2-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162138926.png" alt="image-20231016213850858"></p>
<p>如代码清单2-2所示，我们在第3行将太阳类Sun的构造方法设为private，使其私有化，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己，并使其自有永有，请参看代码清单2-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162139115.png" alt="image-20231016213934088"></p>
<p>如代码清单2-3所示，代码第3行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。这就是“饿汉模式”(eager initialization)，即在初始阶段就主动进行实例化，并时刻保持一种渴求的状态，无论此单例是否有人使用。</p>
<p>单例的太阳对象写好了，可一切皆是私有的，外部怎样才能访问它呢？正如同程序入口的静态方法main()，它不需要任何对象引用就能被访问，我们同样需要一个静态方法getInstance()来获取太阳的单例对象，同时将其设置为“public”以暴露给外部使用，请参看代码清单2-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162141914.png" alt="image-20231016214122870"></p>
<p>如代码清单2-4所示，太阳单例类的雏形已经完成了，对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。当然，读者还可以添加其他功能方法，如发光和发热等，此处就不再赘述了。</p>
<h3 id="2-3-懒汉的队伍"><a href="#2-3-懒汉的队伍" class="headerlink" title="2.3 懒汉的队伍"></a>2.3 懒汉的队伍</h3><p>至此，我们已经学会了单例模式的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。沿着这个思路，我们继续对太阳类进行改造，请参看代码清单2-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162146741.png" alt="image-20231016214603688"></p>
<p>如代码清单2-5所示，可以看到我们一开始并没有造太阳，所以去掉了关键字final，只有在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。这样的好处是如无请求就不实例化，节省了内存空间；而坏处是第一次请求的时候速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳（即使速度快到可以忽略不计）。</p>
<p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第10行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且对sun进行多次赋值（覆盖）操作，这违背了单例的理念。我们再来改良一下，把请求方法加上synchronized（同步锁）让其同步，如此一来，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来，请参看代码清单2-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162148548.png" alt="image-20231016214817514"></p>
<p>如代码清单2-6所示，我们将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。然而这样的做法是要付出一定代价的，试想，线程还没进入方法内部便不管三七二十一直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。我们只是为了实例化一个单例对象而已，犯不上如此兴师动众，使用synchronized让所有请求排队等候。所以，要保证多线程并发下逻辑的正确性，同步锁一定要加得恰到好处，其位置是关键所在，请参看代码清单2-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162149853.png" alt="image-20231016214917776"></p>
<p>如代码清单2-7所示，我们在太阳类Sun中第3行对sun变量的定义不再使用find关键字，这意味着它不再是常量，而是需要后续赋值的变量；而关键字volatile对静态变量的修饰则能保证变量值在各线程访问时的同步性、唯一性。需要特别注意的是，对于第9行的getInstance()方法，我们去掉了方法上的关键字synchronized，使大家都可以同时进入方法并对其进行开发。请仔细阅读每行代码的注释，有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。而在第11行我们又加上了同步块以防止多个线程进入，这就类似于观日台是一个狭长的走廊，大家排队进入。随后在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳</p>
<p>随后发生的事情我们就可以预见了，太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例就可以了，阳光普照大地，将温暖洒向人间。</p>
<p>大家注意到没有，我们一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：外层放宽入口，保证线程并发的高效性；内层加锁同步，保证实例化的单次运行。如此里应外合，不仅达到了单例模式的效果，还完美地保证了构建过程的运行效率，一举两得。</p>
<h3 id="2-4-大道至简"><a href="#2-4-大道至简" class="headerlink" title="2.4 大道至简"></a>2.4 大道至简</h3><p>相比“懒汉模式”，其实在大多数情况下我们通常会更多地使用“饿汉模式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。我们来看单例模式的类结构，如图2-3所示。单例模式的角色定义如下。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162154860.png" alt="image-20231016215458815"></p>
<p>■ Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用private关键字隐藏起来，对外只提供getInstance()方法以获得这个单例对象。</p>
<p>除了“饿汉”与“懒汉”这2种单例模式，其实还有其他的实现方式。但万变不离其宗，它们统统都是由这2种模式发展、衍生而来的。我们都知道Spring框架中的IoC容器很好地帮我们托管了业务对象，如此我们就不必再亲自动手去实例化这些对象了，而在默认情况下我们使用的正是框架提供的“单例模式”。诚然，究其代码实现当然不止如此简单，但我们应该追本溯源，抓住其本质的部分，理解其核心的设计思想，再针对不同的应用场景做出相应的调整与变动，结合实践举一反三。</p>
<h2 id="第3章-原型"><a href="#第3章-原型" class="headerlink" title="第3章　原型"></a>第3章　原型</h2><p>原型模式(Prototype)，在制造业中通常是指大批量生产开始之前研发出的概念模型，并基于各种参数指标对其进行检验，如果达到了质量要求，即可参照这个原型进行批量生产。原型模式达到以原型实例创建副本实例的目的即可，并不需要知道其原始类，也就是说，原型模式可以用对象创建对象，而不是用类创建对象，以此达到效率的提升。</p>
<h3 id="3-1-原件与副本"><a href="#3-1-原件与副本" class="headerlink" title="3.1 原件与副本"></a>3.1 原件与副本</h3><p>在讲原型模式之前，我们先得搞清楚什么是类的实例化。相信大家一定见过活字印章，如图3-1所示，当我们调整好需要的日期（初始化参数），再轻轻一盖（调用构造方法），一个实例化后的日期便跃然纸上了，这个过程正类似于类的实例化。</p>
<p>其实构造一个对象的过程是耗时耗力的。想必大家一定有过打印和复印的经历，为了节省成本，我们通常会用打印机把电子文档打印到A4纸上（原型实例化过程），再用复印机把这份纸质文稿复制多份（原型拷贝过程），这样既实惠又高效。那么，对于第一份打印出来的原文稿，我们可以称之为“原型文件”，而对于复印过程，我们则可以称之为“原型拷贝”，如图3-2所示。</p>
<h3 id="3-2-卡顿的游戏"><a href="#3-2-卡顿的游戏" class="headerlink" title="3.2 卡顿的游戏"></a>3.2 卡顿的游戏</h3><p>想必大家已经明白了类的实例化与克隆之间的区别，二者都是在造对象，但方法绝对是不同的。原型模式的目的是从原型实例克隆出新的实例，对于那些有非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。理论还需与实践结合，下面开始实战部分，假设我们准备设计一个空战游戏的程序，如图3-3所示。</p>
<p>我们这里为了保持简单，设定游戏为单打，也就是说主角飞机只有一架，而敌机则有很多架，而且可以在屏幕上垂直向下移动来撞击主角飞机。具体是如何实现的呢？其实非常简单，就是程序不停改变其坐标并在画面上重绘而已。由浅入深，我们先试着写一个敌机类，请参看代码清单3-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162201482.png" alt="image-20231016220106408"></p>
<p>如代码清单3-1所示，敌机类EnemyPlane在第6行的敌机构造器方法中对飞机的横坐标x进行了初始化，而纵坐标则固定为0，这是由于敌机一开始是从顶部飞出的。所以其纵坐标y必然为0（屏幕左上角坐标为[0, 0]）。继续往下看，敌机类只提供了getter方法而没有提供setter方法，也就是说我们只能在初始化时确定好敌机的横坐标x，之后则不允许再更改坐标了。当游戏运行时，我们只要连续调用第18行的飞行方法fly()，便可以让飞机像雨点一样不断下落。在开始绘制敌机动画之前，我们首先得实例化500架敌机，请参看代码清单3-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162202565.png" alt="image-20231016220239519"></p>
<p>如代码清单3-2所示，我们在第6行使用了循环的方式来批量生产敌机，并使用了“new”关键字来实例化敌机，循环结束后500架敌机便统统被加入第4行定义的飞机列表enemyPlanes中。这种做法看似没有任何问题，然而效率却是非常低的。我们知道在游戏画面上根本没必要同时出现这么多敌机，而在游戏还未开始之前，也就是游戏的加载阶段我们就实例化了这一关卡的所有500架敌机，这不但使加载速度变慢，而且是对有限内存资源的一种浪费。那么到底什么时候去构造敌机？答案当然是懒加载了，也就是按照地图坐标，屏幕滚动到某一点时才实时构造敌机，这样一来问题就解决了。</p>
<p>然而遗憾的是，懒加载依然会有性能问题，主要原因在于我们使用的“new”关键字进行的基于类的实例化过程，因为每架敌机都进行全新构造的做法是不合适的，其代价是耗费更多的CPU资源，尤其在一些大型游戏中，很多个线程在不停地运转着，CPU资源本身就非常宝贵，此时若进行大量的类构造与复杂的初始化工作，必然会造成游戏卡顿，甚至有可能会造成系统无响应，使游戏体验大打折扣，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162204576.png" alt="image-20231016220422526"></p>
<h3 id="3-3-细胞分裂"><a href="#3-3-细胞分裂" class="headerlink" title="3.3 细胞分裂"></a>3.3 细胞分裂</h3><p>硬件永远离不开优秀的软件，我们绝不允许以糟糕的软件设计对硬件发起挑战，因而代码优化势在必行。我们思考一下之前的设计，既然循环第一次后已经实例化好了一个敌机原型，那么之后又何必去重复这个构造过程呢？敌机对象能否像细胞分裂一样自我复制呢？要解决这些问题，原型模式是最好的解决方案了，下面我们对敌机类进行重构并让其支持原型拷贝，请参看代码清单3-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162205833.png" alt="image-20231016220516782"></p>
<p>如代码清单3-3所示，我们让敌机类EnemyPlane实现了java.lang包中的克隆接口Cloneable，并在第29行的实现方法中调用了父类Object的克隆方法，如此一来外部就能够对本类的实例进行克隆操作了，省去了由类而生的再造过程。还需要注意的是，我们在第23行处加入了设置横坐标方法setX()，使被实例化后的敌机对象依然可以支持坐标位置的变更，这是为了保证克隆飞机的坐标位置个性化。</p>
<h3 id="3-4-克隆工厂"><a href="#3-4-克隆工厂" class="headerlink" title="3.4 克隆工厂"></a>3.4 克隆工厂</h3><p>至此，克隆模式其实已经实现了，我们只需简单调用克隆方法便能更高效地得到一个全新的实例副本。为了更方便地生产飞机，我们决定定义一个敌机克隆工厂类，请参看代码清单3-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162208369.png" alt="image-20231016220826329"></p>
<p>如代码清单3-4所示，我们在敌机克隆工厂类EnemyPlaneFactory中第4行使用了一个静态的敌机对象作为原型，并于第7行提供了一个获取敌机实例的方法getInstance()，其中简单地调用克隆方法得到一个新的克隆对象（此处省略了异常捕获代码），并将其横坐标重设为传入的参数，最后返回此克隆对象，这样我们便可轻松获取一架敌机的克隆实例了。</p>
<p>敌机克隆工厂类定义完毕，客户端代码就留给读者自己去实践了。但需要注意，一定得使用“懒加载”的方式，如此既可以节省内存空间，又可以确保敌机的实例化速度，实现敌机的即时性按需克隆，这样游戏便再也不会出现卡顿现象了。</p>
<h3 id="3-5-深拷贝与浅拷贝"><a href="#3-5-深拷贝与浅拷贝" class="headerlink" title="3.5 深拷贝与浅拷贝"></a>3.5 深拷贝与浅拷贝</h3><p>最后，在使用原型模式之前，我们还必须得搞清楚浅拷贝和深拷贝这两个概念，否则会对某些复杂对象的克隆结果感到无比困惑。让我们再扩展一下场景，假设敌机类里有一颗子弹可以发射并击杀玩家的飞机，那么敌机中则包含一颗实例化好的子弹对象，请参看代码清单3-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162213224.png" alt="image-20231016221322201"></p>
<p>如代码清单3-5所示，对于这种复杂一些的敌机类，此时如果进行克隆操作，我们是否能将第3行中的子弹对象一同成功克隆呢？答案是否定的。我们都知道，Java中的变量分为原始类型和引用类型，所谓浅拷贝是指只复制原始类型的值，比如横坐标x与纵坐标y这种以原始类型int定义的值，它们会被复制到新克隆出的对象中。而引用类型bullet同样会被拷贝，但是请注意这个操作只是拷贝了地址引用（指针），也就是说副本敌机与原型敌机中的子弹是同一颗，因为两个同样的地址实际指向的内存对象是同一个bullet对象。</p>
<p>需要注意的是，克隆方法中调用父类Object的clone方法进行的是浅拷贝，所以此处的bullet并没有被真正克隆。然而，每架敌机携带的子弹必须要发射出不同的弹道，这就必然是不同的子弹对象了，所以此时原型模式的浅拷贝实现是无法满足需求的，那么该如何改动呢？请参看如代码清单3-6中对敌机类的深拷贝支持。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162214123.png" alt="image-20231016221434082"></p>
<p>如代码清单3-6所示，首先我们在第13行的克隆方法clone()中依旧对敌机对象进行了克隆操作，紧接着对敌机子弹bullet也进行了克隆，这就是深拷贝操作。当然，此处要注意对于子弹类Bullet同样也得实现克隆接口，请读者自行实现，此处就不再赘述了。</p>
<h3 id="3-6-克隆的本质"><a href="#3-6-克隆的本质" class="headerlink" title="3.6 克隆的本质"></a>3.6 克隆的本质</h3><p>终于，在我们用克隆模式对游戏代码反复重构后，游戏性能得到了极大的提升，流畅的游戏画面确保了优秀的用户体验。最后，我们来看原型模式的类结构，如图3-5所示。原型模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Prototype（原型接口）：声明克隆方法，对应本例程代码中的Cloneable接口。</span><br><span class="line">■ ConcretePrototype（原型实现）：原型接口的实现类，实现方法中调用super.clone()即可得到新克隆的对象。</span><br><span class="line">■ Client（客户端）：客户端只需调用实现此接口的原型对象方法clone()，便可轻松地得到一个全新的实例对象。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162216826.png" alt="image-20231016221647744"></p>
<p>从类到对象叫作“创建”，而由本体对象至副本对象则叫作“克隆”，当需要创建多个类似的复杂对象时，我们就可以考虑用原型模式。究其本质，克隆操作时Java虚拟机会进行内存操作，直接拷贝原型对象数据流生成新的副本对象，绝不会拖泥带水地触发一些多余的复杂操作（如类加载、实例化、初始化等），所以其效率远远高于“new”关键字所触发的实例化操作。看尽世间烦扰，拨开云雾见青天，有时候“简单粗暴”也是一种去繁从简、不绕弯路的解决方案。</p>
<h2 id="第4章-工厂方法"><a href="#第4章-工厂方法" class="headerlink" title="第4章　工厂方法"></a>第4章　工厂方法</h2><p>制造业是一个国家工业经济发展的重要支柱，而工厂则是其根基所在。程序设计中的工厂类往往是对对象构造、实例化、初始化过程的封装，而工厂方法(Factory Method)则可以升华为一种设计模式，它对工厂制造方法进行接口规范化，以允许子类工厂决定具体制造哪类产品的实例，最终降低系统耦合，使系统的可维护性、可扩展性等得到提升。</p>
<h3 id="4-1-工厂的多元化与专业化"><a href="#4-1-工厂的多元化与专业化" class="headerlink" title="4.1 工厂的多元化与专业化"></a>4.1 工厂的多元化与专业化</h3><p>要理解工厂方法模式，我们还得从头说起。众所周知，要制造产品（实例化对象）就得用到关键字“new”，例如“Plane plane=new Plane(); ”，或许还会有一些复杂的初始化代码，这就是我们常用的传统构造方式。然而这样做的结果会使飞机对象的产生代码被牢牢地硬编码在客户端类里，也就是说客户端与实例化过程强耦合了。而事实上，我们完全不必关心产品的制造过程（实例化、初始化），而将这个任务交由相应的工厂来全权负责，工厂最终能交付产品供我们使用即可，如此我们便摆脱了产品生产方式的束缚，实现了与制造过程彻底解耦。</p>
<p>除此之外，工厂方法模式是基于多元化产品的构造方法发展而来的，它开辟了产品多元化的生产模式，不同的产品可以交由不同的专业工厂来生产，例如皮鞋由皮鞋工厂来制造，汽车则由汽车工厂来制造，专业化分工明确，如图4-1所示。</p>
<h3 id="4-2-游戏角色建模"><a href="#4-2-游戏角色建模" class="headerlink" title="4.2 游戏角色建模"></a>4.2 游戏角色建模</h3><p>在制造产品之前，我们先得为它们建模。我们依旧以空战游戏来举例，通常这类游戏中主角飞机都拥有强大的武器装备，以应对敌众我寡的游戏局面，所以敌人的种类就应当多样化，以带给玩家更加丰富多样的游戏体验。于是我们增加了一些敌机、坦克，游戏画面如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162222535.png" alt="image-20231016222253497"></p>
<p>如图4-2所示，游戏中敌人的种类有飞机和坦克，虽然它们之间的区别比较大，但总有一些共同的属性或行为，例如一对用来描述位置状态的坐标，以及一个展示（绘制）方法，以便将自己绘制到相应的地图位置上。好了，现在我们使用抽象类来定义所有敌人的父类，请参看代码清单4-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162223933.png" alt="image-20231016222323896"></p>
<p>如代码清单4-1所示，我们在敌人抽象类Enemy中第13行定义了一个显示方法show()，并声明其抽象方法，以交给子类去实现，并按照构造方法（第7行）中初始化的坐标位置将自己绘制到地图上。接下来是具体子类实现，也就是敌机类和坦克类，请参看代码清单4-2与代码清单4-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224024.png" alt="image-20231016222410990"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224550.png" alt="image-20231016222417493"></p>
<p>如代码清单4-2与代码清单4-3所示，飞机类Airplane和坦克类Tank都继承了敌人抽象类Enemy，并且分别实现了各自独特的展示方法show()，其中坦克应该绘制在下层（但在地图层之上）图层，而飞机则绘制在上层图层，这样才能遮盖住下层的所有图层以达到期望的视觉效果。</p>
<h3 id="4-3-简单工厂不简单"><a href="#4-3-简单工厂不简单" class="headerlink" title="4.3 简单工厂不简单"></a>4.3 简单工厂不简单</h3><p>产品建模完成后，就应该考虑如何实例化和初始化这些敌人了。毋庸置疑，要使它们都出现在屏幕最上方，就得使其纵坐标y被初始化为0，而对于横坐标x该怎样初始化呢？如果让敌人出现于屏幕正中央的话，就得将其横坐标初始化为屏幕宽度的一半，显然，如此玩家只需要一直对准屏幕中央射击，这对游戏可玩性来说是非常糟糕的，所以我们最好让敌人的横坐标随机产生，这样才能给玩家带来更好的游戏体验。我们来看客户端如何进行设置，请参看代码清单4-4</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162225483.png" alt="image-20231016222540439"></p>
<p>如代码清单4-4所示，我们在第4行假设屏幕宽度为100，然后在第7行生成一个从0到“屏幕宽度”的随机数，再以此为横坐标构造并初始化敌人（为保持简单不考虑敌人自身的宽度），这样敌人就会出现在随机的横坐标位置上了。接着往下看，我们在第11行构造坦克时做了同样的设置，最后的输出结果达到了我们的预期，飞机和坦克随机出现于屏幕顶部，游戏可玩性大大提高。</p>
<p>然而，制造随机出现的敌人这个动作貌似不应该出现在客户端类中，试想如果我们还有其他敌人也需要构造的话，那么同样的代码就会再次出现，尤其是当初始化越复杂的时候重复代码就会越多。如此耗时费力，何不把这些实例化逻辑抽离出来作为一个工厂类？沿着这个思路，我们来开发一个制造敌人的简单工厂类，请参看代码清单4-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162228669.png" alt="image-20231016222800625"></p>
<p>如代码清单4-5所示，简单工厂类SimpleFactory将之前在客户端类里制造敌人的代码挪过来，并封装在第10行的制造方法create()方法中，这里我们在第13行加入了一些逻辑判断，使其可以根据传入的敌人种类（飞机或坦克）生产出相应的对象实例，并随机初始化其位置。如此一来，制造敌人这个任务就全权交由简单工厂来负责了，于是客户端便可以直接从简单工厂取用敌人了，请参看代码清单4-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162229987.png" alt="image-20231016222929942"></p>
<p>如代码清单4-6所示，客户端类的代码变得异常简单、清爽，这就是分类封装、各司其职的好处。然而，这个简单工厂的确很“简单”，但并不涉及任何的模式设计范畴，虽然客户端中不再直接出现对产品实例化的代码，但羊毛出在羊身上，制造逻辑只是被换了个地方，挪到了简单工厂中而已，并且客户端还要告知产品种类才能产出，这无疑是另一种意义上的耦合。</p>
<p>除此之外，简单工厂一定要保持简单，否则就不要用简单工厂。随着游戏项目需求的演变，简单工厂的可扩展性也会变得很差，例如对于那段对产品种类的判断逻辑，如果有新的敌人类加入，我们就需要再修改简单工厂。随着生产方式不断多元化，工厂类就得被不断地反复修改，严重缺乏灵活性与可扩展性，尤其是对于一些庞大复杂的系统，大量的产品判断逻辑代码会被堆积在制造方法中，看起来好像功能强大、无所不能，其实维护起来举步维艰，简单工厂就会变得一点也不简单了。</p>
<h3 id="4-4-制定工业制造标准"><a href="#4-4-制定工业制造标准" class="headerlink" title="4.4 制定工业制造标准"></a>4.4 制定工业制造标准</h3><p>其实系统中并不是处处都需要调用这样一个万能的“简单工厂”，有时系统只需要一个坦克对象，所以我们不必大动干戈使用这样一个臃肿的“简单工厂”。另外，由于用户需求的多变，我们又不得不生成大量代码，这正是我们要调和的矛盾。</p>
<p>针对复杂多变的生产需求，我们需要对产品制造的相关代码进行合理规划与分类，将简单工厂的<strong>制造方法进行拆分</strong>，构建起抽象化、多态化的生产模式。下面我们就对各种各样的生产方式（工厂方法）进行抽象，首先定义一个工厂接口，以确立统一的工业制造标准，请参看代码清单4-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162234425.png" alt="image-20231016223455402"></p>
<p>如代码清单4-7所示，工厂接口Factory其实就是工厂方法模式的核心了。我们在第3行中声明了工业制造标准，只要传入屏幕宽度，就在屏幕坐标内产出一个敌人实例，任何工厂都应遵循此接口。接下来我们重构一下之前的简单工厂类，将其按产品种类拆分为两个类，请参看代码清单4-8和代码清单4-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162235172.png" alt="image-20231016223559136"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162236714.png" alt="image-20231016223605686"></p>
<p>如代码清单4-8和代码清单4-9所示，飞机工厂类AirplaneFactory与坦克工厂类TankFactory的代码简洁、明了，它们都以关键字implements声明了本类是实现工厂接口Factory的工厂实现类，并且在第4行给出了工厂方法create()的具体实现，其中飞机工厂制造飞机，坦克工厂制造坦克，各自有其独特的生产方式。</p>
<p>除了飞机和坦克，应该还会有其他的敌人，当玩家抵达游戏关底时总会有Boss出现，这时候我们该如何扩展呢？显而易见，基于此模式继续我们的扩展即可，先定义一个继承自敌人抽象类Enemy的Boss类，相应地还有Boss的工厂类，同样实现工厂方法接口，请分别参看代码清单4-10和代码清单4-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238986.png" alt="image-20231016223805959"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238801.png" alt="image-20231016223813758"></p>
<p>这里要注意代码清单4-11，因为Boss出现的坐标总是处于屏幕的中央位置，所以关底Boss工厂类BossFactory在初始化时在第6行设置Boss对象的横坐标为屏幕宽度的一半，而不是随机生成横坐标。“万事俱备，只欠东风”，客户端开始运行游戏了，请参看代码清单4-12。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162239089.png" alt="image-20231016223917040"></p>
<p>如代码清单4-12所示，我们在第9行的循环体中调用坦克工厂类生成敌人，结果制造出的产品肯定是5辆坦克，接着又在第12行将工厂接口替换为飞机工厂类，结果5架飞机出现在屏幕上。抵达关底后，在第18行我们又将工厂接口替换为关底Boss工厂类，结果关底Boss出现并与玩家进行战斗，具体结果如第22行开始的输出所示。显而易见，多态化后的工厂多样性不言而喻，每个工厂的生产策略或方式都具备自己的产品特色，不同的产品需求都能找到相应的工厂来满足，即便没有，我们也可以添加新工厂来解决，以确保游戏系统具有良好的兼容性和可扩展性。</p>
<h3 id="4-5-劳动分工"><a href="#4-5-劳动分工" class="headerlink" title="4.5 劳动分工"></a>4.5 劳动分工</h3><p>至此，以工厂方法模式构建的空战游戏就完成了，之后若要加入新的敌人类，只需添加相应的工厂类，无须再对现有代码做任何更改。不同于简单工厂，工厂方法模式可以被看作由简单工厂演化而来的高级版，后者才是真正的设计模式。在工厂方法模式中，不仅产品需要分类，工厂同样需要分类，与其把所有生产方式堆积在一个简单工厂类中，不如把生产方式放在具体的子类工厂中去实现，这样做对工厂的抽象化与多态化有诸多好处，避免了由于新加入产品类而反复修改同一个工厂类所带来的困扰，使后期的代码维护以及扩展更加直观、方便。下面我们来看工厂方法模式的类结构，如图4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162249478.png" alt="image-20231016224949418"></p>
<p>工厂方法模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Product（产品）：所有产品的顶级父类，可以是抽象类或者接口。对应本章例程中的敌人抽象类。</span><br><span class="line">■ ConcreteProduct（子产品）：由产品类Product派生出的产品子类，可以有多个产品子类。对应本章例程中的飞机类、坦克类以及关底Boss类。</span><br><span class="line">■ Factory（工厂接口）：定义工厂方法的工厂接口，当然也可以是抽象类，它使顶级工厂制造方法抽象化、标准统一化。</span><br><span class="line">■ ConcreteFactory（工厂实现）：实现了工厂接口的工厂实现类，并决定工厂方法中具体返回哪种产品子类的实例。</span><br></pre></td></tr></table></figure>
<p>工厂方法模式不但能将客户端与敌人的实例化过程彻底解耦，抽象化、多态化后的工厂还能让我们更自由灵活地制造出独特而多样的产品。其实工厂不必万能，方便面工厂不必生产汽车，手机工厂也不必生产牛仔裤，否则就会通而不精，妄想兼备所有产品线的工厂并不是好的工厂。反之，每个工厂都应围绕各自的产品进行生产，专注于自己的产品开发，沿用这种分工明确的工厂模式才能使各产业变得越来越专业化，而不至于造成代码逻辑泛滥，从而降低产出效率。正所谓“闻道有先后，术业有专攻”，正如英国经济学家亚当·斯密提出的劳动分工理论一样，如图4-4所示，明确合理的劳动分工才能真正地促进生产效率的提升。</p>
<h2 id="第5章-抽象工厂"><a href="#第5章-抽象工厂" class="headerlink" title="第5章　抽象工厂"></a>第5章　抽象工厂</h2><p>抽象工厂模式(Abstract Factory)是对工厂的抽象化，而不只是制造方法。我们知道，为了满足不同用户对产品的多样化需求，工厂不会只局限于生产一类产品，但是系统如果按工厂方法那样为每种产品都增加一个新工厂又会造成工厂泛滥。所以，为了调和这种矛盾，抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。抽象工厂是建立在制造复杂产品体系需求基础之上的一种设计模式，在某种意义上，我们可以<strong>将抽象工厂模式理解为工厂方法模式的高度集群化升级版</strong>，所以建议读者先充分理解上一章的内容再来阅读本章。</p>
<h3 id="5-1-品牌与系列"><a href="#5-1-品牌与系列" class="headerlink" title="5.1 品牌与系列"></a>5.1 品牌与系列</h3><p>我们都知道，在工厂方法模式中每个实际的工厂只定义了一个工厂方法。而随着经济发展，人们对产品的需求不断升级，并逐渐走向个性化、多元化，制造业也随之发展壮大起来，各类工厂遍地开花，能够制造的产品种类也丰富了起来，随之而来的弊端就是工厂泛滥。</p>
<p>针对这种情况，我们就需要进行产业规划与整合，对现有工厂进行重构。例如，我们可以基于产品品牌与系列进行生产线规划，按品牌划分A工厂与B工厂。具体以汽车工厂举例，A品牌汽车有轿车、越野车、跑车3个系列的产品，同样地，B品牌汽车也包括以上3个系列的产品，如此便形成了两个产品族，分别由A工厂和B工厂负责生产，每个工厂都有3条生产线，分别生产这3个系列的汽车，如图5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162253113.png" alt="image-20231016225358036"></p>
<p>基于这2个品牌汽车工厂的系列生产线，如果今后产生新的C品牌汽车、D品牌汽车等，都可以沿用此种规划好的生产模式，这便是抽象工厂模式的基础数据模型。</p>
<h3 id="5-2-产品规划"><a href="#5-2-产品规划" class="headerlink" title="5.2 产品规划"></a>5.2 产品规划</h3><p>无论哪种工厂模式，都一定是基于特定的产品特性发展而来的，所以我们首先得从产品建模切入。假设某公司要开发一款星际战争游戏，战争设定在太阳系文明与异星系文明之间展开，游戏兵种就可以分为人类与外星怪兽2个族，游戏画面如图5-2所示。</p>
<p>如图5-2所示，游戏战争场面相当激烈，人类拥有各种军工高科技装备，而外星怪兽则靠血肉之躯与人类战斗，所以这两族的兵种必然有着巨大的差异，这就意味着各兵种首先应该按族划分。此外，从另一个角度来看，它们又有相同之处，2个族的兵种都可以被简单归纳为初级（1级）、中级（2级）、高级（3级）3个等级，如同之前对汽车品牌系列的规划一样，各族兵种也应当按等级划分，最终我们可以得到一个对所有兵种分类归纳的表格，如图5-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162255252.png" alt="image-20231016225545193"></p>
<p>如图5-3所示，兵种规划表格以列划分等级，以行划分族，一目了然，我们可以据此建立数据模型。首先，我们来定义一个所有兵种的顶层父类兵种，这里我们使用抽象类，以达到属性继承给子类的目的，请参看代码清单5-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257378.png" alt="image-20231016225701343"></p>
<p>如代码清单5-1所示，任何兵种都具有攻击力、防御力、生命力、坐标方位等属性，从第3行开始我们对以上属性依次定义。除此之外，第17行的展示show()（绘制到图上）与第19行的攻击attack()这两个抽象方法交由子类实现。接下来我们将兵种按等级分类，假设同一等级的攻击力、防御力等属性值是相同的，所以初级、中级、高级兵种会分别对应3个等级的兵种类，请参看代码清单5-2、代码清单5-3、代码清单5-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257782.png" alt="image-20231016225757744"></p>
<p>如代码清单5-2、代码清单5-3、代码清单5-4所示，各等级兵种类都继承自兵种抽象类Unit，它们对应的攻击力、防御力及生命力也各不相同，等级越高，其属性值也越高（当然制造成本也会更高，本例我们不考虑价格属性）。接下来我们来定义具体的兵种类，首先是人类兵种的海军陆战队员、变形坦克和巨型战舰，分别对应初级、中级、高级兵种，请参看代码清单5-5、代码清单5-6、代码清单5-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259295.png" alt="image-20231016225916264"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259805.png" alt="image-20231016225922771"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259222.png" alt="image-20231016225929170"></p>
<p>如代码清单5-5、代码清单5-6、代码清单5-7所示，我们在第3行的构造方法中调用了父类，并初始化了坐标属性，其攻击力、防御力和生命力已经在对应等级的父类里初始化好了。此外，在代码第8行与第13行我们分别重写了各兵种的展示方法和攻击方法，进行行为差异化，比如坦克可以变形增加攻击力与射程，再比如战舰攻击地面目标时用激光炮，而攻击空中目标的切换至导弹等，本例我们不做过多延伸，读者可自行实现。同样，外星怪兽族对应的初级、中级、高级兵种分别为蟑螂、毒液、猛犸，请参看代码清单5-8、代码清单5-9、代码清单5-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300063.png" alt="image-20231016230041021"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300205.png" alt="image-20231016230048164"></p>
<p>至此，所有兵种类已定义完毕，代码不是难点，重点集中在对兵种的划分上，横向划分族，纵向划分等级（系列），利用类的抽象与继承描绘出所有的游戏角色以及它们之间的关系，同时避免了不少重复代码。</p>
<h3 id="5-3-生产线规划"><a href="#5-3-生产线规划" class="headerlink" title="5.3 生产线规划"></a>5.3 生产线规划</h3><p>既然产品类的数据模型构建完成，相应的产品生产线也应该建立起来，接下来我们就可以定义这些产品的制造工厂了。我们一共定义了6个兵种产品，那么每个产品都需要对应一个工厂类吗？答案是否定的。本着人类靠科技、怪兽靠繁育的游戏理念，人类兵工厂自然是高度工业化的，而怪兽的生产一定靠的是母巢繁殖，所以应该将工厂分为2个族，并且每个族工厂都应该拥有3个等级兵种的制造方法。如此规划不但合理，而且避免了工厂类泛滥的问题。那么，首先我们来制定这3个工业制造标准，也就是定义抽象工厂接口，请参看代码清单5-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162303735.png" alt="image-20231016230330685"></p>
<p>在代码清单5-11中，抽象兵工厂接口定义了3个等级兵种的制造标准，这意味着子类工厂必须具备初级、中级、高级兵种的生产能力（类似一个品牌的不同系列生产线）。理解了这一点后，我们就可以定义人类兵工厂与外星母巢的工厂类实现了，请参看代码清单5-12、代码清单5-13。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162305126.png" alt="image-20231016230551092"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162306521.png" alt="image-20231016230611485"></p>
<p>如代码清单5-12、代码清单5-13所示，人类兵工厂与外星母巢分别实现了3个等级兵种的制造方法，其中前者由低到高分别返回海军陆战队员、变形坦克以及巨型战舰对象，后者则分别返回蟑螂兵、毒液兵以及猛犸巨兽对象，生产线规划非常清晰。好了，所有兵种与工厂准备完毕，我们可以用客户端开始模拟游戏了，请参看代码清单5-14。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162307391.png" alt="image-20231016230713358"></p>
<p>如代码清单5-14所示，第一位玩家选择了人类族，在第9行用抽象兵工厂接口引用了人类兵工厂实现，接着调用3个等级的制造方法分别得到人类族的对应兵种。接着第二位玩家选择了外星怪兽族，这时将抽象兵工厂接口引用替换为外星母巢实现，此时制造出的兵种变为3个等级的外星怪兽族兵种。最后大混战开始了，调用每个兵种的攻击方法会展示出不同的结果。第42行开始的输出证明所有兵种均制造成功，抽象工厂模式得以发挥作用。此时，如果玩家需要一个新族加入，我们可以在此模式之上去实现一个新的族工厂并实现3个等级的制造方法，工厂一经替换即可产出各系列产品兵种，且无须改动现有代码，良好的可扩展性一览无遗，这就是一套拥有完备生产模式的标准化工业系统所带来的好处。</p>
<h3 id="5-4-分而治之"><a href="#5-4-分而治之" class="headerlink" title="5.4 分而治之"></a>5.4 分而治之</h3><p>至此，抽象工厂制造模式已经布局完成，各工厂可以随时大规模投入生产活动了。当然，我们还可以进一步，再加一个“制造工厂的工厂”来决定具体让哪个工厂投入生产活动。此时客户端就无须关心工厂的实例化过程了，直接使用产品就可以了，至于产品属于哪个族也已经无关紧要，这也是抽象工厂可以被视为“工厂的工厂”的原因，读者可以自行实践代码。</p>
<p>与工厂方法模式不同，抽象工厂模式能够应对更加复杂的产品族系，它更类似于一种对“工业制造标准”的制定与推行，各工厂实现都遵循此标准来进行生产活动，以工厂类划分产品族，以制造方法划分产品系列，达到无限扩展产品的目的。最后我们来看抽象工厂模式的类结构，如图5-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162310425.png" alt="image-20231016231020349"></p>
<p>抽象工厂模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">■ AbstractProduct1、AbstractProduct2（抽象产品1、抽象产品2）：产品系列的抽象类，图中一系产品与二系产品分别代表同一产品族的多个产品系列，对应本章例程中的初级、中级、高级兵种抽象类。</span><br><span class="line">■ ProductA1、ProductB1、ProductA2、ProductB2（产品A1、产品B1、产品A2、产品B2）：继承自抽象产品的产品实体类，其中ProductA1与ProductB1代表A族产品与B族产品的同一产品系列，类似于本章例程中人类族与外星怪兽族的初级兵种，之后的产品实体类以此类推。</span><br><span class="line">■ AbstractFactory（抽象工厂接口）：各族工厂的高层抽象，可以是接口或者抽象类。抽象工厂对各产品系列的制造标准进行规范化定义，但具体返回哪个族的产品由具体族工厂决定，它并不关心。</span><br><span class="line">■ ConcreteFactoryA、ConcreteFactoryB（工厂A实现、工厂B实现）：继承自抽象工厂的各族工厂，需实现抽象工厂所定义的产品系列制造方法，可以扩展多个工厂实现。对应本章例程中的人类兵工厂与外星母巢。</span><br><span class="line">■ Client（客户端）：产品的使用者，只关心制造出的产品系列，具体是哪个产品族由工厂决定。</span><br></pre></td></tr></table></figure>
<p>产品虽然繁多，但总有品牌、系列之分。基于此抽象工厂模式以品牌与系列进行全局规划，将看似杂乱无章的产品规划至不同的族系，再通过抽象工厂管理起来，分而治之，合纵连横。需要注意的是，抽象工厂模式一定是基于产品的族系划分来布局的，其产品系列一定是相对固定的，故以抽象工厂来确立工业制造标准（各产品系列生产接口）。而产品族则可以相对灵活多变，如此一来，我们就可以方便地扩展与替换族工厂，以达到灵活产出各类产品族系的目的。</p>
<h2 id="第6章-建造者"><a href="#第6章-建造者" class="headerlink" title="第6章　建造者"></a>第6章　建造者</h2><p>建造者模式(Builder)所构建的对象一定是庞大而复杂的，并且一定是按照既定的制造工序将组件组装起来的，例如计算机、汽车、建筑物等。我们通常将负责构建这些大型对象的工程师称为建造者。建造者模式又称为生成器模式，主要用于对复杂对象的构建、初始化，它可以将多个简单的组件对象按顺序一步步组装起来，最终构建成一个复杂的成品对象。与工厂系列模式不同的是，建造者模式的主要目的在于把烦琐的构建过程从不同对象中抽离出来，使其脱离并独立于产品类与工厂类，最终实现用<strong>同一套标准的制造工序</strong>能够产出不同的产品。</p>
<h3 id="6-1-建造步骤的重要性"><a href="#6-1-建造步骤的重要性" class="headerlink" title="6.1 建造步骤的重要性"></a>6.1 建造步骤的重要性</h3><p>在开始实战之前我们首先得搞清楚建造者面对着什么样的产品模型。以典型的角色扮演类网络游戏为例，在开始游戏之前玩家通常可以选择不同的角色。为了让人物鲜活起来，不同的游戏角色应该有其独特的产品特性，如图6-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171043798.png" alt="image-20231017104346616"></p>
<p>玩家选定角色后需要对其进行初始化，假设整个过程分3个步骤完成。第一步，玩家需要为角色选择形象以及分配力量、灵力、体力、敏捷等属性值，这也是游戏人设中最为重要的一个环节；第二步，玩家可以为角色配备不同的衣服或铠甲，低于所需力量值的铠甲则不能穿戴；第三步，玩家选择手持的武器与盾牌，它同上一步一样需要满足一定的条件。显然，每个角色都是按照这个流程完成初始化的，否则游戏就无法进行下去，例如如果在没有分配角色属性值的前提下就先进行武器选择，那么缺乏力量的角色根本无法配备任何装备或者武器；如果让缺少灵力的战士戴上魔法帽或是让力量弱小的法师手持重型武器，就会导致游戏角色出现不可预知的混乱，如图6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171045082.png" alt="image-20231017104539034"></p>
<p>成型的游戏角色是依靠角色对象、装备对象组装而成的，对于这种复杂对象的构建一定要依赖建造者来完成。除此以外，若要避免图6-2所示的混乱情况的发生，建造者的制造过程不仅要分步完成，还要按照顺序进行，所以建造者的各制造步骤与逻辑都应该被抽离出来独立于数据模型，复杂的游戏角色设定还需交给专业的建造团队去完成。</p>
<h3 id="6-2-地产开发商的困惑"><a href="#6-2-地产开发商的困惑" class="headerlink" title="6.2 地产开发商的困惑"></a>6.2 地产开发商的困惑</h3><p>秉承我们一贯奉行的简单直观的宗旨，既然是建造者，我们就以建筑物建造为例来进行代码实战。盖房子可不能开玩笑，为了保证质量，我们绝不能允许豆腐渣工程出现，所以严谨的设计与施工流程的把控是不可或缺的，否则可能会房倒屋塌、家毁人亡。首先，建筑物本身应该由多个组件组成，且各组件按一定工序建造，缺一不可，如图6-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171047095.png" alt="image-20231017104700045"></p>
<p>如图6-3所示，建筑物的组件建造是相当复杂的，为了简化其数据模型，我们将组成建筑物的模块归纳为3个组件，分别是地基、墙体、屋顶，将它们组装起来就能形成一座建筑物，请参看代码清单6-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171047844.png" alt="image-20231017104739799"></p>
<p>如代码清单6-1所示，为了模拟建筑物类中各组件的建造工序，我们在第4行以List承载各组件，模拟复杂对象中各组件的顺序组装。接着在第6行、第10行、第14行分别定义各组件对应的建造方法（set方法），其中可以看到我们用字符串对象String来模拟各个组件对象。最后在第19行，为了直观地看到建筑物的建造情况，我们重写了toString()方法，按从大到小的组件索引顺序组装各组件，后组装的组件应先展示出来，如屋顶应该首先输出，以此类推。</p>
<p>这个建筑物类的内部构造看起来稍微有点复杂（实际应用中会更复杂），怎样才能用这个复杂的类构建出一个房子对象呢？首先应该调用哪个建造方法才能保证正确的建造工序，而不至于屋顶在下面，地基却跑到天上去呢？地基、墙体、屋顶，这些组件都去哪里找，如何建造？地产开发商（客户端）感到十分困惑，一头雾水。</p>
<h3 id="6-3-建筑施工方"><a href="#6-3-建筑施工方" class="headerlink" title="6.3 建筑施工方"></a>6.3 建筑施工方</h3><p>组建专业的建筑施工团队对建筑工程项目的实施至关重要，于是地产开发商决定通过招标的方式来选择施工方。招标大会上有很多建筑公司来投标，他们各有各的房屋建造资质，有的能建别墅，有的能建多层公寓，还有能力更强的能建摩天大楼，建造工艺也各有区别。但无论如何，开发商规定施工方都应该至少具备三大组件的建造能力，于是施工标准公布出来了，请参看代码清单6-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171050073.png" alt="image-20231017105032039"></p>
<p>如代码清单6-2所示，施工方接口规定了3个施工标准，它们分别对应建造地基、建造墙体以及建造屋顶，另外，第9行还定义了一个获取建筑物的接口getBuilding()，以供产品的交付。接着，开发商按此标准启动了招标工作，一个别墅施工方中标，请参看代码清单6-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171051946.png" alt="image-20231017105109903"></p>
<p>如代码清单6-3所示，这个别墅施工方看起来具备很高的施工水平，对别墅的建造工艺看起来十分考究。不管是建造地基（第10行）、建造墙体（第16行），还是建造屋顶（第22行），别墅施工方都能做到，完全符合开发商公布的施工标准。接下来开发商又考察了一个多层公寓施工方，请参看代码清单6-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171053028.png" alt="image-20231017105302974"></p>
<p>如代码清单6-4所示，多层公寓施工方成功中标，它同别墅施工方一样符合开发商公布的施工标准，但施工方法实现上大相径庭，例如第10行建造地基方法实现buildBasement()中地基挖得比较扎实，以及第16行建造墙体方法buildWall()中进行的迭代施工，这里建造的应该是一梯四户（4个窗户）的8层（循环8次）公寓楼，其建造工艺与别墅施工方有很大不同。</p>
<h3 id="6-4-工程总监"><a href="#6-4-工程总监" class="headerlink" title="6.4 工程总监"></a>6.4 工程总监</h3><p>虽然施工方很好地保证了建筑物三大组件的施工质量，但开发商还是不放心，因为施工方毕竟只负责干活，施工流程无法得到控制。为了解决这个问题，开发商又招聘了一个专业的工程总监来做监理工作，他亲临施工现场指导施工，并把控整个施工流程，请参看代码清单6-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171054487.png" alt="image-20231017105436454"></p>
<p>如代码清单6-5所示，工程总监的角色就像电影制作中的导演一样，他从宏观上管理项目并指导整个施工队的建造流程。在代码第13行的指导方法中，我们依次调用施工方的打地基方法buildBasement()、建造墙体方法buildWall()及建筑物封顶方法buildRoof()，保证了建筑物自下而上的建造工序。可以看到，施工方是在第9行由外部注入的，所以工程总监并不关心是哪个施工方来造房子，更不关心施工方有什么样的建造工艺，但他能保证对施工工序的绝对把控，也就是说，工程总监只控制施工流程。</p>
<h3 id="6-5-项目实施"><a href="#6-5-项目实施" class="headerlink" title="6.5 项目实施"></a>6.5 项目实施</h3><p>至此招标工作结束，一切准备就绪，所有项目干系人（施工方、工程总监）都已就位，可以开始组建项目团队并启动项目了。我们来看开发商如何拿到产品，请参看代码清单6-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171055855.png" alt="image-20231017105548810"></p>
<p>如代码清单6-6所示，开发商首先在第5行组建了别墅施工队并安排给工程总监进行管理，之后调用其指导方法拿到别墅产品。接着开发商在第9行将工程总监管理的施工队替换为多层公寓施工方，最终拿到一栋八层公寓，运行结果如图6-4所示。</p>
<h3 id="6-6-工艺与工序"><a href="#6-6-工艺与工序" class="headerlink" title="6.6 工艺与工序"></a>6.6 工艺与工序</h3><p>项目团队将建筑物产品交付给开发商，项目终于顺利竣工。施工方接口对施工标准的抽象化、标准化使建造者（施工方）的建造质量达到既定要求，且使各建造者的建造“工艺”能够个性化、多态化。此外，工程总监将工作流程抽离出来独立于建造者，使建造“工序”得到统一把控。最终，各种建筑产品都得到了业主的认可，成功离不开团队的共同协作与努力，请参看建造者模式的类结构，如图6-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171057109.png" alt="image-20231017105741061"></p>
<p>建造者模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Product（产品）：复杂的产品类，构建过程相对复杂，需要其他组件组装而成。对应本章例程中的建筑物类。</span><br><span class="line">■ Builder（建造者）：建造者接口，定义了构成产品的各个组件的构建标准，通常有多个步骤。对应本章例程中的施工方接口。</span><br><span class="line">■ ConcreteBuilder（建造者实现）：具体的建造者实现类，可以有多种实现，负责产品的组装但不包含整体建造逻辑。对应本章例程中的别墅施工方类与多层公寓施工方类。</span><br><span class="line">■ Director（指导者）：持有建造者接口引用的指导者类，指导建造者按一定的逻辑进行建造。对应本章例程中的工程总监类。</span><br></pre></td></tr></table></figure>
<p>复杂对象的构建显然需要专业的建造团队，建造标准的确立让产品趋向多样化，其建造工艺可以交给多位建造者去各显其长，而建造工序则交由工程总监去全局把控，把“变”与“不变”分开，使“工艺多样化”“工序标准化”，最终实现通过相同的构建过程生产出不同产品，这也是建造者模式要达成的目标。</p>
<h1 id="结构篇"><a href="#结构篇" class="headerlink" title="结构篇"></a>结构篇</h1><h2 id="第7章-门面"><a href="#第7章-门面" class="headerlink" title="第7章　门面"></a>第7章　门面</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310171102627.png" alt="image-20231017110243576"></p>
<p>门面模式(Facade)可能是最简单的结构型设计模式，它能将多个不同的子系统接口封装起来，并对外提供统一的高层接口，使复杂的子系统变得更易使用。顾名思义，“门”可以理解为建筑物的入口，而“面”则通常指物体的外层表面，比如人脸，如图7-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171103307.png" alt="image-20231017110315250"></p>
<p>无论是“门”还是“面”，指代的都是某系统的外观部分，也就是与外界接触的临界面或接口，所以门面模式常常也被翻译为“外观模式”。利用门面模式，我们可以把多个子系统“关”在门里面隐藏起来，成为一个整合在一起的大系统，来自外部的访问只需通过这道“门面”（接口）来进行，而不必再关心门面背后隐藏的子系统及其如何运转。总之，无论门面内部如何错综复杂，从门面外部看来总是一目了然，使用起来也很简单。</p>
<h3 id="7-1-一键操作"><a href="#7-1-一键操作" class="headerlink" title="7.1 一键操作"></a>7.1 一键操作</h3><p>为了更形象地理解门面模式，我们先来看一个例子。早期的相机使用起来是非常麻烦的，拍照前总是要根据场景情况进行一系列复杂的操作，如对焦、调节闪光灯、调光圈等，非专业人士面对这么一大堆的操作按钮根本无从下手，拍出来的照片质量也不高。随着科技的进步，出现了一种相机，叫作“傻瓜相机”，以形容其使用起来的方便性。用户再也不必学习那些复杂的参数调节了，只要按下快门键就可完成所有操作，如图7-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171104983.png" alt="image-20231017110411937"></p>
<p>显然图7-2右侧的“傻瓜相机”使用起来方便得多。它对庞大复杂的子系统进行了二次封装，把原本复杂的操作接口全都隐藏起来，并在内部加入逻辑使各参数在拍照前进行自动调节，最终只为外界提供一个简单方便的快门按键，让用户能够“一键操作”。如此不但可以防止非专业用户的各种误操作，而且大大提高了用户的拍照效率。在我们的生活中还有很多这样的例子，如自动挡汽车对离合及换挡操作的封装，再如全自动洗衣机对浸泡、漂洗、甩干、排水等一系列操作的封装，像这种“一键操作”式的设计都与门面模式的理念如出一辙。</p>
<h3 id="7-2-亲自下厨的烦扰"><a href="#7-2-亲自下厨的烦扰" class="headerlink" title="7.2 亲自下厨的烦扰"></a>7.2 亲自下厨的烦扰</h3><p>既然我们讲的是门面模式，那么以“商铺门面”的例子进行代码实战最贴切不过了。对很多人来说，做饭这件事情可能并不简单，所以往往会选择下馆子或者吃泡面，如果要亲自下厨的话就免不了一番折腾。我们首先得买菜、洗菜、切菜，然后进行蒸、煮、炒、炸等烹饪过程，最后还得收拾残局，清理碗筷。假设某天小明决定亲自下厨，但因不会做菜所以请妹妹帮忙。我们将步骤简化为以下3步，首先小明找菜贩买菜，然后找妹妹做菜，最后亲自洗碗，具体步骤如图7-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106750.png" alt="image-20231017110601668"></p>
<p>计划实施起来应该不难，我们开始代码实战。首先我们定义蔬菜商类完成第1步，然后让妹妹作为厨房小能手类完成第2步，最后小明作为客户端类进行全局操控并完成第3步，请参看代码清单7-1、代码清单7-2和代码清单7-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106926.png" alt="image-20231017110643882"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106597.png" alt="image-20231017110652563"></p>
<p>如代码清单7-1和代码清单7-2所示，蔬菜商类定义供应蔬菜方法，厨房小能手类则定义下厨烹饪方法，代码没有任何难度。我们主要来看代码清单7-3，小明从第13行依次找蔬菜商买菜，再找妹妹下厨，用完餐后小明洗碗收工。代码看起来虽不复杂，但这一顿饭下来够累人的，不但惊扰四方，还要自己亲自擦桌洗碗，但无论换作谁都要经历这一番操作。如果烹饪方法再复杂一些，再加上客户端对各子系统的操作不当，说不定一顿丰盛的大餐会成为黑暗料理.</p>
<p>期盼是美好的，可现实总是残酷的，一系列复杂的操作过程并不像我们想象的那么简单。小明开始意识到，任何事都亲力亲为的做法可能并不合适，难道其他用户也要像小明一样瞻前顾后、折腾一番？这显然会造成代码冗余。专业的事情还是应该交给专业的人去完成，他们会把这些子系统的操作过程封装起来，再以更为便捷的方式提供给用户使用。</p>
<h3 id="7-3-化繁为简"><a href="#7-3-化繁为简" class="headerlink" title="7.3 化繁为简"></a>7.3 化繁为简</h3><p>在一些商业街区，门面商铺总是聚集在人流量大的地方，而且门头上霓虹闪烁、招牌醒目，访问的便利性使顾客更加愿意购买这些商铺所提供的产品与服务，这也是一个好的门面总能够招揽更多顾客的原因。以餐饮商铺为例，如图7-5所示，为了享受可口的饭菜与优质的服务，小明决定直接访问这家临街门店。</p>
<p>为了达到高效、便捷的目的，门店会统一对子系统进行整合与调度，至于它对蔬菜商、厨师或服务员等子系统是如何操作的，用户都不必了解。下面我们对代码进行改造，创建外观门面类，请参考代码清单7-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171110658.png" alt="image-20231017111005618"></p>
<p>如代码清单7-4所示，外观门面类内部封装了大量的子系统资源，如蔬菜商、厨师、服务员、洗碗工，并于第8行的构造方法中依次对各个子系统进行了初始化操作，也就是说餐厅在开门前需要提前准备好这些资源，以便在第20行的点菜方法order()中进行依次调度。</p>
<p>需要注意的是，我们对外观门面类进行了一定的代码简化，在实际场景中可能还会包含一些更加复杂的逻辑，这也是餐饮门店要对子系统及其调度进行封装的原因，化繁为简的一站式服务才能解放用户的双手。至此，小明再也不必每日为解决吃饭问题而苦恼了，用户要做的只是登门访问，调用其order()方法即可享受现成可口的饭菜了，操作变得简单而优雅。</p>
<h3 id="7-4-整合共享"><a href="#7-4-整合共享" class="headerlink" title="7.4 整合共享"></a>7.4 整合共享</h3><p>门面模式不但重要，而且其应用也非常广泛，如在软件项目中，我们做多表数据更新时，业务逻辑层（Service层）对数据访问层（DAO层）的调用可能包含多个步骤，除此之外还要进行事务处理，最终统一对外提供一个update()方法，如此一来上层（如控制器Controller层）便可一步调用。软件模块应该只专注于各自擅长的领域，合理明确的分工模式才能更好地整合与共享资源。这正是门面模式所解决的问题，其中外观门面类对子系统的整合与共享极大地保证了用户访问的便利性，作为核心模块，其重要性不言而喻，请参看门面模式的类结构，如图7-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171112723.png" alt="image-20231017111205682"></p>
<p>门面模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Facade（外观门面）：封装了多个子系统，并将它们整合起来对外提供统一的访问接口。</span><br><span class="line">■ SubSystemA、SubSystemB、SubSystemC（子系统A、子系统B、子系统C）：隐藏于门面中的子系统，数量任意，且对外部不可见。对应本章例程中的蔬菜商类、厨师类、服务员类等。</span><br><span class="line">■ Client（客户端）：门面系统的使用方，只访问门面提供的接口。</span><br></pre></td></tr></table></figure>
<p>对客户端这种“门外汉”来说，直接使用子系统是复杂而烦琐的，门面则充当了包装类的角色，对子系统进行整合，再对外暴露统一接口，使其结构内繁外简，最终达到资源共享、简化操作的目的。从另一方面讲，门面模式也降低了客户端与子系统之间的依赖度，高内聚才能低耦合。</p>
<h2 id="第8章-组合"><a href="#第8章-组合" class="headerlink" title="第8章　组合"></a>第8章　组合</h2><p>组合模式(Composite)是针对由多个节点对象（部分）组成的树形结构的对象（整体）而发展出的一种结构型设计模式，它能够使客户端在操作整体对象或者其下的每个节点对象时做出统一的响应，保证树形结构对象使用方法的一致性，使客户端不必关注对象的整体或部分，最终达到对象复杂的层次结构与客户端解耦的目的。</p>
<h3 id="8-1-叉树结构"><a href="#8-1-叉树结构" class="headerlink" title="8.1 叉树结构"></a>8.1 叉树结构</h3><p>在现实世界中，某些具有从属关系的事物之间存在着一定的相似性。大家一定见过蕨类植物的叶子吧。如图8-1所示，从宏观上看，这只是一片普通的叶子，当继续观察其中一个分支的时候，我们会发现这个分支其实又是一片全新的叶子，当我们再继续观察这片新叶子的一个分支的时候，又会得到相同的结果。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172112385.png" alt="image-20231017211248219"></p>
<p>因此，我们可以得出结论，不管从哪个层级观察这片叶子，我们都会得到一个固定的结构，这意味着组成植物叶子的部分或整体都有着相同的生长方式，这正是孢子植物的DNA特征。大自然中存在的这种奇妙的结构在人类文明中同样有大量应用，例如文字就具有类似的结构，如图8-2所示，字可以组成词，词组成句子，句子再组成段落、章节……直至最终成书。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172113278.png" alt="image-20231017211304230"></p>
<p>这种结构类似于经典的“叉树”结构。以最简单的“二叉树”为例，此结构始于其开端的“根”节点，往下分出来两个“枝”节点（左右2个节点），接着每个枝节点又可以继续“分枝”，直至其末端的“叶”节点为止，具体结构请参看图8-3。</p>
<p>不管是二叉树还是多叉树，道理都是一样的。无论数据元素是“根”“枝”，还是“叶”，甚至是整体的树，都具有类似的结构。具体来讲，除了叶节点没有子节点，其他节点都具有本级对象包含多个次级子对象的结构特征。所以，我们完全没有必要为每个节点对象定义不同的类（如为字、词、句、段、节、章……等每个节点都定义一个类），否则会造成代码冗余。我们可以用组合模式来表达“部分/整体”的层次结构，提取并抽象其相同的部分，特殊化其不同的部分，以提高系统的可复用性与可扩展性，最终达到以不变应万变的目的。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172113351.png" alt="image-20231017211359310"></p>
<h3 id="8-2-文件系统"><a href="#8-2-文件系统" class="headerlink" title="8.2 文件系统"></a>8.2 文件系统</h3><p>通过对叉树结构的观察，我们发现，无论拿出哪一个“部分”，其与“整体”的结构都是类似的，所以首先我们需要模糊根、枝、叶之间的差异，以实现节点的统一。下面开始代码实战部分，我们就以类似于树结构的文件系统的目录结构为例，如图8-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172114145.png" alt="image-20231017211428084"></p>
<p>文件系统从根目录“C:”开始分支，其下级可以包含“文件夹”或者“文件”，其中文件夹属于“枝”节点，其下级可以继续存放子文件夹或文件，而文件则属于“叶”节点，其下级不再有任何子节点。基于此前的分析，我们可以定义一个抽象的“节点”类来模糊“文件夹”与“文件”，请参看代码清单8-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172115159.png" alt="image-20231017211504116"></p>
<p>如代码清单8-1所示，文件夹或文件都有一个名字，所以在第4行的构造方法中接收并初始化在第2行已定义的节点名，否则不允许节点被创建，这也是可以固化下来的逻辑。对于如何实现代码第9行中的添加子节点方法add(Node child)暂时还不能确定，所以我们声明其为抽象方法，模糊此行为并留给子类去实现。需要注意的是，对于抽象节点类Node的抽象方法其实还可以更加丰富，例如“删除节点”“获取节点”等，这里为了简化代码只声明了“添加节点”方法。下面我们就来实现文件夹类，此类肩负着确立树形结构的重任，这也是组合模式数据结构的精髓所在，请参看代码清单8-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172116893.png" alt="image-20231017211614858"></p>
<p>如代码清单8-2所示，首先，文件夹类继承了抽象节点类Node，并在第3行定义了一个次级节点列表List\<Node>，此处的泛型Node既可以是文件夹又可以是文件，也就是说，文件夹下级可以包含任意多个文件夹或者文件。然后，代码第5行中的构造方法直接调用父类的构造方法，以初始化其文件夹名。最后，在第10行实现了添加子节点方法add(Node child)，将传入的子节点添加至次级节点列表List\<Node>中。对于“叶”节点文件类，其作为末端节点，不应该具备添加子节点的功能，我们来看如何定义文件类，请参看代码清单8-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172118760.png" alt="image-20231017211829729"></p>
<p>如代码清单8-3所示，除了第8行的添加子节点方法add(Node child)，文件类与文件夹类的代码大同小异。如之前提到的，文件属于“叶”节点，不能再将这种结构延续下去，所以我们在第9行输出一个错误消息，告知用户“不能添加子节点”。其实更好的方式是以抛出异常的形式来确保此处逻辑的正确性，外部如果捕获到该异常则可以做出相应的处理，读者可以自行实践。一切就绪，用户就可以构建目录树了。我们来看客户端类怎样添加节点，请参看代码清单8-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172119550.png" alt="image-20231017211922506"></p>
<p>如代码清单8-4所示，正如我们规划文件时常做的操作，第3行中用户以“D盘”文件夹作为根节点构建了目录树，接着从第5行开始创建了“文档”和“音乐”两个文件夹作为“枝”节点，再将相应类型的文件分别置于相应的目录下，其中对音乐文件多加了一级文件夹来区分歌手，以便日后分类管理、查找。如此一来，只要能持有根节点对象“D盘”，就能延伸出整个目录。</p>
<h3 id="8-3-目录树展示"><a href="#8-3-目录树展示" class="headerlink" title="8.3 目录树展示"></a>8.3 目录树展示</h3><p>目录树虽已构建完成，但要体现出组合模式的优势还在于如何运用这个树结构。假如用户现在要查看当前根目录下的所有子目录及文件，这就需要分级展示整棵目录树，正如Windows系统的“tree”命令所实现的，如图8-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172122218.png" alt="image-20231017212221174"></p>
<p>要模拟这种树形展示方式，我们就得在输出节点名称（文件夹名/文件名）之前加上数个空格以表示不同层级，但具体加几个空格还是个未知数，需要根据具体的节点级别而定。而作为抽象节点类则不应考虑这些细节，而应先把这个未知数作为参数变量传入，我们来修改抽象节点类Node并加入展示方法，请参看代码清单8-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172123226.png" alt="image-20231017212319188"></p>
<p>如代码清单8-5所示，我们在第11行实现了以接收空格数量space为传入参数的展示方法tree(int space)，其中的循环体会输出space个连续的空格，最后再输出节点名称。因为此处是抽象节点类的实体方法，所以要保持其通用性。我们抽离出所有节点“相同”的部分作为“公有”的代码块，而“不同”的行为部分则留给子类去实现。首先来看文件类如何实现，请参看代码清单8-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172124753.png" alt="image-20231017212430721"></p>
<p>如代码清单8-6所示，作为末端节点的文件类只需要输出space个空格再加上自己的名称即可，这里与父类的展示方法tree(int space)应该保持一致，所以我们在第14行直接调用父类的展示方法。其实文件类可以不做任何修改，而是直接继承父类的展示方法，此处是为了让读者更清晰直观地看到这种继承关系，同时方便后续做出其他修改。接下来的文件夹类就比较特殊了，它不仅要先输出自己的名字，还要换行再逐个输出子节点的名字，并且要保证空格逐级递增，请参看代码清单8-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172125060.png" alt="image-20231017212540016"></p>
<p>如代码清单8-7所示，同样，文件夹类也重写并覆盖了父类的tree()方法，并且在第16行调用父类的通用tree()方法输出本文件夹的名字。接下来的逻辑就非常有意思了，对于下一级的子节点我们需要依次输出，但前提是要把当前的空格数加1，如此一来子节点的位置会往右偏移一格，这样才能看起来像树形结构一样错落有致。可以看到，在第19行的循环体中我们直接调用了子节点的展示方法并把“加1”后的空格数传递给它即可完成展示。至于当前文件夹下的子节点到底是“文件夹”还是“文件”，我们完全不必操心，因为子节点们会使用自己的展示逻辑。如果它们还有下一级子节点，则与此处逻辑相同，继续循环，把逐级递增的空格数传递下去，直至抵达叶节点为止——始于“文件夹”而终于“文件”，非常完美的递归逻辑。</p>
<p>最后，客户端在任何一级节点上只要调用其展示方法并传入当前目录所需的空格偏移量，就可出现树形列表了，比如若要紧挨控制台左侧展示，客户端则需要以“0”作为偏移量调用根目录的展示方法tree(0)，输出结果如图8-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172126740.png" alt="image-20231017212651702"></p>
<p>需要注意的是，空格偏移量这个必传参数可能让用户非常困惑，或许我们可以为抽象节点类添加一个无参的展示方法“tree()”，在其内部调用“tree(0)”，如此一来就不再需要用户传入偏移量了，使用起来更加方便。请参看代码清单8-8的抽象节点类在第19行做出的改进。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172127812.png" alt="image-20231017212721751"></p>
<h3 id="8-4-自相似性的涌现"><a href="#8-4-自相似性的涌现" class="headerlink" title="8.4 自相似性的涌现"></a>8.4 自相似性的涌现</h3><p>组合模式将树形结构的特点发挥得淋漓尽致，作为最高层级抽象的抽象节点类（接口）泛化了所有节点类，使任何“整体”或“部分”达成统一，枝（根）节点与叶节点的多态化实现以及组合关系进一步勾勒出的树形结构，最终使用户操作一触即发，由“根”到“枝”再到“叶”，逐级递归，自动生成。我们来看组合模式的类结构，如图8-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172142569.png" alt="image-20231017214225514"></p>
<p>组合模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Component（组件接口）：所有复合节点与叶节点的高层抽象，定义出需要对组件操作的接口标准。对应本章例程中的抽象节点类，具体使用接口还是抽象类需根据具体场景而定。</span><br><span class="line">■ Composite（复合组件）：包含多个子组件对象（可以是复合组件或叶端组件）的复合型组件，并实现组件接口中定义的操作方法。对应本章例程中作为“根节点/枝节点”的文件夹类。</span><br><span class="line">■ Leaf（叶端组件）：不包含子组件的终端组件，同样实现组件接口中定义的操作方法。对应本章例程中作为“叶节点”的文件类。</span><br><span class="line">■ Client（客户端）：按所需的层级关系部署相关对象并操作组件接口所定义的接口，即可遍历树结构上的所有组件。</span><br></pre></td></tr></table></figure>
<p>冥冥之中，大自然好似存在着某种神秘的规律，类似的结构总是在重复、迭代地显现出某种自似性。大到连绵的山川、飘浮的云朵、岩石的断裂口，小到树冠、雪花、菜花，甚至是人类的大脑皮层……自然界中很多事物无不体现出分形理论的神秘，其部分与整体一致的呈现与“组合模式”如出一辙。</p>
<p>“一花一世界，一叶一菩提”。世界是纷繁复杂的，然而繁杂中有序，从道家哲学的“道生一”到“三生万物”，从二进制的“0和1”到庞杂的软件系统，再从单细胞的生物到高级动物，“分形理论”无不揭示出事物的规律，其部分与整体的结构特征总是以相似的形式呈现，分形理论如此，组合模式亦是如此。</p>
<h2 id="第9章-装饰器"><a href="#第9章-装饰器" class="headerlink" title="第9章　装饰器"></a>第9章　装饰器</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310172143347.png" alt="image-20231017214356300"></p>
<p>装饰指在某物件上装点额外饰品的行为，以使其原本朴素的外表变得更加饱满、华丽，而装饰器（装饰者）就是能够化“腐朽”为神奇的利器。装饰器模式(Decorator)能够在运行时动态地为原始对象增加一些额外的功能，使其变得更加强大。从某种程度上讲，装饰器非常类似于“继承”，它们都是为了增强原始对象的功能，区别在于方式的不同，后者是在编译时(compile-time)静态地通过对原始类的继承完成，而前者则是在程序运行时(run-time)通过对原始对象动态地“包装”完成，是对类实例（对象）“装饰”的结果</p>
<h3 id="9-1-室内装潢"><a href="#9-1-室内装潢" class="headerlink" title="9.1 室内装潢"></a>9.1 室内装潢</h3><p>既然是装饰器，那么它一定能对客体进行一番加工，并在不改变其原始结构的前提下使客体功能得到扩展、增强。以室内装潢为例，如图9-1所示，要从毛坯房到精装房少不了“装饰”。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172145479.png" alt="image-20231017214529414"></p>
<p>装修风格多种多样，如简约、北欧、地中海、美式和中式等。当然，萝卜青菜各有所爱，每个人的审美取向不尽相同。朴素的毛坯房能给业主留有更大的装修选择空间，以根据自己的喜好进行二次加工。如果开发商出售的是已经装修好的房子，那么就得提供更多选项如“简装房”“精装房”“欧式精装房”“现代中式房”等供业主选择，这种固化下来的商品模式（编译时继承）就显得非常死板，而“买毛坯，送装修”的模式则更加灵活，这也是二手房产市场中毛坯房更加受欢迎的一个原因。成品一定是由半成品加工而成的，灵活多变的装饰才会带来更多的可能，因此装饰器模式应运而生。</p>
<h3 id="9-2-从素面朝天到花容月貌"><a href="#9-2-从素面朝天到花容月貌" class="headerlink" title="9.2 从素面朝天到花容月貌"></a>9.2 从素面朝天到花容月貌</h3><p>室内装修对房屋视觉效果的改善立竿见影，人们化妆也是如此，“人靠衣装马靠鞍”，人们总是惊叹女生们魔法师一般的化妆技巧，可以从素面朝天变成花容月貌（如图9-2所示），化妆前后简直判若两人，这正是装饰器的粉饰效果在发挥作用。</p>
<p>当然，化妆的过程也许对软件研发人员来说比较陌生，但我们可以从设计模式的角度出发，对这项充满神秘色彩的工作进行拆解和分析。下面开始我们的代码实战，首先对于任何妆容展示者必然对应一个标准的展示行为show()，我们将它抽象出来定义为接口Showable，如代码清单9-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172146774.png" alt="image-20231017214655740"></p>
<p>如代码清单9-1所示，Showable这个标准行为需要人去实现，女生们绝对当仁不让，下面来定义女生类，请参看代码清单9-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172147121.png" alt="image-20231017214712094"></p>
<p>如代码清单9-2所示，女生类在第5行中实现了其展示行为，因为目前还没有任何化妆效果，所以展示的只是女生的素颜。如果客户端直接调用show()方法，就会出现素面朝天的结果，这样就达不到我们要的妆容效果了。所以重点来了，此刻我们得借助“化妆品”这种工具来开始这场化妆仪式</p>
<p>化妆品对于女生的妆容效果起着至关重要的作用，我们就称之为“装饰器”吧，请参看代码清单9-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172148463.png" alt="image-20231017214834421"></p>
<p>如代码清单9-3所示，化妆品装饰器类与女生类一样也实现了标准行为展示接口Showable，这说明它同样能够进行展示，只是方式可能比较独特。第5行的构造方法中，化妆品装饰器类在构造自己的时候可以把其他可展示者注入进来并赋给在第3行定义的引用。如此一来，化妆品装饰器类中包含的这个可展示者就成为一个“被装饰者”的角色了。注意第10行的展示方法show()，化妆品装饰器类不但调用了“被装饰者”的展示方法，而且在其前后加入了自己的“粉饰效果”，这就像加了一层“壳”一样，包裹了被装饰对象。最后，我们来看客户端类的运行结果，请参看代码清单9-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172150418.png" alt="image-20231017215012388"></p>
<p>如代码清单9-4所示，客户端类代码干净、利落，我们在第5行将构造出来的女生类实例作为参数传给化妆品装饰器类的构造方法，这就好像为女生外表包裹了一层化妆品一样，对象结构非常生动、形象。接着，我们调用的是化妆品的展示方法show()，第6行的运行结果立竿见影，除女生自己的素颜展示结果之外还加上了额外的化妆效果。</p>
<h3 id="9-3-化妆品的多样化"><a href="#9-3-化妆品的多样化" class="headerlink" title="9.3 化妆品的多样化"></a>9.3 化妆品的多样化</h3><p>至此，我们已经完成了基本的装饰工作，可是装饰器中只有一个简单的“粉饰”效果，这未免过于单调，我们是否忘记了“口红”的效果？除此之外，可能还会有“眼线”“睫毛膏”“腮红”等各种各样的化妆品。</p>
<p>如何让我们的装饰器具备以上所有装饰功效呢？有些读者可能会想到，把这些装饰操作统统加入化妆品装饰器类中，一次搞定所有化妆操作。这样的做法必然是错误的，试想，难道每位女生都习惯于如此浓妆艳抹吗？化妆品的多样性决定了装饰器应该是多态化的，单个装饰器应该只负责自己的化妆功效，例如口红只用于涂口红，眼线笔只用于画眼线，把化妆品按功能分类才能让用户更加灵活地自由搭配，用哪个或不用哪个由用户自己决定，而不是把所有功能都固化在同一个装饰器里。</p>
<p>可能又有读者提出了别的解决方案，化妆品装饰器类已经是展示接口Showable的实现了，这本身已经使多态化成为了可能，那么让所有化妆品类都实现Showable接口不就行了吗？没错，但还记得化妆品装饰器类中出现的被装饰者引用（代码清单9-3的第3行）吗？有没有想过，难道每个化妆品类里都要引用这个被装饰者吗？粉底类里需要加入，口红类里也需要加入……这显然会导致代码冗余。</p>
<p>诚然，Showable接口是能够满足多态化需求的，但它只是对行为接口的一种规范，极度的抽象并不具备对代码继承的功能，所以化妆品的多态化还需要接口与抽象类的搭配使用才能两全其美。装饰器类的抽象化势在必行，我们来看如何重构它，请参看代码清单9-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172200781.png" alt="image-20231017220046741"></p>
<p>如代码清单9-5所示，我们将化妆品装饰器类修改为装饰器抽象类，这主要是为了不允许用户直接实例化此类。接着我们重构了第10行的展示方法show()，其中只是调用了被装饰者的show()方法，而不再做任何装饰操作，至于具体如何装饰则属于其子类的某个化妆品类的操作范畴了，例如之前的“打粉底”操作，我们将其分离出来独立成类，请参看代码清单9-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172201899.png" alt="image-20231017220151864"></p>
<p>如代码清单9-6所示，粉底类不用去实现Showable接口了，而是继承了装饰器抽象类，如此父类中对被装饰者的定义得以继承，可以看到我们在第4行的构造方法中调用了父类的构造方法并注入被装饰者，<strong>这便是继承的优势所在</strong>。当然，这个粉底类的show()方法一定要加上自己特有的操作，如第9行至第11行所示，我们在调用被装饰者的show()方法前后都进行了打粉底操作。化妆尚未结束，打完粉底再涂个口红吧，请参看代码清单9-7口红类。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172203091.png" alt="image-20231017220349061"></p>
<p>如代码清单9-7所示，与粉底类同出一辙，口红类只是进行了自己特有的“涂口红”操作。最后，客户端可以依次把被装饰者“女生”、装饰器“粉底”、装饰器“口红”用构造方法层层包裹起来，再进行展示即可完成整体化妆工作，请参看代码清单9-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172204139.png" alt="image-20231017220441107"></p>
<p>如代码清单9-8所示，客户端类的第4行中出现了多层的构造方法操作，接着在第5行只调用装饰好的madeupGirl对象的展示方法show()，所有装饰效果一触即发，层层递归。需要注意的是一系列构造产生的顺序，我们最终得到的madeupGirl对象本质上引用的是口红，口红里包裹了粉底，粉底里又包裹了女生，正如第6行运行结果所示的化妆效果一样。</p>
<p>至此，装饰器模式重构完毕，化妆品多态化得以顺利实现。如果用户对这些淡妆效果不够满意，我们还可以接着添加其他化妆品类，以便用户自由搭配出自己的理想效果，使“清新淡妆”或“浓妆艳抹”均成为可能。</p>
<h3 id="9-4-无处不在的装饰器"><a href="#9-4-无处不在的装饰器" class="headerlink" title="9.4 无处不在的装饰器"></a>9.4 无处不在的装饰器</h3><p>通过对装饰器模式的学习，读者是否觉得这种如同“俄罗斯套娃”一般层层嵌套的结构似曾相识？有些读者可能已经想到了，没错，其实装饰器模式在Java开发工具包(Java Development Kit, JDK)里就有大量应用，例如“java.io”包里一系列的流处理类InputStream、FileInputStream、BufferedInputStream、ZipInputStream等。举个例子，当对压缩文件进行解压操作时，我们就会用构造器嵌套结构进行文件流装饰，请参看代码清单9-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172206322.png" alt="image-20231017220654274"></p>
<p>如代码清单9-9所示，在第5行，我们首先以文件file初始化并构造文件输入流FileInputStream，然后外层用缓冲输入流BufferedInputStream进行装饰，使文件输入流具备内存缓冲的功能，最外层再用压缩包输入流ZipInputStream进行最终装饰，使文件输入流具备Zip格式文件的功能，之后我们就可以对压缩包进行解压操作了。当然，针对不同场景，Java I/O提供了多种流操作处理类，让各种装饰器能被混搭起来以完成不同的任务。</p>
<h3 id="9-5-自由嵌套"><a href="#9-5-自由嵌套" class="headerlink" title="9.5 自由嵌套"></a>9.5 自由嵌套</h3><p>Java类库中对装饰器模式的应用当然要比我们的例程复杂得多，但基本思想其实是一致的。装饰器模式最终的目的就在于“装饰”对象，其中装饰器抽象类扮演着至关重要的角色，它实现了组件的通用接口，并且使自身抽象化以迫使子类继承，使装饰器固定特性的延续与多态化成为可能。我们来看装饰器模式的类结构，如图9-5所示。装饰器模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Component（组件接口）：所有被装饰组件及装饰器对应的接口标准，指定进行装饰的行为方法。对应本章例程中的展示接口Showable。</span><br><span class="line">■ ConcreteComponent（组件实现）：需要被装饰的组件，实现组件接口标准，只具备自身未被装饰的原始特性。对应本章例程中的女生类Girl。</span><br><span class="line">■ Decorator（装饰器）：装饰器的高层抽象类，同样实现组件接口标准，且包含一个被装饰的组件。</span><br><span class="line">■ ConcreteDecorator（装饰器实现）：继承自装饰器抽象类的具体子类装饰器，可以有多种实现，在被装饰组件对象的基础上为其添加新的特性。对应本章例程中的粉底类FoundationMakeup、口红类Lipstick。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172228557.png" alt="image-20231017222855462"></p>
<p>客户需求是多变且无法预估的，要实现不同功能的自由组合，以“继承”的方式来完成是不现实的，会造成子类泛滥，维护或扩展起来举步维艰。试想，本章例程中用户可能需要“涂口红的女生”或“打粉底的女生”，也可能需要“打粉底再涂口红的女生”或“涂口红再打粉底的女生”。这2种化妆品就产生了女生类的4个子类，如果再增加些化妆品的话，罗列所有功能模块的排列组合会是一个不可能完成的任务。而装饰器模式可以将不同功能的单个模块规划至不同的装饰器类中，各装饰器类独立自主，各司其职。客户端可以根据自己的需求自由搭配各种装饰器，每加一层装饰就会有新的特性体现出来，巧妙的设计让功能模块层层叠加，装饰之上套装饰，最终使原始对象的特性动态地得到增强。</p>
<h2 id="第10章-适配器"><a href="#第10章-适配器" class="headerlink" title="第10章　适配器"></a>第10章　适配器</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310172229245.png" alt="image-20231017222946202"></p>
<p>适配器模式(Adapter)通常也被称为转换器，顾名思义，它一定是进行适应与匹配工作的物件。当一个对象或类的接口不能匹配用户所期待的接口时，适配器就充当中间转换的角色，以达到兼容用户接口的目的，同时适配器也实现了客户端与接口的解耦，提高了组件的可复用性。</p>
<h3 id="10-1-跨越鸿沟靠适配"><a href="#10-1-跨越鸿沟靠适配" class="headerlink" title="10.1 跨越鸿沟靠适配"></a>10.1 跨越鸿沟靠适配</h3><p>对象是多样化的，对象之间通过信息交换，也就是互动、沟通，世界才充满生机，否则就是死水一潭。人类最常用的沟通方式就是语言，两个人对话时，一方通过嘴巴发出声音，另一方则通过耳朵接收这些语言信息，所以嘴巴和耳朵（接口）必须兼容同一种语言（参数）才能达到沟通的目的。试想，我们跟不懂中文的人讲中文一定是徒劳的，因为对方根本无法理解我们在讲什么，更不要说人类和动物对话了，接口不兼容的结果就是对牛弹琴，如图10-1所示。</p>
<p>要跨越语言的鸿沟就必须找个会两种语言的翻译，将接口转换才能使沟通进行下去，我们将翻译这个角色称为适配器。适配器在我们生活中非常常见，如内存卡转换器、手机充电器、各种USB接口适配器等，再如我们上网用的调制解调器，它能够进行数模转换，让互联网服务提供商(ISP)与用户之间的网络接口互相适配与兼容，最终使两端进行正常通信。</p>
<h3 id="10-2-插头与插孔的冲突"><a href="#10-2-插头与插孔的冲突" class="headerlink" title="10.2 插头与插孔的冲突"></a>10.2 插头与插孔的冲突</h3><p>举一个生活中常见的实例，我们新买了一台电视机，其电源插头是两相的，不巧的是墙上的插孔却是三相的，这时电视机便无法通电使用。我们以代码来重现这个场景，首先得将墙上的三相插孔接口确立下来，请参看代码清单10-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172232757.png" alt="image-20231017223248717"></p>
<p>如代码清单10-1所示，我们为三相插孔接口TriplePin定义了一个三插通电标准electrify()，其中3个参数l、n、e分别对应火线(live)、零线(null)和地线(earth)。同样，我们定义两相插孔接口，请参看代码清单10-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172233195.png" alt="image-20231017223320154"></p>
<p>如代码清单10-2所示，与三相插孔接口所不同的是，两相插孔接口DualPin定义的是2个参数的通电标准，可以看到electrify()的参数中缺少了地线e。插孔接口定义完毕，接下来可以定义电视机类了。如之前提到的，电视机的两相插头是两插标准，所以它实现的是两相插孔接口DualPin，请参看代码清单10-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172234596.png" alt="image-20231017223417554"></p>
<p>如代码清单10-3所示，因为电视机类TV实现了两相插孔接口DualPin，所以代码第4行的通电方法electrify()只接通火线与零线，然后开机。代码很简单，而目前我们面临的问题是，墙上的接口是三相插孔，而电视机实现的是两相插孔，二者无法匹配，如代码清单10-4所示，客户端无法将两相插头与三相插孔完成接驳。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172235883.png" alt="image-20231017223501846"></p>
<h3 id="10-3-通用适配"><a href="#10-3-通用适配" class="headerlink" title="10.3 通用适配"></a>10.3 通用适配</h3><p>针对接口不兼容的情况，可能有人会提出比较极端的解决方案，就是把插头掰弯强行适配，若是三相插头接两相插孔的话，就把零线插针拔掉。虽然目的达到了，但经过这么一番暴力修改，插头也无法再兼容其原生接口了，这显然是违背设计模式原则的。</p>
<p>为了不破坏现有的电视机插头，我们需要一个适配器来做电源转换，有了它我们便可以顺利地把电视机两相插头转接到墙上的三相插孔中了，如图10-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172236028.png" alt="image-20231017223634986"></p>
<p>图10-2中间的适配器就像翻译一样，其插孔兼容右侧的两相插头，而其插头则兼容左侧的三相插孔，集两种接口于一身，承上启下，解决了接口间的冲突问题。我们来定义这个适配器，请参看代码清单10-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172237026.png" alt="image-20231017223659985"></p>
<p>如代码清单10-5所示，与电视机类不同的是，适配器类Adapter实现的是三相插孔接口，这意味着它能够兼容墙上的三相插孔了。注意代码第3行定义的两相插孔的引用，我们在第6行的构造方法中对其进行初始化，也就是说，适配器中嵌入一个两相插孔，任何此规格的设备都是可以接入进来的。最后，在第12行实现的三相插孔通电方法中，适配器转去调用了接入的两插设备，并且丢弃了地线参数e，这就完成了三相转两相的调制过程，最终达到适配效果。至此，这个适配器就可以将任意两插设备匹配到三相插孔上了。我们来看如何让电视机接通电源，请参看代码清单10-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172238810.png" alt="image-20231017223843772"></p>
<p>如代码清单10-6所示，客户端类在第5行构造的是两插标准的电视机对象，接着给构造好的适配器注入电视机对象（将电视机两相插头插入适配器），并将其赋给三相插孔接口（将匹配好的适配器插入墙上的三相插孔）。最后，我们直接调用三插通电方法给电视机供电，如第9行的输出结果所示，表面上看我们使用的是三插通电标准，而实际上是用两插标准为电视机供电（只使用了火线与零线），最终电视机顺利开启，两插标准的电视机与三相插孔接口成功得以适配。需要注意的是，适配器并不关心接入的设备是电视机、洗衣机还是电冰箱，只要是两相插头的设备均可以进行适配，所以说它是一种通用的适配器。</p>
<h3 id="10-4-专属适配"><a href="#10-4-专属适配" class="headerlink" title="10.4 专属适配"></a>10.4 专属适配</h3><p>除了10.3节所讲的“对象适配器”，我们还可以用“类适配器”实现接口的匹配，这是实现适配器模式的另一种方式。顾名思义，既然是类适配器，那么一定是属于某个类的“专属适配器”，也就是在编码阶段已经将被匹配的设备与目标接口进行对接了。我们继续之前的例子，请参看代码清单10-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172253954.png" alt="image-20231017225326917"></p>
<p>类适配器模式实现起来更简单，如代码清单10-7所示，电视机专属适配器类中并未包含被适配对象（如电视机）的引用，而是在开始定义类的时候就直接继承自电视机了，此外还一并实现了三相插孔接口。接着在第4行的三插通电方法中，我们利用“super”关键字调用父类（电视机类TV）定义的两插通电方法，以实现适配。下面我们来使用这个类适配器，请参看代码清单10-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172258861.png" alt="image-20231017225803826"></p>
<p>如代码清单10-8所示，第5行我们直接将实例化后的适配器对象接入墙上的三相插孔，接着直接通电使用即可。如输出结果所示，类适配器模式不但使用起来更加简单，而且其效果与对象适配器模式毫无二致。</p>
<p>然而，这个类适配器是继承自电视机的子类，在类定义的时候就已经与电视机完成了接驳，也就是说，类适配器与电视机的继承关系让它固化为一种专属适配器，这就造成了继承耦合，倘若我们需要适配其他两插设备，它就显得无能为力了。例如要适配两相插头的洗衣机，我们就不得不再写一个“洗衣机专属适配器”，这显然是一种代码冗余，说明适配器兼容性差。</p>
<p>当然，事物没有绝对的好与坏，对象适配器与类适配器各有各的适用场景。假如我们只需要匹配电视机这一种设备，并且未来也没有任何其他的设备扩展需求，那么类适配器使用起来可能更加简便，所以具体用什么、怎么用还要视具体情况而定，切不要有过分偏执、非黑即白的思想。</p>
<h3 id="10-5-化解难以调和的矛盾"><a href="#10-5-化解难以调和的矛盾" class="headerlink" title="10.5 化解难以调和的矛盾"></a>10.5 化解难以调和的矛盾</h3><p>众所周知，反复修改代码的代价是巨大的，因为所有依赖关系都要受到牵连，这不但会引入更多没有必要的重构与测试工作，而且其波及范围难以估量，可能会带来不可预知的风险，结果得不偿失。适配器模式让兼容性问题在不必修改任何代码的情况下得以解决，其中适配器类是核心，我们首先来看对象适配器模式的类结构，如图10-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172302200.png" alt="image-20231017230232147"></p>
<p>对象适配器模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Target（目标接口）：客户端要使用的目标接口标准，对应本章例程中的三相插孔接口TriplePin。</span><br><span class="line">■ Adapter（适配器）：实现了目标接口，负责适配（转换）被适配者的接口specificRequest()为目标接口request()，对应本章例程中的电视机专属适配器类TVAdapter。</span><br><span class="line">■ Adaptee（被适配者）：被适配者的接口标准，目前不能兼容目标接口的问题接口，可以有多种实现类，对应本章例程中的两相插孔接口DualPin。■ Client（客户端）：目标接口的使用者。</span><br></pre></td></tr></table></figure>
<p>下面是类适配器模式的类结构，请参看图10-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172304827.png" alt="image-20231017230429780"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">■ Target（目标接口）：客户端要使用的目标接口标准，对应本章例程中的三相插孔接口TriplePin。■ Adapter（适配器）：继承自被适配者类且实现了目标接口，负责适配（转换）被适配者的接口specificRequest()为目标接口request()。■ Adaptee（被适配者）：被适配者的类实现，目前不能兼容目标接口的问题类，对应本章例程中的电视机类TV。■ Client（客户端）：目标接口的使用者。</span><br></pre></td></tr></table></figure>
<p>对象适配器模式与类适配器模式基本相同，二者的区别在于前者的Adaptee（被适配者）以接口形式出现并被Adapter（适配器）引用，而后者则以父类的角色出现并被Adapter（适配器）继承，所以前者更加灵活，后者则更为简便。其实不管何种模式，从本质上看适配器至少都应该具备模块两侧的接口特性，如此才能承上启下，促成双方的顺利对接与互动，如图10-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172306995.png" alt="image-20231017230630944"></p>
<p>成功利用适配器模式对系统进行扩展后，我们就不必再为解决兼容性问题去暴力修改类接口了，转而通过适配器，以更为优雅、巧妙的方式将两侧“对立”的接口“整合”在一起，顺利化解双方难以调和的矛盾，最终使它们顺利接通。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">创建篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8D%95%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">第2章　单例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%A4%AA%E9%98%B3"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 孤独的太阳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A5%BF%E6%B1%89%E9%80%A0%E6%97%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.2 饿汉造日</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%87%92%E6%B1%89%E7%9A%84%E9%98%9F%E4%BC%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.3 懒汉的队伍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.4 大道至简</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">第3章　原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E4%BB%B6%E4%B8%8E%E5%89%AF%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.1 原件与副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%A1%E9%A1%BF%E7%9A%84%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2 卡顿的游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.3 细胞分裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%8B%E9%9A%86%E5%B7%A5%E5%8E%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.4 克隆工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.5.</span> <span class="toc-text">3.5 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%85%8B%E9%9A%86%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">3.6 克隆的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">第4章　工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B7%A5%E5%8E%82%E7%9A%84%E5%A4%9A%E5%85%83%E5%8C%96%E4%B8%8E%E4%B8%93%E4%B8%9A%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.1 工厂的多元化与专业化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.2 游戏角色建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%B8%8D%E7%AE%80%E5%8D%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3 简单工厂不简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%88%B6%E5%AE%9A%E5%B7%A5%E4%B8%9A%E5%88%B6%E9%80%A0%E6%A0%87%E5%87%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.4 制定工业制造标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8A%B3%E5%8A%A8%E5%88%86%E5%B7%A5"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.5 劳动分工</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">1.4.</span> <span class="toc-text">第5章　抽象工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%93%81%E7%89%8C%E4%B8%8E%E7%B3%BB%E5%88%97"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.1 品牌与系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%92"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.2 产品规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%94%9F%E4%BA%A7%E7%BA%BF%E8%A7%84%E5%88%92"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.3 生产线规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">5.4 分而治之</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BB%BA%E9%80%A0%E8%80%85"><span class="toc-number">1.5.</span> <span class="toc-text">第6章　建造者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%BB%BA%E9%80%A0%E6%AD%A5%E9%AA%A4%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.1 建造步骤的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%9C%B0%E4%BA%A7%E5%BC%80%E5%8F%91%E5%95%86%E7%9A%84%E5%9B%B0%E6%83%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.2 地产开发商的困惑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%BB%BA%E7%AD%91%E6%96%BD%E5%B7%A5%E6%96%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.3 建筑施工方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%9B%91"><span class="toc-number">1.5.4.</span> <span class="toc-text">6.4 工程总监</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD"><span class="toc-number">1.5.5.</span> <span class="toc-text">6.5 项目实施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%B7%A5%E8%89%BA%E4%B8%8E%E5%B7%A5%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.6 工艺与工序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">结构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%97%A8%E9%9D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">第7章　门面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%80%E9%94%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text">7.1 一键操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E4%BA%B2%E8%87%AA%E4%B8%8B%E5%8E%A8%E7%9A%84%E7%83%A6%E6%89%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">7.2 亲自下厨的烦扰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">7.3 化繁为简</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%95%B4%E5%90%88%E5%85%B1%E4%BA%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">7.4 整合共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%BB%84%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">第8章　组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">8.1 叉树结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">8.2 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%9B%AE%E5%BD%95%E6%A0%91%E5%B1%95%E7%A4%BA"><span class="toc-number">2.2.3.</span> <span class="toc-text">8.3 目录树展示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%87%AA%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9A%84%E6%B6%8C%E7%8E%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">8.4 自相似性的涌现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">第9章　装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%AE%A4%E5%86%85%E8%A3%85%E6%BD%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">9.1 室内装潢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BB%8E%E7%B4%A0%E9%9D%A2%E6%9C%9D%E5%A4%A9%E5%88%B0%E8%8A%B1%E5%AE%B9%E6%9C%88%E8%B2%8C"><span class="toc-number">2.3.2.</span> <span class="toc-text">9.2 从素面朝天到花容月貌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%8C%96%E5%A6%86%E5%93%81%E7%9A%84%E5%A4%9A%E6%A0%B7%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">9.3 化妆品的多样化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">9.4 无处不在的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E8%87%AA%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-number">2.3.5.</span> <span class="toc-text">9.5 自由嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">第10章　适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E8%B7%A8%E8%B6%8A%E9%B8%BF%E6%B2%9F%E9%9D%A0%E9%80%82%E9%85%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">10.1 跨越鸿沟靠适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%8F%92%E5%A4%B4%E4%B8%8E%E6%8F%92%E5%AD%94%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">10.2 插头与插孔的冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%80%9A%E7%94%A8%E9%80%82%E9%85%8D"><span class="toc-number">2.4.3.</span> <span class="toc-text">10.3 通用适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E4%B8%93%E5%B1%9E%E9%80%82%E9%85%8D"><span class="toc-number">2.4.4.</span> <span class="toc-text">10.4 专属适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%8C%96%E8%A7%A3%E9%9A%BE%E4%BB%A5%E8%B0%83%E5%92%8C%E7%9A%84%E7%9F%9B%E7%9B%BE"><span class="toc-number">2.4.5.</span> <span class="toc-text">10.5 化解难以调和的矛盾</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="秒懂设计模式"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秒懂设计模式"/></a><div class="content"><a class="title" href="/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="秒懂设计模式">秒懂设计模式</a><time datetime="2023-10-16T13:35:45.000Z" title="发表于 2023-10-16 21:35:45">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven实战"/></a><div class="content"><a class="title" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战">Maven实战</a><time datetime="2023-10-15T11:12:27.000Z" title="发表于 2023-10-15 19:12:27">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解HTTP"/></a><div class="content"><a class="title" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2023-10-15T10:39:45.000Z" title="发表于 2023-10-15 18:39:45">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud微服务和分布式系统实践"/></a><div class="content"><a class="title" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践">Spring Cloud微服务和分布式系统实践</a><time datetime="2023-10-13T10:57:16.000Z" title="发表于 2023-10-13 18:57:16">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>