<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>秒懂设计模式 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:type" content="article">
<meta property="og:title" content="秒懂设计模式">
<meta property="og:url" content="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-16T13:35:45.000Z">
<meta property="article:modified_time" content="2023-12-01T07:26:41.337Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '秒懂设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 15:26:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">187</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">秒懂设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-16T13:35:45.000Z" title="发表于 2023-10-16 21:35:45">2023-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-01T07:26:41.337Z" title="更新于 2023-12-01 15:26:41">2023-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="秒懂设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="创建篇"><a href="#创建篇" class="headerlink" title="创建篇"></a>创建篇</h1><h2 id="第2章-单例"><a href="#第2章-单例" class="headerlink" title="第2章　单例"></a>第2章　单例</h2><p>单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。</p>
<h3 id="2-1-孤独的太阳"><a href="#2-1-孤独的太阳" class="headerlink" title="2.1 孤独的太阳"></a>2.1 孤独的太阳</h3><p>盘古开天，造日月星辰。从“夸父逐日”到“后羿射日”，太阳对于我们的先祖一直具有着神秘的色彩与非凡的意义。随着科学的不断发展，我们逐渐揭开了太阳系的神秘面纱。我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳，如图2-1所示。</p>
<p>与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例，它持续提供给地球充足的阳光与能量，离开它地球就不会有今天的勃勃生机，但倘若天上有9个太阳，那么将会带来一场灾难。太阳东升西落，循环往复，不多不少仅此一例。</p>
<h3 id="2-2-饿汉造日"><a href="#2-2-饿汉造日" class="headerlink" title="2.2 饿汉造日"></a>2.2 饿汉造日</h3><p>既然太阳系里只有一个太阳，我们就需要严格把控太阳实例化的过程。我们从最简单的开始，先来写一个Sun类。请参看代码清单2-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162137499.png" alt="image-20231016213756320"></p>
<p>如代码清单2-1所示，太阳类Sun中目前什么都没有。接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。有些读者可能会疑惑，我们并没有写构造器，为什么太阳还可以被实例化呢？这是因为Java可以自动为其加上一个无参构造器。为防止太阳实例泛滥将世界再次带入灾难，我们必须禁止外部调用构造器，请参看代码清单2-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162138926.png" alt="image-20231016213850858"></p>
<p>如代码清单2-2所示，我们在第3行将太阳类Sun的构造方法设为private，使其私有化，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己，并使其自有永有，请参看代码清单2-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162139115.png" alt="image-20231016213934088"></p>
<p>如代码清单2-3所示，代码第3行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。这就是“饿汉模式”(eager initialization)，即在初始阶段就主动进行实例化，并时刻保持一种渴求的状态，无论此单例是否有人使用。</p>
<p>单例的太阳对象写好了，可一切皆是私有的，外部怎样才能访问它呢？正如同程序入口的静态方法main()，它不需要任何对象引用就能被访问，我们同样需要一个静态方法getInstance()来获取太阳的单例对象，同时将其设置为“public”以暴露给外部使用，请参看代码清单2-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162141914.png" alt="image-20231016214122870"></p>
<p>如代码清单2-4所示，太阳单例类的雏形已经完成了，对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。当然，读者还可以添加其他功能方法，如发光和发热等，此处就不再赘述了。</p>
<h3 id="2-3-懒汉的队伍"><a href="#2-3-懒汉的队伍" class="headerlink" title="2.3 懒汉的队伍"></a>2.3 懒汉的队伍</h3><p>至此，我们已经学会了单例模式的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。沿着这个思路，我们继续对太阳类进行改造，请参看代码清单2-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162146741.png" alt="image-20231016214603688"></p>
<p>如代码清单2-5所示，可以看到我们一开始并没有造太阳，所以去掉了关键字final，只有在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。这样的好处是如无请求就不实例化，节省了内存空间；而坏处是第一次请求的时候速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳（即使速度快到可以忽略不计）。</p>
<p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第10行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且对sun进行多次赋值（覆盖）操作，这违背了单例的理念。我们再来改良一下，把请求方法加上synchronized（同步锁）让其同步，如此一来，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来，请参看代码清单2-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162148548.png" alt="image-20231016214817514"></p>
<p>如代码清单2-6所示，我们将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。然而这样的做法是要付出一定代价的，试想，线程还没进入方法内部便不管三七二十一直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。我们只是为了实例化一个单例对象而已，犯不上如此兴师动众，使用synchronized让所有请求排队等候。所以，要保证多线程并发下逻辑的正确性，同步锁一定要加得恰到好处，其位置是关键所在，请参看代码清单2-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162149853.png" alt="image-20231016214917776"></p>
<p>如代码清单2-7所示，我们在太阳类Sun中第3行对sun变量的定义不再使用final关键字，这意味着它不再是常量，而是需要后续赋值的变量；而关键字volatile对静态变量的修饰则能保证变量值在各线程访问时的同步性、唯一性。需要特别注意的是，对于第9行的getInstance()方法，我们去掉了方法上的关键字synchronized，使大家都可以同时进入方法并对其进行开发。请仔细阅读每行代码的注释，有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。而在第11行我们又加上了同步块以防止多个线程进入，这就类似于观日台是一个狭长的走廊，大家排队进入。随后在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳</p>
<p>随后发生的事情我们就可以预见了，太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例就可以了，阳光普照大地，将温暖洒向人间。</p>
<p>大家注意到没有，我们一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：外层放宽入口，保证线程并发的高效性；内层加锁同步，保证实例化的单次运行。如此里应外合，不仅达到了单例模式的效果，还完美地保证了构建过程的运行效率，一举两得。</p>
<p><strong>懒汉式的双检锁是在保证线程安全的同时最大化性能。</strong></p>
<h3 id="2-4-大道至简"><a href="#2-4-大道至简" class="headerlink" title="2.4 大道至简"></a>2.4 大道至简</h3><p>相比“懒汉模式”，其实在大多数情况下我们通常会更多地使用“饿汉模式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。我们来看单例模式的类结构，如图2-3所示。单例模式的角色定义如下。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162154860.png" alt="image-20231016215458815"></p>
<p>■ Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用private关键字隐藏起来，对外只提供getInstance()方法以获得这个单例对象。</p>
<p>除了“饿汉”与“懒汉”这2种单例模式，其实还有其他的实现方式。但万变不离其宗，它们统统都是由这2种模式发展、衍生而来的。我们都知道Spring框架中的IoC容器很好地帮我们托管了业务对象，如此我们就不必再亲自动手去实例化这些对象了，而在默认情况下我们使用的正是框架提供的“单例模式”。诚然，究其代码实现当然不止如此简单，但我们应该追本溯源，抓住其本质的部分，理解其核心的设计思想，再针对不同的应用场景做出相应的调整与变动，结合实践举一反三。</p>
<h2 id="第3章-原型"><a href="#第3章-原型" class="headerlink" title="第3章　原型"></a>第3章　原型</h2><p>原型模式(Prototype)，在制造业中通常是指大批量生产开始之前研发出的概念模型，并基于各种参数指标对其进行检验，如果达到了质量要求，即可参照这个原型进行批量生产。原型模式达到以原型实例创建副本实例的目的即可，并不需要知道其原始类，也就是说，原型模式可以用对象创建对象，而不是用类创建对象，以此达到效率的提升。</p>
<h3 id="3-1-原件与副本"><a href="#3-1-原件与副本" class="headerlink" title="3.1 原件与副本"></a>3.1 原件与副本</h3><p>在讲原型模式之前，我们先得搞清楚什么是类的实例化。相信大家一定见过活字印章，如图3-1所示，当我们调整好需要的日期（初始化参数），再轻轻一盖（调用构造方法），一个实例化后的日期便跃然纸上了，这个过程正类似于类的实例化。</p>
<p>其实构造一个对象的过程是耗时耗力的。想必大家一定有过打印和复印的经历，为了节省成本，我们通常会用打印机把电子文档打印到A4纸上（原型实例化过程），再用复印机把这份纸质文稿复制多份（原型拷贝过程），这样既实惠又高效。那么，对于第一份打印出来的原文稿，我们可以称之为“原型文件”，而对于复印过程，我们则可以称之为“原型拷贝”，如图3-2所示。</p>
<h3 id="3-2-卡顿的游戏"><a href="#3-2-卡顿的游戏" class="headerlink" title="3.2 卡顿的游戏"></a>3.2 卡顿的游戏</h3><p>想必大家已经明白了类的实例化与克隆之间的区别，二者都是在造对象，但方法绝对是不同的。原型模式的目的是从原型实例克隆出新的实例，对于那些有非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。理论还需与实践结合，下面开始实战部分，假设我们准备设计一个空战游戏的程序，如图3-3所示。</p>
<p>我们这里为了保持简单，设定游戏为单打，也就是说主角飞机只有一架，而敌机则有很多架，而且可以在屏幕上垂直向下移动来撞击主角飞机。具体是如何实现的呢？其实非常简单，就是程序不停改变其坐标并在画面上重绘而已。由浅入深，我们先试着写一个敌机类，请参看代码清单3-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162201482.png" alt="image-20231016220106408"></p>
<p>如代码清单3-1所示，敌机类EnemyPlane在第6行的敌机构造器方法中对飞机的横坐标x进行了初始化，而纵坐标则固定为0，这是由于敌机一开始是从顶部飞出的。所以其纵坐标y必然为0（屏幕左上角坐标为[0, 0]）。继续往下看，敌机类只提供了getter方法而没有提供setter方法，也就是说我们只能在初始化时确定好敌机的横坐标x，之后则不允许再更改坐标了。当游戏运行时，我们只要连续调用第18行的飞行方法fly()，便可以让飞机像雨点一样不断下落。在开始绘制敌机动画之前，我们首先得实例化500架敌机，请参看代码清单3-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162202565.png" alt="image-20231016220239519"></p>
<p>如代码清单3-2所示，我们在第6行使用了循环的方式来批量生产敌机，并使用了“new”关键字来实例化敌机，循环结束后500架敌机便统统被加入第4行定义的飞机列表enemyPlanes中。这种做法看似没有任何问题，然而效率却是非常低的。我们知道在游戏画面上根本没必要同时出现这么多敌机，而在游戏还未开始之前，也就是游戏的加载阶段我们就实例化了这一关卡的所有500架敌机，这不但使加载速度变慢，而且是对有限内存资源的一种浪费。那么到底什么时候去构造敌机？答案当然是懒加载了，也就是按照地图坐标，屏幕滚动到某一点时才实时构造敌机，这样一来问题就解决了。</p>
<p>然而遗憾的是，懒加载依然会有性能问题，主要原因在于我们使用的“new”关键字进行的基于类的实例化过程，因为每架敌机都进行全新构造的做法是不合适的，其代价是耗费更多的CPU资源，尤其在一些大型游戏中，很多个线程在不停地运转着，CPU资源本身就非常宝贵，此时若进行大量的类构造与复杂的初始化工作，必然会造成游戏卡顿，甚至有可能会造成系统无响应，使游戏体验大打折扣，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162204576.png" alt="image-20231016220422526"></p>
<h3 id="3-3-细胞分裂"><a href="#3-3-细胞分裂" class="headerlink" title="3.3 细胞分裂"></a>3.3 细胞分裂</h3><p>硬件永远离不开优秀的软件，我们绝不允许以糟糕的软件设计对硬件发起挑战，因而代码优化势在必行。我们思考一下之前的设计，既然循环第一次后已经实例化好了一个敌机原型，那么之后又何必去重复这个构造过程呢？敌机对象能否像细胞分裂一样自我复制呢？要解决这些问题，原型模式是最好的解决方案了，下面我们对敌机类进行重构并让其支持原型拷贝，请参看代码清单3-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162205833.png" alt="image-20231016220516782"></p>
<p>如代码清单3-3所示，我们让敌机类EnemyPlane实现了java.lang包中的克隆接口Cloneable，并在第29行的实现方法中调用了父类Object的克隆方法，如此一来外部就能够对本类的实例进行克隆操作了，省去了由类而生的再造过程。还需要注意的是，我们在第23行处加入了设置横坐标方法setX()，使被实例化后的敌机对象依然可以支持坐标位置的变更，这是为了保证克隆飞机的坐标位置个性化。</p>
<h3 id="3-4-克隆工厂"><a href="#3-4-克隆工厂" class="headerlink" title="3.4 克隆工厂"></a>3.4 克隆工厂</h3><p>至此，克隆模式其实已经实现了，我们只需简单调用克隆方法便能更高效地得到一个全新的实例副本。为了更方便地生产飞机，我们决定定义一个敌机克隆工厂类，请参看代码清单3-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162208369.png" alt="image-20231016220826329"></p>
<p>如代码清单3-4所示，我们在敌机克隆工厂类EnemyPlaneFactory中第4行使用了一个静态的敌机对象作为原型，并于第7行提供了一个获取敌机实例的方法getInstance()，其中简单地调用克隆方法得到一个新的克隆对象（此处省略了异常捕获代码），并将其横坐标重设为传入的参数，最后返回此克隆对象，这样我们便可轻松获取一架敌机的克隆实例了。</p>
<p>敌机克隆工厂类定义完毕，客户端代码就留给读者自己去实践了。但需要注意，一定得使用“懒加载”的方式，如此既可以节省内存空间，又可以确保敌机的实例化速度，实现敌机的即时性按需克隆，这样游戏便再也不会出现卡顿现象了。</p>
<h3 id="3-5-深拷贝与浅拷贝"><a href="#3-5-深拷贝与浅拷贝" class="headerlink" title="3.5 深拷贝与浅拷贝"></a>3.5 深拷贝与浅拷贝</h3><p>最后，在使用原型模式之前，我们还必须得搞清楚浅拷贝和深拷贝这两个概念，否则会对某些复杂对象的克隆结果感到无比困惑。让我们再扩展一下场景，假设敌机类里有一颗子弹可以发射并击杀玩家的飞机，那么敌机中则包含一颗实例化好的子弹对象，请参看代码清单3-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162213224.png" alt="image-20231016221322201"></p>
<p>如代码清单3-5所示，对于这种复杂一些的敌机类，此时如果进行克隆操作，我们是否能将第3行中的子弹对象一同成功克隆呢？答案是否定的。我们都知道，Java中的变量分为原始类型和引用类型，所谓浅拷贝是指只复制原始类型的值，比如横坐标x与纵坐标y这种以原始类型int定义的值，它们会被复制到新克隆出的对象中。而引用类型bullet同样会被拷贝，但是请注意这个操作只是拷贝了地址引用（指针），也就是说副本敌机与原型敌机中的子弹是同一颗，因为两个同样的地址实际指向的内存对象是同一个bullet对象。</p>
<p>需要注意的是，克隆方法中调用父类Object的clone方法进行的是浅拷贝，所以此处的bullet并没有被真正克隆。然而，每架敌机携带的子弹必须要发射出不同的弹道，这就必然是不同的子弹对象了，所以此时原型模式的浅拷贝实现是无法满足需求的，那么该如何改动呢？请参看如代码清单3-6中对敌机类的深拷贝支持。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162214123.png" alt="image-20231016221434082"></p>
<p>如代码清单3-6所示，首先我们在第13行的克隆方法clone()中依旧对敌机对象进行了克隆操作，紧接着对敌机子弹bullet也进行了克隆，这就是深拷贝操作。当然，此处要注意对于子弹类Bullet同样也得实现克隆接口，请读者自行实现，此处就不再赘述了。</p>
<h3 id="3-6-克隆的本质"><a href="#3-6-克隆的本质" class="headerlink" title="3.6 克隆的本质"></a>3.6 克隆的本质</h3><p>终于，在我们用克隆模式对游戏代码反复重构后，游戏性能得到了极大的提升，流畅的游戏画面确保了优秀的用户体验。最后，我们来看原型模式的类结构，如图3-5所示。原型模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Prototype（原型接口）：声明克隆方法，对应本例程代码中的Cloneable接口。</span><br><span class="line">■ ConcretePrototype（原型实现）：原型接口的实现类，实现方法中调用super.clone()即可得到新克隆的对象。</span><br><span class="line">■ Client（客户端）：客户端只需调用实现此接口的原型对象方法clone()，便可轻松地得到一个全新的实例对象。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162216826.png" alt="image-20231016221647744"></p>
<p>从类到对象叫作“创建”，而由本体对象至副本对象则叫作“克隆”，当需要创建多个类似的复杂对象时，我们就可以考虑用原型模式。究其本质，克隆操作时Java虚拟机会进行内存操作，直接拷贝原型对象数据流生成新的副本对象，绝不会拖泥带水地触发一些多余的复杂操作（如类加载、实例化、初始化等），所以其效率远远高于“new”关键字所触发的实例化操作。看尽世间烦扰，拨开云雾见青天，有时候“简单粗暴”也是一种去繁从简、不绕弯路的解决方案。</p>
<h2 id="第4章-工厂方法"><a href="#第4章-工厂方法" class="headerlink" title="第4章　工厂方法"></a>第4章　工厂方法</h2><p>制造业是一个国家工业经济发展的重要支柱，而工厂则是其根基所在。程序设计中的工厂类往往是对对象构造、实例化、初始化过程的封装，而工厂方法(Factory Method)则可以升华为一种设计模式，它对工厂制造方法进行接口规范化，以允许子类工厂决定具体制造哪类产品的实例，最终降低系统耦合，使系统的可维护性、可扩展性等得到提升。</p>
<h3 id="4-1-工厂的多元化与专业化"><a href="#4-1-工厂的多元化与专业化" class="headerlink" title="4.1 工厂的多元化与专业化"></a>4.1 工厂的多元化与专业化</h3><p>要理解工厂方法模式，我们还得从头说起。众所周知，要制造产品（实例化对象）就得用到关键字“new”，例如“Plane plane=new Plane(); ”，或许还会有一些复杂的初始化代码，这就是我们常用的传统构造方式。然而这样做的结果会使飞机对象的产生代码被牢牢地硬编码在客户端类里，也就是说客户端与实例化过程强耦合了。而事实上，我们完全不必关心产品的制造过程（实例化、初始化），而将这个任务交由相应的工厂来全权负责，工厂最终能交付产品供我们使用即可，如此我们便摆脱了产品生产方式的束缚，实现了与制造过程彻底解耦。</p>
<p>除此之外，工厂方法模式是基于多元化产品的构造方法发展而来的，它开辟了产品多元化的生产模式，不同的产品可以交由不同的专业工厂来生产，例如皮鞋由皮鞋工厂来制造，汽车则由汽车工厂来制造，专业化分工明确，如图4-1所示。</p>
<h3 id="4-2-游戏角色建模"><a href="#4-2-游戏角色建模" class="headerlink" title="4.2 游戏角色建模"></a>4.2 游戏角色建模</h3><p>在制造产品之前，我们先得为它们建模。我们依旧以空战游戏来举例，通常这类游戏中主角飞机都拥有强大的武器装备，以应对敌众我寡的游戏局面，所以敌人的种类就应当多样化，以带给玩家更加丰富多样的游戏体验。于是我们增加了一些敌机、坦克，游戏画面如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162222535.png" alt="image-20231016222253497"></p>
<p>如图4-2所示，游戏中敌人的种类有飞机和坦克，虽然它们之间的区别比较大，但总有一些共同的属性或行为，例如一对用来描述位置状态的坐标，以及一个展示（绘制）方法，以便将自己绘制到相应的地图位置上。好了，现在我们使用抽象类来定义所有敌人的父类，请参看代码清单4-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162223933.png" alt="image-20231016222323896"></p>
<p>如代码清单4-1所示，我们在敌人抽象类Enemy中第13行定义了一个显示方法show()，并声明其抽象方法，以交给子类去实现，并按照构造方法（第7行）中初始化的坐标位置将自己绘制到地图上。接下来是具体子类实现，也就是敌机类和坦克类，请参看代码清单4-2与代码清单4-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224024.png" alt="image-20231016222410990"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224550.png" alt="image-20231016222417493"></p>
<p>如代码清单4-2与代码清单4-3所示，飞机类Airplane和坦克类Tank都继承了敌人抽象类Enemy，并且分别实现了各自独特的展示方法show()，其中坦克应该绘制在下层（但在地图层之上）图层，而飞机则绘制在上层图层，这样才能遮盖住下层的所有图层以达到期望的视觉效果。</p>
<h3 id="4-3-简单工厂不简单"><a href="#4-3-简单工厂不简单" class="headerlink" title="4.3 简单工厂不简单"></a>4.3 简单工厂不简单</h3><p>产品建模完成后，就应该考虑如何实例化和初始化这些敌人了。毋庸置疑，要使它们都出现在屏幕最上方，就得使其纵坐标y被初始化为0，而对于横坐标x该怎样初始化呢？如果让敌人出现于屏幕正中央的话，就得将其横坐标初始化为屏幕宽度的一半，显然，如此玩家只需要一直对准屏幕中央射击，这对游戏可玩性来说是非常糟糕的，所以我们最好让敌人的横坐标随机产生，这样才能给玩家带来更好的游戏体验。我们来看客户端如何进行设置，请参看代码清单4-4</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162225483.png" alt="image-20231016222540439"></p>
<p>如代码清单4-4所示，我们在第4行假设屏幕宽度为100，然后在第7行生成一个从0到“屏幕宽度”的随机数，再以此为横坐标构造并初始化敌人（为保持简单不考虑敌人自身的宽度），这样敌人就会出现在随机的横坐标位置上了。接着往下看，我们在第11行构造坦克时做了同样的设置，最后的输出结果达到了我们的预期，飞机和坦克随机出现于屏幕顶部，游戏可玩性大大提高。</p>
<p>然而，制造随机出现的敌人这个动作貌似不应该出现在客户端类中，试想如果我们还有其他敌人也需要构造的话，那么同样的代码就会再次出现，尤其是当初始化越复杂的时候重复代码就会越多。如此耗时费力，何不把这些实例化逻辑抽离出来作为一个工厂类？沿着这个思路，我们来开发一个制造敌人的简单工厂类，请参看代码清单4-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162228669.png" alt="image-20231016222800625"></p>
<p>如代码清单4-5所示，简单工厂类SimpleFactory将之前在客户端类里制造敌人的代码挪过来，并封装在第10行的制造方法create()方法中，这里我们在第13行加入了一些逻辑判断，使其可以根据传入的敌人种类（飞机或坦克）生产出相应的对象实例，并随机初始化其位置。如此一来，制造敌人这个任务就全权交由简单工厂来负责了，于是客户端便可以直接从简单工厂取用敌人了，请参看代码清单4-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162229987.png" alt="image-20231016222929942"></p>
<p>如代码清单4-6所示，客户端类的代码变得异常简单、清爽，这就是分类封装、各司其职的好处。然而，这个简单工厂的确很“简单”，但并不涉及任何的模式设计范畴，虽然客户端中不再直接出现对产品实例化的代码，但羊毛出在羊身上，制造逻辑只是被换了个地方，挪到了简单工厂中而已，并且客户端还要告知产品种类才能产出，这无疑是另一种意义上的耦合。</p>
<p>除此之外，简单工厂一定要保持简单，否则就不要用简单工厂。随着游戏项目需求的演变，简单工厂的可扩展性也会变得很差，例如对于那段对产品种类的判断逻辑，如果有新的敌人类加入，我们就需要再修改简单工厂。随着生产方式不断多元化，工厂类就得被不断地反复修改，严重缺乏灵活性与可扩展性，尤其是对于一些庞大复杂的系统，大量的产品判断逻辑代码会被堆积在制造方法中，看起来好像功能强大、无所不能，其实维护起来举步维艰，简单工厂就会变得一点也不简单了。</p>
<h3 id="4-4-制定工业制造标准"><a href="#4-4-制定工业制造标准" class="headerlink" title="4.4 制定工业制造标准"></a>4.4 制定工业制造标准</h3><p>其实系统中并不是处处都需要调用这样一个万能的“简单工厂”，有时系统只需要一个坦克对象，所以我们不必大动干戈使用这样一个臃肿的“简单工厂”。另外，由于用户需求的多变，我们又不得不生成大量代码，这正是我们要调和的矛盾。</p>
<p>针对复杂多变的生产需求，我们需要对产品制造的相关代码进行合理规划与分类，将简单工厂的<strong>制造方法进行拆分</strong>，构建起抽象化、多态化的生产模式。下面我们就对各种各样的生产方式（工厂方法）进行抽象，首先定义一个工厂接口，以确立统一的工业制造标准，请参看代码清单4-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162234425.png" alt="image-20231016223455402"></p>
<p>如代码清单4-7所示，工厂接口Factory其实就是工厂方法模式的核心了。我们在第3行中声明了工业制造标准，只要传入屏幕宽度，就在屏幕坐标内产出一个敌人实例，任何工厂都应遵循此接口。接下来我们重构一下之前的简单工厂类，将其按产品种类拆分为两个类，请参看代码清单4-8和代码清单4-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162235172.png" alt="image-20231016223559136"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162236714.png" alt="image-20231016223605686"></p>
<p>如代码清单4-8和代码清单4-9所示，飞机工厂类AirplaneFactory与坦克工厂类TankFactory的代码简洁、明了，它们都以关键字implements声明了本类是实现工厂接口Factory的工厂实现类，并且在第4行给出了工厂方法create()的具体实现，其中飞机工厂制造飞机，坦克工厂制造坦克，各自有其独特的生产方式。</p>
<p>除了飞机和坦克，应该还会有其他的敌人，当玩家抵达游戏关底时总会有Boss出现，这时候我们该如何扩展呢？显而易见，基于此模式继续我们的扩展即可，先定义一个继承自敌人抽象类Enemy的Boss类，相应地还有Boss的工厂类，同样实现工厂方法接口，请分别参看代码清单4-10和代码清单4-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238986.png" alt="image-20231016223805959"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238801.png" alt="image-20231016223813758"></p>
<p>这里要注意代码清单4-11，因为Boss出现的坐标总是处于屏幕的中央位置，所以关底Boss工厂类BossFactory在初始化时在第6行设置Boss对象的横坐标为屏幕宽度的一半，而不是随机生成横坐标。“万事俱备，只欠东风”，客户端开始运行游戏了，请参看代码清单4-12。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162239089.png" alt="image-20231016223917040"></p>
<p>如代码清单4-12所示，我们在第9行的循环体中调用坦克工厂类生成敌人，结果制造出的产品肯定是5辆坦克，接着又在第12行将工厂接口替换为飞机工厂类，结果5架飞机出现在屏幕上。抵达关底后，在第18行我们又将工厂接口替换为关底Boss工厂类，结果关底Boss出现并与玩家进行战斗，具体结果如第22行开始的输出所示。显而易见，多态化后的工厂多样性不言而喻，每个工厂的生产策略或方式都具备自己的产品特色，不同的产品需求都能找到相应的工厂来满足，即便没有，我们也可以添加新工厂来解决，以确保游戏系统具有良好的兼容性和可扩展性。</p>
<h3 id="4-5-劳动分工"><a href="#4-5-劳动分工" class="headerlink" title="4.5 劳动分工"></a>4.5 劳动分工</h3><p>至此，以工厂方法模式构建的空战游戏就完成了，之后若要加入新的敌人类，只需添加相应的工厂类，无须再对现有代码做任何更改。不同于简单工厂，工厂方法模式可以被看作由简单工厂演化而来的高级版，后者才是真正的设计模式。在工厂方法模式中，不仅产品需要分类，工厂同样需要分类，与其把所有生产方式堆积在一个简单工厂类中，不如把生产方式放在具体的子类工厂中去实现，这样做对工厂的抽象化与多态化有诸多好处，避免了由于新加入产品类而反复修改同一个工厂类所带来的困扰，使后期的代码维护以及扩展更加直观、方便。下面我们来看工厂方法模式的类结构，如图4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162249478.png" alt="image-20231016224949418"></p>
<p>工厂方法模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Product（产品）：所有产品的顶级父类，可以是抽象类或者接口。对应本章例程中的敌人抽象类。</span><br><span class="line">■ ConcreteProduct（子产品）：由产品类Product派生出的产品子类，可以有多个产品子类。对应本章例程中的飞机类、坦克类以及关底Boss类。</span><br><span class="line">■ Factory（工厂接口）：定义工厂方法的工厂接口，当然也可以是抽象类，它使顶级工厂制造方法抽象化、标准统一化。</span><br><span class="line">■ ConcreteFactory（工厂实现）：实现了工厂接口的工厂实现类，并决定工厂方法中具体返回哪种产品子类的实例。</span><br></pre></td></tr></table></figure>
<p>工厂方法模式不但能将客户端与敌人的实例化过程彻底解耦，抽象化、多态化后的工厂还能让我们更自由灵活地制造出独特而多样的产品。其实工厂不必万能，方便面工厂不必生产汽车，手机工厂也不必生产牛仔裤，否则就会通而不精，妄想兼备所有产品线的工厂并不是好的工厂。反之，每个工厂都应围绕各自的产品进行生产，专注于自己的产品开发，沿用这种分工明确的工厂模式才能使各产业变得越来越专业化，而不至于造成代码逻辑泛滥，从而降低产出效率。正所谓“闻道有先后，术业有专攻”，正如英国经济学家亚当·斯密提出的劳动分工理论一样，如图4-4所示，明确合理的劳动分工才能真正地促进生产效率的提升。</p>
<h2 id="第5章-抽象工厂"><a href="#第5章-抽象工厂" class="headerlink" title="第5章　抽象工厂"></a>第5章　抽象工厂</h2><p>抽象工厂模式(Abstract Factory)是对工厂的抽象化，而不只是制造方法。我们知道，为了满足不同用户对产品的多样化需求，工厂不会只局限于生产一类产品，但是系统如果按工厂方法那样为每种产品都增加一个新工厂又会造成工厂泛滥。所以，为了调和这种矛盾，抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。抽象工厂是建立在制造复杂产品体系需求基础之上的一种设计模式，在某种意义上，我们可以<strong>将抽象工厂模式理解为工厂方法模式的高度集群化升级版</strong>，所以建议读者先充分理解上一章的内容再来阅读本章。</p>
<h3 id="5-1-品牌与系列"><a href="#5-1-品牌与系列" class="headerlink" title="5.1 品牌与系列"></a>5.1 品牌与系列</h3><p>我们都知道，在工厂方法模式中每个实际的工厂只定义了一个工厂方法。而随着经济发展，人们对产品的需求不断升级，并逐渐走向个性化、多元化，制造业也随之发展壮大起来，各类工厂遍地开花，能够制造的产品种类也丰富了起来，随之而来的弊端就是工厂泛滥。</p>
<p>针对这种情况，我们就需要进行产业规划与整合，对现有工厂进行重构。例如，我们可以基于产品品牌与系列进行生产线规划，按品牌划分A工厂与B工厂。具体以汽车工厂举例，A品牌汽车有轿车、越野车、跑车3个系列的产品，同样地，B品牌汽车也包括以上3个系列的产品，如此便形成了两个产品族，分别由A工厂和B工厂负责生产，每个工厂都有3条生产线，分别生产这3个系列的汽车，如图5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162253113.png" alt="image-20231016225358036"></p>
<p>基于这2个品牌汽车工厂的系列生产线，如果今后产生新的C品牌汽车、D品牌汽车等，都可以沿用此种规划好的生产模式，这便是抽象工厂模式的基础数据模型。</p>
<h3 id="5-2-产品规划"><a href="#5-2-产品规划" class="headerlink" title="5.2 产品规划"></a>5.2 产品规划</h3><p>无论哪种工厂模式，都一定是基于特定的产品特性发展而来的，所以我们首先得从产品建模切入。假设某公司要开发一款星际战争游戏，战争设定在太阳系文明与异星系文明之间展开，游戏兵种就可以分为人类与外星怪兽2个族，游戏画面如图5-2所示。</p>
<p>如图5-2所示，游戏战争场面相当激烈，人类拥有各种军工高科技装备，而外星怪兽则靠血肉之躯与人类战斗，所以这两族的兵种必然有着巨大的差异，这就意味着各兵种首先应该按族划分。此外，从另一个角度来看，它们又有相同之处，2个族的兵种都可以被简单归纳为初级（1级）、中级（2级）、高级（3级）3个等级，如同之前对汽车品牌系列的规划一样，各族兵种也应当按等级划分，最终我们可以得到一个对所有兵种分类归纳的表格，如图5-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162255252.png" alt="image-20231016225545193"></p>
<p>如图5-3所示，兵种规划表格以列划分等级，以行划分族，一目了然，我们可以据此建立数据模型。首先，我们来定义一个所有兵种的顶层父类兵种，这里我们使用抽象类，以达到属性继承给子类的目的，请参看代码清单5-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257378.png" alt="image-20231016225701343"></p>
<p>如代码清单5-1所示，任何兵种都具有攻击力、防御力、生命力、坐标方位等属性，从第3行开始我们对以上属性依次定义。除此之外，第17行的展示show()（绘制到图上）与第19行的攻击attack()这两个抽象方法交由子类实现。接下来我们将兵种按等级分类，假设同一等级的攻击力、防御力等属性值是相同的，所以初级、中级、高级兵种会分别对应3个等级的兵种类，请参看代码清单5-2、代码清单5-3、代码清单5-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257782.png" alt="image-20231016225757744"></p>
<p>如代码清单5-2、代码清单5-3、代码清单5-4所示，各等级兵种类都继承自兵种抽象类Unit，它们对应的攻击力、防御力及生命力也各不相同，等级越高，其属性值也越高（当然制造成本也会更高，本例我们不考虑价格属性）。接下来我们来定义具体的兵种类，首先是人类兵种的海军陆战队员、变形坦克和巨型战舰，分别对应初级、中级、高级兵种，请参看代码清单5-5、代码清单5-6、代码清单5-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259295.png" alt="image-20231016225916264"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259805.png" alt="image-20231016225922771"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259222.png" alt="image-20231016225929170"></p>
<p>如代码清单5-5、代码清单5-6、代码清单5-7所示，我们在第3行的构造方法中调用了父类，并初始化了坐标属性，其攻击力、防御力和生命力已经在对应等级的父类里初始化好了。此外，在代码第8行与第13行我们分别重写了各兵种的展示方法和攻击方法，进行行为差异化，比如坦克可以变形增加攻击力与射程，再比如战舰攻击地面目标时用激光炮，而攻击空中目标的切换至导弹等，本例我们不做过多延伸，读者可自行实现。同样，外星怪兽族对应的初级、中级、高级兵种分别为蟑螂、毒液、猛犸，请参看代码清单5-8、代码清单5-9、代码清单5-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300063.png" alt="image-20231016230041021"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300205.png" alt="image-20231016230048164"></p>
<p>至此，所有兵种类已定义完毕，代码不是难点，重点集中在对兵种的划分上，横向划分族，纵向划分等级（系列），利用类的抽象与继承描绘出所有的游戏角色以及它们之间的关系，同时避免了不少重复代码。</p>
<h3 id="5-3-生产线规划"><a href="#5-3-生产线规划" class="headerlink" title="5.3 生产线规划"></a>5.3 生产线规划</h3><p>既然产品类的数据模型构建完成，相应的产品生产线也应该建立起来，接下来我们就可以定义这些产品的制造工厂了。我们一共定义了6个兵种产品，那么每个产品都需要对应一个工厂类吗？答案是否定的。本着人类靠科技、怪兽靠繁育的游戏理念，人类兵工厂自然是高度工业化的，而怪兽的生产一定靠的是母巢繁殖，所以应该将工厂分为2个族，并且每个族工厂都应该拥有3个等级兵种的制造方法。如此规划不但合理，而且避免了工厂类泛滥的问题。那么，首先我们来制定这3个工业制造标准，也就是定义抽象工厂接口，请参看代码清单5-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162303735.png" alt="image-20231016230330685"></p>
<p>在代码清单5-11中，抽象兵工厂接口定义了3个等级兵种的制造标准，这意味着子类工厂必须具备初级、中级、高级兵种的生产能力（类似一个品牌的不同系列生产线）。理解了这一点后，我们就可以定义人类兵工厂与外星母巢的工厂类实现了，请参看代码清单5-12、代码清单5-13。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162305126.png" alt="image-20231016230551092"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162306521.png" alt="image-20231016230611485"></p>
<p>如代码清单5-12、代码清单5-13所示，人类兵工厂与外星母巢分别实现了3个等级兵种的制造方法，其中前者由低到高分别返回海军陆战队员、变形坦克以及巨型战舰对象，后者则分别返回蟑螂兵、毒液兵以及猛犸巨兽对象，生产线规划非常清晰。好了，所有兵种与工厂准备完毕，我们可以用客户端开始模拟游戏了，请参看代码清单5-14。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162307391.png" alt="image-20231016230713358"></p>
<p>如代码清单5-14所示，第一位玩家选择了人类族，在第9行用抽象兵工厂接口引用了人类兵工厂实现，接着调用3个等级的制造方法分别得到人类族的对应兵种。接着第二位玩家选择了外星怪兽族，这时将抽象兵工厂接口引用替换为外星母巢实现，此时制造出的兵种变为3个等级的外星怪兽族兵种。最后大混战开始了，调用每个兵种的攻击方法会展示出不同的结果。第42行开始的输出证明所有兵种均制造成功，抽象工厂模式得以发挥作用。此时，如果玩家需要一个新族加入，我们可以在此模式之上去实现一个新的族工厂并实现3个等级的制造方法，工厂一经替换即可产出各系列产品兵种，且无须改动现有代码，良好的可扩展性一览无遗，这就是一套拥有完备生产模式的标准化工业系统所带来的好处。</p>
<h3 id="5-4-分而治之"><a href="#5-4-分而治之" class="headerlink" title="5.4 分而治之"></a>5.4 分而治之</h3><p>至此，抽象工厂制造模式已经布局完成，各工厂可以随时大规模投入生产活动了。当然，我们还可以进一步，再加一个“制造工厂的工厂”来决定具体让哪个工厂投入生产活动。此时客户端就无须关心工厂的实例化过程了，直接使用产品就可以了，至于产品属于哪个族也已经无关紧要，这也是抽象工厂可以被视为“工厂的工厂”的原因，读者可以自行实践代码。</p>
<p>与工厂方法模式不同，抽象工厂模式能够应对更加复杂的产品族系，它更类似于一种对“工业制造标准”的制定与推行，各工厂实现都遵循此标准来进行生产活动，以工厂类划分产品族，以制造方法划分产品系列，达到无限扩展产品的目的。最后我们来看抽象工厂模式的类结构，如图5-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162310425.png" alt="image-20231016231020349"></p>
<p>抽象工厂模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">■ AbstractProduct1、AbstractProduct2（抽象产品1、抽象产品2）：产品系列的抽象类，图中一系产品与二系产品分别代表同一产品族的多个产品系列，对应本章例程中的初级、中级、高级兵种抽象类。</span><br><span class="line">■ ProductA1、ProductB1、ProductA2、ProductB2（产品A1、产品B1、产品A2、产品B2）：继承自抽象产品的产品实体类，其中ProductA1与ProductB1代表A族产品与B族产品的同一产品系列，类似于本章例程中人类族与外星怪兽族的初级兵种，之后的产品实体类以此类推。</span><br><span class="line">■ AbstractFactory（抽象工厂接口）：各族工厂的高层抽象，可以是接口或者抽象类。抽象工厂对各产品系列的制造标准进行规范化定义，但具体返回哪个族的产品由具体族工厂决定，它并不关心。</span><br><span class="line">■ ConcreteFactoryA、ConcreteFactoryB（工厂A实现、工厂B实现）：继承自抽象工厂的各族工厂，需实现抽象工厂所定义的产品系列制造方法，可以扩展多个工厂实现。对应本章例程中的人类兵工厂与外星母巢。</span><br><span class="line">■ Client（客户端）：产品的使用者，只关心制造出的产品系列，具体是哪个产品族由工厂决定。</span><br></pre></td></tr></table></figure>
<p>产品虽然繁多，但总有品牌、系列之分。基于此抽象工厂模式以品牌与系列进行全局规划，将看似杂乱无章的产品规划至不同的族系，再通过抽象工厂管理起来，分而治之，合纵连横。需要注意的是，抽象工厂模式一定是基于产品的族系划分来布局的，其产品系列一定是相对固定的，故以抽象工厂来确立工业制造标准（各产品系列生产接口）。而产品族则可以相对灵活多变，如此一来，我们就可以方便地扩展与替换族工厂，以达到灵活产出各类产品族系的目的。</p>
<h2 id="第6章-建造者"><a href="#第6章-建造者" class="headerlink" title="第6章　建造者"></a>第6章　建造者</h2><p>建造者模式(Builder)所构建的对象一定是庞大而复杂的，并且一定是按照既定的制造工序将组件组装起来的，例如计算机、汽车、建筑物等。我们通常将负责构建这些大型对象的工程师称为建造者。建造者模式又称为生成器模式，主要用于对复杂对象的构建、初始化，它可以将多个简单的组件对象按顺序一步步组装起来，最终构建成一个复杂的成品对象。与工厂系列模式不同的是，建造者模式的主要目的在于把烦琐的构建过程从不同对象中抽离出来，使其脱离并独立于产品类与工厂类，最终实现用<strong>同一套标准的制造工序</strong>能够产出不同的产品。</p>
<h3 id="6-1-建造步骤的重要性"><a href="#6-1-建造步骤的重要性" class="headerlink" title="6.1 建造步骤的重要性"></a>6.1 建造步骤的重要性</h3><p>在开始实战之前我们首先得搞清楚建造者面对着什么样的产品模型。以典型的角色扮演类网络游戏为例，在开始游戏之前玩家通常可以选择不同的角色。为了让人物鲜活起来，不同的游戏角色应该有其独特的产品特性，如图6-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171043798.png" alt="image-20231017104346616"></p>
<p>玩家选定角色后需要对其进行初始化，假设整个过程分3个步骤完成。第一步，玩家需要为角色选择形象以及分配力量、灵力、体力、敏捷等属性值，这也是游戏人设中最为重要的一个环节；第二步，玩家可以为角色配备不同的衣服或铠甲，低于所需力量值的铠甲则不能穿戴；第三步，玩家选择手持的武器与盾牌，它同上一步一样需要满足一定的条件。显然，每个角色都是按照这个流程完成初始化的，否则游戏就无法进行下去，例如如果在没有分配角色属性值的前提下就先进行武器选择，那么缺乏力量的角色根本无法配备任何装备或者武器；如果让缺少灵力的战士戴上魔法帽或是让力量弱小的法师手持重型武器，就会导致游戏角色出现不可预知的混乱，如图6-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171045082.png" alt="image-20231017104539034"></p>
<p>成型的游戏角色是依靠角色对象、装备对象组装而成的，对于这种复杂对象的构建一定要依赖建造者来完成。除此以外，若要避免图6-2所示的混乱情况的发生，建造者的制造过程不仅要分步完成，还要按照顺序进行，所以建造者的各制造步骤与逻辑都应该被抽离出来独立于数据模型，复杂的游戏角色设定还需交给专业的建造团队去完成。</p>
<h3 id="6-2-地产开发商的困惑"><a href="#6-2-地产开发商的困惑" class="headerlink" title="6.2 地产开发商的困惑"></a>6.2 地产开发商的困惑</h3><p>秉承我们一贯奉行的简单直观的宗旨，既然是建造者，我们就以建筑物建造为例来进行代码实战。盖房子可不能开玩笑，为了保证质量，我们绝不能允许豆腐渣工程出现，所以严谨的设计与施工流程的把控是不可或缺的，否则可能会房倒屋塌、家毁人亡。首先，建筑物本身应该由多个组件组成，且各组件按一定工序建造，缺一不可，如图6-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171047095.png" alt="image-20231017104700045"></p>
<p>如图6-3所示，建筑物的组件建造是相当复杂的，为了简化其数据模型，我们将组成建筑物的模块归纳为3个组件，分别是地基、墙体、屋顶，将它们组装起来就能形成一座建筑物，请参看代码清单6-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171047844.png" alt="image-20231017104739799"></p>
<p>如代码清单6-1所示，为了模拟建筑物类中各组件的建造工序，我们在第4行以List承载各组件，模拟复杂对象中各组件的顺序组装。接着在第6行、第10行、第14行分别定义各组件对应的建造方法（set方法），其中可以看到我们用字符串对象String来模拟各个组件对象。最后在第19行，为了直观地看到建筑物的建造情况，我们重写了toString()方法，按从大到小的组件索引顺序组装各组件，后组装的组件应先展示出来，如屋顶应该首先输出，以此类推。</p>
<p>这个建筑物类的内部构造看起来稍微有点复杂（实际应用中会更复杂），怎样才能用这个复杂的类构建出一个房子对象呢？首先应该调用哪个建造方法才能保证正确的建造工序，而不至于屋顶在下面，地基却跑到天上去呢？地基、墙体、屋顶，这些组件都去哪里找，如何建造？地产开发商（客户端）感到十分困惑，一头雾水。</p>
<h3 id="6-3-建筑施工方"><a href="#6-3-建筑施工方" class="headerlink" title="6.3 建筑施工方"></a>6.3 建筑施工方</h3><p>组建专业的建筑施工团队对建筑工程项目的实施至关重要，于是地产开发商决定通过招标的方式来选择施工方。招标大会上有很多建筑公司来投标，他们各有各的房屋建造资质，有的能建别墅，有的能建多层公寓，还有能力更强的能建摩天大楼，建造工艺也各有区别。但无论如何，开发商规定施工方都应该至少具备三大组件的建造能力，于是施工标准公布出来了，请参看代码清单6-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171050073.png" alt="image-20231017105032039"></p>
<p>如代码清单6-2所示，施工方接口规定了3个施工标准，它们分别对应建造地基、建造墙体以及建造屋顶，另外，第9行还定义了一个获取建筑物的接口getBuilding()，以供产品的交付。接着，开发商按此标准启动了招标工作，一个别墅施工方中标，请参看代码清单6-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171051946.png" alt="image-20231017105109903"></p>
<p>如代码清单6-3所示，这个别墅施工方看起来具备很高的施工水平，对别墅的建造工艺看起来十分考究。不管是建造地基（第10行）、建造墙体（第16行），还是建造屋顶（第22行），别墅施工方都能做到，完全符合开发商公布的施工标准。接下来开发商又考察了一个多层公寓施工方，请参看代码清单6-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171053028.png" alt="image-20231017105302974"></p>
<p>如代码清单6-4所示，多层公寓施工方成功中标，它同别墅施工方一样符合开发商公布的施工标准，但施工方法实现上大相径庭，例如第10行建造地基方法实现buildBasement()中地基挖得比较扎实，以及第16行建造墙体方法buildWall()中进行的迭代施工，这里建造的应该是一梯四户（4个窗户）的8层（循环8次）公寓楼，其建造工艺与别墅施工方有很大不同。</p>
<h3 id="6-4-工程总监"><a href="#6-4-工程总监" class="headerlink" title="6.4 工程总监"></a>6.4 工程总监</h3><p>虽然施工方很好地保证了建筑物三大组件的施工质量，但开发商还是不放心，因为施工方毕竟只负责干活，施工流程无法得到控制。为了解决这个问题，开发商又招聘了一个专业的工程总监来做监理工作，他亲临施工现场指导施工，并把控整个施工流程，请参看代码清单6-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171054487.png" alt="image-20231017105436454"></p>
<p>如代码清单6-5所示，工程总监的角色就像电影制作中的导演一样，他从宏观上管理项目并指导整个施工队的建造流程。在代码第13行的指导方法中，我们依次调用施工方的打地基方法buildBasement()、建造墙体方法buildWall()及建筑物封顶方法buildRoof()，保证了建筑物自下而上的建造工序。可以看到，施工方是在第9行由外部注入的，所以工程总监并不关心是哪个施工方来造房子，更不关心施工方有什么样的建造工艺，但他能保证对施工工序的绝对把控，也就是说，工程总监只控制施工流程。</p>
<h3 id="6-5-项目实施"><a href="#6-5-项目实施" class="headerlink" title="6.5 项目实施"></a>6.5 项目实施</h3><p>至此招标工作结束，一切准备就绪，所有项目干系人（施工方、工程总监）都已就位，可以开始组建项目团队并启动项目了。我们来看开发商如何拿到产品，请参看代码清单6-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171055855.png" alt="image-20231017105548810"></p>
<p>如代码清单6-6所示，开发商首先在第5行组建了别墅施工队并安排给工程总监进行管理，之后调用其指导方法拿到别墅产品。接着开发商在第9行将工程总监管理的施工队替换为多层公寓施工方，最终拿到一栋八层公寓，运行结果如图6-4所示。</p>
<h3 id="6-6-工艺与工序"><a href="#6-6-工艺与工序" class="headerlink" title="6.6 工艺与工序"></a>6.6 工艺与工序</h3><p>项目团队将建筑物产品交付给开发商，项目终于顺利竣工。施工方接口对施工标准的抽象化、标准化使建造者（施工方）的建造质量达到既定要求，且使各建造者的建造“工艺”能够个性化、多态化。此外，工程总监将工作流程抽离出来独立于建造者，使建造“工序”得到统一把控。最终，各种建筑产品都得到了业主的认可，成功离不开团队的共同协作与努力，请参看建造者模式的类结构，如图6-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171057109.png" alt="image-20231017105741061"></p>
<p>建造者模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Product（产品）：复杂的产品类，构建过程相对复杂，需要其他组件组装而成。对应本章例程中的建筑物类。</span><br><span class="line">■ Builder（建造者）：建造者接口，定义了构成产品的各个组件的构建标准，通常有多个步骤。对应本章例程中的施工方接口。</span><br><span class="line">■ ConcreteBuilder（建造者实现）：具体的建造者实现类，可以有多种实现，负责产品的组装但不包含整体建造逻辑。对应本章例程中的别墅施工方类与多层公寓施工方类。</span><br><span class="line">■ Director（指导者）：持有建造者接口引用的指导者类，指导建造者按一定的逻辑进行建造。对应本章例程中的工程总监类。</span><br></pre></td></tr></table></figure>
<p>复杂对象的构建显然需要专业的建造团队，建造标准的确立让产品趋向多样化，其建造工艺可以交给多位建造者去各显其长，而建造工序则交由工程总监去全局把控，把“变”与“不变”分开，使“工艺多样化”“工序标准化”，最终实现通过相同的构建过程生产出不同产品，这也是建造者模式要达成的目标。</p>
<h1 id="结构篇"><a href="#结构篇" class="headerlink" title="结构篇"></a>结构篇</h1><h2 id="第7章-门面"><a href="#第7章-门面" class="headerlink" title="第7章　门面"></a>第7章　门面</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310171102627.png" alt="image-20231017110243576"></p>
<p>门面模式(Facade)可能是最简单的结构型设计模式，它能将多个不同的子系统接口封装起来，并对外提供统一的高层接口，使复杂的子系统变得更易使用。顾名思义，“门”可以理解为建筑物的入口，而“面”则通常指物体的外层表面，比如人脸，如图7-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171103307.png" alt="image-20231017110315250"></p>
<p>无论是“门”还是“面”，指代的都是某系统的外观部分，也就是与外界接触的临界面或接口，所以门面模式常常也被翻译为“外观模式”。利用门面模式，我们可以把多个子系统“关”在门里面隐藏起来，成为一个整合在一起的大系统，来自外部的访问只需通过这道“门面”（接口）来进行，而不必再关心门面背后隐藏的子系统及其如何运转。总之，无论门面内部如何错综复杂，从门面外部看来总是一目了然，使用起来也很简单。</p>
<h3 id="7-1-一键操作"><a href="#7-1-一键操作" class="headerlink" title="7.1 一键操作"></a>7.1 一键操作</h3><p>为了更形象地理解门面模式，我们先来看一个例子。早期的相机使用起来是非常麻烦的，拍照前总是要根据场景情况进行一系列复杂的操作，如对焦、调节闪光灯、调光圈等，非专业人士面对这么一大堆的操作按钮根本无从下手，拍出来的照片质量也不高。随着科技的进步，出现了一种相机，叫作“傻瓜相机”，以形容其使用起来的方便性。用户再也不必学习那些复杂的参数调节了，只要按下快门键就可完成所有操作，如图7-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171104983.png" alt="image-20231017110411937"></p>
<p>显然图7-2右侧的“傻瓜相机”使用起来方便得多。它对庞大复杂的子系统进行了二次封装，把原本复杂的操作接口全都隐藏起来，并在内部加入逻辑使各参数在拍照前进行自动调节，最终只为外界提供一个简单方便的快门按键，让用户能够“一键操作”。如此不但可以防止非专业用户的各种误操作，而且大大提高了用户的拍照效率。在我们的生活中还有很多这样的例子，如自动挡汽车对离合及换挡操作的封装，再如全自动洗衣机对浸泡、漂洗、甩干、排水等一系列操作的封装，像这种“一键操作”式的设计都与门面模式的理念如出一辙。</p>
<h3 id="7-2-亲自下厨的烦扰"><a href="#7-2-亲自下厨的烦扰" class="headerlink" title="7.2 亲自下厨的烦扰"></a>7.2 亲自下厨的烦扰</h3><p>既然我们讲的是门面模式，那么以“商铺门面”的例子进行代码实战最贴切不过了。对很多人来说，做饭这件事情可能并不简单，所以往往会选择下馆子或者吃泡面，如果要亲自下厨的话就免不了一番折腾。我们首先得买菜、洗菜、切菜，然后进行蒸、煮、炒、炸等烹饪过程，最后还得收拾残局，清理碗筷。假设某天小明决定亲自下厨，但因不会做菜所以请妹妹帮忙。我们将步骤简化为以下3步，首先小明找菜贩买菜，然后找妹妹做菜，最后亲自洗碗，具体步骤如图7-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106750.png" alt="image-20231017110601668"></p>
<p>计划实施起来应该不难，我们开始代码实战。首先我们定义蔬菜商类完成第1步，然后让妹妹作为厨房小能手类完成第2步，最后小明作为客户端类进行全局操控并完成第3步，请参看代码清单7-1、代码清单7-2和代码清单7-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106926.png" alt="image-20231017110643882"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171106597.png" alt="image-20231017110652563"></p>
<p>如代码清单7-1和代码清单7-2所示，蔬菜商类定义供应蔬菜方法，厨房小能手类则定义下厨烹饪方法，代码没有任何难度。我们主要来看代码清单7-3，小明从第13行依次找蔬菜商买菜，再找妹妹下厨，用完餐后小明洗碗收工。代码看起来虽不复杂，但这一顿饭下来够累人的，不但惊扰四方，还要自己亲自擦桌洗碗，但无论换作谁都要经历这一番操作。如果烹饪方法再复杂一些，再加上客户端对各子系统的操作不当，说不定一顿丰盛的大餐会成为黑暗料理.</p>
<p>期盼是美好的，可现实总是残酷的，一系列复杂的操作过程并不像我们想象的那么简单。小明开始意识到，任何事都亲力亲为的做法可能并不合适，难道其他用户也要像小明一样瞻前顾后、折腾一番？这显然会造成代码冗余。专业的事情还是应该交给专业的人去完成，他们会把这些子系统的操作过程封装起来，再以更为便捷的方式提供给用户使用。</p>
<h3 id="7-3-化繁为简"><a href="#7-3-化繁为简" class="headerlink" title="7.3 化繁为简"></a>7.3 化繁为简</h3><p>在一些商业街区，门面商铺总是聚集在人流量大的地方，而且门头上霓虹闪烁、招牌醒目，访问的便利性使顾客更加愿意购买这些商铺所提供的产品与服务，这也是一个好的门面总能够招揽更多顾客的原因。以餐饮商铺为例，如图7-5所示，为了享受可口的饭菜与优质的服务，小明决定直接访问这家临街门店。</p>
<p>为了达到高效、便捷的目的，门店会统一对子系统进行整合与调度，至于它对蔬菜商、厨师或服务员等子系统是如何操作的，用户都不必了解。下面我们对代码进行改造，创建外观门面类，请参考代码清单7-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171110658.png" alt="image-20231017111005618"></p>
<p>如代码清单7-4所示，外观门面类内部封装了大量的子系统资源，如蔬菜商、厨师、服务员、洗碗工，并于第8行的构造方法中依次对各个子系统进行了初始化操作，也就是说餐厅在开门前需要提前准备好这些资源，以便在第20行的点菜方法order()中进行依次调度。</p>
<p>需要注意的是，我们对外观门面类进行了一定的代码简化，在实际场景中可能还会包含一些更加复杂的逻辑，这也是餐饮门店要对子系统及其调度进行封装的原因，化繁为简的一站式服务才能解放用户的双手。至此，小明再也不必每日为解决吃饭问题而苦恼了，用户要做的只是登门访问，调用其order()方法即可享受现成可口的饭菜了，操作变得简单而优雅。</p>
<h3 id="7-4-整合共享"><a href="#7-4-整合共享" class="headerlink" title="7.4 整合共享"></a>7.4 整合共享</h3><p>门面模式不但重要，而且其应用也非常广泛，如在软件项目中，我们做多表数据更新时，业务逻辑层（Service层）对数据访问层（DAO层）的调用可能包含多个步骤，除此之外还要进行事务处理，最终统一对外提供一个update()方法，如此一来上层（如控制器Controller层）便可一步调用。软件模块应该只专注于各自擅长的领域，合理明确的分工模式才能更好地整合与共享资源。这正是门面模式所解决的问题，其中外观门面类对子系统的整合与共享极大地保证了用户访问的便利性，作为核心模块，其重要性不言而喻，请参看门面模式的类结构，如图7-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171112723.png" alt="image-20231017111205682"></p>
<p>门面模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Facade（外观门面）：封装了多个子系统，并将它们整合起来对外提供统一的访问接口。</span><br><span class="line">■ SubSystemA、SubSystemB、SubSystemC（子系统A、子系统B、子系统C）：隐藏于门面中的子系统，数量任意，且对外部不可见。对应本章例程中的蔬菜商类、厨师类、服务员类等。</span><br><span class="line">■ Client（客户端）：门面系统的使用方，只访问门面提供的接口。</span><br></pre></td></tr></table></figure>
<p>对客户端这种“门外汉”来说，直接使用子系统是复杂而烦琐的，门面则充当了包装类的角色，对子系统进行整合，再对外暴露统一接口，使其结构内繁外简，最终达到资源共享、简化操作的目的。从另一方面讲，门面模式也降低了客户端与子系统之间的依赖度，高内聚才能低耦合。</p>
<h2 id="第8章-组合"><a href="#第8章-组合" class="headerlink" title="第8章　组合"></a>第8章　组合</h2><p>组合模式(Composite)是针对由多个节点对象（部分）组成的树形结构的对象（整体）而发展出的一种结构型设计模式，它能够使客户端在操作整体对象或者其下的每个节点对象时做出统一的响应，保证树形结构对象使用方法的一致性，使客户端不必关注对象的整体或部分，最终达到对象复杂的层次结构与客户端解耦的目的。</p>
<h3 id="8-1-叉树结构"><a href="#8-1-叉树结构" class="headerlink" title="8.1 叉树结构"></a>8.1 叉树结构</h3><p>在现实世界中，某些具有从属关系的事物之间存在着一定的相似性。大家一定见过蕨类植物的叶子吧。如图8-1所示，从宏观上看，这只是一片普通的叶子，当继续观察其中一个分支的时候，我们会发现这个分支其实又是一片全新的叶子，当我们再继续观察这片新叶子的一个分支的时候，又会得到相同的结果。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172112385.png" alt="image-20231017211248219"></p>
<p>因此，我们可以得出结论，不管从哪个层级观察这片叶子，我们都会得到一个固定的结构，这意味着组成植物叶子的部分或整体都有着相同的生长方式，这正是孢子植物的DNA特征。大自然中存在的这种奇妙的结构在人类文明中同样有大量应用，例如文字就具有类似的结构，如图8-2所示，字可以组成词，词组成句子，句子再组成段落、章节……直至最终成书。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172113278.png" alt="image-20231017211304230"></p>
<p>这种结构类似于经典的“叉树”结构。以最简单的“二叉树”为例，此结构始于其开端的“根”节点，往下分出来两个“枝”节点（左右2个节点），接着每个枝节点又可以继续“分枝”，直至其末端的“叶”节点为止，具体结构请参看图8-3。</p>
<p>不管是二叉树还是多叉树，道理都是一样的。无论数据元素是“根”“枝”，还是“叶”，甚至是整体的树，都具有类似的结构。具体来讲，除了叶节点没有子节点，其他节点都具有本级对象包含多个次级子对象的结构特征。所以，我们完全没有必要为每个节点对象定义不同的类（如为字、词、句、段、节、章……等每个节点都定义一个类），否则会造成代码冗余。我们可以用组合模式来表达“部分/整体”的层次结构，提取并抽象其相同的部分，特殊化其不同的部分，以提高系统的可复用性与可扩展性，最终达到以不变应万变的目的。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172113351.png" alt="image-20231017211359310"></p>
<h3 id="8-2-文件系统"><a href="#8-2-文件系统" class="headerlink" title="8.2 文件系统"></a>8.2 文件系统</h3><p>通过对叉树结构的观察，我们发现，无论拿出哪一个“部分”，其与“整体”的结构都是类似的，所以首先我们需要模糊根、枝、叶之间的差异，以实现节点的统一。下面开始代码实战部分，我们就以类似于树结构的文件系统的目录结构为例，如图8-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172114145.png" alt="image-20231017211428084"></p>
<p>文件系统从根目录“C:”开始分支，其下级可以包含“文件夹”或者“文件”，其中文件夹属于“枝”节点，其下级可以继续存放子文件夹或文件，而文件则属于“叶”节点，其下级不再有任何子节点。基于此前的分析，我们可以定义一个抽象的“节点”类来模糊“文件夹”与“文件”，请参看代码清单8-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172115159.png" alt="image-20231017211504116"></p>
<p>如代码清单8-1所示，文件夹或文件都有一个名字，所以在第4行的构造方法中接收并初始化在第2行已定义的节点名，否则不允许节点被创建，这也是可以固化下来的逻辑。对于如何实现代码第9行中的添加子节点方法add(Node child)暂时还不能确定，所以我们声明其为抽象方法，模糊此行为并留给子类去实现。需要注意的是，对于抽象节点类Node的抽象方法其实还可以更加丰富，例如“删除节点”“获取节点”等，这里为了简化代码只声明了“添加节点”方法。下面我们就来实现文件夹类，此类肩负着确立树形结构的重任，这也是组合模式数据结构的精髓所在，请参看代码清单8-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172116893.png" alt="image-20231017211614858"></p>
<p>如代码清单8-2所示，首先，文件夹类继承了抽象节点类Node，并在第3行定义了一个次级节点列表List\<Node>，此处的泛型Node既可以是文件夹又可以是文件，也就是说，文件夹下级可以包含任意多个文件夹或者文件。然后，代码第5行中的构造方法直接调用父类的构造方法，以初始化其文件夹名。最后，在第10行实现了添加子节点方法add(Node child)，将传入的子节点添加至次级节点列表List\<Node>中。对于“叶”节点文件类，其作为末端节点，不应该具备添加子节点的功能，我们来看如何定义文件类，请参看代码清单8-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172118760.png" alt="image-20231017211829729"></p>
<p>如代码清单8-3所示，除了第8行的添加子节点方法add(Node child)，文件类与文件夹类的代码大同小异。如之前提到的，文件属于“叶”节点，不能再将这种结构延续下去，所以我们在第9行输出一个错误消息，告知用户“不能添加子节点”。其实更好的方式是以抛出异常的形式来确保此处逻辑的正确性，外部如果捕获到该异常则可以做出相应的处理，读者可以自行实践。一切就绪，用户就可以构建目录树了。我们来看客户端类怎样添加节点，请参看代码清单8-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172119550.png" alt="image-20231017211922506"></p>
<p>如代码清单8-4所示，正如我们规划文件时常做的操作，第3行中用户以“D盘”文件夹作为根节点构建了目录树，接着从第5行开始创建了“文档”和“音乐”两个文件夹作为“枝”节点，再将相应类型的文件分别置于相应的目录下，其中对音乐文件多加了一级文件夹来区分歌手，以便日后分类管理、查找。如此一来，只要能持有根节点对象“D盘”，就能延伸出整个目录。</p>
<h3 id="8-3-目录树展示"><a href="#8-3-目录树展示" class="headerlink" title="8.3 目录树展示"></a>8.3 目录树展示</h3><p>目录树虽已构建完成，但要体现出组合模式的优势还在于如何运用这个树结构。假如用户现在要查看当前根目录下的所有子目录及文件，这就需要分级展示整棵目录树，正如Windows系统的“tree”命令所实现的，如图8-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172122218.png" alt="image-20231017212221174"></p>
<p>要模拟这种树形展示方式，我们就得在输出节点名称（文件夹名/文件名）之前加上数个空格以表示不同层级，但具体加几个空格还是个未知数，需要根据具体的节点级别而定。而作为抽象节点类则不应考虑这些细节，而应先把这个未知数作为参数变量传入，我们来修改抽象节点类Node并加入展示方法，请参看代码清单8-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172123226.png" alt="image-20231017212319188"></p>
<p>如代码清单8-5所示，我们在第11行实现了以接收空格数量space为传入参数的展示方法tree(int space)，其中的循环体会输出space个连续的空格，最后再输出节点名称。因为此处是抽象节点类的实体方法，所以要保持其通用性。我们抽离出所有节点“相同”的部分作为“公有”的代码块，而“不同”的行为部分则留给子类去实现。首先来看文件类如何实现，请参看代码清单8-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172124753.png" alt="image-20231017212430721"></p>
<p>如代码清单8-6所示，作为末端节点的文件类只需要输出space个空格再加上自己的名称即可，这里与父类的展示方法tree(int space)应该保持一致，所以我们在第14行直接调用父类的展示方法。其实文件类可以不做任何修改，而是直接继承父类的展示方法，此处是为了让读者更清晰直观地看到这种继承关系，同时方便后续做出其他修改。接下来的文件夹类就比较特殊了，它不仅要先输出自己的名字，还要换行再逐个输出子节点的名字，并且要保证空格逐级递增，请参看代码清单8-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172125060.png" alt="image-20231017212540016"></p>
<p>如代码清单8-7所示，同样，文件夹类也重写并覆盖了父类的tree()方法，并且在第16行调用父类的通用tree()方法输出本文件夹的名字。接下来的逻辑就非常有意思了，对于下一级的子节点我们需要依次输出，但前提是要把当前的空格数加1，如此一来子节点的位置会往右偏移一格，这样才能看起来像树形结构一样错落有致。可以看到，在第19行的循环体中我们直接调用了子节点的展示方法并把“加1”后的空格数传递给它即可完成展示。至于当前文件夹下的子节点到底是“文件夹”还是“文件”，我们完全不必操心，因为子节点们会使用自己的展示逻辑。如果它们还有下一级子节点，则与此处逻辑相同，继续循环，把逐级递增的空格数传递下去，直至抵达叶节点为止——始于“文件夹”而终于“文件”，非常完美的递归逻辑。</p>
<p>最后，客户端在任何一级节点上只要调用其展示方法并传入当前目录所需的空格偏移量，就可出现树形列表了，比如若要紧挨控制台左侧展示，客户端则需要以“0”作为偏移量调用根目录的展示方法tree(0)，输出结果如图8-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172126740.png" alt="image-20231017212651702"></p>
<p>需要注意的是，空格偏移量这个必传参数可能让用户非常困惑，或许我们可以为抽象节点类添加一个无参的展示方法“tree()”，在其内部调用“tree(0)”，如此一来就不再需要用户传入偏移量了，使用起来更加方便。请参看代码清单8-8的抽象节点类在第19行做出的改进。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172127812.png" alt="image-20231017212721751"></p>
<h3 id="8-4-自相似性的涌现"><a href="#8-4-自相似性的涌现" class="headerlink" title="8.4 自相似性的涌现"></a>8.4 自相似性的涌现</h3><p>组合模式将树形结构的特点发挥得淋漓尽致，作为最高层级抽象的抽象节点类（接口）泛化了所有节点类，使任何“整体”或“部分”达成统一，枝（根）节点与叶节点的多态化实现以及组合关系进一步勾勒出的树形结构，最终使用户操作一触即发，由“根”到“枝”再到“叶”，逐级递归，自动生成。我们来看组合模式的类结构，如图8-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172142569.png" alt="image-20231017214225514"></p>
<p>组合模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Component（组件接口）：所有复合节点与叶节点的高层抽象，定义出需要对组件操作的接口标准。对应本章例程中的抽象节点类，具体使用接口还是抽象类需根据具体场景而定。</span><br><span class="line">■ Composite（复合组件）：包含多个子组件对象（可以是复合组件或叶端组件）的复合型组件，并实现组件接口中定义的操作方法。对应本章例程中作为“根节点/枝节点”的文件夹类。</span><br><span class="line">■ Leaf（叶端组件）：不包含子组件的终端组件，同样实现组件接口中定义的操作方法。对应本章例程中作为“叶节点”的文件类。</span><br><span class="line">■ Client（客户端）：按所需的层级关系部署相关对象并操作组件接口所定义的接口，即可遍历树结构上的所有组件。</span><br></pre></td></tr></table></figure>
<p>冥冥之中，大自然好似存在着某种神秘的规律，类似的结构总是在重复、迭代地显现出某种自似性。大到连绵的山川、飘浮的云朵、岩石的断裂口，小到树冠、雪花、菜花，甚至是人类的大脑皮层……自然界中很多事物无不体现出分形理论的神秘，其部分与整体一致的呈现与“组合模式”如出一辙。</p>
<p>“一花一世界，一叶一菩提”。世界是纷繁复杂的，然而繁杂中有序，从道家哲学的“道生一”到“三生万物”，从二进制的“0和1”到庞杂的软件系统，再从单细胞的生物到高级动物，“分形理论”无不揭示出事物的规律，其部分与整体的结构特征总是以相似的形式呈现，分形理论如此，组合模式亦是如此。</p>
<h2 id="第9章-装饰器"><a href="#第9章-装饰器" class="headerlink" title="第9章　装饰器"></a>第9章　装饰器</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310172143347.png" alt="image-20231017214356300"></p>
<p>装饰指在某物件上装点额外饰品的行为，以使其原本朴素的外表变得更加饱满、华丽，而装饰器（装饰者）就是能够化“腐朽”为神奇的利器。装饰器模式(Decorator)能够在运行时动态地为原始对象增加一些额外的功能，使其变得更加强大。从某种程度上讲，装饰器非常类似于“继承”，它们都是为了增强原始对象的功能，区别在于方式的不同，后者是在编译时(compile-time)静态地通过对原始类的继承完成，而前者则是在程序运行时(run-time)通过对原始对象动态地“包装”完成，是对类实例（对象）“装饰”的结果</p>
<h3 id="9-1-室内装潢"><a href="#9-1-室内装潢" class="headerlink" title="9.1 室内装潢"></a>9.1 室内装潢</h3><p>既然是装饰器，那么它一定能对客体进行一番加工，并在不改变其原始结构的前提下使客体功能得到扩展、增强。以室内装潢为例，如图9-1所示，要从毛坯房到精装房少不了“装饰”。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172145479.png" alt="image-20231017214529414"></p>
<p>装修风格多种多样，如简约、北欧、地中海、美式和中式等。当然，萝卜青菜各有所爱，每个人的审美取向不尽相同。朴素的毛坯房能给业主留有更大的装修选择空间，以根据自己的喜好进行二次加工。如果开发商出售的是已经装修好的房子，那么就得提供更多选项如“简装房”“精装房”“欧式精装房”“现代中式房”等供业主选择，这种固化下来的商品模式（编译时继承）就显得非常死板，而“买毛坯，送装修”的模式则更加灵活，这也是二手房产市场中毛坯房更加受欢迎的一个原因。成品一定是由半成品加工而成的，灵活多变的装饰才会带来更多的可能，因此装饰器模式应运而生。</p>
<h3 id="9-2-从素面朝天到花容月貌"><a href="#9-2-从素面朝天到花容月貌" class="headerlink" title="9.2 从素面朝天到花容月貌"></a>9.2 从素面朝天到花容月貌</h3><p>室内装修对房屋视觉效果的改善立竿见影，人们化妆也是如此，“人靠衣装马靠鞍”，人们总是惊叹女生们魔法师一般的化妆技巧，可以从素面朝天变成花容月貌（如图9-2所示），化妆前后简直判若两人，这正是装饰器的粉饰效果在发挥作用。</p>
<p>当然，化妆的过程也许对软件研发人员来说比较陌生，但我们可以从设计模式的角度出发，对这项充满神秘色彩的工作进行拆解和分析。下面开始我们的代码实战，首先对于任何妆容展示者必然对应一个标准的展示行为show()，我们将它抽象出来定义为接口Showable，如代码清单9-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172146774.png" alt="image-20231017214655740"></p>
<p>如代码清单9-1所示，Showable这个标准行为需要人去实现，女生们绝对当仁不让，下面来定义女生类，请参看代码清单9-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172147121.png" alt="image-20231017214712094"></p>
<p>如代码清单9-2所示，女生类在第5行中实现了其展示行为，因为目前还没有任何化妆效果，所以展示的只是女生的素颜。如果客户端直接调用show()方法，就会出现素面朝天的结果，这样就达不到我们要的妆容效果了。所以重点来了，此刻我们得借助“化妆品”这种工具来开始这场化妆仪式</p>
<p>化妆品对于女生的妆容效果起着至关重要的作用，我们就称之为“装饰器”吧，请参看代码清单9-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172148463.png" alt="image-20231017214834421"></p>
<p>如代码清单9-3所示，化妆品装饰器类与女生类一样也实现了标准行为展示接口Showable，这说明它同样能够进行展示，只是方式可能比较独特。第5行的构造方法中，化妆品装饰器类在构造自己的时候可以把其他可展示者注入进来并赋给在第3行定义的引用。如此一来，化妆品装饰器类中包含的这个可展示者就成为一个“被装饰者”的角色了。注意第10行的展示方法show()，化妆品装饰器类不但调用了“被装饰者”的展示方法，而且在其前后加入了自己的“粉饰效果”，这就像加了一层“壳”一样，包裹了被装饰对象。最后，我们来看客户端类的运行结果，请参看代码清单9-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172150418.png" alt="image-20231017215012388"></p>
<p>如代码清单9-4所示，客户端类代码干净、利落，我们在第5行将构造出来的女生类实例作为参数传给化妆品装饰器类的构造方法，这就好像为女生外表包裹了一层化妆品一样，对象结构非常生动、形象。接着，我们调用的是化妆品的展示方法show()，第6行的运行结果立竿见影，除女生自己的素颜展示结果之外还加上了额外的化妆效果。</p>
<h3 id="9-3-化妆品的多样化"><a href="#9-3-化妆品的多样化" class="headerlink" title="9.3 化妆品的多样化"></a>9.3 化妆品的多样化</h3><p>至此，我们已经完成了基本的装饰工作，可是装饰器中只有一个简单的“粉饰”效果，这未免过于单调，我们是否忘记了“口红”的效果？除此之外，可能还会有“眼线”“睫毛膏”“腮红”等各种各样的化妆品。</p>
<p>如何让我们的装饰器具备以上所有装饰功效呢？有些读者可能会想到，把这些装饰操作统统加入化妆品装饰器类中，一次搞定所有化妆操作。这样的做法必然是错误的，试想，难道每位女生都习惯于如此浓妆艳抹吗？化妆品的多样性决定了装饰器应该是多态化的，单个装饰器应该只负责自己的化妆功效，例如口红只用于涂口红，眼线笔只用于画眼线，把化妆品按功能分类才能让用户更加灵活地自由搭配，用哪个或不用哪个由用户自己决定，而不是把所有功能都固化在同一个装饰器里。</p>
<p>可能又有读者提出了别的解决方案，化妆品装饰器类已经是展示接口Showable的实现了，这本身已经使多态化成为了可能，那么让所有化妆品类都实现Showable接口不就行了吗？没错，但还记得化妆品装饰器类中出现的被装饰者引用（代码清单9-3的第3行）吗？有没有想过，难道每个化妆品类里都要引用这个被装饰者吗？粉底类里需要加入，口红类里也需要加入……这显然会导致代码冗余。</p>
<p>诚然，Showable接口是能够满足多态化需求的，但它只是对行为接口的一种规范，极度的抽象并不具备对代码继承的功能，所以化妆品的多态化还需要接口与抽象类的搭配使用才能两全其美。装饰器类的抽象化势在必行，我们来看如何重构它，请参看代码清单9-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172200781.png" alt="image-20231017220046741"></p>
<p>如代码清单9-5所示，我们将化妆品装饰器类修改为装饰器抽象类，这主要是为了不允许用户直接实例化此类。接着我们重构了第10行的展示方法show()，其中只是调用了被装饰者的show()方法，而不再做任何装饰操作，至于具体如何装饰则属于其子类的某个化妆品类的操作范畴了，例如之前的“打粉底”操作，我们将其分离出来独立成类，请参看代码清单9-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172201899.png" alt="image-20231017220151864"></p>
<p>如代码清单9-6所示，粉底类不用去实现Showable接口了，而是继承了装饰器抽象类，如此父类中对被装饰者的定义得以继承，可以看到我们在第4行的构造方法中调用了父类的构造方法并注入被装饰者，<strong>这便是继承的优势所在</strong>。当然，这个粉底类的show()方法一定要加上自己特有的操作，如第9行至第11行所示，我们在调用被装饰者的show()方法前后都进行了打粉底操作。化妆尚未结束，打完粉底再涂个口红吧，请参看代码清单9-7口红类。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172203091.png" alt="image-20231017220349061"></p>
<p>如代码清单9-7所示，与粉底类同出一辙，口红类只是进行了自己特有的“涂口红”操作。最后，客户端可以依次把被装饰者“女生”、装饰器“粉底”、装饰器“口红”用构造方法层层包裹起来，再进行展示即可完成整体化妆工作，请参看代码清单9-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172204139.png" alt="image-20231017220441107"></p>
<p>如代码清单9-8所示，客户端类的第4行中出现了多层的构造方法操作，接着在第5行只调用装饰好的madeupGirl对象的展示方法show()，所有装饰效果一触即发，层层递归。需要注意的是一系列构造产生的顺序，我们最终得到的madeupGirl对象本质上引用的是口红，口红里包裹了粉底，粉底里又包裹了女生，正如第6行运行结果所示的化妆效果一样。</p>
<p>至此，装饰器模式重构完毕，化妆品多态化得以顺利实现。如果用户对这些淡妆效果不够满意，我们还可以接着添加其他化妆品类，以便用户自由搭配出自己的理想效果，使“清新淡妆”或“浓妆艳抹”均成为可能。</p>
<h3 id="9-4-无处不在的装饰器"><a href="#9-4-无处不在的装饰器" class="headerlink" title="9.4 无处不在的装饰器"></a>9.4 无处不在的装饰器</h3><p>通过对装饰器模式的学习，读者是否觉得这种如同“俄罗斯套娃”一般层层嵌套的结构似曾相识？有些读者可能已经想到了，没错，其实装饰器模式在Java开发工具包(Java Development Kit, JDK)里就有大量应用，例如“java.io”包里一系列的流处理类InputStream、FileInputStream、BufferedInputStream、ZipInputStream等。举个例子，当对压缩文件进行解压操作时，我们就会用构造器嵌套结构进行文件流装饰，请参看代码清单9-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172206322.png" alt="image-20231017220654274"></p>
<p>如代码清单9-9所示，在第5行，我们首先以文件file初始化并构造文件输入流FileInputStream，然后外层用缓冲输入流BufferedInputStream进行装饰，使文件输入流具备内存缓冲的功能，最外层再用压缩包输入流ZipInputStream进行最终装饰，使文件输入流具备Zip格式文件的功能，之后我们就可以对压缩包进行解压操作了。当然，针对不同场景，Java I/O提供了多种流操作处理类，让各种装饰器能被混搭起来以完成不同的任务。</p>
<h3 id="9-5-自由嵌套"><a href="#9-5-自由嵌套" class="headerlink" title="9.5 自由嵌套"></a>9.5 自由嵌套</h3><p>Java类库中对装饰器模式的应用当然要比我们的例程复杂得多，但基本思想其实是一致的。装饰器模式最终的目的就在于“装饰”对象，其中装饰器抽象类扮演着至关重要的角色，它实现了组件的通用接口，并且使自身抽象化以迫使子类继承，使装饰器固定特性的延续与多态化成为可能。我们来看装饰器模式的类结构，如图9-5所示。装饰器模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Component（组件接口）：所有被装饰组件及装饰器对应的接口标准，指定进行装饰的行为方法。对应本章例程中的展示接口Showable。</span><br><span class="line">■ ConcreteComponent（组件实现）：需要被装饰的组件，实现组件接口标准，只具备自身未被装饰的原始特性。对应本章例程中的女生类Girl。</span><br><span class="line">■ Decorator（装饰器）：装饰器的高层抽象类，同样实现组件接口标准，且包含一个被装饰的组件。</span><br><span class="line">■ ConcreteDecorator（装饰器实现）：继承自装饰器抽象类的具体子类装饰器，可以有多种实现，在被装饰组件对象的基础上为其添加新的特性。对应本章例程中的粉底类FoundationMakeup、口红类Lipstick。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172228557.png" alt="image-20231017222855462"></p>
<p>客户需求是多变且无法预估的，要实现不同功能的自由组合，以“继承”的方式来完成是不现实的，会造成子类泛滥，维护或扩展起来举步维艰。试想，本章例程中用户可能需要“涂口红的女生”或“打粉底的女生”，也可能需要“打粉底再涂口红的女生”或“涂口红再打粉底的女生”。这2种化妆品就产生了女生类的4个子类，如果再增加些化妆品的话，罗列所有功能模块的排列组合会是一个不可能完成的任务。而装饰器模式可以将不同功能的单个模块规划至不同的装饰器类中，各装饰器类独立自主，各司其职。客户端可以根据自己的需求自由搭配各种装饰器，每加一层装饰就会有新的特性体现出来，巧妙的设计让功能模块层层叠加，装饰之上套装饰，最终使原始对象的特性动态地得到增强。</p>
<h2 id="第10章-适配器"><a href="#第10章-适配器" class="headerlink" title="第10章　适配器"></a>第10章　适配器</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310172229245.png" alt="image-20231017222946202"></p>
<p>适配器模式(Adapter)通常也被称为转换器，顾名思义，它一定是进行适应与匹配工作的物件。当一个对象或类的接口不能匹配用户所期待的接口时，适配器就充当中间转换的角色，以达到兼容用户接口的目的，同时适配器也实现了客户端与接口的解耦，提高了组件的可复用性。</p>
<h3 id="10-1-跨越鸿沟靠适配"><a href="#10-1-跨越鸿沟靠适配" class="headerlink" title="10.1 跨越鸿沟靠适配"></a>10.1 跨越鸿沟靠适配</h3><p>对象是多样化的，对象之间通过信息交换，也就是互动、沟通，世界才充满生机，否则就是死水一潭。人类最常用的沟通方式就是语言，两个人对话时，一方通过嘴巴发出声音，另一方则通过耳朵接收这些语言信息，所以嘴巴和耳朵（接口）必须兼容同一种语言（参数）才能达到沟通的目的。试想，我们跟不懂中文的人讲中文一定是徒劳的，因为对方根本无法理解我们在讲什么，更不要说人类和动物对话了，接口不兼容的结果就是对牛弹琴，如图10-1所示。</p>
<p>要跨越语言的鸿沟就必须找个会两种语言的翻译，将接口转换才能使沟通进行下去，我们将翻译这个角色称为适配器。适配器在我们生活中非常常见，如内存卡转换器、手机充电器、各种USB接口适配器等，再如我们上网用的调制解调器，它能够进行数模转换，让互联网服务提供商(ISP)与用户之间的网络接口互相适配与兼容，最终使两端进行正常通信。</p>
<h3 id="10-2-插头与插孔的冲突"><a href="#10-2-插头与插孔的冲突" class="headerlink" title="10.2 插头与插孔的冲突"></a>10.2 插头与插孔的冲突</h3><p>举一个生活中常见的实例，我们新买了一台电视机，其电源插头是两相的，不巧的是墙上的插孔却是三相的，这时电视机便无法通电使用。我们以代码来重现这个场景，首先得将墙上的三相插孔接口确立下来，请参看代码清单10-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172232757.png" alt="image-20231017223248717"></p>
<p>如代码清单10-1所示，我们为三相插孔接口TriplePin定义了一个三插通电标准electrify()，其中3个参数l、n、e分别对应火线(live)、零线(null)和地线(earth)。同样，我们定义两相插孔接口，请参看代码清单10-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172233195.png" alt="image-20231017223320154"></p>
<p>如代码清单10-2所示，与三相插孔接口所不同的是，两相插孔接口DualPin定义的是2个参数的通电标准，可以看到electrify()的参数中缺少了地线e。插孔接口定义完毕，接下来可以定义电视机类了。如之前提到的，电视机的两相插头是两插标准，所以它实现的是两相插孔接口DualPin，请参看代码清单10-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172234596.png" alt="image-20231017223417554"></p>
<p>如代码清单10-3所示，因为电视机类TV实现了两相插孔接口DualPin，所以代码第4行的通电方法electrify()只接通火线与零线，然后开机。代码很简单，而目前我们面临的问题是，墙上的接口是三相插孔，而电视机实现的是两相插孔，二者无法匹配，如代码清单10-4所示，客户端无法将两相插头与三相插孔完成接驳。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172235883.png" alt="image-20231017223501846"></p>
<h3 id="10-3-通用适配"><a href="#10-3-通用适配" class="headerlink" title="10.3 通用适配"></a>10.3 通用适配</h3><p>针对接口不兼容的情况，可能有人会提出比较极端的解决方案，就是把插头掰弯强行适配，若是三相插头接两相插孔的话，就把零线插针拔掉。虽然目的达到了，但经过这么一番暴力修改，插头也无法再兼容其原生接口了，这显然是违背设计模式原则的。</p>
<p>为了不破坏现有的电视机插头，我们需要一个适配器来做电源转换，有了它我们便可以顺利地把电视机两相插头转接到墙上的三相插孔中了，如图10-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172236028.png" alt="image-20231017223634986"></p>
<p>图10-2中间的适配器就像翻译一样，其插孔兼容右侧的两相插头，而其插头则兼容左侧的三相插孔，集两种接口于一身，承上启下，解决了接口间的冲突问题。我们来定义这个适配器，请参看代码清单10-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172237026.png" alt="image-20231017223659985"></p>
<p>如代码清单10-5所示，与电视机类不同的是，适配器类Adapter实现的是三相插孔接口，这意味着它能够兼容墙上的三相插孔了。注意代码第3行定义的两相插孔的引用，我们在第6行的构造方法中对其进行初始化，也就是说，适配器中嵌入一个两相插孔，任何此规格的设备都是可以接入进来的。最后，在第12行实现的三相插孔通电方法中，适配器转去调用了接入的两插设备，并且丢弃了地线参数e，这就完成了三相转两相的调制过程，最终达到适配效果。至此，这个适配器就可以将任意两插设备匹配到三相插孔上了。我们来看如何让电视机接通电源，请参看代码清单10-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172238810.png" alt="image-20231017223843772"></p>
<p>如代码清单10-6所示，客户端类在第5行构造的是两插标准的电视机对象，接着给构造好的适配器注入电视机对象（将电视机两相插头插入适配器），并将其赋给三相插孔接口（将匹配好的适配器插入墙上的三相插孔）。最后，我们直接调用三插通电方法给电视机供电，如第9行的输出结果所示，表面上看我们使用的是三插通电标准，而实际上是用两插标准为电视机供电（只使用了火线与零线），最终电视机顺利开启，两插标准的电视机与三相插孔接口成功得以适配。需要注意的是，适配器并不关心接入的设备是电视机、洗衣机还是电冰箱，只要是两相插头的设备均可以进行适配，所以说它是一种通用的适配器。</p>
<h3 id="10-4-专属适配"><a href="#10-4-专属适配" class="headerlink" title="10.4 专属适配"></a>10.4 专属适配</h3><p>除了10.3节所讲的“对象适配器”，我们还可以用“类适配器”实现接口的匹配，这是实现适配器模式的另一种方式。顾名思义，既然是类适配器，那么一定是属于某个类的“专属适配器”，也就是在编码阶段已经将被匹配的设备与目标接口进行对接了。我们继续之前的例子，请参看代码清单10-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172253954.png" alt="image-20231017225326917"></p>
<p>类适配器模式实现起来更简单，如代码清单10-7所示，电视机专属适配器类中并未包含被适配对象（如电视机）的引用，而是在开始定义类的时候就直接继承自电视机了，此外还一并实现了三相插孔接口。接着在第4行的三插通电方法中，我们利用“super”关键字调用父类（电视机类TV）定义的两插通电方法，以实现适配。下面我们来使用这个类适配器，请参看代码清单10-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172258861.png" alt="image-20231017225803826"></p>
<p>如代码清单10-8所示，第5行我们直接将实例化后的适配器对象接入墙上的三相插孔，接着直接通电使用即可。如输出结果所示，类适配器模式不但使用起来更加简单，而且其效果与对象适配器模式毫无二致。</p>
<p>然而，这个类适配器是继承自电视机的子类，在类定义的时候就已经与电视机完成了接驳，也就是说，类适配器与电视机的继承关系让它固化为一种专属适配器，这就造成了继承耦合，倘若我们需要适配其他两插设备，它就显得无能为力了。例如要适配两相插头的洗衣机，我们就不得不再写一个“洗衣机专属适配器”，这显然是一种代码冗余，说明适配器兼容性差。</p>
<p>当然，事物没有绝对的好与坏，对象适配器与类适配器各有各的适用场景。假如我们只需要匹配电视机这一种设备，并且未来也没有任何其他的设备扩展需求，那么类适配器使用起来可能更加简便，所以具体用什么、怎么用还要视具体情况而定，切不要有过分偏执、非黑即白的思想。</p>
<h3 id="10-5-化解难以调和的矛盾"><a href="#10-5-化解难以调和的矛盾" class="headerlink" title="10.5 化解难以调和的矛盾"></a>10.5 化解难以调和的矛盾</h3><p>众所周知，反复修改代码的代价是巨大的，因为所有依赖关系都要受到牵连，这不但会引入更多没有必要的重构与测试工作，而且其波及范围难以估量，可能会带来不可预知的风险，结果得不偿失。适配器模式让兼容性问题在不必修改任何代码的情况下得以解决，其中适配器类是核心，我们首先来看对象适配器模式的类结构，如图10-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172302200.png" alt="image-20231017230232147"></p>
<p>对象适配器模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Target（目标接口）：客户端要使用的目标接口标准，对应本章例程中的三相插孔接口TriplePin。</span><br><span class="line">■ Adapter（适配器）：实现了目标接口，负责适配（转换）被适配者的接口specificRequest()为目标接口request()，对应本章例程中的电视机专属适配器类TVAdapter。</span><br><span class="line">■ Adaptee（被适配者）：被适配者的接口标准，目前不能兼容目标接口的问题接口，可以有多种实现类，对应本章例程中的两相插孔接口DualPin。■ Client（客户端）：目标接口的使用者。</span><br></pre></td></tr></table></figure>
<p>下面是类适配器模式的类结构，请参看图10-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172304827.png" alt="image-20231017230429780"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">■ Target（目标接口）：客户端要使用的目标接口标准，对应本章例程中的三相插孔接口TriplePin。■ Adapter（适配器）：继承自被适配者类且实现了目标接口，负责适配（转换）被适配者的接口specificRequest()为目标接口request()。■ Adaptee（被适配者）：被适配者的类实现，目前不能兼容目标接口的问题类，对应本章例程中的电视机类TV。■ Client（客户端）：目标接口的使用者。</span><br></pre></td></tr></table></figure>
<p>对象适配器模式与类适配器模式基本相同，二者的区别在于前者的Adaptee（被适配者）以接口形式出现并被Adapter（适配器）引用，而后者则以父类的角色出现并被Adapter（适配器）继承，所以前者更加灵活，后者则更为简便。其实不管何种模式，从本质上看适配器至少都应该具备模块两侧的接口特性，如此才能承上启下，促成双方的顺利对接与互动，如图10-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310172306995.png" alt="image-20231017230630944"></p>
<p>成功利用适配器模式对系统进行扩展后，我们就不必再为解决兼容性问题去暴力修改类接口了，转而通过适配器，以更为优雅、巧妙的方式将两侧“对立”的接口“整合”在一起，顺利化解双方难以调和的矛盾，最终使它们顺利接通。</p>
<h2 id="第11章-享元"><a href="#第11章-享元" class="headerlink" title="第11章　享元"></a>第11章　享元</h2><p>计算机世界中无穷无尽的可能，其本质都是由1和0两个“元”的组合变化而产生的。元，顾名思义，始也，有本初、根源的意思。“享元”则是共享元件的意思。享元模式的英文flyweight是轻量级的意思，这就意味着享元模式能使程序变得更加轻量化。当系统存在大量的对象，并且这些对象又具有相同的内部状态时，我们就可以用享元模式共享相同的元件对象，以避免对象泛滥造成资源浪费。</p>
<h3 id="11-1-马赛克"><a href="#11-1-马赛克" class="headerlink" title="11.1 马赛克"></a>11.1 马赛克</h3><p>除了计算机世界，我们的真实世界也充满了各种“享元”的应用。很多人一定有过装修房子的经历，装修离不开瓷砖、木地板、马赛克等建筑材料。针对不同的房间会选择不同材质、花色的单块地砖或墙砖拼接成一个完整的面，尤其是马赛克这种建筑材料拼成的图案会更加复杂，近看好像显示器像素一样密密麻麻地排列在一起，如图11-1所示。</p>
<p>虽然马赛克小块数量比较多，但经过观察我们会发现，归类后只有4种：黑色块、灰色块、灰白色块以及白色块。我们可以说，这就是4个“元”色块。</p>
<h3 id="11-2-游戏地图"><a href="#11-2-游戏地图" class="headerlink" title="11.2 游戏地图"></a>11.2 游戏地图</h3><p>在早期的RPG（角色扮演类）游戏中，为了营造出不同的环境氛围，游戏的地图系统可以绘制出各种各样的地貌特征，如河流、山川、草地、沙漠、荒原，以及人造的房屋、道路、围墙等。为了避免问题的复杂化，我们就以草原地图作为范例，如图11-2所示。</p>
<p>对于图11-2所示的游戏地图，如果我们加载一整张图片并显示在屏幕上，游戏场景的加载速度一定会比较慢，而且组装地图的灵活性也会大打折扣，后期主角的移动碰撞逻辑还要提前对碰撞点坐标进行标记，这种设计显然不够妥当。正如之前探讨过的马赛克，我们可以发现整张游戏地图都是由一个个小的单元图块组成的，其中除房屋比较大之外，其他图块的尺寸都一样，它们分别为河流、草地、道路，这些图块便是4个元图块，如图11-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180934108.png" alt="image-20231018093448931"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180934939.png" alt="image-20231018093455890"></p>
<h3 id="11-3-卡顿的加载过程"><a href="#11-3-卡顿的加载过程" class="headerlink" title="11.3 卡顿的加载过程"></a>11.3 卡顿的加载过程</h3><p>在开始代码实战之前，我们先思考怎样去建模。首先我们应该定义一个图块类来描述图块，具体属性应该包括“图片”和“位置”信息，并且具备按照这些信息去绘制图块的能力，请参看代码清单11-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180935502.png" alt="image-20231018093536454"></p>
<p>图块类看起来非常简单直观，代码清单11-1的第3行定义了图块的材质图对象的引用，此处我们用String来模拟。第4行定义了图块所在游戏地图的横坐标与纵坐标：x与y。第7行开始在构造方法中进行图片与坐标的初始化。此时我们把图片加载到内存，如I/O操作要耗费半秒时间，我们在第8行模拟输出。最后是第13行的绘制方法，能够把图片按照坐标位置显示在游戏地图上。一切就绪，开始测试绘制一些图块，请参看代码清单11-2的客户端运行情况。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180937653.png" alt="image-20231018093705509"></p>
<p>如代码清单11-2所示，客户端将所有图块进行初始化并绘制出来，顺利完成地图拼接。然而，通过观察运行结果我们会发现一个问题，第17行到第26行每次加载一张图片都要耗费半秒时间，10张图块就要耗费5秒，如果加载整张地图将会耗费多长时间？如此糟糕的游戏体验简直就是在挑战玩家的忍耐力，缓慢的地图加载过程会让玩家失去兴趣。</p>
<p>面对解决加载卡顿的问题，有些读者可能已经想到我们之前学过的原型模式了。对，我们完全可以把相同的图块对象共享，用克隆的方式来省去实例化的过程，从而加快初始化速度。然而，对这几个图块克隆貌似没什么问题，地图加载速度确实提高了，但是构建巨大的地图一定会在内存中产生庞大的图块对象群，从而导致大量的内存开销。如果没有内存回收机制，甚至会造成内存溢出，系统崩溃，如图11-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180938827.png" alt="image-20231018093810756"></p>
<p>用原型模式一定是不合适的，地图中的图块并非像游戏中动态的人物角色一样可以实时移动，它们的图片与坐标状态初始化后就固定下来了，简单讲就是被绘制出来后就不必变动了，即使要变也是将拼好的地图作为一个大对象整体挪动。图块一旦被绘制出来就不需要保留任何坐标状态，内存中自然也就不需要保留大量的图块对象了。</p>
<h3 id="11-4-图件共享"><a href="#11-4-图件共享" class="headerlink" title="11.4 图件共享"></a>11.4 图件共享</h3><p>要提高游戏性能，我们只能利用少量的对象拼接整张地图。继续分析地图，我们会发现每个图块的坐标是不同的，但有很大一部分图块的材质图（图片）是相同的，也就是说，同样的材质图会在不同的坐标位置上重复出现。于是我们可以得出结论，材质图是可以作为享元的，而坐标则不能。</p>
<p>既然要共享相同的图片，那么我们就得将图块类按图片拆分成更细的材质类，如河流类、草地类、道路类等。而坐标不能作为图块类的享元属性，所以我们就得设法把这个属性抽离出去由外部负责。不能纸上谈兵，我们继续代码实战，首先需要定义一个接口，规范这些材质类的绘图标准，请参看代码清单11-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180940261.png" alt="image-20231018094043229"></p>
<p>如代码清单11-3所示，我们定义了绘图接口，使坐标作为参数传递进来并进行绘图。当然，除了接口方式，我们还可以用抽象类抽离出更多的属性和方法，使子类变得更加简单。接下来我们再定义一系列材质类并实现此绘图接口，首先是河流类，如代码清单11-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180941382.png" alt="image-20231018094127321"></p>
<p>河流类中只定义了图片作为内部属性。在第6行的类构造器中加载河流图片，这就是类内部即将共享的“元”数据了，我们通常称之为“内蕴状态”。而作为“外蕴状态”的坐标是无法作为享元的，所以将其作为参数由第11行实现的绘图方法中由外部传入。以此类推，接下来我们定义草地类、道路类、房屋类，请分别参看代码清单11-5、代码清单11-6和代码清单11-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180942385.png" alt="image-20231018094232339"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180942598.png" alt="image-20231018094244563"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180942774.png" alt="image-20231018094249737"></p>
<p>这里要注意代码清单11-7的房屋类与其他类有所区别，它拥有自己特定的绘图方法，调用后会在地板图层之上绘制房屋，覆盖下面的地板（房屋图片比其他图片要大一些），以使地图变得更加立体化。接下来就是实现“元之共享”的关键了，我们得定义一个图件工厂类，并将各种图件对象提前放入内存中共享，如此便可以避免每次从磁盘重新加载，请参看代码清单11-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180944472.png" alt="image-20231018094447424"></p>
<p>如代码清单11-8所示，图件工厂类类似于一个图库管理器，其中维护着所有的图件元对象。首先在第5行的构造方法中初始化一个散列图的“缓存池”，然后通过懒加载模式来维护它。当客户端调用第9行的获取图件方法getDrawable()时，程序首先会判断目标图件是否已经实例化并存在于缓存池中，如果没有则实例化并放入图库缓存池供下次使用，到这里目标图件必然存在于缓存池中了。最后在第28行直接从缓存池中获取目标图件并返回。如此，无论外部需要什么图件，也无论外部获取多少次图件，每类图件都只会在内存中被加载一次，这便是“元共享”的秘密所在。最后让我们来看客户端如何构建游戏地图，请参看代码清单11-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180946688.png" alt="image-20231018094615613"></p>
<p>如代码清单11-9所示，我们抛弃了利用“new”关键字随意制造对象的方法，改用这个图件工厂类来构建并共享图件元，外部需要什么图件直接向图件工厂索要即可。此外，图件工厂类返回的图件实例也不再包含坐标信息这个属性了，而是将其作为绘图方法的参数即时传入。结果立竿见影，从第23行开始的输出中可以看到，每个图件对象在初次实例化时会耗费半秒时间，而下次请求时就不会再出现加载图片的耗时操作了，也就是从图库缓存池直接拿到了。</p>
<h3 id="11-5-万变不离其宗"><a href="#11-5-万变不离其宗" class="headerlink" title="11.5 万变不离其宗"></a>11.5 万变不离其宗</h3><p>至此，享元模式的运用让程序运行更加流畅，地图加载再也不会出现卡顿现象了，加载图片时的I/O流操作所导致的CPU效率及内存占用的问题同时得以解决，游戏体验得以提升和改善。享元模式让图件对象将可共享的内蕴状态“图片”维护起来，将外蕴状态“坐标”抽离出去并定义于接口参数中，基于此，享元工厂便可以顺利将图件对象共享，以供外部随时使用。我们来看享元模式的类结构，如图11-5所示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Flyweight（享元接口）：所有元件的高层规范，声明与外蕴状态互动的接口标准。对应本章例程中的绘图接口Drawable。</span><br><span class="line">■ ConcreteFlyweight（享元实现）：享元接口的元件实现类，自身维护着内蕴状态，且能接受并响应外蕴状态，可以有多个实现，一个享元对象可以被称作一个“元”。对应本章例程中的河流类River、草地类Grass、道路类Road等。</span><br><span class="line">■ FlyweightFactory（享元工厂）：用来维护享元对象的工厂，负责对享元对象实例进行创建与管理，并对外提供获取享元对象的服务。</span><br><span class="line">■ Client（客户端）：享元的使用者，负责维护外蕴状态。对应本章例程中的图件工厂类TileFactory。</span><br></pre></td></tr></table></figure>
<p>与中国古代先哲们对“阴阳”二元的思考类似，“享元”的理念其实就是萃取事物的本质，将对象的内蕴状态与外蕴状态剥离开来，其中内蕴状态成为真正的“元”数据，而外蕴状态则被抽离出去由外部负责维护，最终达成内外相济、里应外合的结构，使元得以共享。大千世界，万物苍生，究其“元”，万变不离其宗，宜“享”之。</p>
<h2 id="第12章-代理"><a href="#第12章-代理" class="headerlink" title="第12章　代理"></a>第12章　代理</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310180952481.png" alt="image-20231018095249410"></p>
<p>代理模式(Proxy)，顾名思义，有代表打理的意思。某些情况下，当客户端不能或不适合直接访问目标业务对象时，业务对象可以通过代理把自己的业务托管起来，使客户端间接地通过代理进行业务访问。如此不但能方便用户使用，还能对客户端的访问进行一定的控制。简单来说，就是代理方以业务对象的名义，代理了它的业务。</p>
<h3 id="12-1-4S店"><a href="#12-1-4S店" class="headerlink" title="12.1 4S店"></a>12.1 4S店</h3><p>在我们的社会活动中存在着各种各样的代理，例如销售代理商，他们受商品制造商委托负责代理商品的销售业务，而购买方（如最终消费者）则不必与制造商发生关联，也不用关心商品的具体制造过程，而是直接找代理商购买产品。</p>
<p>如图12-1所示，顾客通常不会找汽车制造商直接购买汽车，而是通过4S店购买。介于顾客与制造商之间，4S店对汽车制造商生产的整车与零配件提供销售代理服务，并且在制造商原本职能的基础之上增加了一些额外的附加服务，如汽车上牌、注册、保养、维修等，使顾客与汽车制造商彻底脱离关系。除此之外，代理模式的示例还有明星经纪人对明星推广业务的代理；律师对原告或被告官司的代理；旅游团对门票、机票业务的代理等，不胜枚举。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180954016.png" alt="image-20231018095432963"></p>
<h3 id="12-2-访问互联网"><a href="#12-2-访问互联网" class="headerlink" title="12.2 访问互联网"></a>12.2 访问互联网</h3><p>现代社会中，网络已经渗透到人们工作和生活的方方面面，为了满足各种需求，不管是公司还是家庭，网络的组建工作都必不可少。根据网络环境的不同，适当地使用各种网络设备十分重要，例如我们常见的家用路由器，其最重要的一个功能就是代理上网业务，使其下面所有终端设备都能够连入互联网，如图12-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180955356.png" alt="image-20231018095509305"></p>
<p>图12-2所示的是一个简单的家庭网络的网络结构。从左往右看，首先我们得去网络服务提供商(ISP)申请互联网(Internet)宽带业务，然后通过光纤入户并拿到一个调制解调器(Modem)，也就是我们俗称的“猫”（以下简称为猫），它负责在模拟信号（或者光信号）与数字信号之间做调制转换（类似于适配器）。接下来连接的就是我们的主角——路由器(Router)了，它负责代理互联网服务。最后，我们每天使用的一些终端设备，例如笔记本电脑、台式机、手机、电视机等，不管通过Wi-Fi还是网线，都能通过路由器代理成功上网。基于此结构，我们尝试以代码来实现，首先定义一个互联网访问接口Internet，请参看代码清单12-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180956306.png" alt="image-20231018095607271"></p>
<p>如代码清单12-1所示，我们对互联网访问接口进行简化，假设它只有一个互联网访问标准（协议）httpAccess，并接受一个url地址。毫无疑问，直接与互联网连接的一定是“猫”，所以我们首先让“猫”实现互联网访问接口，请参看代码清单12-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310180956004.png" alt="image-20231018095633958"></p>
<p>如代码清单12-2所示，调制解调器（猫）实现了互联网访问接口，并在构造方法中进行拨号上网的密码校验，校验通过后用户即可通过调用互联网访问实现方法httpAccess()上网了。此方法来者不拒，接受用户的一切访问。</p>
<h3 id="12-3-互联网代理"><a href="#12-3-互联网代理" class="headerlink" title="12.3 互联网代理"></a>12.3 互联网代理</h3><p>虽然“猫”允许用户直接访问互联网，但用户每次上网都不得不进行拨号操作，这确实不太方便。此外，“猫”要对大量的终端上网设备进行资源分配与管理，难免力不从心。例如，孩子学习时总是偷偷上网看电影或玩游戏，只依靠家长是很难得到有效控制的。再如，我们上网时会遭遇一些高危网站的攻击，严重威胁到我们的网络安全，所以我们有必要采取一些技术手段来屏蔽终端设备对这些有害网站的访问，这些事还是得交给代理去负责，例如建立黑名单机制。</p>
<p>如图12-3所示，要在用户与互联网之间建立黑名单机制并禁止终端设备对有害网站的访问，我们就得把终端设备（客户端）与“猫”的连接隔离开，并在它们之间加上路由器进行代理管控。当终端设备请求访问互联网时，我们就将其传入的地址与黑名单进行比对，如果该地址存在于黑名单中则禁止访问，反之则通过校验并转交给“猫”以连接互联网。这个逻辑非常清晰，下面我们用路由器来实现，请参看代码清单12-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181029012.png" alt="image-20231018102944965"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181029041.png" alt="image-20231018102950982"></p>
<p>如代码清单12-3所示，路由器与“猫”一样实现了互联网接口，并于第6行的构造方法中主动实例化了“猫”，作为被代理的目标业务（互联网业务）类。重点在于第11行的互联网访问实现方法中，我们对提前设定好的黑名单进行遍历，如果访问地址中带有黑名单中的敏感字眼就禁止访问并直接退出，如果遍历结束则代表没有发现任何威胁，此时就可以假设访问地址是相对安全的。当访问地址成功通过安全校验后，代码第18行中路由器移交控制权，将请求转发给“猫”进行互联网访问。可以看到，其实路由器本质上并不具备上网功能，而只是充当代理角色，对访问进行监管、控制与转发。</p>
<p>至此，家庭网络已经搭建完毕，网络安全问题也得以解决，一切准备就绪。让我们打开计算机，畅游互联网，请参看代码清单12-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181031622.png" alt="image-20231018103157574"></p>
<p>如代码清单12-4所示，客户端（终端设备）一开始创建的并不是“猫”，而是实例化路由器来连接互联网。简单来讲，就是用户只需要知道连接路由器便可以上网了，至于“猫”是什么，用户完全可以无视。接下来，用户由第5行开始访问一系列的网站，可以看到路由器依次给出了访问结果，其中“电影”与“游戏”的相关的网站都被屏蔽了，而“工作”与“学习”则予以正常通过。如此不但省去了客户端拨号的麻烦（路由器可以帮助拨号），而且避免了用户访问一些娱乐网站。因此，家长不必担心孩子在学习时间去看电影玩游戏了（可以增强为在固定时间段进行屏蔽），从此高枕无忧。</p>
<h3 id="12-4-万能的动态代理"><a href="#12-4-万能的动态代理" class="headerlink" title="12.4 万能的动态代理"></a>12.4 万能的动态代理</h3><p>通过代码实践，相信读者已经充分理解代理模式了，这也是最简单、常用的一种代理模式。除此之外，还有一种特殊的代理模式叫作“动态代理”，其实例化过程是动态完成的，也就是说我们不需要专门针对某个接口去编写代码实现一个代理类，而是在接口运行时动态生成。</p>
<p>继续我们之前的实例，现在假设有这样一种场景，当网络中的终端设备越来越多（例如组建公司网络）时，网络接口逐渐被占满，此时路由器就有点力不从心、不堪负重。这就需要我们进行网络升级，加装交换机来连接更多的终端设备。由于交换机主要负责内网的通信服务，因此现在我们将视角切换到局域网，首先定义局域网访问接口Intranet，请参看代码清单12-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181042924.png" alt="image-20231018104254888"></p>
<p>如代码清单12-5所示，与之前的互联网访问接口Internet定义的httpAccess不同，局域网访问接口Intranet定义了文件访问标准（协议）fileAccess，并以文件的绝对地址作为参数。接下来，由交换机组建的局域网一定能为终端设备间的文件访问与共享提供服务，我们让交换机来实现这个局域网访问接口，请参看代码清单12-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181043021.png" alt="image-20231018104326976"></p>
<p>如代码清单12-6所示，交换机Switch实现了局域网访问接口Intranet，此时终端设备间的互访也就顺利实现了，如一台计算机请求从另一台内网计算机上复制共享文件。但交换机还不具备任何代理功能，不要着急，接下来就需要动态代理了。</p>
<p>随着终端设备数量的增多，内网安全防范措施也得跟着加强。若要对终端设备之间的互访进行管控，我们就不得不再编写一个局域网接口的代理SwitchProxy，并加上之前的黑名单过滤逻辑。这虽然看似简单，但问题是，不管是代理互联网业务还是代理局域网业务，都是基于同样的一份黑名单对访问地址进行校验，如果每个代理都加上这一逻辑，显然是冗余的，将其抽离出来势在必行。</p>
<p>单单看这个黑名单过滤功能的代理，它应该是一个通用的过滤器，不应该与任何业务接口发生关联。要灵活地实现业务功能，就要抛开业务接口的牵绊，在运行时针对某业务接口动态地生成具备黑名单过滤功能的代理，从而彻底跳出业务规范的条条框框。多说无益，我们将抽离出来的功能定义在黑名单过滤器中，请参看代码清单12-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181046621.png" alt="image-20231018104601570"></p>
<p>如代码清单12-7所示，黑名单过滤器的功能代码不再与任何业务接口有瓜葛了，而且实现了JDK反射包中提供的InvocationHandler（动态调用处理器）接口，这个接口定义了动态反射调用的标准，这意味着黑名单过滤器可以代理任意类的任意方法，这就使万能代理成为可能。注意看第9行代码，我们在构造方法中将被代理对象注入进来交给第6行定义的Object类对象引用origin，所以此处不管是路由器还是交换机都能够被代理。接下来是动态代理的重中之重。我们在代码第14行实现了InvocationHandler的invoke()方法，此处规定要将进行过滤的目标地址字符串放在参数组args的第一个元素位置，得到参数后进行循环过滤，如果校验通过则调用被代理对象的原始方法。注意我们在第25行中利用反射机制去调用origin（被代理对象）的mth()方法（被代理类的“方法对象”），具体被调用的是哪个被代理对象的哪个方法在运行时才能确定下来。</p>
<p>我们已经将黑名单机制的相关逻辑抽离出来了，并且加上了动态代理生成的功能，那么我们之前实现的路由器代理就要进行重构，删除其中的黑名单过滤功能代码，只保留自动拨号功能，请参看代码清单12-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181049420.png" alt="image-20231018104903368"></p>
<p>至此，每个网络模块都变得更加简单了，我们只需要根据需求进行动态组装来实现不同代理。当用户要访问外网时，我们就用RouterProxy或者Modem生成基于互联网访问接口Internet的黑名单代理；当用户要访问内网时，我们就用交换机Switch生成基于局域网访问接口Intranet的黑名单代理。我们来看客户端示例，请参看代码清单12-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181049624.png" alt="image-20231018104939575"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181049369.png" alt="image-20231018104945318"></p>
<p>如代码清单12-9所示，客户端在第6行调用了JDK提供的代理生成器Proxy的生产方法newProxyInstance()，并传入过滤器与路由器的相关参数，将过滤器功能与被代理对象组装在一起，动态生成代理对象，接着用它访问了若干互联网地址。可以看到运行结果，路由器代理本身已经代理了“猫”的上网功能并加装了自动拨号功能，在此基础上外层的动态代理又加装了地址校验功能。同理，从第27行开始，代码为交换机加入过滤器功能并生成动态代理，接着用它访问了局域网中的文件，运行结果同样有效。无论用户访问互联网还是局域网，动态代理都充分完成了对网络地址访问的代理与管控工作。</p>
<p>至此，我们已经将管控业务（地址校验业务）完全抽离，并独立于系统主业务，也就是说，管控业务不再侵入实际业务类。并且，我们能够更加灵活地将这段业务逻辑加入不同的业务对象，如此，我们再也不必在编程时针对某个业务类量身定做其特有的代理类了，达到了一劳永逸的目的。</p>
<h3 id="12-5-业务增强与管控"><a href="#12-5-业务增强与管控" class="headerlink" title="12.5 业务增强与管控"></a>12.5 业务增强与管控</h3><p>不管是在编程时预定义静态代理，还是在运行时即时生成代理，它们的基本理念都是通过拦截被代理对象的原始业务并在其之前或之后加入一些额外的业务或者控制逻辑，来最终实现在不改变原始类（被代理类）的情况下对其进行加工、管控。换句话说，虽然动态代理更加灵活，但它也是在静态代理的基础之上发展而来的，究其本质，万变不离其宗，我们来看代理模式的类结构，如图12-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181104699.png" alt="image-20231018110441643"></p>
<p>代理模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Subject（业务接口）：对业务接口标准的定义与表示，对应本章例程中的互联网访问接口Internet。</span><br><span class="line">■ RealSubject（被代理业务）：需要被代理的实际业务类，实现了业务接口，对应本章例程中的调制解调器Modem。</span><br><span class="line">■ Proxy（代理）：同样实现了业务接口标准，包含被代理对象的实例并对其进行管控，对外提供代理后的业务方法，对应本章例程中的路由器RouterProxy。■ Client（客户端）：业务的使用者，直接使用代理业务，而非实际业务。</span><br></pre></td></tr></table></figure>
<p>代理模式不仅能增强原业务功能，更重要的是还能对其进行业务管控。对用户来讲，隐藏于代理中的实际业务被透明化了，而暴露出来的是代理业务，以此避免客户端直接进行业务访问所带来的安全隐患，从而保证系统业务的可控性、安全性。</p>
<h2 id="第13章-桥接"><a href="#第13章-桥接" class="headerlink" title="第13章　桥接"></a>第13章　桥接</h2><p>桥接模式(Bridge)能将抽象与实现分离，使二者可以各自单独变化而不受对方约束，使用时再将它们组合起来，就像架设桥梁一样连接它们的功能，如此降低了抽象与实现这两个可变维度的耦合度，以保证系统的可扩展性。</p>
<h3 id="13-1-基础建设"><a href="#13-1-基础建设" class="headerlink" title="13.1 基础建设"></a>13.1 基础建设</h3><p>人类社会的发展有一条不变的规律，即“要致富，先修路”。路桥作为重要的交通基础设施，在经济发展中扮演着不可或缺的角色。它可以把原本相对独立的区域连接起来，使得贸易往来更加便利与高效，从而极大地促进经济合作与发展。如图13-1所示，古代丝绸之路连通了东西方的经贸往来，让各个国家取长补短、互惠互利，最终使各方经济发展纷纷受惠。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181509340.png" alt="image-20231018150950201"></p>
<p>古有丝绸之路，21世纪则有全球化。桥接模式类似于这种全球化劳动分工的经济模式。全球产业分工后，国家可以发挥各自的优势，制造自己最擅长的产品组件，再通过合作组成产业链，以此提高生产效率并实现产品多元化。拿手机制造来说，芯片可以由美国设计制造，屏幕可以由韩国制造，摄像头则可以由日本制造……最后由中国制造其他半导体组件并完成手机的组装，从而形成手机制造产业链并使产品高效生产。如此一来，每个国家都能发挥自己的长处，生产各式各样的组件，最终组装出各种品类的产品，其中各种品牌、型号、配置应有尽有，以此满足不同的用户需求，这便是桥接模式的最大价值。</p>
<h3 id="13-2-形与色的纠葛"><a href="#13-2-形与色的纠葛" class="headerlink" title="13.2 形与色的纠葛"></a>13.2 形与色的纠葛</h3><p>既然基础建设如此重要，那么我们就用实例来分析一下桥接模式下的产业分工与合作。假设我们要画一幅抽象画，它主要由各种形状的色块组成，以此来表达世界的多样性，如图13-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181512669.png" alt="image-20231018151206619"></p>
<p>要完成这幅作品，不同颜色的画笔是必不可少的工具，那么相应地我们就得定义这些画笔工具类。首先抛开画笔的颜色，画笔本身一定是类似的，所以我们定义一个画笔抽象类，请参看代码清单13-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181512146.png" alt="image-20231018151232103"></p>
<p>如代码清单13-1所示，画笔抽象类在第3行定义了抽象方法getColor()获取颜色，并交给子类实现不同的颜色；接着在第5行绘图方法draw()中先调用getColor()以获取具体的颜色，然后画出一个三角形。下面我们来看具体的黑色画笔类BlackPen，请参看代码清单13-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181513714.png" alt="image-20231018151350671"></p>
<p>如代码清单13-2所示，黑色画笔类在第4行实现了获取颜色方法getColor()，并输出了字符串“黑”，以此来模拟黑色墨水的输出。我们先不急于进行过多的扩展，至少目前已经足以进行作画了，我们用客户端试着运行一下，请参看代码清单13-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181514041.png" alt="image-20231018151416999"></p>
<p>如代码清单13-3所示，我们在第5行调用黑色画笔类的绘图方法draw()后成功输出了“黑△”（黑色三角形）。同理，我们可以继续定义白色画笔类，画出“白△”（白色三角形）。然而，不管我们制造多少种颜色的画笔，都只能画出三角形，这是因为我们在抽象类里硬编码了对“△”的输出，这就造成了形状被牢牢地捆绑于各类彩色画笔中，对于其他形状的绘制则无能为力，使系统丧失了灵活性与可扩展性。</p>
<h3 id="13-3-架构产业链"><a href="#13-3-架构产业链" class="headerlink" title="13.3 架构产业链"></a>13.3 架构产业链</h3><p>我们已经利用画笔的抽象实现了颜色的多态，现在要解决的问题是对形状的抽离，将形状与颜色彻底分离开来，使它们各自扩展。既然颜色是由画笔来决定的，那么形状可以依赖尺子来规范其笔触线条走向。我们设想这样一个场景，画笔与尺子这两种工具分别产于南北两座孤岛，北岛擅长制造各色画笔，南岛则擅长制造各种形状的尺子，如图13-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181515672.png" alt="image-20231018151546618"></p>
<p>图13-3所示的是产业分工与合作的最佳范例之一，按照这种模式我们开始规划南岛文具产业。首先我们把可以规范形状的尺子类从画笔产业中独立出来，它们至少能够画出正方形、三角形和圆形，来看看南岛所制造的尺子，如图13-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181516723.png" alt="image-20231018151632676"></p>
<p>尺子的功能是对笔触线条走向进行规范。为了让尺子各尽其能而不至于毫无章法地扩展，我们先定义一个尺子的高层接口，请参看代码清单13-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181516363.png" alt="image-20231018151652320"></p>
<p>如代码清单13-4所示，尺子接口定义了笔触线条走向规范方法regularize()，为各种形状的尺子实现留好了接口。为保持简单，我们在这里忽略形状的大小，假设一种形状对应一个类，那么应该有正方形尺子类、三角形尺子类以及圆形尺子类，分别对应代码清单13-5、代码清单13-6以及代码清单13-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181517540.png" alt="image-20231018151722492"></p>
<p>如代码清单13-5、代码清单13-6以及代码清单13-7所示，南岛文具产业已经被规划完成。接着我们来看处于产业链另一端的北岛文具产业，其擅长制造的是彩色画笔，如图13-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181517350.png" alt="image-20231018151740302"></p>
<p>依照南、北岛的产业合作模式，我们同样需要对北岛产业进行重新规划，也就是对之前的画笔类相关代码进行重构。因为画笔必须有尺子的协助才能完成漂亮的画作，所以我们假设北岛制造处于“产业链下游”，修改之前的画笔抽象类，使其能够用到尺子，请参看代码清单13-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181518944.png" alt="image-20231018151809851"></p>
<p>如代码清单13-8所示，画笔类在第3行声明了尺子接口的引用，并在第5行的构造方法中将尺子对象注入进来，这样画笔就能使用尺子进行绘画了，此处便是南北产业通过桥梁的对接形成产业链的关键点。接着第9行的绘图方法draw()被我们抽象化了，毕竟抽象画笔并不能确定将来要画什么形状、什么颜色、如何画等细节，所以应该留给画笔子类去实现。最后，我们来实现具体颜色的画笔子类。为了保持简单，我们只实现黑色和白色两种颜色的画笔，请分别参看代码清单13-9、代码清单13-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181519613.png" alt="image-20231018151900568"></p>
<p>如代码清单13-9、代码清单13-10所示，黑白画笔均继承自画笔类，在第4行的构造方法中我们调用父类的构造方法并注入传入的尺子，建立与南岛产业的桥梁。在第9行的绘图方法draw()中，我们先输出对应的具体颜色，接着调用尺子的笔触规范方法regularize()绘制相关形状。至此，南北产业链规划完毕，我们可以利用这些文具开始绘画了，请参看代码清单13-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181519581.png" alt="image-20231018151942530"></p>
<p>如代码清单13-11所示，客户端对各种画笔与尺子进行了相关的实例化操作，如第8行，在实例化白色画笔时为其注入三角形尺子，如第18行输出所示，这时它所画出的图形为白色三角形。有了桥接模式，客户端便可以任意组装自己需要的颜色与形状进行绘图了。</p>
<h3 id="13-4-笛卡儿积"><a href="#13-4-笛卡儿积" class="headerlink" title="13.4 笛卡儿积"></a>13.4 笛卡儿积</h3><p>在桥接的产业合作模式下，南、北岛勤劳的工人们继续扩大生产，制造了更多样式的尺子和画笔，让客户端能够更自由地作画。通过例程我们可以看到，桥接模式将原本对形状的继承关系改为聚合（组合）关系，使形状实现从颜色中分离出来，最终完成多类组件维度上的自由扩展与拼装，使形与色的自由搭配成为可能。</p>
<p>如图13-6所示，实线与虚线连接了2种颜色与3种形状的所有搭配，结果生成了6种可能，用笛卡儿积的方式可以描述如下。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181520984.png" alt="image-20231018152041929"></p>
<p>如果将形状与颜色这2个维度分别作为行与列，就会形成表13-1所示的矩阵形式。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181521867.png" alt="image-20231018152102832"></p>
<p>如表13-1所示，我们的例子其实比较简单，只是2色3形的笛卡儿积组合，如果再加入更多的颜色与形状，笛卡儿积的结果数量会大得惊人。举个例子，我们现有7种颜色和10种形状，组合起来就有70(7×10)种可能，假如设计程序时我们只用继承的方式去实现每种可能，那么至少需要70个类。如果颜色与形状不断增多，系统可能会出现代码冗余以及类泛滥的情况，之后每加一种颜色或形状都将举步维艰，系统扩展工作将会是一场灾难。如果利用桥接模式的设计，我们只需要17(7+10)个类便可以组装成任意可能了，并且之后对任何维度的扩展也是轻而易举的。</p>
<h3 id="13-5-多姿多彩的世界"><a href="#13-5-多姿多彩的世界" class="headerlink" title="13.5 多姿多彩的世界"></a>13.5 多姿多彩的世界</h3><p>桥接模式构架了一种分化的结构模型，巧妙地将抽象与实现解耦，分离出了2个维度（尺子与画笔）并允许其各自延伸和扩展，最终使系统更加松散、灵活，请参看桥接模式的类结构（见图13-7）。</p>
<p>如图13-7所示，我们可以把桥接模式分为“抽象方”与“实现方”2个维度阵营，其中各角色的定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Abstraction（抽象方）：抽象一方的高层接口，多以抽象类形式出现并持有实现方的接口引用，对应本章例程中的画笔类。</span><br><span class="line">■ AbstractionImpl（抽象方实施）：继承自抽象方的具体子类实现，可以有多种实施并在抽象方维度上自由扩展，对应本章例程中的黑色画笔和白色画笔。</span><br><span class="line">■ Implementor（实现方）：实现一方的接口规范，从抽象方中剥离出来成为另一个维度，独立于抽象方并不受其干扰，对应本章例程中的尺子接口。</span><br><span class="line">■ ConcreteImplementor（实现方实施）：实现一方的具体实施类，可以有多个实施并在实现方维度上自由扩展，对应本章例程中的正方形尺子类、三角形尺子类、圆形尺子类。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181522760.png" alt="image-20231018152233659"></p>
<p>经济发展靠分工，系统扩展靠抽离，桥接模式将抽象与实现彻底解耦，使形状与颜色的纠葛终被化解，各自为营，互不侵扰。劳动分工实现了各种产品制造的自由扩展，使其能够在各自维度上达成多态，无限延伸。桥梁作为经贸发展的纽带更是不可或缺，它让贸易双方各尽其能，并达到合作共赢的状态。产业链的形成则使原本的产品再次组合，具备更多的功能。多姿多彩的世界，一定离不开形形色色的自由组合。</p>
<h1 id="行为篇"><a href="#行为篇" class="headerlink" title="行为篇"></a>行为篇</h1><h2 id="第14章-模板方法"><a href="#第14章-模板方法" class="headerlink" title="第14章　模板方法"></a>第14章　模板方法</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310181558047.png" alt="image-20231018155820970"></p>
<p>模板是对多种事物的结构、形式、行为的模式化总结，而模板方法模式(Template Method)则是对一系列类行为（方法）的模式化。我们将总结出来的行为规律固化在基类中，对具体的行为实现则进行抽象化并交给子类去完成，如此便实现了子类对基类模板的套用。</p>
<p>模板方法模式非常类似于定制表格（如本章封面图所示），设计者先将所有需要填写的信息头（字段名）抽取出来，再将它们整合在一起成为一种既定格式的表格，最后让填表人按照这个标准化模板去填写自己特有的信息，而不必为书写内容、先后顺序、格式而感到困扰。</p>
<h3 id="14-1-生存技能"><a href="#14-1-生存技能" class="headerlink" title="14.1 生存技能"></a>14.1 生存技能</h3><p>除了填写表格，我们的现实生活中还有很多模板方法模式的实例，如工作流程、项目管理等。我们先从一个简单的例子开始。如图14-1所示，哺乳动物的生存技能（行为）是多样化的，有的能上天，有的能入海，但都离不开觅食这个过程，如鲸在海里觅食，蝙蝠在空中捕捉昆虫，而人类则可以利用各种交通工具到想去的地方用餐。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181600900.png" alt="image-20231018160010835"></p>
<p>如图14-1所示，既然鲸、人类、蝙蝠都是动物，那么一定得具备动物最基本的生存技能，所以我们建模时要体现其“动”与“吃”这两种本能行为，缺一不可。基于此，我们开始代码实战，先从动物生活之地——大海开始定义鲸类，请参看代码清单14-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181600693.png" alt="image-20231018160027654"></p>
<p>如代码清单14-1所示，鲸类第3行的移动方法move()以游泳的方式展现其移动能力，接着第7行的进食方法eat()则展现其吃鱼这种行为特征，最后第11行的生存方法live()则依次调用前两者，以展现其游动身体捕鱼吃的生存方式。接下来人类以另一种生存方式出现了，请参看代码清单14-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181600527.png" alt="image-20231018160042485"></p>
<p>如代码清单14-2所示，作为高级动物的人类同样需要移动与进食，但人类不能像鲸那样在水下生存，更不会用嘴捕鱼。人类利用自己的聪明才智发明了交通工具，可以在第3行的移动方法move()中开车上路，并且在第7行的进食方法eat()中施展人类最为普遍的生存技能：上班、挣钱、吃饭。至于蝙蝠当然是飞行着才能捉到虫子吃，我们先暂停一下，不急着去实现。</p>
<p>尽管人类的生存技能与鲸不同，但请注意代码第11行的生存方法live()（生存方式）与鲸完全一致。也就是说，无论是鲸还是人类，都必须通过“移动”与“进食”才能活下去，这也是动物必须遵从的基本生存法则。</p>
<h3 id="14-2-生存法则"><a href="#14-2-生存法则" class="headerlink" title="14.2 生存法则"></a>14.2 生存法则</h3><p>从之前的代码中我们可以看到，虽然哺乳动物的生存技能有着天壤之别，但它们的生存方法live()毫无二致。倘若为每种动物都编写一遍同样的方法，必定会造成代码冗余。我们不如将这个生存法则抽离出来，就像表格一样，作为一个通用的模板方法，定义在哺乳动物类中，请参看代码清单14-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181601657.png" alt="image-20231018160136612"></p>
<p>如代码清单14-3所示，哺乳动物类在第3行与第5行分别定义了“移动”与“进食”两种动物本能，利用抽象方法关键字“abstract”声明凡是哺乳动物必须实现这两个行为。接着第7行的生存方法live()则以实体方法的形式出现，这就意味着所有哺乳动物都要以此为模板，这便是我们要抽离出来的模板方法了。可以看到第8行与第9行我们在模板方法中分别调用了move()方法与eat()方法，固化下来的生存法则必须先“移动”再“进食”才能完成“捕食”。此外，我们使用了关键字“final”使此模板方法不能被重写修改。哺乳动物类已经完成，我们得重构之前的鲸类与人类的代码，请参看代码清单14-4、代码清单14-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181605307.png" alt="image-20231018160503258"></p>
<p>如代码清单14-4、代码清单14-5所示，鲸类与人类都继承了哺乳动物基类，较之前的代码更加简单了，它们只需要实现自己独特的生存技能move()与eat()，至于生存方法live()则直接由基类而来。哺乳动物的基因模板得以继承，容不得半点改动。至此，模板方法模式已经构建完成，如果还有其他哺乳动物加入，只需照猫画虎，例如我们未完成的蝙蝠类，请参看代码清单14-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181605368.png" alt="image-20231018160519333"></p>
<p>如代码清单14-6所示，蝙蝠让天空也出现了哺乳动物的身影。至此，哺乳动物遍布海、陆、空，物种更加丰富多样了。最后我们来看在客户端如何让哺乳动物们生龙活虎起来，请参看代码清单14-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181605630.png" alt="image-20231018160536586"></p>
<p>如代码清单14-7所示，哺乳动物统一调用了通用的模板方法live()，以此作为生存法则就能很好地存活下去。可以看到第13行的输出中，动物们都拥有各自的生存技能，在自然环境下各显神通。</p>
<h3 id="14-3-项目管理模板"><a href="#14-3-项目管理模板" class="headerlink" title="14.3 项目管理模板"></a>14.3 项目管理模板</h3><p>模板方法非常简单实用，我们可以让它再包含一些逻辑，就像一套既定的工作流程，来为后人铺路。如图14-2所示，当我们做一些简单的软件项目管理时，常常会采用传统的瀑布模型，这时我们可以把整个项目周期分为5个阶段，分别是需求分析、软件设计、代码开发、质量测试、上线发布。</p>
<p>要以模板方法模式来实现项目管理的瀑布模型，我们首先得定义一个瀑布模型项目管理类，抽象出所有项目阶段以供实体方法调用，请参看代码清单14-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181606528.png" alt="image-20231018160643477"></p>
<p>如代码清单14-8所示，瀑布模型项目管理类从第3行到第11行分别声明了项目管理周期中各阶段的分步抽象方法，其中包括需求分析analyze()、软件设计design()、代码开发develop()、质量测试test()、上线发布release()。这些步骤的实现统统由子类去自由发挥，例如第9行的质量测试方法test()，子类可以进行人工测试，也可以实现自动化测试，此处不必关心这些实现细节。站在项目管理的角度来看，抽象类应该关注的是对大局的操控，把控项目进度，避免造成资源浪费，譬如程序员在没有确立技术框架的情况下就进行代码开发，难免会引入不必要的工作量，可见模板方法的重要性。基于此，我们在代码第13行定义了模板方法，在项目启动方法kickoff()中从宏观上制订了整个项目的固定流程，由第14行开始首先进行需求分析，再交给架构师进行软件设计，接着程序员设计文档进行代码开发或者修改bug的迭代流程，直至测试通过为止，最终上线发布。整个项目的实施阶段被组织起来，充分展现了瀑布模型项目周期。</p>
<p>瀑布模型的模板已经准备就绪，下面轮到具体的项目子类去填补（实现）空缺了。碰巧这时公司决定开发一套人力资源管理系统，由于项目比较简单，预估在一个季度内就能完成，因此项目组决定用瀑布模型进行管理。于是我们果断立项并继承了瀑布模型模板，请参看代码清单14-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181607620.png" alt="image-20231018160721572"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181607190.png" alt="image-20231018160730153"></p>
<p>如代码清单14-9所示，人力资源管理系统项目类继承了瀑布模型项目管理类，并按照项目自身特性实现了所有项目阶段的分步方法，如第18行的开发方法develop()，如果代码包含bug则首先修复，否则开发系统功能，此过程也许会引入新的bug，所以第39行的测试方法test()会发现bug并进行上报，以保证产品质量。更多的实现细节请读者自行思考、实践，我们就不做过多解释了。</p>
<p>除此之外，人力资源管理系统还需要与外部应用进行交互，由于只需要提供几个简单的功能接口，因此项目组决定不分配过多的资源，所有工作都由开发人员完成。项目同样使用瀑布模型模板进行管理，请参看代码清单14-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181608290.png" alt="image-20231018160820238"></p>
<p>如代码清单14-10所示，由于API项目的特殊性，开发人员承担了所有工作，代码逻辑看起来也相对简单。例如在第12行的软件设计方法design()中，开发人员研究了微服务框架并省去了很多代码开发工作，在第18行的开发方法develop()中开发人员一并完成了bug修复及API功能开发工作，第27行的测试方法test()将测试工作交给了自动化测试平台，测试自动化省去了很多人力成本……最后，我们来看项目管理者如何开展这两个项目，请参看代码清单14-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181608506.png" alt="image-20231018160852461"></p>
<p>如代码清单14-11所示，人力资源管理系统项目参与人员更多，开发与测试迭代了几轮后才得以交付上线； API项目则没有耗费太多的资源，大部分工作由开发人员自行完成。虽然这两个项目的具体实施细节有很大区别，但它们的项目管理工作都是从模板中继承而来的，都按照瀑布模型的模板方法来进行。换句话说，各个项目的具体实施方法可以根据项目特性自由发挥，但项目流程的管理规范则必须按照既定模板（模板方法）来实行。</p>
<h3 id="14-4-虚实结合"><a href="#14-4-虚实结合" class="headerlink" title="14.4 虚实结合"></a>14.4 虚实结合</h3><p>总之，模板方法模式可以将总结出来的规律沉淀为一种既定格式，并固化于模板中以供子类继承，对未确立下来的步骤方法进行抽象化，使其得以延续、多态化，最终架构起一个平台，使系统实现在不改变预设规则的前提下，对每个分步骤进行个性化定义的目的。下面我们来拆解模板方法模式的类结构，如图14-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181611266.png" alt="image-20231018161125197"></p>
<p>模板方法模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">■ AbstractClass（抽象基类）：定义出原始操作步骤的抽象方法(primitiveOperation)以供子类实现，并作为在模板方法中被调用的一个步骤。此外还实现了不可重写的模板方法，其可将所有原始操作组织起来成为一个框架或者平台。对应本章例程中的瀑布模型项目管理类PM。</span><br><span class="line">■ ConcreteClassA、ConcreteClassB（实现类A、实现类B）：继承自抽象基类并且对所有的原始操作进行分步实现，可以有多种实现以呈现每个步骤的多样性。对应本章例程中的人力资源管理系统项目类HRProject 、API项目类APIProject。</span><br></pre></td></tr></table></figure>
<p>模板方法模式巧妙地结合了抽象类虚部方法与实部方法，分别定义了可变部分与不变部分，其中前者留给子类去实现，保证了系统的可扩展性；而后者则包含一系列对前者的逻辑调用，为子类提供了一种固有的应用指导规范，从而达到虚中带实、虚实结合的状态。正所谓“人法地、地法天、天法道、道法自然”，虚实结合、刚柔并济才能灵活且不失规范。</p>
<h2 id="第15章-迭代器"><a href="#第15章-迭代器" class="headerlink" title="第15章　迭代器"></a>第15章　迭代器</h2><p>迭代，在程序中特指对某集合中各元素逐个取用的行为。迭代器模式(Iterator)提供了一种机制来按顺序访问集合中的各元素，而不需要知道集合内部的构造。换句话讲，迭代器满足了对集合迭代的需求，并向外部提供了一种统一的迭代方式，而不必暴露集合的内部数据结构。</p>
<h3 id="15-1-物以类聚"><a href="#15-1-物以类聚" class="headerlink" title="15.1 物以类聚"></a>15.1 物以类聚</h3><p>迭代的过程是基于一系列数据展开的，所以集合是不得不提的概念。物以类聚，集合是由一个或多个确定的元素构成的整体，其实就是把一系列类似的元素按某种数据结构集结起来，作为一个整体来引用，以便于维护。简单来讲，可以把集合理解为“一堆”或者“一群”类似的元素集结起来的整体。为了承载不同的数据形式，集合类提供了多种多样的数据结构，如我们常用的ArrayList、HashSet、HashMap等，具体分类结构如图15-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181616543.png" alt="image-20231018161624496"></p>
<p>每种集合都有不同的特性，可以满足对各种数据结构的承载需求。有了集合才会产生对其迭代的需求，而每种数据结构的迭代方式又不尽相同，所以，定义标准化的迭代器势在必行，以提供统一、通用的使用方法。</p>
<h3 id="15-2-循环往复"><a href="#15-2-循环往复" class="headerlink" title="15.2 循环往复"></a>15.2 循环往复</h3><p>遍历是一种周而复始的体现。生活中也有很多这样的场景，例如生产线上对每件产品加工过程的重复，再如读书时对每一页的翻阅动作的重复。为了达到遍历的目的，对元素的迭代是必不可少的。而迭代器则可以帮助我们对当前状态进行自动记录，并提供获取下一个元素的方法。如图15-2所示，书是由很多页元素组成的集合，我们读书时通常是从前往后翻阅，这时页码会按翻阅顺序逐步增大，如此才能将书页连接起来以保证内容的连续性和完整性，这个过程就可以被看作对整本书的迭代遍历。</p>
<p>在我们的阅读过程中，有时会用到一些工具来记录我们的阅读状态，例如大家常常用到的书签，我们会将它夹在书页中标记当前的阅读位置，下次阅读时就不会忘记上次读到哪一页了。从某种程度上讲，书签有点类似于迭代器的角色，它记录着读者访问书页的迭代状态。</p>
<p>当然，不迭代也是可以进行遍历的，但会不可避免地产生大量重复代码。我们先来看一个反例，仍以读书为例，我们来看如何不使用迭代方式来遍历全书，请参看代码清单15-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181618476.png" alt="image-20231018161803433"></p>
<p>如代码清单15-1所示，基于常见的ArrayList作为页的集合，我们可以看到这是一本100页的书。第24行的阅读方法read()的确对全书进行了遍历，但其中除了页码不同，每行代码完全是一模一样的，如此重复且硬编码的遍历方式绝对是不可取的。所以我们改用循环迭代的方式进行遍历，如此不但能大量减少代码量，而且不必考虑书页数量，最终同样能达到遍历全书的目的。下面我们可用foreach循环来完成这个任务，请参看代码清单15-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181619569.png" alt="image-20231018161909523"></p>
<h3 id="15-3-遍历标准化"><a href="#15-3-遍历标准化" class="headerlink" title="15.3 遍历标准化"></a>15.3 遍历标准化</h3><p>不同的数据结构需要不同的集合类，而针对不同的集合类的迭代方式也不尽相同，如for、foreach、while，甚至Java8引入的流式遍历等。举个例子，我们可以使用传统的for循环对List集合进行迭代遍历，而对于Set集合，for循环就无能为力了，这是因为Set本身集合不存在index索引号，所以必须用foreach循环（迭代器Iterator）进行遍历。难道就没有一种通用的迭代标准，能让调用者使用统一的方式进行遍历吗？如果我们深究源码就会发现，Collection接口中有这样一个接口，请参看代码清单15-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181619503.png" alt="image-20231018161957471"></p>
<p>如代码清单15-3所示，这是Collection接口的一段源码，可以看到其明确声明了获取迭代器的接口iterator()，通过调用这个接口就可以返回标准的迭代器对象。既然有了这种标准，那么Collection这集合类就可以实现自己的迭代器。而Map集合也可以按照同样的方式，从其EntrySet中获取迭代器。可见，标准化的迭代器其实已经被各种集合类实现了，否则用户就无法站在Collection接口的抽象高度上对任何集合进行统一遍历。</p>
<p>举一个形象的例子，如图15-3所示，作为一种拥有特殊数据结构的集合，弹夹可以容纳多颗子弹。向弹夹内装填子弹与压栈操作非常类似，而射击则类似于出栈操作。首先要弹出最后一次装填的子弹，子弹发射后再弹出下一颗子弹，直到弹出装填的第一颗子弹为止，最后弹夹被清空，遍历结束。这与栈集合“先进后出，后进先出”的数据结构如出一辙。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181620510.png" alt="image-20231018162026467"></p>
<p>除了这些，弹夹的结构其实还有很多种，不同的数据结构使它们的迭代逻辑也有所不同。而站在枪支的角度看（集合的使用者），它对弹夹的内部构造一无所知，因此将各种弹夹的遍历方式标准化就显得非常重要。于是我们就需要让所有弹夹都提供标准统一的迭代接口，这样枪支与其对接后只需简单地调用接口就能取出下一颗子弹了，以此遍历直到取空为止。从逻辑层面上讲，遍历方式的标准化使枪支可以使用任何类型的弹夹。</p>
<h3 id="15-4-分离迭代器"><a href="#15-4-分离迭代器" class="headerlink" title="15.4 分离迭代器"></a>15.4 分离迭代器</h3><p>在15.3节的例程中，我们使用了比较普遍的数据结构ArrayList，它是JDK自带的集合类实现，所以我们能够顺理成章地使用标准迭代方式进行遍历。倘若我们需要新定义一个特殊的集合类，那么该如何进行迭代呢？下面我们来挑战一个比较复杂的数据结构，其迭代器的实现一定会更加有趣。</p>
<p>如图15-4所示，汽车前挡风玻璃上安装了一台行车记录仪，它最主要的一项功能就是记录行驶路途中所拍摄的视频信息，以防发生交通事故后作为证据之用。我们知道，行车记录仪所记录下来的视频文件是比较大的，同时其存储空间又是有限的，那么它是怎样确保一直不间断地录制视频，并且存储空间不被占满呢？这就需要我们深究其内部数据结构了。</p>
<p>其实，行车记录仪的视频录制存盘操作有循环覆写的特性，待空间不够用时，新录的视频就会覆盖最早的视频，以首尾相接的环形结构来解决存储空间有限的问题。好，我们开始构建这个数据模型，首先定义一个行车记录仪类，请参看代码清单15-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181621609.png" alt="image-20231018162155565"></p>
<p>如代码清单15-4所示，假设行车记录仪的存储空间只够存储10条视频，我们首先在第4行定义了一个原始的字符串数组records，用来模拟视频记录，并在第3行用一个索引index来标记当前记录所在位置。当用户调用第6行的append()方法插入视频之前，我们得先看空间有没有满，如果满了就把索引调整到起始位置再记录视频，也就是覆盖索引第一个位置的视频，否则将索引加1覆盖下一条视频。视频循环覆盖逻辑已经完成了，为了给用户显示，我们提供了两个显示方法：一个是第15行的display()方法，可以按默认数组顺序显示；另一个是第21行的displayByOrder()方法，可以根据用户习惯从新到旧地显示内容。此处循环逻辑有些复杂，但不是我们的关注重点，读者可以略过。下面客户端开始使用这个行车记录仪了，请参看代码清单15-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181622406.png" alt="image-20231018162224327"></p>
<p>如代码清单15-5所示，客户端一共记录了12条视频，超出了行车记录仪存储空间的最大容量数（10条视频），这会不会导致行车记录仪存储空间的溢出异常呢？实践出真知，我们在第9行调用了它的显示方法display()，正如运行结果显示，“视频_10”和“视频_11”这2条视频先后分别覆盖了最早记录下来的“视频_0”和“视频_1”，一切如愿，行车记录仪的循环覆盖机制工作正常。</p>
<p>然而，我们只实现了简单的显示功能，如果用户需要使用集合中的原始数据，该如何遍历所有记录呢？我们提供的接口貌似过于死板，可扩展性不够。有读者可能会说，直接将数据记录records暴露出去给用户不就可以了吗？如此简单粗暴的做法确实能达到目的，但是这会严重破坏行车记录仪的数据逻辑封装。用户对索引位置等内部状态信息一无所知，也不会进行维护，如果用户随意对数据进行增加或删除就会导致索引位置错乱，再继续记录很可能会覆盖最新、最重要的视频信息，导致用户数据安全无法得到保证。</p>
<p>看来定义迭代器是有必要的，如此我们不但可以避免用户随意操作而导致的内部逻辑混乱，还能提供给用户更方便、统一的数据遍历接口。我们知道，集合只是一个数据的容器，不应该对数据的迭代负责，所以我们应该将迭代逻辑抽离出来，独立于迭代器中。下面我们来定义迭代器接口，请参看代码清单15-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181623252.png" alt="image-20231018162341220"></p>
<p>如代码清单15-6所示，迭代器接口中只定义了两个功能接口，其中第3行的next()方法用于返回下一个元素，而第5行的hasNext()方法用于询问迭代器是否还有下一个元素，此处我们做了适度简化，当然直接使用Java工具包util中自带的Iterator接口也是可以的。接下来我们就要对之前的行车记录仪进行重构了，首先我们让它实现JDK提供的接口Iterable（代码比较简单，我们就不亲自写了，读者可以自行查看源码），使其拥有创建迭代器iterator的能力，请参看代码清单15-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181624192.png" alt="image-20231018162403109"></p>
<p>如代码清单15-7所示，行车记录仪类在第16行实现了Iterable接口的iterator()方法，并实例化一个迭代器并返回客户端。接着我们在第20行以内部类的形式实现了行车记录仪的迭代器，这样就能使迭代器轻松访问行车记录仪的私有数据集，并同时达到了迭代器与集合分离的目的。迭代器实现的重点在于第21行定义的迭代器游标cursor，我们将其初始化为集合索引的位置，二者相对独立，自此再无瓜葛。接着是对迭代器接口标配的2个方法hasNext()与next()的实现，相较于重构之前，代码看起来简单多了，相信读者可以轻松理解，我们就不赘述了。最后，客户端可以进行遍历了，请参看代码清单15-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181624124.png" alt="image-20231018162429080"></p>
<p>如代码清单15-8所示，依然假设行车记录仪记录了12条视频，在用户对视频集进行遍历前首先于第15行获取迭代器，然后利用迭代器Iterator的hasNext()方法作为while循环的条件，如果有下一条数据则继续迭代，否则结束遍历。循环体内我们调用迭代器的next()方法获取下一条数据进行处理，直至循环结束。可以看到，第21行用户将“视频_10”与“视频_8”复制至U盘作为证据，最终在第42行成功输出结果。</p>
<p>至此，我们实现的迭代器已经基本完成，用户不但可以使用Iterator进行迭代，而且foreach循环也得到了支持，用户再也不必为捉摸不定的迭代方式而犯愁了。当然，为保持简单，我们并没有实现迭代器的所有功能接口，例如对remove()功能接口的实现，利用这个接口用户便可以删除视频记录了。读者可以在此基础上继续代码实践，需要注意的是对迭代器游标的控制。</p>
<h3 id="15-5-鱼与熊掌兼得"><a href="#15-5-鱼与熊掌兼得" class="headerlink" title="15.5 鱼与熊掌兼得"></a>15.5 鱼与熊掌兼得</h3><p>最后，我们来整理一下集合迭代器的整个实现过程。为了完成对各种集合类的遍历，我们定义了统一的迭代器接口Iterator，基于此我们让集合以内部类的方式实现其特有的迭代逻辑，再将自己标记为Iterable并返回迭代器实例，以证明自己是具备迭代能力的。具体的集合内部结构与迭代逻辑对于客户端这个“局外人”是透明的，客户端只需要知道这个集合是可以迭代的，并向集合发起迭代请求以获取迭代器即可以进行标准方式的遍历了。我们来看迭代器模式的类结构，如图15-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181625630.png" alt="image-20231018162527580"></p>
<p>迭代器模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">■ Aggregate（集合接口）：集合标准接口，一种具备迭代能力的指标。对应本章例程中的Iterable接口。</span><br><span class="line">■ ConcreteAggregate（集合实现）：实现集合接口Aggregate的具体集合类，可以实例化并返回一个迭代器以供外部使用。对应本章例程中的行车记录仪类DrivingRecorder。</span><br><span class="line">■ Iterator（迭代器接口）：迭代器的接口标准，定义了进行迭代操作所需的一些方法，如next()、hasNext()等。</span><br><span class="line">■ ConcreteIterator（迭代器实现）：迭代器接口Iterator的具体实现类，记录迭代状态并对外部提供所有迭代器功能的实现。</span><br><span class="line">■ Client（客户端）：集合数据的使用者，需要从集合获取迭代器再进行遍历。</span><br></pre></td></tr></table></figure>
<p>对于任何类型的集合，要防止内部机制不被暴露或破坏，以及确保用户对每个元素有足够的访问权限，迭代器模式起到了至关重要的作用。迭代器巧妙地利用了内部类的形式与集合类分离，然则“藕断丝连”，迭代器依然对其内部的元素保有访问权限，如此便促成了集合的完美封装，在此基础上还提供给用户一套标准的迭代器接口，使各种繁杂的遍历方式得以统一。迭代器模式的应用，能在内部事务不受干涉的前提下，保持一定的对外部开放，让我们“鱼与熊掌兼得”。</p>
<h2 id="第16章-责任链"><a href="#第16章-责任链" class="headerlink" title="第16章　责任链"></a>第16章　责任链</h2><p>责任链是由很多责任节点串联起来的一条任务链条，其中每一个责任节点都是一个业务处理环节。责任链模式(Chain of Responsibility)允许业务请求者将责任链视为一个整体并对其发起请求，而不必关心链条内部具体的业务逻辑与流程走向，也就是说，请求者不必关心具体是哪个节点起了作用，总之业务最终能得到相应的处理。在软件系统中，当一个业务需要经历一系列业务对象去处理时，我们可以把这些业务对象串联起来成为一条业务责任链，请求者可以直接通过访问业务责任链来完成业务的处理，最终实现请求者与响应者的解耦。</p>
<h3 id="16-1-简单的生产线"><a href="#16-1-简单的生产线" class="headerlink" title="16.1 简单的生产线"></a>16.1 简单的生产线</h3><p>倘若一个系统中有一系列零散的功能节点，它们都负责处理相关的业务，但处理方式又各不相同。这时客户面对这么一大堆功能节点可能无从下手，根本不知道选择哪个功能节点去提交请求，返回的结果也许只是个半成品，还得再次提交给下一个功能节点，处理过程相当烦琐。虽然从某种角度看，每个功能节点均承担各自的义务，分工明确、各司其职，但从外部来看则显得毫无组织，团队犹如一盘散沙。所以为了更高效、更完整地解决客户的问题，各节点一定要发扬团队精神，利用责任链模式组织起来，形成一个有序、有效的业务处理集群，为客户提供更方便、更快捷的服务。</p>
<p>以最简单的责任链举例，汽车生产线的制造流程就使用了这种模式。首先我们进行劳动分工，将汽车零件的安装工作拆分并分配给各安装节点，责任明确划分；然后架构生产线，将安装节点组织起来，首尾相接，规划操作流程；最终，通过生产线的传递，汽车便从零件到成品得以量产，生产效率大大提升</p>
<p>如图16-1所示，我们将汽车生产线从左至右分为3个功能节点，其中A节点负责组装车架、安装车轮；B节点负责安装发动机、油箱、传动轴等内部机件；C节点进行组装外壳、喷漆等操作，这样将产品逐级传递，每经过一个节点就完成一部分工作，最终完成产品交付。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181630586.png" alt="image-20231018163050542"></p>
<h3 id="16-2-工作流程拆分"><a href="#16-2-工作流程拆分" class="headerlink" title="16.2 工作流程拆分"></a>16.2 工作流程拆分</h3><p>生产线的例子其实相对机械、简单，我们来看一个带有一些逻辑的责任链：报销审批流程。公司为了更高效、安全规范地把控审核工作，通常会将整个审批工作过程按负责人或者工作职责进行拆分，并组织好各个环节中的逻辑关系及走向，最终形成标准化的审批流程，如图16-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181631520.png" alt="image-20231018163149471"></p>
<p>如图16-2所示，审批流程需要依次通过财务专员、财务经理、财务总监的审批。如果申请金额在审批人的审批职权范围内则审批通过并终止流程，反之则会升级至更高层级的上级去继续审批，直至最终的财务总监，如果仍旧超出财务总监的审批金额则驳回申请，流程终止。</p>
<p>我们思考一下该如何设计这个审批流程，如果将业务逻辑写在一个类中去完成，还不至于太烦琐，但是如果需要进一步修改审批流程，我们就必须不断地更改这段逻辑代码，导致可扩展性、可维护性变差，完全谈不上任何设计。因此，我们有必要首先按角色对业务进行拆分，将不同的业务代码放在不同的角色类中，如此达到职权分拆的目的，可维护性也能得到提高。</p>
<h3 id="16-3-踢皮球"><a href="#16-3-踢皮球" class="headerlink" title="16.3 踢皮球"></a>16.3 踢皮球</h3><p>基于图16-2的审批流程图，我们来做一个简单的实例。假设某公司的报销审批流程有3个审批角色，分别是财务专员（1000元审批权限）、财务经理（5000元审批权限）以及财务总监（10000元审批权限），依次对应代码清单16-1，代码清单16-2以及代码清单16-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181633126.png" alt="image-20231018163345085"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181634796.png" alt="image-20231018163406757"></p>
<p>以代码清单16-3为例，第9行定义了财务总监类CFO的审批方法approve()并接受要审批的金额，如果金额在10000元以内则审批通过，否则驳回此申请。3个审批角色的代码都比较类似，只要超过其审批金额的权限就驳回申请，反之则审批通过。接下来，客户端开始提交申请了，请参看代码清单16-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181635877.png" alt="image-20231018163516836"></p>
<p>如代码清单16-4所示，第19行的处理结果显示审批通过，10000元的大额报销单终于被总监审批了。然而这种办事效率确实不敢恭维，申请人先找专员被升级处理，再找经理又被告知数额过大得去找总监，来来回回找了3个审批人处理，浪费了申请人的大量时间与精力。虽然事情是办理了，但申请人非常不满意，审批流程太过烦琐，总觉得有种被踢皮球的感觉。</p>
<p>如果我们后期为了优化和完善这个业务流程而添加新的审批角色，或者进一步增加更加复杂的逻辑，那么情况就会变得更糟。申请人不得不跟着学习这个流程，不停修改自己的申请逻辑，无形中增加了维护成本。</p>
<p>但是对审批人来说，他们只能负责自己职权范围内的业务，否则就是越权，所以处理不了的只能让申请人去找上级。问题到底出在哪里？其实这一切都是工作流架构设计不合理导致的。</p>
<h3 id="16-4-架构工作流"><a href="#16-4-架构工作流" class="headerlink" title="16.4 架构工作流"></a>16.4 架构工作流</h3><p>缺少架构的流程不是完备的工作流，否则申请人终将被淹没在一堆复杂的审批流程中。要完全解决申请人与审批人之间的矛盾，我们必须对现有代码进行重构。</p>
<p>经过观察代码清单16-4中的审批流程逻辑，我们可以发现审批人的业务之间有环环相扣的关联，对于超出审批人职权范围的申请会传递给上级，直到解决问题为止。这种传递机制就需要我们搭建一个链式结构的工作流，这也是责任链模式的精髓之所在。基于这种思想，我们来重构审批人的代码，请参看代码清单16-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181639118.png" alt="image-20231018163900076"></p>
<p>如代码清单16-5所示，我们用抽象类来定义审批人。由于审批人在无权审批时需要传递业务给其上级领导，因此我们在第4行定义上级领导的引用nextApprover，与下一位审批人串联起来，同时将其注入第10行。当然，每位审批人的角色不同，其审批逻辑也有所区别，所以我们在第15行对审批方法进行抽象，交由具体的子类审批角色去继承和实现。我们接着对3个审批角色的代码进行重构，请分别参看代码清单16-6、代码清单16-7、代码清单16-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181640892.png" alt="image-20231018164004845"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181640058.png" alt="image-20231018164013012"></p>
<p>如代码清单16-6所示，财务专员类继承了审批人抽象类并实现了审批方法approve()，接收到报销申请金额后自第9行开始申明自己的审批权限为1000元，若超出则调用自己上级领导的审批方法，将审批业务传递下去，注意第13行对nextApprover的巧妙引用。代码清单16-7中的财务经理类则大同小异，其审批权限上升至5000元。比较特殊的审批人是责任链末节点的财务总监类，如代码清单16-8第12行所示，最高职级的财务总监CFO的审批逻辑略有不同，当申请金额超出10000元后就再有下一个审批人了，所以此时就会驳回报销申请。一切就绪，是时候生成这条责任链了，请参看代码清单16-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181643645.png" alt="image-20231018164303596"></p>
<p>如代码清单16-9所示，一开始我们在第4行构造了财务专员，接着组装了责任链（其实这里还可以交给工作流工厂去构造责任链，读者可以自行实践练习），由低到高逐级进行审批角色对象的注入，直至财务总监。申请人的业务办理流程就非常简单了，客户端直接面对的就是财务专员，只需将申请递交给他处理，接着审批流程奇迹般地启动了，业务在这个责任链上层层递交，直至完成。请从代码第9行开始查看各种不同金额的审批场景对应的办理流程，从输出看出达到了工作流的预期运行结果。</p>
<h3 id="16-5-让业务飞一会儿"><a href="#16-5-让业务飞一会儿" class="headerlink" title="16.5 让业务飞一会儿"></a>16.5 让业务飞一会儿</h3><p>至此，以责任链模式为基础架构的工作流搭建完成，各审批角色只需要定义其职权范围内的工作，再依靠高层抽象实现角色责任的链式结构，审批逻辑得以拆分、串联，让业务申请在责任链上逐级传递。如此一来，申请人再也不必关心业务处理细节与结果了，彻底将工作流或业务逻辑抛开，轻松地将申请递交给责任链入口即可得到最终结果。下面我们来看责任链模式的类结构，如图16-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181644282.png" alt="image-20231018164425232"></p>
<p>责任链模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Handler（业务处理者）：所有业务处理节点的顶层抽象，定义了抽象业务处理方法handle()并留给子类实现，其实体方法setSuccessor()（注入继任者）则用于责任链的构建。对应本章例程中的审批人Approver。</span><br><span class="line">■ ConcreteHandler1、ConcreteHandler2……（业务处理者实现类）：实际业务处理的实现类，可以有任意多个，每个都实现了handle()方法以处理自己职权范围内的业务，职权范围之外的事则传递给下一位继任者（另一个业务处理者）。对应本章例程中的财务专员类Staff、财务经理类Manager、财务总监类CFO。</span><br><span class="line">■ Client（客户端）：业务申请人，只需对业务链条的第一个入口节点发起请求即可得到最终响应。</span><br></pre></td></tr></table></figure>
<p>责任链模式的本质是处理某种连续的工作流，并确保业务能够被传递至相应的责任节点上得到处理。当然，责任链也不一定是单一的链式结构，我们甚至可以让一位审批人将业务传递给多位审批人，或是加入更复杂的业务逻辑以完善工作流，最终使不同的业务有不同的传递方向。不管是何种形式的呈现，读者都要能够根据具体的业务场景，更灵活、恰当地运用责任链模式，而不是照本宣科、生搬硬套。</p>
<p>对责任链模式的应用让我们一劳永逸，之后我们便可以泰然自若地应对业务需求的变更，方便地对业务链条进行拆分、重组，以及对单独节点的增、删、改。结构松散的业务处理节点让系统具备更加灵活的可伸缩性、可扩展性。责任链模式让申请方与处理方解耦，申请人可以彻底从业务细节中解脱出来，无论多么复杂的审批流程，都只需要简单的等待，让业务在责任链上飞一会儿。</p>
<h2 id="第17章-策略"><a href="#第17章-策略" class="headerlink" title="第17章　策略"></a>第17章　策略</h2><p>策略，古时也称“计”，指为了达成某个目标而提前策划好的方案。但计划往往不如变化快，当目标突变或者周遭情况不允许实施某方案的时候，我们就得临时变更方案。策略模式(Strategy)强调的是行为的灵活切换，比如一个类的多个方法有着类似的行为接口，可以将它们抽离出来作为一系列策略类，在运行时灵活对接，变更其算法策略，以适应不同的场景。    </p>
<p>例如我们经常在电影中看到，特工在执行任务时总要准备好几套方案以应对突如其来的变化。实施过程中由于情况突变而导致预案无法继续实施A计划时，马上更换为B计划，以另一种行为方式达成目标。所以说提前策划非常重要，而随机应变的能力更是不可或缺，系统需要时刻确保灵活性、机动性才能立于不败之地。</p>
<h3 id="17-1-“顽固不化”的系统"><a href="#17-1-“顽固不化”的系统" class="headerlink" title="17.1 “顽固不化”的系统"></a>17.1 “顽固不化”的系统</h3><p>一个设计优秀的系统，绝不能来回更改底层代码，而是要站在高层抽象的角度构筑一套相对固化的模式，并能使新加入的代码以实现类的方式接入系统，让系统功能得到无限的算法扩展，以适应用户需求的多样性。</p>
<p>我们先从一个反例开始，了解一个有设计缺陷的系统。流行于20世纪80年代的便携式掌上游戏机的系统设计非常简单，最常见的是“俄罗斯方块”游戏机，如图17-1所示。这种游戏机只能玩一款游戏，所以玩家逐渐减少，最终退出了市场。这是一种嵌入式系统设计，主机不包含任何操作系统。制造商只是简单地将软件固化在游戏机芯片中，造成游戏（软件）与游戏机（硬件）的强耦合。玩家要想换个游戏就得再购买一台游戏机，严重缺乏可扩展性。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181650035.png" alt="image-20231018165010976"></p>
<p>如图17-1所示，与这种耦合性极高的系统设计类似的还有计算器，它只能用于简单的数学运算，算法功能到此为止，没有后续扩展的可能性。我们就以计算器为例，探讨一下这种设计存在的问题。假设计算器可以进行加减法运算，请参看代码清单17-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181650742.png" alt="image-20231018165033707"></p>
<p>如代码清单17-1所示，我们分别为计算器类定义了加减法，看上去简单易懂。然而随着算法的不断增加，如乘法、除法、乘方、开方等，我们不得不把机器拆开，然后对代码进行修改。当然，对计算器这种嵌入式系统来说，这么做也无可厚非，毕竟其功能有限且相对固定，但若换作一个庞大的系统，反复的代码修改会让系统维护变成灾难，最终大量的方法被堆积在同一个类中，臃肿不堪。如图17-2所示，反复对系统的修改、加装，致使模块间的调用关系错综复杂，系统维护与升级工作变得举步维艰，无从下手。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181651284.png" alt="image-20231018165107213"></p>
<h3 id="17-2-游戏卡带"><a href="#17-2-游戏卡带" class="headerlink" title="17.2 游戏卡带"></a>17.2 游戏卡带</h3><p>通过分析和对比代码清单17-1中的计算器类，我们不难发现，不管是何种算法（加、减、乘、除等），都属于运算。从外部来看，它们都是基于对两个数字型入参的运算接口，并能返回数字型的运算结果。既然如此，不如把这些算法抽离出来，使它们独立于计算器，并各自封装，让一种算法对应一个类，要使用哪种算法时将其接入即可，如此算法扩展便得到了保证。这种设计上的演变不正类似于从嵌入式掌上游戏机到可插卡式游戏机的演变吗？如图17-3所示，不同种类的游戏卡带就像各种独立的策略类，只要为游戏机更换不同的卡带就能带来全新体验，这也是这种设计思想可以一直延续至今的原因（想象一下操作系统与应用软件的关系）。</p>
<p>策略与系统分离的设计看起来非常灵活，基于这种设计思想，我们对计算器类进行重构。首先要对一系列的算法进行接口抽象，也就是为所有的算法（加法、减法或者即将加入的其他算法）定义一个统一的算法策略接口，请参看代码清单17-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181652684.png" alt="image-20231018165234653"></p>
<p>如代码清单17-2所示，为保持简单，我们假设算法策略接口的参数与返回结果都是整数，接收参数为操作数a与被操作数b，通过运算后返回结果。算法策略接口定义完毕，顺理成章，我们接着分别定义加法策略、减法策略对应的实现类，请参看代码清单17-3、代码清单17-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181653205.png" alt="image-20231018165305164"></p>
<p>如代码清单17-3、代码清单17-4所示，加法策略类与减法策略类都实现了算法策略接口，并分别实现了自己特有的运算方法calculate()。理所当然，第5行加法策略实现的是加法运算，减法策略实现的是减法运算。可以看到，算法策略接口Strategy的标准规范化使它们同属一系，但又以类划分，相对独立。接下来就可以使用这一系列算法策略了，我们对计算器类进行重构，使其能够将算法策略注入系统，请参看代码清单17-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181653661.png" alt="image-20231018165346623"></p>
<p>如代码清单17-5所示，计算器类里已经不存在具体的加减法运算实现了，取而代之的是第10行对算法策略接口strategy的计算方法calculate()的调用，而具体使用的是哪种算法策略则完全取决于第5行的setStrategy()方法。它可以将具体的算法策略注入进来，所以对于第9行的获取结果方法getResult()，注入不同的算法策略将会得到不同的响应结果。至此，策略应用系统搭建完成，下面我们就可以使用这个计算器了，请参看代码清单17-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181655423.png" alt="image-20231018165544347"></p>
<p>如代码清单17-6所示，从第4行开始，客户端类对计算器类进行实例化，接着注入加法策略实现，并调用getResult()方法，此时进行的是“1 + 1”的运算并得到结果2。接着再注入减法策略实现，此时进行的是“1 - 1”的运算并得到计算结果0。</p>
<p>显而易见，通过重构的计算器类变得非常灵活，不管进行哪种运算，我们只需注入相应的算法策略即可得到结果。此外，今后若要进行功能扩展，只需要新增兼容策略接口的算法策略类（如乘法、除法等），这与插卡式游戏机的策略如出一辙，我们不必再对系统做任何修改便可实现功能的无限扩展。</p>
<h3 id="17-3-万能的USB接口"><a href="#17-3-万能的USB接口" class="headerlink" title="17.3 万能的USB接口"></a>17.3 万能的USB接口</h3><p>不知读者是否记得，我们曾在第1章中提到过策略模式，并以计算机USB接口为例做过相关的探讨。下面我们补全这个例子的代码部分，彻底理解策略模式，首先参看图17-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181656260.png" alt="image-20231018165633207"></p>
<p>相信大家对图17-4中的计算机、USB接口还有各种设备之间的关系以及使用方法都非常熟悉了，这些模块组成的系统正是策略模式的最佳范例。与之前的计算器实例类似，首先我们定义策略接口，对应本例中的USB接口，请参看代码清单17-7</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181657809.png" alt="image-20231018165701778"></p>
<p>如代码清单17-7所示，依旧为了保持简单，我们只为USB接口定义一个读取数据方法read()。接下来就是各种USB设备的策略实现类了，其中键盘、鼠标及摄像头分别定义各自的实现类，请分别参看代码清单17-8、代码清单17-9和代码清单17-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181657738.png" alt="image-20231018165744693"></p>
<p>如代码清单17-8、代码清单17-9、代码清单17-10所示，所有USB设备都在第5行实现了USB接口的读取数据方法read()，如键盘设备捕获的是键盘指令数据，鼠标设备捕获的是坐标与点击指令数据，摄像头设备捕获的是视频流数据。最后，我们需要将它们与计算机主机进行接驳，请参看代码清单17-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181658215.png" alt="image-20231018165818181"></p>
<p>如代码清单17-11所示，计算机主机让插入设备模块成为可能，可以看到在代码第3行我们将USB接口“焊接”在计算机主机上，使其成为计算机的一个属性，接着在第5行对外暴露setUSB()方法，用以接驳插入的USB设备对象，最后在第9行的compute()方法中，我们调用了插入设备的读取数据方法read()。一切就绪，我们来看客户端如何使用，请参看代码清单17-12。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181658870.png" alt="image-20231018165846826"></p>
<p>如代码清单17-12所示，客户端首先实例化了计算机主机，接着分别插入键盘、鼠标及摄像头，并调用计算机的compute()方法。从第17行开始的输出结果显示，当客户端插入不同的USB设备时，计算机主机也会做出不同的行为响应。</p>
<p>我们通过对计算机USB接口的标准化，使计算机系统拥有了无限扩展外设的能力，需要什么功能只需要购买相关的USB设备。可见在策略模式中，USB接口起到了至关重要的解耦作用。如果没有USB接口的存在，我们就不得不将外设直接“焊接”在主机上，致使设备与主机高度耦合，系统将彻底丧失对外设的替换与扩展能力</p>
<h3 id="17-4-即插即用"><a href="#17-4-即插即用" class="headerlink" title="17.4 即插即用"></a>17.4 即插即用</h3><p>策略模式让策略与系统环境彻底解耦，通过对算法策略的抽象、拆分，再拼装、接入外设，使系统行为的可塑性得到了增强。策略接口的引入也让各种策略实现彻底解放，最终实现算法分立，即插即用。请参看如下策略模式的类结构，如图17-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181659815.png" alt="image-20231018165930766"></p>
<p>策略模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Strategy（策略接口）：定义通用的策略规范标准，包含在系统环境中并声明策略接口标准。对应本章例程中的USB接口USB。</span><br><span class="line">■ ConcreteStrategyA、ConcreteStrategyB、ConcreteStrategyC……（策略实现）：实现了策略接口的策略实现类，可以有多种不同的策略实现，但都得符合策略接口定义的规范。对应本章例程中的USB键盘类Keyboard、USB鼠标类Mouse、USB摄像头类Camera。</span><br><span class="line">■ Context（系统环境）：包含策略接口的系统环境，对外提供更换策略实现的方法setStrategy()以及执行策略的方法executeStrategy()，其本身并不关心执行的是哪种策略实现。对应本章例程中的计算机主机类Computer。</span><br></pre></td></tr></table></figure>
<p>变化是世界的常态，唯一不变的就是变化本身。拥有顺势而为、随机应变的能力才能立于不败之地。策略模式的运用能让系统的应变能力得到提升，适应随时变化的需求。接口的巧妙运用让一系列的策略可以脱离系统而单独存在，使系统拥有更灵活、更强大的“可插拔”扩展功能。</p>
<h2 id="第18章-状态"><a href="#第18章-状态" class="headerlink" title="第18章　状态"></a>第18章　状态</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310181700078.png" alt="image-20231018170018000"></p>
<p>状态指事物基于所处的状况、形态表现出的不同的行为特性。状态模式(State)构架出一套完备的事物内部状态转换机制，并将内部状态包裹起来且对外部不可见，使其行为能随其状态的改变而改变，同时简化了事物的复杂的状态变化逻辑。</p>
<h3 id="18-1-事物的状态"><a href="#18-1-事物的状态" class="headerlink" title="18.1 事物的状态"></a>18.1 事物的状态</h3><p>面向对象最基本的特性——“封装”是对现实世界中事物的模拟，类封装了属性与方法，其被实例化后的对象属性则体现出某种状态，以至调用其方法时会展现出某种相应的行为，这一切都与状态脱不了干系。以我们赖以生存的水举例，它有3种形态，如图18-1（左）所示，0℃以下的固态冰、常温下的液态水，以及100℃以上的气态水蒸气。我们可以总结出，当温度变化导致水的状态发生变化时，它就会有不同的行为，如冰会滚动、水会流动、水蒸气则会漂浮。</p>
<p>事物状态的变化驱动机制是非常普遍的存在。人类更是无法逾越自然界的常规，如图18-1（右）所示，人类的情感状态更加复杂多变，不同的心态会表现出不同的行为，如高兴时会欢笑，悲伤时会哭泣，愤怒时会责备，兴奋时会手舞足蹈……喜怒哀乐，五味杂陈。</p>
<h3 id="18-2-简单的二元态"><a href="#18-2-简单的二元态" class="headerlink" title="18.2 简单的二元态"></a>18.2 简单的二元态</h3><p>世界是复杂的，事物的状态是多样的，但“万物之始，大道至简”，我们就从最简单的“二元态”实例出发。如果你此刻在室内，你会发现有电灯，它有两种状态：通电与断电，分别对应灯亮与灯灭这两种行为。控制电灯通电与断电的开关则为用户提供两个接口(user interface)，一个是开启，另一个是关闭，如图18-2所示。</p>
<p>电灯拥有“开”和“关”两个按钮，我们就以“开关”来模拟电灯的状态变化驱动机制。首先我们需要定义一个开关类，并提供两个方法“开灯”与“关灯”，分别引发灯亮与灯灭的行为，请参看代码清单18-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181703782.png" alt="image-20231018170300743"></p>
<p>如代码清单18-1所示，开关类于第4行用布尔值true与false来代表电灯的两种状态，并使其初始状态默认为关闭(false)。第6行的开灯方法switchOn()中先切换状态为“开启”(true)再使灯亮。与之相反，第11行的关灯方法switchOff()则切换状态为“关闭”(false)使灯灭。</p>
<p>程序看起来好像没什么问题，但如果深究就会发现，针对开关状态的维护代码有点考虑不周全。如果客户端连续按下开或者关按钮会出现什么情况呢？实际上这即使没有逻辑错误也增加了无意义的冗余操作，已经点亮的灯又何必再次被开启呢？所以这个开关类的状态校验很不完善，我们需要加入针对当前状态的条件判断，也就是说，开启的状态下不能再开启，关闭的状态下不能再关闭，请参看代码清单18-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181703318.png" alt="image-20231018170330267"></p>
<p>如代码清单18-2所示，我们在开灯方法与关灯方法中加入了逻辑判断。如果正常切换状态则通过校验，使灯亮或灭，否则重复开或重复关的话则不进行操作并警告用户不必再次操作，当然此时也可以抛出异常，但为了保持简单我们就不复杂化了。这样的设计至少看起来没有任何问题，我们来测试一下，请参看代码清单18-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181703938.png" alt="image-20231018170350866"></p>
<p>如代码清单18-3所示，我们在第5行与第9行分别进行了重复开与重复关的操作，可以看到注释中标注出的运行结果，不管如何操作都不会再出现错误操作的问题了，逻辑非常严密。然而非常遗憾的是，这依旧不算是好的设计，如果状态再复杂些，逻辑判断就会越加越多。</p>
<h3 id="18-3-交通灯的状态"><a href="#18-3-交通灯的状态" class="headerlink" title="18.3 交通灯的状态"></a>18.3 交通灯的状态</h3><p>对于电灯开关这种简单的二元开关，如果状态变多，会产生什么结果呢？以交通信号灯为例，它一般包括红、黄、绿3种颜色状态，不同状态之间的切换包含这样的逻辑：红灯只能切换为黄灯，黄灯可以切换为绿灯或红灯，绿灯只能切换为黄灯，如图18-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181704507.png" alt="image-20231018170441465"></p>
<p>交通灯的状态维护与切换并不像电灯一样简单，如果还是按照之前的设计，复杂的状态校验逻辑会大量堆积在每个方法中，因此造成的错误必将导致严重的交通事故，后果不堪设想。实践出真知，基于之前的设计，我们用代码亲自验证一下效果，请参看代码清单18-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181705385.png" alt="image-20231018170500336"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181705022.png" alt="image-20231018170504982"></p>
<p>如代码清单18-4所示，这个交通灯状态切换逻辑看起来非常复杂，满当当地摆放在类里面，维护起来也非常让人头疼。这只是十字路口的一处交通灯而已，若是东西南北各处交通灯全部联动起来的话，其复杂程度难以想象。要解决这个问题，我们<strong>就得基于状态模式</strong>，将这个庞大的类进行拆分，用一种更为优雅的方式将这些切换逻辑组织起来，让状态的切换及维护变得轻松自如。沿着这个思路，我们把状态相关模块从交通灯里抽离出来，这里首先定义一个状态接口以形成规范，请参看代码清单18-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181705204.png" alt="image-20231018170546129"></p>
<p>如代码清单18-5所示，状态接口分别定义3个标准，它们依次是切换为绿灯（通行）状态、切换为黄灯（警示）状态，以及切换为红灯（禁行）状态。需要注意的是每个接口方法的入参，这里传入的交通灯引用到底有何用意？我们先保留这个问题。状态接口既然已经定义完毕，那么接着就得实现交通灯的3种状态，它们依次是红灯状态、黄灯状态和绿灯状态，请分别参看代码清单18-6、代码清单18-7和代码清单18-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181706955.png" alt="image-20231018170621918"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181706208.png" alt="image-20231018170628171"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181706595.png" alt="image-20231018170635549"></p>
<p>如代码清单18-6、代码清单18-7和代码清单18-8所示，每种状态都分别实现了状态接口的切换方法。非常神奇的是，我们看不到任何的切换逻辑了，之前代码中的一大堆if、else全都消失不见了。以代码清单18-8的绿灯状态为例，按照我们之前分析过的切换逻辑：“绿灯状态下无须重复切换为绿灯，并且绿灯也不能直接切换为红灯。”所以在代码清单18-8第4行的切换到绿灯方法switchToGreen()中与第15行的切换到红灯方法switchToRed()中，禁止这2种切换行为并输出错误消息。而绿灯切换为黄灯则是合法的，所以在第9行的切换到黄灯方法switchToYellow()中，我们调用了方法传入的交通灯对象的setState()方法，更新其状态为黄灯状态并触发黄灯亮起，这也是将交通灯作为入参的意义所在。按照这种模式，其他的状态类实现都大同小异，以此类推。</p>
<p>通过对交通灯系统的初步重构，我们将“状态”接口化、模块化，最终将它们从臃肿的交通灯类代码中抽离出来，独立于交通灯类，并分别拥有自己的接口实现。如此一来，我们奇迹般地摆脱了各种复杂的状态切换逻辑，代码变得特别清爽、优雅。至于状态接口中传入的交通灯对象以及对其状态更新的setState()方法，读者可能会感到困惑，我们先来重构交通灯类，让一切豁然开朗，请参看代码清单18-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181709496.png" alt="image-20231018170934419"></p>
<p>如代码清单18-9所示，状态切换逻辑已经被拆分出去了，交通灯类变得非常简单。首先，在第4行我们以状态接口State定义交通灯当前的默认初始状态为红灯。接着，在第6行对外暴露了设置状态方法setState()。最后在第11行、第16行及第21行的3个状态切换方法中，我们没有做任何具体的切换操作，而是调用了当前状态对象所对应的切换方法。需要注意的是，为了让状态对象能够访问到setState()更新交通灯的状态，我们将交通灯对象“this”作为参数一并传入，将任务移交给当前的状态对象去执行，也就是说，交通灯只是持有当前的状态，至于到底该如何响应及进行状态切换，全权交由当前状态对象处理。至此，基于状态模式的交通灯系统构建完毕，我们来定义客户端类使用交通灯，请参看代码清单18-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181710126.png" alt="image-20231018171011081"></p>
<p>如代码清单18-10所示，客户端一开始实例化了交通灯，接着按照交规进行了一系列的交通灯切换操作，可以看到输出一切正常。注意第16行，操作失败后会收到告警信息，这说明即便切换了错误的状态，也不会酿成车祸，状态切换及校验机制工作正常。</p>
<p>当然，我们还可以采取更为简单的状态接口为客户端提供更便捷的使用方式，例如对于18.2节中的电灯开关，我们完全可以定义一个开关接口Switcher，并提供一个统一的switch()方法接口，如此一来，不管当前电灯是何种状态，用户只需要调用这一个方法便可实现电灯状态的自动切换，并实现开灯和关灯功能了。各个场景需要其最恰当的实现方式，具体代码请读者自行实践，这里就不赘述了。</p>
<h3 id="18-4-状态响应机制"><a href="#18-4-状态响应机制" class="headerlink" title="18.4 状态响应机制"></a>18.4 状态响应机制</h3><p>至此，状态模式的应用将系统状态从系统环境（系统宿主）中彻底抽离出来，状态接口确立了高层统一规范，使状态响应机制分立、自治，以一种松耦合的方式实现了系统状态与行为的联动机制。如此一来，系统环境不再处理任何状态响应及切换逻辑，而是转发给当前状态对象去处理，同时将自身引用“this”传递下去。也就是说，系统环境只需要持有当前状态，而不必再关心如何根据状态进行响应，或是如何进行状态更新了。请参看状态模式的类结构，如图18-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310181711300.png" alt="image-20231018171139252"></p>
<p>状态模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ State（状态接口）：定义通用的状态规范标准，其中处理请求方法handle()将系统环境Context作为参数传入。对应本章例程中的状态接口State。</span><br><span class="line">■ ConcreteStateA、ConcreteStateB、ConcreteStateC（状态实现A、状态实现B、状态实现C）：具体的状态实现类，根据系统环境用于表达系统环境Context的各个状态，它们都要符合状态接口的规范。对应本章例程中的红灯状态Red、绿灯状态Green以及黄灯状态Yellow。</span><br><span class="line">■ Context（系统环境）：系统的环境，持有状态接口的引用，以及更新状态方法setState()，对外暴露请求发起方法request()，对应本章例程中的交通灯类TrafficLight。</span><br></pre></td></tr></table></figure>
<p>从类结构上看，状态模式与策略模式非常类似，其不同之处在于，策略模式是将策略算法抽离出来并由外部注入，从而引发不同的系统行为，其可扩展性更好；而状态模式则将状态及其行为响应机制抽离出来，这能让系统状态与行为响应有更好的逻辑控制能力，并且实现系统状态主动式的自我转换。状态模式与策略模式的侧重点不同，所以适用于不同的场景。总之，如果系统中堆积着大量的状态判断语句，那么就可以考虑应用状态模式，它能让系统原本复杂的状态响应及维护逻辑变得异常简单。状态的解耦与分立让代码看起来更加清晰、明了，可读性大大增强，同时系统的运行效率与健壮性也能得到全面提升。</p>
<h2 id="第19章-备忘录"><a href="#第19章-备忘录" class="headerlink" title="第19章　备忘录"></a>第19章　备忘录</h2><p>备忘录用来记录曾经发生过的事情，使回溯历史变得切实可行。备忘录模式(Memento)则可以在不破坏元对象封装性的前提下捕获其在某些时刻的内部状态，并像历史快照一样将它们保留在元对象之外，以备恢复之用。</p>
<h3 id="19-1-时光流逝"><a href="#19-1-时光流逝" class="headerlink" title="19.1 时光流逝"></a>19.1 时光流逝</h3><p>光阴似箭，岁月如梭，时间在一分一秒地不停流逝，一去不返，如图19-1所示。想必我们都做过错误的决定，最终导致糟糕的结果。然而这个世界并不存在后悔药，做出的决定如覆水难收。</p>
<p>然而，在计算机世界中，我们似乎可以来去自如，例如浏览器前进与后退、撤销文档修改、数据库备份与恢复、游戏存盘载入、操作系统快照恢复、手机恢复出厂设置等操作稀松平常。再深入到面向对象层面，我们知道当程序运行时一个对象的状态有可能随时发生变化，而当修改其状态时我们可以对其进行记录，如此便能够将对象恢复到任意记录的状态。备忘录模式正是采用这种理念，让历史重演。</p>
<h3 id="19-2-覆水难收"><a href="#19-2-覆水难收" class="headerlink" title="19.2 覆水难收"></a>19.2 覆水难收</h3><p>为了更生动地展现备忘录模式，以使读者更容易理解，我们来模拟这样一个场景：假设某作家要写一部科幻小说，当他构思完成后打开编辑器软件开始创作的时候，必然会创建一个文档。那么我们首先来定义这个文档类Doc，请参看代码清单19-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182224524.png" alt="image-20231018222405403"></p>
<p>如代码清单19-1所示，作为一个简单的Java对象(Plain Ordinary Java Object,POJO)类，文档类包括两个内部属性：文档标题title与文档内容body，它们拥有各自的get方法与set方法。可以看到，这个类实例化出的对象一定包含“文档标题”与“文档内容”两个状态，并且会在运行时随着作家对文档的修改而改变，尤其是对“文档内容”的修改，如此才能达到编辑文档的目的。接下来当然少不了作家用来修改这个文档的编辑器类，请参看代码清单19-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182225473.png" alt="image-20231018222526423"></p>
<p>如代码清单19-2所示，我们先从最简单的功能看起，第5行当编辑器类实例化时需要载入一个文档对象，并展示其内容。接下来是编辑器最重要的编辑功能了。我们保持以最简单的代码来模拟文档的编辑功能，从第11行开始依次有插入方法append()、删除方法delete()、存盘方法save()，以及显示文档内容方法show()，请读者仔细阅读，此处不做赘述。一切就绪，作家可以开始使用这个编辑器了，关于客户端类Client，请参看代码清单19-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182226739.png" alt="image-20231018222642687"></p>
<p>如代码清单19-3所示，作家开始创作并一口气写完了两章的内容，第27行输出的文档内容让他颇有成就感。于是他决定冲杯咖啡，休息一下，并没有调用存盘方法save()便离开了计算机，一切看起来非常顺利。然而不幸的是，作家的宠物猫跳上了他的计算机键盘，不巧按下了Delete键并触发了第36行的删除操作，结果整个文档从内存中被清空了，如图19-2所示。作家5000字的心血付之东流，不得不为自己的疏忽大意付出惨痛的代价。</p>
<h3 id="19-3-破镜重圆"><a href="#19-3-破镜重圆" class="headerlink" title="19.3 破镜重圆"></a>19.3 破镜重圆</h3><p>编辑器类提供的删除方法本来是出于软件功能的完整性而设计的，却反而给用户带来了潜在风险。所以，我们一定要避免发生这类误操作，才能带来更好的用户体验。大家一定想到了以Ctrl+Z组合键触发的撤销操作了吧。这条编辑器指令可以瞬间撤销用户的上一步操作并回退到上一个文档状态，这样不但给了用户吃后悔药的机会，还能省去用户频繁地进行存盘操作的麻烦。</p>
<p>这种自动备忘录机制是如何实现的呢？既然可以回溯历史，就一定得定义一个历史快照类，用来记录用户每步操作后的文档状态，请参看代码清单19-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182229516.png" alt="image-20231018222905473"></p>
<p>如代码清单19-4所示，和文档类Doc非常类似，历史快照类History也是一个POJO类，它同样封装了属性“文档内容”。可以看到第5行的构造方法中对文档内容的初始化，这样我们便可以记录文档内容的快照了。我们知道，每生成一个历史快照对象就相当于在备忘录中写下一笔记录，一个对象对应一个快照，那么由谁来生成这个快照记录呢？我们对文档类Doc进行重构，做一些快照功能上的增强，请参看代码清单19-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182229441.png" alt="image-20231018222952378"></p>
<p>如代码清单19-5所示，我们在第27行加入了创建历史记录方法createHistory()，它能够生成并返回当前文档内容对应的历史快照。与之相反，第31行则对应历史记录的恢复方法restoreHistory()，它能够根据传入的历史快照参数将文档内容恢复到任意历史时间点。</p>
<p>至此，文档类便具备了快照生成与恢复功能。要实现编辑器的撤销功能，我们首先得在用户进行编辑操作时对文档进行历史快照备份，如此才能恢复到任意历史时间点。下面我们对编辑器类进行重构，请参看代码清单19-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182232072.png" alt="image-20231018223207019"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182232731.png" alt="image-20231018223213686"></p>
<p>如代码清单19-6所示，我们首先在第4行加入了一个历史记录列表historyRecords，我们可以把它当作一本有很多页的历史书，顺序记录着每个时间点发生的历史事件，它的当前页码体现于第5行，即以整型定义的时间点索引historyPosition。注意第33行的备份方法backup()，它能将文档生成的快照加入历史记录列表historyRecords，做好历史的记录。然后回到第10行的构造方法，这里我们对备忘录进行初始化，并且调用备份方法backup()将文档初始状态保存至备忘录。同样，文档的所有变更操作完成后都应该将当前文档状态“载入史册”，如之后的插入方法append()以及删除方法delete()中对备份方法的调用。</p>
<p>载入史册”是为了“回溯历史”，因此第43行的撤销方法undo()才能真正实现“昨日重现”。随着历史的推进，之前定义的时间点索引historyPosition会逐渐增大，要回溯历史就要将索引减小，一直到0指向的最初状态为止。从第44行开始，我们首先进行了校验操作，如果时间点索引在0点位置就不可以回溯了，非法越界操作应当直接返回，反之则是合法操作，此时可以将时间点索引减1，再将其所对应的历史记录取出，并将内容恢复至当前打开的文档中。此外，编辑器既然能回溯历史，当然也得有与之相反的功能，也就是第54行的重做方法redo()，实现了这两个功能才能让文档内容在历史时间轴上任意游走。此处略去redo()的代码，请读者自行实践练习。</p>
<p>“工欲善其事，必先利其器”，编辑器拥有了强大的撤销、重做功能，作家对文档的每次修改统统被记入备忘录，从此可以高枕无忧了。终于，作家可以重新开始他的小说创作了，请参看代码清单19-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182234851.png" alt="image-20231018223411793"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182234149.png" alt="image-20231018223425117"></p>
<p>如代码清单19-7所示，作家又一口气写了两章内容。假设在第36行对文档进行了误删除操作，就可以在第44行从容不迫地按下Ctrl+Z组合键，以此触发编辑器的撤销方法undo()，接着可以清楚地看到输出中5000字内容被奇迹般地恢复如初，世界依旧美好。</p>
<h3 id="19-4-历史回溯"><a href="#19-4-历史回溯" class="headerlink" title="19.4 历史回溯"></a>19.4 历史回溯</h3><p>备忘录模式就像一台时光机，让我们在软件世界里自由自在地进行时空穿梭。需要注意的是，备忘录类一定独立于元数据类而单独成类，其生成的历史记录也应该在元数据类之外进行维护，这样不但确保了元数据类的封装不被破坏，而且实现了对其内部状态历史变化的捕获与恢复。请参看备忘录模式的类结构，如图19-3所示</p>
<p>备忘录模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Originator（元）：状态需要被记录的元对象类，其状态是随时可变的。既可以生成包含其内部状态的即时备忘录，也可以利用传入的备忘录恢复到对应状态。对应本章例程中的文档类Doc。</span><br><span class="line">■ Memento（备忘录）：与元对象相仿，但只需要保留元对象的状态，一个状态对应一个备忘录对象。对应本章例程中的历史快照类History。</span><br><span class="line">■ CareTaker（看护人）：历史记录的维护者，持有所有记录的历史记录，并且提供对元数据对象的恢复操作，如撤销undo()、重做redo()等，一般不提供对历史记录的修改。对应本章例程中的编辑器类Editor。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182237394.png" alt="image-20231018223701340"></p>
<p>在程序运行的过程中，内存中的对象状态变幻莫测，备忘录模式能为我们捕获每一个精彩的历史瞬间，让其留存于备忘录的每一页，以便我们回溯历史，勇敢前行。备忘录模式非常简单、易懂，但读者在应用时一定要小心一些陷阱，例如在元对象状态数据量过大的情况下，或者是无限制地对元对象进行快照备份的操作，都可能会导致内存空间资源的过度耗费，使系统性能变得越来越差。这时就要看读者怎样变通了，譬如为备忘录历史记录加上容量限制，可以总是保存最近的20条记录。通过诸如此类的方式可以改善这种情况，所以读者一定要根据特定的场景进行适当的变通，保持灵活开放的思维才能更好地利用设计模式，设计出更优秀的应用程序。</p>
<h2 id="第20章-中介"><a href="#第20章-中介" class="headerlink" title="第20章　中介"></a>第20章　中介</h2><p>中介是在事物之间传播信息的中间媒介。中介模式(Mediator)为对象构架出一个互动平台，通过减少对象间的依赖程度以达到解耦的目的。我们的生活中有各种各样的媒介，如婚介所、房产中介、门户网站、电子商务、交换机组网、通信基站、即时通软件等，这些都与人类的生活息息相关，离开它们我们将举步维艰。</p>
<p>对媒体来说，虽然它们的作用都一样，但在传递信息的方式上还是有差别的。如图20-1所示，以传统媒体为例，书刊杂志、报纸、电视、广播等，都是把信息传递给读者，有些是实时的（如电视），有些是延迟的（如报纸），但它们都是以单向的传递方式来传递信息的。而作为新媒体的互联网，不但可以更高效地把信息传递给用户，而且可以反向地获取用户的反馈信息。除此之外，互联网还能作为一个平台，让用户相互进行沟通，这种全终端、多点互通的结构特点更类似于中介模式。</p>
<h3 id="20-1-简单直接交互"><a href="#20-1-简单直接交互" class="headerlink" title="20.1 简单直接交互"></a>20.1 简单直接交互</h3><p>通过中介我们可以更轻松、高效地完成信息交互。读者可能会提出这样的疑问：如果排除空间的限制，沟通人可以直接进行交互，根本不需要任何第三方的介入，如图20-2所示，对于面对面的二人沟通，中介显得有些多余。</p>
<p>为了更直观地理解中介的作用，我们用代码来模拟这种没有第三方参与的信息交互场景。首先定义人类，他一定得能听能说才能达成沟通，请参看代码清单20-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182240207.png" alt="image-20231018224047164"></p>
<p>如代码清单20-1所示，人类在第3行以名字作为代号来区分不同的人（对象），接着在第4行持有另外一方沟通人的引用，并于第14行的连接方法connect()中将对方注入以建立连接，如此才能与对方进行沟通。当然，作为人类一定可以讲话与聆听，于是我们在第18行的发言方法talk()中调用了对方的聆听方法，并将消息传递给对方。在第22行的聆听方法listen()中收到对方的消息时则进行输出。人类代码看起来非常简单，此时尚未涉及第三方。我们让两人开始沟通，请参看客户端代码清单20-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182242598.png" alt="image-20231018224214557"></p>
<p>如代码清单20-2所示，张三和李四两人聊得不亦乐乎，第14行的输出结果显示双方沟通顺利达成，信息可由一方发出再传递给另一方，反之亦然，看起来这种沟通毫无障碍。这种设计虽然简单、直接，但请注意第7行与第8行代码，双方在沟通前必须先建立连接，互相持有对方对象的引用，这样才能知道对方的存在。但如此便造成你中有我、我中有你，谁也离不开谁的状况，双方对象的耦合性太强。虽然在两人沟通的情况下，强耦合也不会造成太大问题，但是倘若我们要进行一场多方讨论的会议，那么在这种沟通模式下，每个参会人就不止是持有沟通对方这么简单了，而是必须持有其他所有人对象的引用列表（如使用ArrayList），以建立每个对象之间的两两连接。我们以对象间的引用关系图来表示这种模式，如图20-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182243012.png" alt="image-20231018224318961"></p>
<p>对象间这种千丝万缕的耦合关系会带来很大的麻烦，当我们要加入或减少一个参会人时，都要将其同步更新给所有人，每个人发送消息时都要先查找一遍消息接收方，从而产生很多重复工作。我们陷入了一种多对多的对象关联陷阱，这让复杂的对象关系难以维护，所以必须重新考虑更合理的设计模式。</p>
<h3 id="20-2-构建交互平台"><a href="#20-2-构建交互平台" class="headerlink" title="20.2 构建交互平台"></a>20.2 构建交互平台</h3><p>要解决对象间复杂的耦合问题，我们就必须借助第三方平台来把它们拆分开。首先要做的是把每个人持有的重复引用抽离出来，将所有人的引用列表放入一个中介类，这样就可以在同一个地方将它们统一维护起来，对引用的操作只需要进行一次。我们来看引入中介平台后的对象关系图，如图20-4所示。</p>
<p>引入中介后，每个对象不再维护与其他对象的引用了，取而代之的是与中介建立直接关联，与图20-3相比，引用关系瞬间变得一目了然。我们以聊天室为例开始代码实战，首先对之前的人类People进行重构，请参看代码清单20-3中的用户类。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182244866.png" alt="image-20231018224427817"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182244243.png" alt="image-20231018224450195"></p>
<p>如代码清单20-3所示，在第5行我们直接持有聊天室的引用chatRoom，并在第15行的用户登录方法login()中将其注入进来。接着调用聊天室的连接注册方法register()与其建立连接，这意味着用户不再与其他用户建立连接了，而是连接聊天室并告知“我进来了，请进行注册”。同样，第20行的发言方法talk()以及第24行的聆听方法listen()也不与其他用户发生关联，前者会将消息直接发送给聊天室，后者则负责接收来自聊天室的消息。</p>
<p>通过上述操作，我们斩断了多用户之间的关联，一切关联都被间接地交给中介聊天室去处理，用户与用户彻底解耦。当然，用户在离开聊天室时还应该有一个注销方法，我们会在之后加入它。接下来就是至关重要的聊天室类了，它就是中介，请参看代码清单20-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182245931.png" alt="image-20231018224557886"></p>
<p>如代码清单20-4所示，聊天室类在第9行维护了一个以用户类User为泛型的用户列表users，以记录当前聊天室中的所有用户。要进入聊天室的用户需要调用第11行的连接注册方法register()，注册后会被加入用户列表中。同样，我们将第18行的发送消息方法sendMsg()也暴露给用户，当用户发送消息到平台时依次调用所有注册用户的聆听方法listen()，将消息转发给聊天室内的所有在线用户。最后，我们来看客户端如何将聊天室建立起来，请参看代码清单20-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182247725.png" alt="image-20231018224704677"></p>
<p>如代码清单20-4所示，聊天室类在第9行维护了一个以用户类User为泛型的用户列表users，以记录当前聊天室中的所有用户。要进入聊天室的用户需要调用第11行的连接注册方法register()，注册后会被加入用户列表中。同样，我们将第18行的发送消息方法sendMsg()也暴露给用户，当用户发送消息到平台时依次调用所有注册用户的聆听方法listen()，将消息转发给聊天室内的所有在线用户。最后，我们来看客户端如何将聊天室建立起来，请参看代码清单20-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182248016.png" alt="image-20231018224843915"></p>
<p>如代码清单20-5所示，不管是谁发言，用户只需自第11行起进入中介聊天室与其建立连接，即可轻松将消息发送至所有在线用户，消息以广播的形式覆盖聊天室内的每一个角落。聊天室中介平台的搭建，让用户以一种间接的方式进行沟通，彻底从错综复杂的用户直接关联中解脱出来。</p>
<h3 id="20-3-多态化沟通"><a href="#20-3-多态化沟通" class="headerlink" title="20.3 多态化沟通"></a>20.3 多态化沟通</h3><p>我们已经实现了围绕聊天室展开的群聊系统。如果需要进一步增强功能就得继续对系统进行重构，例如用户可能需要一对一的私密聊天，或者VIP用户需要具有超级权限等功能。这时我们就可以对聊天室与用户进行多态化设计，首先重构聊天室类与用户类，请分别参看代码清单20-6、代码清单20-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182250843.png" alt="image-20231018225004799"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182250441.png" alt="image-20231018225048393"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182250144.png" alt="image-20231018225057062"></p>
<p>如代码清单20-6与代码清单20-7所示，聊天室抽象类与用户类定义了一些基础的功能，对之前的代码进行了增强以完善系统功能，如聊天室类发送消息方法sendMsg()的抽象化，再如用户类对发言方法talk()的改造。如此一来，子类就可以根据自己的特性进行继承或者重写以实现自己的个性化。系统框架一旦构建，子类便可进行无限扩展。接下来我们定义公共聊天室和私密聊天室两个子类，请参看代码清单20-8和代码清单20-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182252205.png" alt="image-20231018225214153"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182252388.png" alt="image-20231018225249344"></p>
<p>如代码清单20-8、代码清单20-9所示，公共聊天室除了可以广播式发送消息，还增加了发送消息给特定用户的功能；私密聊天室将加入人数限制为两人，沟通只在两人世界中展开。同样，我们来定义一个超级用户类，让他拥有更多的权限，请参看代码清单20-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182253044.png" alt="image-20231018225323003"></p>
<p>如代码清单20-10所示，我们为超级用户增加了一个特殊权限方法kick()，将破坏聊天规则的用户踢出聊天室。当然，我们还可以为超级用户添加更多权限，例如“警告”“禁言”等方法，读者可以思考一下如何实现。至此，基于中介模式的聊天室多态化让系统功能越来越丰富了，我们将通用功能的公共代码抽象到了父类中实现，而对于个性化的功能则具体由子类去实现，并且让用户与平台各自负责自己的工作，类有所属，各尽其能。</p>
<h3 id="20-4-星形拓扑"><a href="#20-4-星形拓扑" class="headerlink" title="20.4 星形拓扑"></a>20.4 星形拓扑</h3><p>中介模式不仅在生活中应用广泛，还大量存在于软硬件架构中，例如微服务架构中的注册发现中心、数据库中的外键关系表，再如网络设备中的路由器等，中介的角色均发挥了使对象解耦的关键作用。不管是对象引用维护还是消息的转发，都由处于中心节点的中介全权负责，最终架构出一套类似于星形拓扑的网络结构，如图20-5所示，极大地简化了各对象间多对多的复杂关联，最终解决了对象间过度耦合、频繁交互的问题，请参看中介模式的类结构，如图20-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182254298.png" alt="image-20231018225444249"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310182254760.png" alt="image-20231018225451711"></p>
<p>中介模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Mediator（中介）：共事者之间通信的中介平台接口，定义与共事者的通信标准，如连接注册方法与发送消息方法等。对应本章例程中的聊天室类ChatRoom（本例以抽象类的形式定义中介接口）。</span><br><span class="line">■ ConcreteMediator（中介实现）：可以有多种实现，持有所有共事者对象的列表，并实现中介定义的通信方法。对应本章例程中的公共聊天室类PublicChatRoom、私密聊天室类PrivateChatRoom。</span><br><span class="line">■ Colleague（共事者）、ConcreteColleague（共事实现）：共事者可以有多种共事者实现。共事者持有中介对象的引用，以使其在发送消息时可以调用中介，并由它转发给其他共事者对象。对应本章例程中的用户类User。</span><br></pre></td></tr></table></figure>
<p>众所周知，对象间显式的互相引用越多，意味着依赖性越强，同时独立性越弱，不利于代码的维护与扩展。中介模式很好地解决了这些问题，它能将多方互动的工作交由中间平台去完成，解除了你中有我、我中有你的相互依赖，让各个模块之间的关系变得更加松散、独立，最终增强系统的可复用性与可扩展性，同时也使系统运行效率得到提升。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BA%95%E5%B1%82%E6%80%9D%E7%BB%B4/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">程序员的底层思维</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">187</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">创建篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8D%95%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">第2章　单例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%A4%AA%E9%98%B3"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 孤独的太阳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A5%BF%E6%B1%89%E9%80%A0%E6%97%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.2 饿汉造日</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%87%92%E6%B1%89%E7%9A%84%E9%98%9F%E4%BC%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.3 懒汉的队伍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.4 大道至简</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">第3章　原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E4%BB%B6%E4%B8%8E%E5%89%AF%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.1 原件与副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%A1%E9%A1%BF%E7%9A%84%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2 卡顿的游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.3 细胞分裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%8B%E9%9A%86%E5%B7%A5%E5%8E%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.4 克隆工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.5.</span> <span class="toc-text">3.5 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%85%8B%E9%9A%86%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">3.6 克隆的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">第4章　工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B7%A5%E5%8E%82%E7%9A%84%E5%A4%9A%E5%85%83%E5%8C%96%E4%B8%8E%E4%B8%93%E4%B8%9A%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.1 工厂的多元化与专业化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.2 游戏角色建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%B8%8D%E7%AE%80%E5%8D%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3 简单工厂不简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%88%B6%E5%AE%9A%E5%B7%A5%E4%B8%9A%E5%88%B6%E9%80%A0%E6%A0%87%E5%87%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.4 制定工业制造标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8A%B3%E5%8A%A8%E5%88%86%E5%B7%A5"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.5 劳动分工</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">1.4.</span> <span class="toc-text">第5章　抽象工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%93%81%E7%89%8C%E4%B8%8E%E7%B3%BB%E5%88%97"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.1 品牌与系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%92"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.2 产品规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%94%9F%E4%BA%A7%E7%BA%BF%E8%A7%84%E5%88%92"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.3 生产线规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">5.4 分而治之</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BB%BA%E9%80%A0%E8%80%85"><span class="toc-number">1.5.</span> <span class="toc-text">第6章　建造者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%BB%BA%E9%80%A0%E6%AD%A5%E9%AA%A4%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.1 建造步骤的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%9C%B0%E4%BA%A7%E5%BC%80%E5%8F%91%E5%95%86%E7%9A%84%E5%9B%B0%E6%83%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.2 地产开发商的困惑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%BB%BA%E7%AD%91%E6%96%BD%E5%B7%A5%E6%96%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.3 建筑施工方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%9B%91"><span class="toc-number">1.5.4.</span> <span class="toc-text">6.4 工程总监</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD"><span class="toc-number">1.5.5.</span> <span class="toc-text">6.5 项目实施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%B7%A5%E8%89%BA%E4%B8%8E%E5%B7%A5%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.6 工艺与工序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">结构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%97%A8%E9%9D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">第7章　门面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%80%E9%94%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text">7.1 一键操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E4%BA%B2%E8%87%AA%E4%B8%8B%E5%8E%A8%E7%9A%84%E7%83%A6%E6%89%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">7.2 亲自下厨的烦扰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">7.3 化繁为简</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%95%B4%E5%90%88%E5%85%B1%E4%BA%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">7.4 整合共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%BB%84%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">第8章　组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">8.1 叉树结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">8.2 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%9B%AE%E5%BD%95%E6%A0%91%E5%B1%95%E7%A4%BA"><span class="toc-number">2.2.3.</span> <span class="toc-text">8.3 目录树展示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%87%AA%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9A%84%E6%B6%8C%E7%8E%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">8.4 自相似性的涌现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">第9章　装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%AE%A4%E5%86%85%E8%A3%85%E6%BD%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">9.1 室内装潢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BB%8E%E7%B4%A0%E9%9D%A2%E6%9C%9D%E5%A4%A9%E5%88%B0%E8%8A%B1%E5%AE%B9%E6%9C%88%E8%B2%8C"><span class="toc-number">2.3.2.</span> <span class="toc-text">9.2 从素面朝天到花容月貌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%8C%96%E5%A6%86%E5%93%81%E7%9A%84%E5%A4%9A%E6%A0%B7%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">9.3 化妆品的多样化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">9.4 无处不在的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E8%87%AA%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-number">2.3.5.</span> <span class="toc-text">9.5 自由嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">第10章　适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E8%B7%A8%E8%B6%8A%E9%B8%BF%E6%B2%9F%E9%9D%A0%E9%80%82%E9%85%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">10.1 跨越鸿沟靠适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%8F%92%E5%A4%B4%E4%B8%8E%E6%8F%92%E5%AD%94%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">10.2 插头与插孔的冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%80%9A%E7%94%A8%E9%80%82%E9%85%8D"><span class="toc-number">2.4.3.</span> <span class="toc-text">10.3 通用适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E4%B8%93%E5%B1%9E%E9%80%82%E9%85%8D"><span class="toc-number">2.4.4.</span> <span class="toc-text">10.4 专属适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%8C%96%E8%A7%A3%E9%9A%BE%E4%BB%A5%E8%B0%83%E5%92%8C%E7%9A%84%E7%9F%9B%E7%9B%BE"><span class="toc-number">2.4.5.</span> <span class="toc-text">10.5 化解难以调和的矛盾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BA%AB%E5%85%83"><span class="toc-number">2.5.</span> <span class="toc-text">第11章　享元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E9%A9%AC%E8%B5%9B%E5%85%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">11.1 马赛克</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E6%B8%B8%E6%88%8F%E5%9C%B0%E5%9B%BE"><span class="toc-number">2.5.2.</span> <span class="toc-text">11.2 游戏地图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E5%8D%A1%E9%A1%BF%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">11.3 卡顿的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%9B%BE%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">2.5.4.</span> <span class="toc-text">11.4 图件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E4%B8%87%E5%8F%98%E4%B8%8D%E7%A6%BB%E5%85%B6%E5%AE%97"><span class="toc-number">2.5.5.</span> <span class="toc-text">11.5 万变不离其宗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E4%BB%A3%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">第12章　代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-4S%E5%BA%97"><span class="toc-number">2.6.1.</span> <span class="toc-text">12.1 4S店</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91"><span class="toc-number">2.6.2.</span> <span class="toc-text">12.2 访问互联网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E4%BA%92%E8%81%94%E7%BD%91%E4%BB%A3%E7%90%86"><span class="toc-number">2.6.3.</span> <span class="toc-text">12.3 互联网代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E4%B8%87%E8%83%BD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.6.4.</span> <span class="toc-text">12.4 万能的动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E4%B8%9A%E5%8A%A1%E5%A2%9E%E5%BC%BA%E4%B8%8E%E7%AE%A1%E6%8E%A7"><span class="toc-number">2.6.5.</span> <span class="toc-text">12.5 业务增强与管控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%A1%A5%E6%8E%A5"><span class="toc-number">2.7.</span> <span class="toc-text">第13章　桥接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE"><span class="toc-number">2.7.1.</span> <span class="toc-text">13.1 基础建设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E5%BD%A2%E4%B8%8E%E8%89%B2%E7%9A%84%E7%BA%A0%E8%91%9B"><span class="toc-number">2.7.2.</span> <span class="toc-text">13.2 形与色的纠葛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E6%9E%B6%E6%9E%84%E4%BA%A7%E4%B8%9A%E9%93%BE"><span class="toc-number">2.7.3.</span> <span class="toc-text">13.3 架构产业链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF"><span class="toc-number">2.7.4.</span> <span class="toc-text">13.4 笛卡儿积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E5%A4%9A%E5%A7%BF%E5%A4%9A%E5%BD%A9%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-number">2.7.5.</span> <span class="toc-text">13.5 多姿多彩的世界</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">行为篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">第14章　模板方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E7%94%9F%E5%AD%98%E6%8A%80%E8%83%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">14.1 生存技能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E7%94%9F%E5%AD%98%E6%B3%95%E5%88%99"><span class="toc-number">3.1.2.</span> <span class="toc-text">14.2 生存法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.1.3.</span> <span class="toc-text">14.3 项目管理模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E8%99%9A%E5%AE%9E%E7%BB%93%E5%90%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">14.4 虚实结合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">第15章　迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E7%89%A9%E4%BB%A5%E7%B1%BB%E8%81%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">15.1 物以类聚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E5%BE%AA%E7%8E%AF%E5%BE%80%E5%A4%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">15.2 循环往复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E9%81%8D%E5%8E%86%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">15.3 遍历标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E5%88%86%E7%A6%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">15.4 分离迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%85%BC%E5%BE%97"><span class="toc-number">3.2.5.</span> <span class="toc-text">15.5 鱼与熊掌兼得</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="toc-number">3.3.</span> <span class="toc-text">第16章　责任链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E4%BA%A7%E7%BA%BF"><span class="toc-number">3.3.1.</span> <span class="toc-text">16.1 简单的生产线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%8B%86%E5%88%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">16.2 工作流程拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E8%B8%A2%E7%9A%AE%E7%90%83"><span class="toc-number">3.3.3.</span> <span class="toc-text">16.3 踢皮球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E6%9E%B6%E6%9E%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">16.4 架构工作流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-%E8%AE%A9%E4%B8%9A%E5%8A%A1%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF"><span class="toc-number">3.3.5.</span> <span class="toc-text">16.5 让业务飞一会儿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.</span> <span class="toc-text">第17章　策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E2%80%9C%E9%A1%BD%E5%9B%BA%E4%B8%8D%E5%8C%96%E2%80%9D%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">17.1 “顽固不化”的系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E6%B8%B8%E6%88%8F%E5%8D%A1%E5%B8%A6"><span class="toc-number">3.4.2.</span> <span class="toc-text">17.2 游戏卡带</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E4%B8%87%E8%83%BD%E7%9A%84USB%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">17.3 万能的USB接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">17.4 即插即用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.</span> <span class="toc-text">第18章　状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E4%BA%8B%E7%89%A9%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.1.</span> <span class="toc-text">18.1 事物的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%85%83%E6%80%81"><span class="toc-number">3.5.2.</span> <span class="toc-text">18.2 简单的二元态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E4%BA%A4%E9%80%9A%E7%81%AF%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.3.</span> <span class="toc-text">18.3 交通灯的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.4.</span> <span class="toc-text">18.4 状态响应机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E5%A4%87%E5%BF%98%E5%BD%95"><span class="toc-number">3.6.</span> <span class="toc-text">第19章　备忘录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E6%97%B6%E5%85%89%E6%B5%81%E9%80%9D"><span class="toc-number">3.6.1.</span> <span class="toc-text">19.1 时光流逝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E8%A6%86%E6%B0%B4%E9%9A%BE%E6%94%B6"><span class="toc-number">3.6.2.</span> <span class="toc-text">19.2 覆水难收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-%E7%A0%B4%E9%95%9C%E9%87%8D%E5%9C%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">19.3 破镜重圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-%E5%8E%86%E5%8F%B2%E5%9B%9E%E6%BA%AF"><span class="toc-number">3.6.4.</span> <span class="toc-text">19.4 历史回溯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E4%B8%AD%E4%BB%8B"><span class="toc-number">3.7.</span> <span class="toc-text">第20章　中介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-%E7%AE%80%E5%8D%95%E7%9B%B4%E6%8E%A5%E4%BA%A4%E4%BA%92"><span class="toc-number">3.7.1.</span> <span class="toc-text">20.1 简单直接交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%B9%B3%E5%8F%B0"><span class="toc-number">3.7.2.</span> <span class="toc-text">20.2 构建交互平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-%E5%A4%9A%E6%80%81%E5%8C%96%E6%B2%9F%E9%80%9A"><span class="toc-number">3.7.3.</span> <span class="toc-text">20.3 多态化沟通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91"><span class="toc-number">3.7.4.</span> <span class="toc-text">20.4 星形拓扑</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/%E7%AE%80%E5%8E%86%E4%B9%A6%E5%86%99%E7%A7%98%E7%B1%8D/" title="简历书写秘籍"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简历书写秘籍"/></a><div class="content"><a class="title" href="/2023/12/01/%E7%AE%80%E5%8E%86%E4%B9%A6%E5%86%99%E7%A7%98%E7%B1%8D/" title="简历书写秘籍">简历书写秘籍</a><time datetime="2023-12-01T08:08:40.000Z" title="发表于 2023-12-01 16:08:40">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/30/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E5%92%8C%E5%88%86%E7%B1%BB%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/" title="恶意软件检测和分类可视化技术综述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意软件检测和分类可视化技术综述"/></a><div class="content"><a class="title" href="/2023/11/30/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E5%92%8C%E5%88%86%E7%B1%BB%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/" title="恶意软件检测和分类可视化技术综述">恶意软件检测和分类可视化技术综述</a><time datetime="2023-11-30T07:34:39.000Z" title="发表于 2023-11-30 15:34:39">2023-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/30/big2015%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A6%82%E8%BF%B0/" title="big2015数据集概述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="big2015数据集概述"/></a><div class="content"><a class="title" href="/2023/11/30/big2015%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A6%82%E8%BF%B0/" title="big2015数据集概述">big2015数据集概述</a><time datetime="2023-11-30T02:58:54.000Z" title="发表于 2023-11-30 10:58:54">2023-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/30/%E5%9F%BA%E4%BA%8ECNN%E7%9A%84%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/" title="基于CNN的恶意软件分类方法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于CNN的恶意软件分类方法"/></a><div class="content"><a class="title" href="/2023/11/30/%E5%9F%BA%E4%BA%8ECNN%E7%9A%84%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/" title="基于CNN的恶意软件分类方法">基于CNN的恶意软件分类方法</a><time datetime="2023-11-30T02:40:14.000Z" title="发表于 2023-11-30 10:40:14">2023-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/29/novel%E8%AE%B0%E5%BF%86%E7%AC%94%E8%AE%B0/" title="novel记忆笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="novel记忆笔记"/></a><div class="content"><a class="title" href="/2023/11/29/novel%E8%AE%B0%E5%BF%86%E7%AC%94%E8%AE%B0/" title="novel记忆笔记">novel记忆笔记</a><time datetime="2023-11-29T13:54:44.000Z" title="发表于 2023-11-29 21:54:44">2023-11-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>