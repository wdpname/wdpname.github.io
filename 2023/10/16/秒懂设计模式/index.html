<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>秒懂设计模式 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:type" content="article">
<meta property="og:title" content="秒懂设计模式">
<meta property="og:url" content="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="创建篇第2章　单例单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。 2.1 孤独的太阳盘古开天，造日月星辰。从“夸父逐日”到“后羿射日">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-16T13:35:45.000Z">
<meta property="article:modified_time" content="2023-10-16T15:15:14.309Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '秒懂设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-16 23:15:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">秒懂设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-16T13:35:45.000Z" title="发表于 2023-10-16 21:35:45">2023-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-16T15:15:14.309Z" title="更新于 2023-10-16 23:15:14">2023-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="秒懂设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="创建篇"><a href="#创建篇" class="headerlink" title="创建篇"></a>创建篇</h1><h2 id="第2章-单例"><a href="#第2章-单例" class="headerlink" title="第2章　单例"></a>第2章　单例</h2><p>单例模式(Singleton)是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。</p>
<h3 id="2-1-孤独的太阳"><a href="#2-1-孤独的太阳" class="headerlink" title="2.1 孤独的太阳"></a>2.1 孤独的太阳</h3><p>盘古开天，造日月星辰。从“夸父逐日”到“后羿射日”，太阳对于我们的先祖一直具有着神秘的色彩与非凡的意义。随着科学的不断发展，我们逐渐揭开了太阳系的神秘面纱。我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳，如图2-1所示。</p>
<p>与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例，它持续提供给地球充足的阳光与能量，离开它地球就不会有今天的勃勃生机，但倘若天上有9个太阳，那么将会带来一场灾难。太阳东升西落，循环往复，不多不少仅此一例。</p>
<h3 id="2-2-饿汉造日"><a href="#2-2-饿汉造日" class="headerlink" title="2.2 饿汉造日"></a>2.2 饿汉造日</h3><p>既然太阳系里只有一个太阳，我们就需要严格把控太阳实例化的过程。我们从最简单的开始，先来写一个Sun类。请参看代码清单2-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162137499.png" alt="image-20231016213756320"></p>
<p>如代码清单2-1所示，太阳类Sun中目前什么都没有。接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。有些读者可能会疑惑，我们并没有写构造器，为什么太阳还可以被实例化呢？这是因为Java可以自动为其加上一个无参构造器。为防止太阳实例泛滥将世界再次带入灾难，我们必须禁止外部调用构造器，请参看代码清单2-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162138926.png" alt="image-20231016213850858"></p>
<p>如代码清单2-2所示，我们在第3行将太阳类Sun的构造方法设为private，使其私有化，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己，并使其自有永有，请参看代码清单2-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162139115.png" alt="image-20231016213934088"></p>
<p>如代码清单2-3所示，代码第3行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。这就是“饿汉模式”(eager initialization)，即在初始阶段就主动进行实例化，并时刻保持一种渴求的状态，无论此单例是否有人使用。</p>
<p>单例的太阳对象写好了，可一切皆是私有的，外部怎样才能访问它呢？正如同程序入口的静态方法main()，它不需要任何对象引用就能被访问，我们同样需要一个静态方法getInstance()来获取太阳的单例对象，同时将其设置为“public”以暴露给外部使用，请参看代码清单2-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162141914.png" alt="image-20231016214122870"></p>
<p>如代码清单2-4所示，太阳单例类的雏形已经完成了，对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。当然，读者还可以添加其他功能方法，如发光和发热等，此处就不再赘述了。</p>
<h3 id="2-3-懒汉的队伍"><a href="#2-3-懒汉的队伍" class="headerlink" title="2.3 懒汉的队伍"></a>2.3 懒汉的队伍</h3><p>至此，我们已经学会了单例模式的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。沿着这个思路，我们继续对太阳类进行改造，请参看代码清单2-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162146741.png" alt="image-20231016214603688"></p>
<p>如代码清单2-5所示，可以看到我们一开始并没有造太阳，所以去掉了关键字final，只有在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。这样的好处是如无请求就不实例化，节省了内存空间；而坏处是第一次请求的时候速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳（即使速度快到可以忽略不计）。</p>
<p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第10行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且对sun进行多次赋值（覆盖）操作，这违背了单例的理念。我们再来改良一下，把请求方法加上synchronized（同步锁）让其同步，如此一来，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来，请参看代码清单2-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162148548.png" alt="image-20231016214817514"></p>
<p>如代码清单2-6所示，我们将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。然而这样的做法是要付出一定代价的，试想，线程还没进入方法内部便不管三七二十一直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。我们只是为了实例化一个单例对象而已，犯不上如此兴师动众，使用synchronized让所有请求排队等候。所以，要保证多线程并发下逻辑的正确性，同步锁一定要加得恰到好处，其位置是关键所在，请参看代码清单2-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162149853.png" alt="image-20231016214917776"></p>
<p>如代码清单2-7所示，我们在太阳类Sun中第3行对sun变量的定义不再使用find关键字，这意味着它不再是常量，而是需要后续赋值的变量；而关键字volatile对静态变量的修饰则能保证变量值在各线程访问时的同步性、唯一性。需要特别注意的是，对于第9行的getInstance()方法，我们去掉了方法上的关键字synchronized，使大家都可以同时进入方法并对其进行开发。请仔细阅读每行代码的注释，有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。而在第11行我们又加上了同步块以防止多个线程进入，这就类似于观日台是一个狭长的走廊，大家排队进入。随后在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳</p>
<p>随后发生的事情我们就可以预见了，太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例就可以了，阳光普照大地，将温暖洒向人间。</p>
<p>大家注意到没有，我们一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：外层放宽入口，保证线程并发的高效性；内层加锁同步，保证实例化的单次运行。如此里应外合，不仅达到了单例模式的效果，还完美地保证了构建过程的运行效率，一举两得。</p>
<h3 id="2-4-大道至简"><a href="#2-4-大道至简" class="headerlink" title="2.4 大道至简"></a>2.4 大道至简</h3><p>相比“懒汉模式”，其实在大多数情况下我们通常会更多地使用“饿汉模式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。我们来看单例模式的类结构，如图2-3所示。单例模式的角色定义如下。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162154860.png" alt="image-20231016215458815"></p>
<p>■ Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用private关键字隐藏起来，对外只提供getInstance()方法以获得这个单例对象。</p>
<p>除了“饿汉”与“懒汉”这2种单例模式，其实还有其他的实现方式。但万变不离其宗，它们统统都是由这2种模式发展、衍生而来的。我们都知道Spring框架中的IoC容器很好地帮我们托管了业务对象，如此我们就不必再亲自动手去实例化这些对象了，而在默认情况下我们使用的正是框架提供的“单例模式”。诚然，究其代码实现当然不止如此简单，但我们应该追本溯源，抓住其本质的部分，理解其核心的设计思想，再针对不同的应用场景做出相应的调整与变动，结合实践举一反三。</p>
<h2 id="第3章-原型"><a href="#第3章-原型" class="headerlink" title="第3章　原型"></a>第3章　原型</h2><p>原型模式(Prototype)，在制造业中通常是指大批量生产开始之前研发出的概念模型，并基于各种参数指标对其进行检验，如果达到了质量要求，即可参照这个原型进行批量生产。原型模式达到以原型实例创建副本实例的目的即可，并不需要知道其原始类，也就是说，原型模式可以用对象创建对象，而不是用类创建对象，以此达到效率的提升。</p>
<h3 id="3-1-原件与副本"><a href="#3-1-原件与副本" class="headerlink" title="3.1 原件与副本"></a>3.1 原件与副本</h3><p>在讲原型模式之前，我们先得搞清楚什么是类的实例化。相信大家一定见过活字印章，如图3-1所示，当我们调整好需要的日期（初始化参数），再轻轻一盖（调用构造方法），一个实例化后的日期便跃然纸上了，这个过程正类似于类的实例化。</p>
<p>其实构造一个对象的过程是耗时耗力的。想必大家一定有过打印和复印的经历，为了节省成本，我们通常会用打印机把电子文档打印到A4纸上（原型实例化过程），再用复印机把这份纸质文稿复制多份（原型拷贝过程），这样既实惠又高效。那么，对于第一份打印出来的原文稿，我们可以称之为“原型文件”，而对于复印过程，我们则可以称之为“原型拷贝”，如图3-2所示。</p>
<h3 id="3-2-卡顿的游戏"><a href="#3-2-卡顿的游戏" class="headerlink" title="3.2 卡顿的游戏"></a>3.2 卡顿的游戏</h3><p>想必大家已经明白了类的实例化与克隆之间的区别，二者都是在造对象，但方法绝对是不同的。原型模式的目的是从原型实例克隆出新的实例，对于那些有非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。理论还需与实践结合，下面开始实战部分，假设我们准备设计一个空战游戏的程序，如图3-3所示。</p>
<p>我们这里为了保持简单，设定游戏为单打，也就是说主角飞机只有一架，而敌机则有很多架，而且可以在屏幕上垂直向下移动来撞击主角飞机。具体是如何实现的呢？其实非常简单，就是程序不停改变其坐标并在画面上重绘而已。由浅入深，我们先试着写一个敌机类，请参看代码清单3-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162201482.png" alt="image-20231016220106408"></p>
<p>如代码清单3-1所示，敌机类EnemyPlane在第6行的敌机构造器方法中对飞机的横坐标x进行了初始化，而纵坐标则固定为0，这是由于敌机一开始是从顶部飞出的。所以其纵坐标y必然为0（屏幕左上角坐标为[0, 0]）。继续往下看，敌机类只提供了getter方法而没有提供setter方法，也就是说我们只能在初始化时确定好敌机的横坐标x，之后则不允许再更改坐标了。当游戏运行时，我们只要连续调用第18行的飞行方法fly()，便可以让飞机像雨点一样不断下落。在开始绘制敌机动画之前，我们首先得实例化500架敌机，请参看代码清单3-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162202565.png" alt="image-20231016220239519"></p>
<p>如代码清单3-2所示，我们在第6行使用了循环的方式来批量生产敌机，并使用了“new”关键字来实例化敌机，循环结束后500架敌机便统统被加入第4行定义的飞机列表enemyPlanes中。这种做法看似没有任何问题，然而效率却是非常低的。我们知道在游戏画面上根本没必要同时出现这么多敌机，而在游戏还未开始之前，也就是游戏的加载阶段我们就实例化了这一关卡的所有500架敌机，这不但使加载速度变慢，而且是对有限内存资源的一种浪费。那么到底什么时候去构造敌机？答案当然是懒加载了，也就是按照地图坐标，屏幕滚动到某一点时才实时构造敌机，这样一来问题就解决了。</p>
<p>然而遗憾的是，懒加载依然会有性能问题，主要原因在于我们使用的“new”关键字进行的基于类的实例化过程，因为每架敌机都进行全新构造的做法是不合适的，其代价是耗费更多的CPU资源，尤其在一些大型游戏中，很多个线程在不停地运转着，CPU资源本身就非常宝贵，此时若进行大量的类构造与复杂的初始化工作，必然会造成游戏卡顿，甚至有可能会造成系统无响应，使游戏体验大打折扣，如图3-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162204576.png" alt="image-20231016220422526"></p>
<h3 id="3-3-细胞分裂"><a href="#3-3-细胞分裂" class="headerlink" title="3.3 细胞分裂"></a>3.3 细胞分裂</h3><p>硬件永远离不开优秀的软件，我们绝不允许以糟糕的软件设计对硬件发起挑战，因而代码优化势在必行。我们思考一下之前的设计，既然循环第一次后已经实例化好了一个敌机原型，那么之后又何必去重复这个构造过程呢？敌机对象能否像细胞分裂一样自我复制呢？要解决这些问题，原型模式是最好的解决方案了，下面我们对敌机类进行重构并让其支持原型拷贝，请参看代码清单3-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162205833.png" alt="image-20231016220516782"></p>
<p>如代码清单3-3所示，我们让敌机类EnemyPlane实现了java.lang包中的克隆接口Cloneable，并在第29行的实现方法中调用了父类Object的克隆方法，如此一来外部就能够对本类的实例进行克隆操作了，省去了由类而生的再造过程。还需要注意的是，我们在第23行处加入了设置横坐标方法setX()，使被实例化后的敌机对象依然可以支持坐标位置的变更，这是为了保证克隆飞机的坐标位置个性化。</p>
<h3 id="3-4-克隆工厂"><a href="#3-4-克隆工厂" class="headerlink" title="3.4 克隆工厂"></a>3.4 克隆工厂</h3><p>至此，克隆模式其实已经实现了，我们只需简单调用克隆方法便能更高效地得到一个全新的实例副本。为了更方便地生产飞机，我们决定定义一个敌机克隆工厂类，请参看代码清单3-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162208369.png" alt="image-20231016220826329"></p>
<p>如代码清单3-4所示，我们在敌机克隆工厂类EnemyPlaneFactory中第4行使用了一个静态的敌机对象作为原型，并于第7行提供了一个获取敌机实例的方法getInstance()，其中简单地调用克隆方法得到一个新的克隆对象（此处省略了异常捕获代码），并将其横坐标重设为传入的参数，最后返回此克隆对象，这样我们便可轻松获取一架敌机的克隆实例了。</p>
<p>敌机克隆工厂类定义完毕，客户端代码就留给读者自己去实践了。但需要注意，一定得使用“懒加载”的方式，如此既可以节省内存空间，又可以确保敌机的实例化速度，实现敌机的即时性按需克隆，这样游戏便再也不会出现卡顿现象了。</p>
<h3 id="3-5-深拷贝与浅拷贝"><a href="#3-5-深拷贝与浅拷贝" class="headerlink" title="3.5 深拷贝与浅拷贝"></a>3.5 深拷贝与浅拷贝</h3><p>最后，在使用原型模式之前，我们还必须得搞清楚浅拷贝和深拷贝这两个概念，否则会对某些复杂对象的克隆结果感到无比困惑。让我们再扩展一下场景，假设敌机类里有一颗子弹可以发射并击杀玩家的飞机，那么敌机中则包含一颗实例化好的子弹对象，请参看代码清单3-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162213224.png" alt="image-20231016221322201"></p>
<p>如代码清单3-5所示，对于这种复杂一些的敌机类，此时如果进行克隆操作，我们是否能将第3行中的子弹对象一同成功克隆呢？答案是否定的。我们都知道，Java中的变量分为原始类型和引用类型，所谓浅拷贝是指只复制原始类型的值，比如横坐标x与纵坐标y这种以原始类型int定义的值，它们会被复制到新克隆出的对象中。而引用类型bullet同样会被拷贝，但是请注意这个操作只是拷贝了地址引用（指针），也就是说副本敌机与原型敌机中的子弹是同一颗，因为两个同样的地址实际指向的内存对象是同一个bullet对象。</p>
<p>需要注意的是，克隆方法中调用父类Object的clone方法进行的是浅拷贝，所以此处的bullet并没有被真正克隆。然而，每架敌机携带的子弹必须要发射出不同的弹道，这就必然是不同的子弹对象了，所以此时原型模式的浅拷贝实现是无法满足需求的，那么该如何改动呢？请参看如代码清单3-6中对敌机类的深拷贝支持。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162214123.png" alt="image-20231016221434082"></p>
<p>如代码清单3-6所示，首先我们在第13行的克隆方法clone()中依旧对敌机对象进行了克隆操作，紧接着对敌机子弹bullet也进行了克隆，这就是深拷贝操作。当然，此处要注意对于子弹类Bullet同样也得实现克隆接口，请读者自行实现，此处就不再赘述了。</p>
<h3 id="3-6-克隆的本质"><a href="#3-6-克隆的本质" class="headerlink" title="3.6 克隆的本质"></a>3.6 克隆的本质</h3><p>终于，在我们用克隆模式对游戏代码反复重构后，游戏性能得到了极大的提升，流畅的游戏画面确保了优秀的用户体验。最后，我们来看原型模式的类结构，如图3-5所示。原型模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">■ Prototype（原型接口）：声明克隆方法，对应本例程代码中的Cloneable接口。</span><br><span class="line">■ ConcretePrototype（原型实现）：原型接口的实现类，实现方法中调用super.clone()即可得到新克隆的对象。</span><br><span class="line">■ Client（客户端）：客户端只需调用实现此接口的原型对象方法clone()，便可轻松地得到一个全新的实例对象。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162216826.png" alt="image-20231016221647744"></p>
<p>从类到对象叫作“创建”，而由本体对象至副本对象则叫作“克隆”，当需要创建多个类似的复杂对象时，我们就可以考虑用原型模式。究其本质，克隆操作时Java虚拟机会进行内存操作，直接拷贝原型对象数据流生成新的副本对象，绝不会拖泥带水地触发一些多余的复杂操作（如类加载、实例化、初始化等），所以其效率远远高于“new”关键字所触发的实例化操作。看尽世间烦扰，拨开云雾见青天，有时候“简单粗暴”也是一种去繁从简、不绕弯路的解决方案。</p>
<h2 id="第4章-工厂方法"><a href="#第4章-工厂方法" class="headerlink" title="第4章　工厂方法"></a>第4章　工厂方法</h2><p>制造业是一个国家工业经济发展的重要支柱，而工厂则是其根基所在。程序设计中的工厂类往往是对对象构造、实例化、初始化过程的封装，而工厂方法(Factory Method)则可以升华为一种设计模式，它对工厂制造方法进行接口规范化，以允许子类工厂决定具体制造哪类产品的实例，最终降低系统耦合，使系统的可维护性、可扩展性等得到提升。</p>
<h3 id="4-1-工厂的多元化与专业化"><a href="#4-1-工厂的多元化与专业化" class="headerlink" title="4.1 工厂的多元化与专业化"></a>4.1 工厂的多元化与专业化</h3><p>要理解工厂方法模式，我们还得从头说起。众所周知，要制造产品（实例化对象）就得用到关键字“new”，例如“Plane plane=new Plane(); ”，或许还会有一些复杂的初始化代码，这就是我们常用的传统构造方式。然而这样做的结果会使飞机对象的产生代码被牢牢地硬编码在客户端类里，也就是说客户端与实例化过程强耦合了。而事实上，我们完全不必关心产品的制造过程（实例化、初始化），而将这个任务交由相应的工厂来全权负责，工厂最终能交付产品供我们使用即可，如此我们便摆脱了产品生产方式的束缚，实现了与制造过程彻底解耦。</p>
<p>除此之外，工厂方法模式是基于多元化产品的构造方法发展而来的，它开辟了产品多元化的生产模式，不同的产品可以交由不同的专业工厂来生产，例如皮鞋由皮鞋工厂来制造，汽车则由汽车工厂来制造，专业化分工明确，如图4-1所示。</p>
<h3 id="4-2-游戏角色建模"><a href="#4-2-游戏角色建模" class="headerlink" title="4.2 游戏角色建模"></a>4.2 游戏角色建模</h3><p>在制造产品之前，我们先得为它们建模。我们依旧以空战游戏来举例，通常这类游戏中主角飞机都拥有强大的武器装备，以应对敌众我寡的游戏局面，所以敌人的种类就应当多样化，以带给玩家更加丰富多样的游戏体验。于是我们增加了一些敌机、坦克，游戏画面如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162222535.png" alt="image-20231016222253497"></p>
<p>如图4-2所示，游戏中敌人的种类有飞机和坦克，虽然它们之间的区别比较大，但总有一些共同的属性或行为，例如一对用来描述位置状态的坐标，以及一个展示（绘制）方法，以便将自己绘制到相应的地图位置上。好了，现在我们使用抽象类来定义所有敌人的父类，请参看代码清单4-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162223933.png" alt="image-20231016222323896"></p>
<p>如代码清单4-1所示，我们在敌人抽象类Enemy中第13行定义了一个显示方法show()，并声明其抽象方法，以交给子类去实现，并按照构造方法（第7行）中初始化的坐标位置将自己绘制到地图上。接下来是具体子类实现，也就是敌机类和坦克类，请参看代码清单4-2与代码清单4-3。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224024.png" alt="image-20231016222410990"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162224550.png" alt="image-20231016222417493"></p>
<p>如代码清单4-2与代码清单4-3所示，飞机类Airplane和坦克类Tank都继承了敌人抽象类Enemy，并且分别实现了各自独特的展示方法show()，其中坦克应该绘制在下层（但在地图层之上）图层，而飞机则绘制在上层图层，这样才能遮盖住下层的所有图层以达到期望的视觉效果。</p>
<h3 id="4-3-简单工厂不简单"><a href="#4-3-简单工厂不简单" class="headerlink" title="4.3 简单工厂不简单"></a>4.3 简单工厂不简单</h3><p>产品建模完成后，就应该考虑如何实例化和初始化这些敌人了。毋庸置疑，要使它们都出现在屏幕最上方，就得使其纵坐标y被初始化为0，而对于横坐标x该怎样初始化呢？如果让敌人出现于屏幕正中央的话，就得将其横坐标初始化为屏幕宽度的一半，显然，如此玩家只需要一直对准屏幕中央射击，这对游戏可玩性来说是非常糟糕的，所以我们最好让敌人的横坐标随机产生，这样才能给玩家带来更好的游戏体验。我们来看客户端如何进行设置，请参看代码清单4-4</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162225483.png" alt="image-20231016222540439"></p>
<p>如代码清单4-4所示，我们在第4行假设屏幕宽度为100，然后在第7行生成一个从0到“屏幕宽度”的随机数，再以此为横坐标构造并初始化敌人（为保持简单不考虑敌人自身的宽度），这样敌人就会出现在随机的横坐标位置上了。接着往下看，我们在第11行构造坦克时做了同样的设置，最后的输出结果达到了我们的预期，飞机和坦克随机出现于屏幕顶部，游戏可玩性大大提高。</p>
<p>然而，制造随机出现的敌人这个动作貌似不应该出现在客户端类中，试想如果我们还有其他敌人也需要构造的话，那么同样的代码就会再次出现，尤其是当初始化越复杂的时候重复代码就会越多。如此耗时费力，何不把这些实例化逻辑抽离出来作为一个工厂类？沿着这个思路，我们来开发一个制造敌人的简单工厂类，请参看代码清单4-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162228669.png" alt="image-20231016222800625"></p>
<p>如代码清单4-5所示，简单工厂类SimpleFactory将之前在客户端类里制造敌人的代码挪过来，并封装在第10行的制造方法create()方法中，这里我们在第13行加入了一些逻辑判断，使其可以根据传入的敌人种类（飞机或坦克）生产出相应的对象实例，并随机初始化其位置。如此一来，制造敌人这个任务就全权交由简单工厂来负责了，于是客户端便可以直接从简单工厂取用敌人了，请参看代码清单4-6。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162229987.png" alt="image-20231016222929942"></p>
<p>如代码清单4-6所示，客户端类的代码变得异常简单、清爽，这就是分类封装、各司其职的好处。然而，这个简单工厂的确很“简单”，但并不涉及任何的模式设计范畴，虽然客户端中不再直接出现对产品实例化的代码，但羊毛出在羊身上，制造逻辑只是被换了个地方，挪到了简单工厂中而已，并且客户端还要告知产品种类才能产出，这无疑是另一种意义上的耦合。</p>
<p>除此之外，简单工厂一定要保持简单，否则就不要用简单工厂。随着游戏项目需求的演变，简单工厂的可扩展性也会变得很差，例如对于那段对产品种类的判断逻辑，如果有新的敌人类加入，我们就需要再修改简单工厂。随着生产方式不断多元化，工厂类就得被不断地反复修改，严重缺乏灵活性与可扩展性，尤其是对于一些庞大复杂的系统，大量的产品判断逻辑代码会被堆积在制造方法中，看起来好像功能强大、无所不能，其实维护起来举步维艰，简单工厂就会变得一点也不简单了。</p>
<h3 id="4-4-制定工业制造标准"><a href="#4-4-制定工业制造标准" class="headerlink" title="4.4 制定工业制造标准"></a>4.4 制定工业制造标准</h3><p>其实系统中并不是处处都需要调用这样一个万能的“简单工厂”，有时系统只需要一个坦克对象，所以我们不必大动干戈使用这样一个臃肿的“简单工厂”。另外，由于用户需求的多变，我们又不得不生成大量代码，这正是我们要调和的矛盾。</p>
<p>针对复杂多变的生产需求，我们需要对产品制造的相关代码进行合理规划与分类，将简单工厂的<strong>制造方法进行拆分</strong>，构建起抽象化、多态化的生产模式。下面我们就对各种各样的生产方式（工厂方法）进行抽象，首先定义一个工厂接口，以确立统一的工业制造标准，请参看代码清单4-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162234425.png" alt="image-20231016223455402"></p>
<p>如代码清单4-7所示，工厂接口Factory其实就是工厂方法模式的核心了。我们在第3行中声明了工业制造标准，只要传入屏幕宽度，就在屏幕坐标内产出一个敌人实例，任何工厂都应遵循此接口。接下来我们重构一下之前的简单工厂类，将其按产品种类拆分为两个类，请参看代码清单4-8和代码清单4-9。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162235172.png" alt="image-20231016223559136"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162236714.png" alt="image-20231016223605686"></p>
<p>如代码清单4-8和代码清单4-9所示，飞机工厂类AirplaneFactory与坦克工厂类TankFactory的代码简洁、明了，它们都以关键字implements声明了本类是实现工厂接口Factory的工厂实现类，并且在第4行给出了工厂方法create()的具体实现，其中飞机工厂制造飞机，坦克工厂制造坦克，各自有其独特的生产方式。</p>
<p>除了飞机和坦克，应该还会有其他的敌人，当玩家抵达游戏关底时总会有Boss出现，这时候我们该如何扩展呢？显而易见，基于此模式继续我们的扩展即可，先定义一个继承自敌人抽象类Enemy的Boss类，相应地还有Boss的工厂类，同样实现工厂方法接口，请分别参看代码清单4-10和代码清单4-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238986.png" alt="image-20231016223805959"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162238801.png" alt="image-20231016223813758"></p>
<p>这里要注意代码清单4-11，因为Boss出现的坐标总是处于屏幕的中央位置，所以关底Boss工厂类BossFactory在初始化时在第6行设置Boss对象的横坐标为屏幕宽度的一半，而不是随机生成横坐标。“万事俱备，只欠东风”，客户端开始运行游戏了，请参看代码清单4-12。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162239089.png" alt="image-20231016223917040"></p>
<p>如代码清单4-12所示，我们在第9行的循环体中调用坦克工厂类生成敌人，结果制造出的产品肯定是5辆坦克，接着又在第12行将工厂接口替换为飞机工厂类，结果5架飞机出现在屏幕上。抵达关底后，在第18行我们又将工厂接口替换为关底Boss工厂类，结果关底Boss出现并与玩家进行战斗，具体结果如第22行开始的输出所示。显而易见，多态化后的工厂多样性不言而喻，每个工厂的生产策略或方式都具备自己的产品特色，不同的产品需求都能找到相应的工厂来满足，即便没有，我们也可以添加新工厂来解决，以确保游戏系统具有良好的兼容性和可扩展性。</p>
<h3 id="4-5-劳动分工"><a href="#4-5-劳动分工" class="headerlink" title="4.5 劳动分工"></a>4.5 劳动分工</h3><p>至此，以工厂方法模式构建的空战游戏就完成了，之后若要加入新的敌人类，只需添加相应的工厂类，无须再对现有代码做任何更改。不同于简单工厂，工厂方法模式可以被看作由简单工厂演化而来的高级版，后者才是真正的设计模式。在工厂方法模式中，不仅产品需要分类，工厂同样需要分类，与其把所有生产方式堆积在一个简单工厂类中，不如把生产方式放在具体的子类工厂中去实现，这样做对工厂的抽象化与多态化有诸多好处，避免了由于新加入产品类而反复修改同一个工厂类所带来的困扰，使后期的代码维护以及扩展更加直观、方便。下面我们来看工厂方法模式的类结构，如图4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162249478.png" alt="image-20231016224949418"></p>
<p>工厂方法模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">■ Product（产品）：所有产品的顶级父类，可以是抽象类或者接口。对应本章例程中的敌人抽象类。</span><br><span class="line">■ ConcreteProduct（子产品）：由产品类Product派生出的产品子类，可以有多个产品子类。对应本章例程中的飞机类、坦克类以及关底Boss类。</span><br><span class="line">■ Factory（工厂接口）：定义工厂方法的工厂接口，当然也可以是抽象类，它使顶级工厂制造方法抽象化、标准统一化。</span><br><span class="line">■ ConcreteFactory（工厂实现）：实现了工厂接口的工厂实现类，并决定工厂方法中具体返回哪种产品子类的实例。</span><br></pre></td></tr></table></figure>
<p>工厂方法模式不但能将客户端与敌人的实例化过程彻底解耦，抽象化、多态化后的工厂还能让我们更自由灵活地制造出独特而多样的产品。其实工厂不必万能，方便面工厂不必生产汽车，手机工厂也不必生产牛仔裤，否则就会通而不精，妄想兼备所有产品线的工厂并不是好的工厂。反之，每个工厂都应围绕各自的产品进行生产，专注于自己的产品开发，沿用这种分工明确的工厂模式才能使各产业变得越来越专业化，而不至于造成代码逻辑泛滥，从而降低产出效率。正所谓“闻道有先后，术业有专攻”，正如英国经济学家亚当·斯密提出的劳动分工理论一样，如图4-4所示，明确合理的劳动分工才能真正地促进生产效率的提升。</p>
<h2 id="第5章-抽象工厂"><a href="#第5章-抽象工厂" class="headerlink" title="第5章　抽象工厂"></a>第5章　抽象工厂</h2><p>抽象工厂模式(Abstract Factory)是对工厂的抽象化，而不只是制造方法。我们知道，为了满足不同用户对产品的多样化需求，工厂不会只局限于生产一类产品，但是系统如果按工厂方法那样为每种产品都增加一个新工厂又会造成工厂泛滥。所以，为了调和这种矛盾，抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。抽象工厂是建立在制造复杂产品体系需求基础之上的一种设计模式，在某种意义上，我们可以<strong>将抽象工厂模式理解为工厂方法模式的高度集群化升级版</strong>，所以建议读者先充分理解上一章的内容再来阅读本章。</p>
<h3 id="5-1-品牌与系列"><a href="#5-1-品牌与系列" class="headerlink" title="5.1 品牌与系列"></a>5.1 品牌与系列</h3><p>我们都知道，在工厂方法模式中每个实际的工厂只定义了一个工厂方法。而随着经济发展，人们对产品的需求不断升级，并逐渐走向个性化、多元化，制造业也随之发展壮大起来，各类工厂遍地开花，能够制造的产品种类也丰富了起来，随之而来的弊端就是工厂泛滥。</p>
<p>针对这种情况，我们就需要进行产业规划与整合，对现有工厂进行重构。例如，我们可以基于产品品牌与系列进行生产线规划，按品牌划分A工厂与B工厂。具体以汽车工厂举例，A品牌汽车有轿车、越野车、跑车3个系列的产品，同样地，B品牌汽车也包括以上3个系列的产品，如此便形成了两个产品族，分别由A工厂和B工厂负责生产，每个工厂都有3条生产线，分别生产这3个系列的汽车，如图5-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162253113.png" alt="image-20231016225358036"></p>
<p>基于这2个品牌汽车工厂的系列生产线，如果今后产生新的C品牌汽车、D品牌汽车等，都可以沿用此种规划好的生产模式，这便是抽象工厂模式的基础数据模型。</p>
<h3 id="5-2-产品规划"><a href="#5-2-产品规划" class="headerlink" title="5.2 产品规划"></a>5.2 产品规划</h3><p>无论哪种工厂模式，都一定是基于特定的产品特性发展而来的，所以我们首先得从产品建模切入。假设某公司要开发一款星际战争游戏，战争设定在太阳系文明与异星系文明之间展开，游戏兵种就可以分为人类与外星怪兽2个族，游戏画面如图5-2所示。</p>
<p>如图5-2所示，游戏战争场面相当激烈，人类拥有各种军工高科技装备，而外星怪兽则靠血肉之躯与人类战斗，所以这两族的兵种必然有着巨大的差异，这就意味着各兵种首先应该按族划分。此外，从另一个角度来看，它们又有相同之处，2个族的兵种都可以被简单归纳为初级（1级）、中级（2级）、高级（3级）3个等级，如同之前对汽车品牌系列的规划一样，各族兵种也应当按等级划分，最终我们可以得到一个对所有兵种分类归纳的表格，如图5-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162255252.png" alt="image-20231016225545193"></p>
<p>如图5-3所示，兵种规划表格以列划分等级，以行划分族，一目了然，我们可以据此建立数据模型。首先，我们来定义一个所有兵种的顶层父类兵种，这里我们使用抽象类，以达到属性继承给子类的目的，请参看代码清单5-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257378.png" alt="image-20231016225701343"></p>
<p>如代码清单5-1所示，任何兵种都具有攻击力、防御力、生命力、坐标方位等属性，从第3行开始我们对以上属性依次定义。除此之外，第17行的展示show()（绘制到图上）与第19行的攻击attack()这两个抽象方法交由子类实现。接下来我们将兵种按等级分类，假设同一等级的攻击力、防御力等属性值是相同的，所以初级、中级、高级兵种会分别对应3个等级的兵种类，请参看代码清单5-2、代码清单5-3、代码清单5-4。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162257782.png" alt="image-20231016225757744"></p>
<p>如代码清单5-2、代码清单5-3、代码清单5-4所示，各等级兵种类都继承自兵种抽象类Unit，它们对应的攻击力、防御力及生命力也各不相同，等级越高，其属性值也越高（当然制造成本也会更高，本例我们不考虑价格属性）。接下来我们来定义具体的兵种类，首先是人类兵种的海军陆战队员、变形坦克和巨型战舰，分别对应初级、中级、高级兵种，请参看代码清单5-5、代码清单5-6、代码清单5-7。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259295.png" alt="image-20231016225916264"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259805.png" alt="image-20231016225922771"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162259222.png" alt="image-20231016225929170"></p>
<p>如代码清单5-5、代码清单5-6、代码清单5-7所示，我们在第3行的构造方法中调用了父类，并初始化了坐标属性，其攻击力、防御力和生命力已经在对应等级的父类里初始化好了。此外，在代码第8行与第13行我们分别重写了各兵种的展示方法和攻击方法，进行行为差异化，比如坦克可以变形增加攻击力与射程，再比如战舰攻击地面目标时用激光炮，而攻击空中目标的切换至导弹等，本例我们不做过多延伸，读者可自行实现。同样，外星怪兽族对应的初级、中级、高级兵种分别为蟑螂、毒液、猛犸，请参看代码清单5-8、代码清单5-9、代码清单5-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300063.png" alt="image-20231016230041021"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162300205.png" alt="image-20231016230048164"></p>
<p>至此，所有兵种类已定义完毕，代码不是难点，重点集中在对兵种的划分上，横向划分族，纵向划分等级（系列），利用类的抽象与继承描绘出所有的游戏角色以及它们之间的关系，同时避免了不少重复代码。</p>
<h3 id="5-3-生产线规划"><a href="#5-3-生产线规划" class="headerlink" title="5.3 生产线规划"></a>5.3 生产线规划</h3><p>既然产品类的数据模型构建完成，相应的产品生产线也应该建立起来，接下来我们就可以定义这些产品的制造工厂了。我们一共定义了6个兵种产品，那么每个产品都需要对应一个工厂类吗？答案是否定的。本着人类靠科技、怪兽靠繁育的游戏理念，人类兵工厂自然是高度工业化的，而怪兽的生产一定靠的是母巢繁殖，所以应该将工厂分为2个族，并且每个族工厂都应该拥有3个等级兵种的制造方法。如此规划不但合理，而且避免了工厂类泛滥的问题。那么，首先我们来制定这3个工业制造标准，也就是定义抽象工厂接口，请参看代码清单5-11。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162303735.png" alt="image-20231016230330685"></p>
<p>在代码清单5-11中，抽象兵工厂接口定义了3个等级兵种的制造标准，这意味着子类工厂必须具备初级、中级、高级兵种的生产能力（类似一个品牌的不同系列生产线）。理解了这一点后，我们就可以定义人类兵工厂与外星母巢的工厂类实现了，请参看代码清单5-12、代码清单5-13。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162305126.png" alt="image-20231016230551092"></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162306521.png" alt="image-20231016230611485"></p>
<p>如代码清单5-12、代码清单5-13所示，人类兵工厂与外星母巢分别实现了3个等级兵种的制造方法，其中前者由低到高分别返回海军陆战队员、变形坦克以及巨型战舰对象，后者则分别返回蟑螂兵、毒液兵以及猛犸巨兽对象，生产线规划非常清晰。好了，所有兵种与工厂准备完毕，我们可以用客户端开始模拟游戏了，请参看代码清单5-14。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162307391.png" alt="image-20231016230713358"></p>
<p>如代码清单5-14所示，第一位玩家选择了人类族，在第9行用抽象兵工厂接口引用了人类兵工厂实现，接着调用3个等级的制造方法分别得到人类族的对应兵种。接着第二位玩家选择了外星怪兽族，这时将抽象兵工厂接口引用替换为外星母巢实现，此时制造出的兵种变为3个等级的外星怪兽族兵种。最后大混战开始了，调用每个兵种的攻击方法会展示出不同的结果。第42行开始的输出证明所有兵种均制造成功，抽象工厂模式得以发挥作用。此时，如果玩家需要一个新族加入，我们可以在此模式之上去实现一个新的族工厂并实现3个等级的制造方法，工厂一经替换即可产出各系列产品兵种，且无须改动现有代码，良好的可扩展性一览无遗，这就是一套拥有完备生产模式的标准化工业系统所带来的好处。</p>
<h3 id="5-4-分而治之"><a href="#5-4-分而治之" class="headerlink" title="5.4 分而治之"></a>5.4 分而治之</h3><p>至此，抽象工厂制造模式已经布局完成，各工厂可以随时大规模投入生产活动了。当然，我们还可以进一步，再加一个“制造工厂的工厂”来决定具体让哪个工厂投入生产活动。此时客户端就无须关心工厂的实例化过程了，直接使用产品就可以了，至于产品属于哪个族也已经无关紧要，这也是抽象工厂可以被视为“工厂的工厂”的原因，读者可以自行实践代码。</p>
<p>与工厂方法模式不同，抽象工厂模式能够应对更加复杂的产品族系，它更类似于一种对“工业制造标准”的制定与推行，各工厂实现都遵循此标准来进行生产活动，以工厂类划分产品族，以制造方法划分产品系列，达到无限扩展产品的目的。最后我们来看抽象工厂模式的类结构，如图5-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310162310425.png" alt="image-20231016231020349"></p>
<p>抽象工厂模式的各角色定义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">■ AbstractProduct1、AbstractProduct2（抽象产品1、抽象产品2）：产品系列的抽象类，图中一系产品与二系产品分别代表同一产品族的多个产品系列，对应本章例程中的初级、中级、高级兵种抽象类。</span><br><span class="line">■ ProductA1、ProductB1、ProductA2、ProductB2（产品A1、产品B1、产品A2、产品B2）：继承自抽象产品的产品实体类，其中ProductA1与ProductB1代表A族产品与B族产品的同一产品系列，类似于本章例程中人类族与外星怪兽族的初级兵种，之后的产品实体类以此类推。</span><br><span class="line">■ AbstractFactory（抽象工厂接口）：各族工厂的高层抽象，可以是接口或者抽象类。抽象工厂对各产品系列的制造标准进行规范化定义，但具体返回哪个族的产品由具体族工厂决定，它并不关心。</span><br><span class="line">■ ConcreteFactoryA、ConcreteFactoryB（工厂A实现、工厂B实现）：继承自抽象工厂的各族工厂，需实现抽象工厂所定义的产品系列制造方法，可以扩展多个工厂实现。对应本章例程中的人类兵工厂与外星母巢。</span><br><span class="line">■ Client（客户端）：产品的使用者，只关心制造出的产品系列，具体是哪个产品族由工厂决定。</span><br></pre></td></tr></table></figure>
<p>产品虽然繁多，但总有品牌、系列之分。基于此抽象工厂模式以品牌与系列进行全局规划，将看似杂乱无章的产品规划至不同的族系，再通过抽象工厂管理起来，分而治之，合纵连横。需要注意的是，抽象工厂模式一定是基于产品的族系划分来布局的，其产品系列一定是相对固定的，故以抽象工厂来确立工业制造标准（各产品系列生产接口）。而产品族则可以相对灵活多变，如此一来，我们就可以方便地扩展与替换族工厂，以达到灵活产出各类产品族系的目的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://wdpname.github.io/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">创建篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8D%95%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">第2章　单例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%A4%AA%E9%98%B3"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 孤独的太阳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A5%BF%E6%B1%89%E9%80%A0%E6%97%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.2 饿汉造日</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%87%92%E6%B1%89%E7%9A%84%E9%98%9F%E4%BC%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.3 懒汉的队伍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.4 大道至简</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">第3章　原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E4%BB%B6%E4%B8%8E%E5%89%AF%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.1 原件与副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%A1%E9%A1%BF%E7%9A%84%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2 卡顿的游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.3 细胞分裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%8B%E9%9A%86%E5%B7%A5%E5%8E%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.4 克隆工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.5.</span> <span class="toc-text">3.5 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%85%8B%E9%9A%86%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">3.6 克隆的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">第4章　工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B7%A5%E5%8E%82%E7%9A%84%E5%A4%9A%E5%85%83%E5%8C%96%E4%B8%8E%E4%B8%93%E4%B8%9A%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.1 工厂的多元化与专业化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.2 游戏角色建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%B8%8D%E7%AE%80%E5%8D%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3 简单工厂不简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%88%B6%E5%AE%9A%E5%B7%A5%E4%B8%9A%E5%88%B6%E9%80%A0%E6%A0%87%E5%87%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.4 制定工业制造标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8A%B3%E5%8A%A8%E5%88%86%E5%B7%A5"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.5 劳动分工</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">1.4.</span> <span class="toc-text">第5章　抽象工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%93%81%E7%89%8C%E4%B8%8E%E7%B3%BB%E5%88%97"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.1 品牌与系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%92"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.2 产品规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%94%9F%E4%BA%A7%E7%BA%BF%E8%A7%84%E5%88%92"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.3 生产线规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">5.4 分而治之</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="秒懂设计模式"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秒懂设计模式"/></a><div class="content"><a class="title" href="/2023/10/16/%E7%A7%92%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="秒懂设计模式">秒懂设计模式</a><time datetime="2023-10-16T13:35:45.000Z" title="发表于 2023-10-16 21:35:45">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven实战"/></a><div class="content"><a class="title" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战">Maven实战</a><time datetime="2023-10-15T11:12:27.000Z" title="发表于 2023-10-15 19:12:27">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解HTTP"/></a><div class="content"><a class="title" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2023-10-15T10:39:45.000Z" title="发表于 2023-10-15 18:39:45">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud微服务和分布式系统实践"/></a><div class="content"><a class="title" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践">Spring Cloud微服务和分布式系统实践</a><time datetime="2023-10-13T10:57:16.000Z" title="发表于 2023-10-13 18:57:16">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>