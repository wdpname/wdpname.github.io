<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring Cloud微服务和分布式系统实践 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第一部分 概述和基础本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。 本部分包含以下内容： ●分布式和微服务概述； ●技术基础。 第1章 分布式和微服务概述1.1 互联网系统的特征在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Cloud微服务和分布式系统实践">
<meta property="og:url" content="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第一部分 概述和基础本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。 本部分包含以下内容： ●分布式和微服务概述； ●技术基础。 第1章 分布式和微服务概述1.1 互联网系统的特征在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-13T10:57:16.000Z">
<meta property="article:modified_time" content="2023-11-08T14:49:05.848Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Cloud微服务和分布式系统实践',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-08 22:49:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Cloud微服务和分布式系统实践</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T10:57:16.000Z" title="发表于 2023-10-13 18:57:16">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-08T14:49:05.848Z" title="更新于 2023-11-08 22:49:05">2023-11-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Cloud微服务和分布式系统实践"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第一部分-概述和基础"><a href="#第一部分-概述和基础" class="headerlink" title="第一部分 概述和基础"></a>第一部分 概述和基础</h1><p>本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。</p>
<p>本部分包含以下内容：</p>
<p>●分布式和微服务概述；</p>
<p>●技术基础。</p>
<h2 id="第1章-分布式和微服务概述"><a href="#第1章-分布式和微服务概述" class="headerlink" title="第1章 分布式和微服务概述"></a>第1章 分布式和微服务概述</h2><h3 id="1-1-互联网系统的特征"><a href="#1-1-互联网系统的特征" class="headerlink" title="1.1 互联网系统的特征"></a>1.1 互联网系统的特征</h3><p>在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的系统，我们把这种多台机器相互协作完成企业业务功能的系统，称为分布式系统。</p>
<h3 id="1-2-分布式系统概述"><a href="#1-2-分布式系统概述" class="headerlink" title="1.2 分布式系统概述"></a>1.2 分布式系统概述</h3><p>分布式系统由一组为了完成共同任务而协调工作的计算机节点组成，它们通过网络进行通信。分布式系统能满足互联网对大数据存储、高并发和快响应的要求，采用了分而治之的思想。从实际成本来说，可以使用廉价的普通机器进行独立运算。然后通过相互协助来完成网站业务，这样就可以完成单个计算机节点无法完成的计算和存储任务了。为了让大家能够更好地了解分布式系统的好处，这里先给出一个简易的分布式架构，如图1-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141444580.png" alt="image-20231014144436444"></p>
<h4 id="1-2-1-分布式的切分方法"><a href="#1-2-1-分布式的切分方法" class="headerlink" title="1.2.1 分布式的切分方法"></a>1.2.1 分布式的切分方法</h4><p>使用分布式系统，就意味着需要将系统按照不同的维度（如业务、数据等）切分给各个不同节点的机器。因此，需要对业务或者数据进行合理切分，让多个机器节点能够相互协作，以满足业务功能的需要。在下面几节中，我们将讨论分布式常见的切分方法。但是请注意，这里只是讨论了常用的切分方法，并不是只有这些切分方法。</p>
<h5 id="1．水平切分"><a href="#1．水平切分" class="headerlink" title="1．水平切分"></a>1．水平切分</h5><p>所谓水平切分，就是将同一个系统部署到多台机器上，如图1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141445823.png" alt="image-20231014144534794"></p>
<p>从图1-3中可以看到，单体的Web服务器变成了多个Web服务器节点，每台服务器都有相同的应用，都能独立完成计算，互不相干。这样的切分有以下几个好处。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●简单：只需要实现一个路由算法，将请求合理地分配到各个节点即可。目前能够快速方便地实现这个功能的网关包括Nginx、Netflix Zuul和Spring Cloud Gateway等。</span><br><span class="line">●独立：每个节点都有完整的运算功能，不需要依赖其他节点，因此系统之间不需要太多的交互。</span><br><span class="line">●高可用：当出现不能工作的节点时，系统仍然可以继续运行，无须停机，因为路由算法不会给不能工作的节点分配请求。</span><br><span class="line">●可伸缩：可以随着业务的增长，增加服务节点，也可以随着业务的缩减，减少服务节点，二者都十分容易。</span><br><span class="line">●高性能：因为都是在单机内完成，不需要做外部调用，因此可以得到很高的性能。</span><br></pre></td></tr></table></figure>
<p>以上就是水平切分的优势，但是这样的分法，也有很大的弊端。随着业务的发展，业务会从简单变复杂。例如，一个电商的网站，用户和业务不断膨胀，所需的产品、卖家、交易和评论业务也会日趋复杂。如果此时还将所有的业务全部集中在一套系统里开发，那么显然所有业务都会耦合到一套系统里，日后的扩展和维护会越来越困难。一方面，我们会不断地通过打包来升级系统，使得系统的稳定性和可靠性不断下降；另一方面，维护起来也不方便，例如，要升级产品业务，就需要对全部节点进行升级，而这样的升级会比较麻烦。</p>
<h5 id="2．垂直切分"><a href="#2．垂直切分" class="headerlink" title="2．垂直切分"></a>2．垂直切分</h5><p>如上所述，随着业务的增加和深入，以及用户数的膨胀，有时候，单一业务也会随之变得异常复杂，有必要按照业务的维度进行拆分，将各个业务独立出来，单独开发和维护。假设，我们将用户、交易和产品系统拆分出来，独立开发，就可以得到图1-4所示的架构。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141446321.png" alt="image-20231014144659292"></p>
<p>从图1-4中可以看出，我们把系统按照业务维度进行了切分，这样每一个系统就都能独立开发和维护了。垂直切分有以下好处。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">●提高业务独立性：只要根据业务把系统划分成高内聚、低耦合的模块，就能极大地降低开发难度。</span><br><span class="line">●提高灵活性：任何一个业务发生改变，都只需要维护相关的系统，而无须将全部系统打包上线。</span><br><span class="line">●提高可维护性：独立的系统更容易发现问题。因为将业务分离出去后，发生的异常情况更容易被定位了，所以开发者和业务人员维护起来更方便了。虽然这样的划分带来了以上诸多好处，但其存在的弊端也是值得我们重视的。</span><br><span class="line">●增加了系统之间的协作：系统之间往往需要协作完成任务，也就是说，系统之间是相互依赖的。例如，购买一件商品，需要买家系统提供买家信息，产品系统扣减产品库存，交易系统记录商品交易，这需要3个系统共同协作来完成。从这个角度来说，系统之间必须进行协作。现今流行的系统交互有远程过程调用（RPC）、面向服务的架构（SOA）、REST风格请求和消息机制等。</span><br><span class="line">●降低了可用性：因为系统之间存在依赖，所以任何一个系统出现问题，都会影响其他系统。例如，产品系统不可用，就无法扣减库存，也就无法进行购买产品的交易了。由此可见，可用性大大降低。</span><br><span class="line">●数据一致性难以保证：因为节点之间需要通信，而网络通信往往并不可靠，所以节点之间数据的一致性难以保证。只能通过某些方法尽量减少不一致性。</span><br></pre></td></tr></table></figure>
<h5 id="3．混合切分"><a href="#3．混合切分" class="headerlink" title="3．混合切分"></a>3．混合切分</h5><p>上文我们讨论了水平切分和垂直切分，也讨论了它们的利弊。本节的混合切分是将水平切分和垂直切分结合起来的一种切分方法。现今微服务架构大部分采用了这种分法，因此这也是本章的重点内容之一。先看一下图1-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141447967.png" alt="image-20231014144759925"></p>
<p>在图1-5中，先是把系统按照业务维度切分到不同的服务器群里。然后，又对其中一种业务系统进行了水平切分，使得这种业务系统可以在多个节点中运行。最后，系统之间采用了交互机制进行协作。</p>
<p>通过其中的垂直切分，我们能够将业务分隔为独立的系统。这样就不会形成大耦合，有利于灵活的管理和简化后续的开发。而对每一个独立的业务系统又采用了水平切分，即使某个节点因为某种原因不可用，也有其他业务系统节点可以代替它。这样系统就可以变为高可用的了。这样的划分依旧不能克服系统之间大量交互和难以维护的数据一致性的问题，同时，切分节点比较多也会使实施分布式系统的硬件成本提高。实际上，无论何种划分，都不可能使得分布式系统只有优点，没有缺点。相对于耦合性和缺乏灵活性来说，大量交互和数据一致性的问题则更容易处理，因此混合划分渐渐成为主流划分方式。</p>
<h4 id="1-2-2-分布式系统所面临的问题"><a href="#1-2-2-分布式系统所面临的问题" class="headerlink" title="1.2.2 分布式系统所面临的问题"></a>1.2.2 分布式系统所面临的问题</h4><p>略</p>
<h3 id="1-3-分布式系统的设计原则"><a href="#1-3-分布式系统的设计原则" class="headerlink" title="1.3 分布式系统的设计原则"></a>1.3 分布式系统的设计原则</h3><p>鉴于分布式系统的复杂性，一些专家和学者提出了不同的理论，其中最著名、最有影响力的当属CAP原则和BASE理论。</p>
<h4 id="1-3-1-CAP原则"><a href="#1-3-1-CAP原则" class="headerlink" title="1.3.1 CAP原则"></a>1.3.1 CAP原则</h4><p>分布式系统有许多优点和缺点，其主要特点是一致性、可用性和分区容忍。它们的具体含义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●一致性（consistency）：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。</span><br><span class="line">●可用性（availability）：保证每个请求不管成功还是失败都有响应。</span><br><span class="line">●分区容忍性（partition tolerance）：系统中任何的信息丢失或者失败都不会影响系统的继续运作。</span><br></pre></td></tr></table></figure>
<p>针对这3个特点，Eric Brewer教授在2000年提出了CAP原则，也称为CAP定理。该原则指出，任何分布式系统都不能同时满足3个特点，如图1-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141451950.png" alt="image-20231014145103913"></p>
<p>也就是说，任何的分布式系统都只能较好地完成其中的两个指标，无法完成3个指标。</p>
<p>在当今互联网中，保持可用性往往是第一位的，其次是性能。因为从客户的感知来说，可用和快速响应能够提供更好的体验。一致性可以通过其他手段来保证，本书后面会给出具体的方法。</p>
<p>微服务主要<strong>追求可用性和分区容忍性（AP），轻一致性（C）</strong>。</p>
<h4 id="1-3-2-BASE理论"><a href="#1-3-2-BASE理论" class="headerlink" title="1.3.2 BASE理论"></a>1.3.2 BASE理论</h4><p>在现实的业务中，金额和商品的库存数据是企业生产的核心数据，在分布式系统中保证这些数据的一致性，是分布式系统的核心任务之一。在不同的线程和机器之间保持数据的一致性是十分困难的，需要使用很多协议才能保证。在保证一致性的同时，也会给系统带来复杂性和性能的丢失。在BASE理论中，一致性又分为强一致性和弱一致性。需要注意的是，CAP原则中的一致性是指强一致性。这里，我们先来了解什么是强一致性和弱一致性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●强一致性：当用户完成数据更新操作之后，任何后续线程或者其他节点都能访问到最新值。这样的设计是最友好的，即用户上一次的操作，下一次都能读到。但根据CAP原则，这种实现需要对性能做出较大的牺牲。</span><br><span class="line">●弱一致性：当用户完成数据更新操作之后，并不能保证后续线程或者其他节点马上访问到最新值。它只能通过某种方法来保证最后的一致性。</span><br></pre></td></tr></table></figure>
<p>BASE理论是eBay的架构师Dan Pritchett在ACM上发表的文章中正式提出来的，是对大型分布式系统的实践总结。</p>
<p>BASE理论的核心思想是：即使分布式系统无法做到<strong>强一致性</strong>，也可以采用适当的方法达到<strong>最终一致性</strong>。</p>
<p>BASE并非一个英文单词，而是几个英文单词的简写。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●BA（Basically Available，基本可用）：在分布式系统中，最重要的需求是保证基本可用，有响应结果返回。例如，在“双十一抢购”的苛刻环境下，用户到电商处进行抢购。即使抢购失败，系统也会提示“系统繁忙，请过会儿再来”。我们分析一下这样的场景。用户是来购买商品的，而在抢购的环境下可能因为资源瓶颈，无法完成。为了避免用户长时间等待，系统会提示用户过会儿再来。这里的提示信息不需要消耗太多的系统资源，因而这样的场景就是典型的降级服务。虽然没有完成客户需要的抢购，但是却给了用户明确的信息，避免了用户长时间等待的情况，这样会给用户带来良好的体验。●S（Soft State，软状态）：其意义在于允许系统存在中间状态。一般来说，系统之间的数据通信都会存有副本，而这些副本都会存在一定的延迟。这时推荐使用弱一致性代替强一致性。这样的好处在于，提高系统的可用和性能。在网站用户的体验中，快速显示结果往往比一致性更为重要，因为没人愿意使用一个几十秒都不能响应的网站。</span><br><span class="line">●E（Eventual Consistency，最终一致性）：是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，以保证数据的正确性。</span><br></pre></td></tr></table></figure>
<p>BASE理论的应用场景是大型分布式系统，它的核心内容是放弃强一致性，保证系统的可用性。因为分布式系统自身的融合和扩展就相当复杂，如果需要保证强一致性就需要额外引入许多复杂的协议，这会导致技术的复杂化，同时对性能也有影响。BASE理论则建议让数据在一段时间内不一致，从而降低技术实现的复杂性，并提高系统的性能，最后再通过某种手段使得数据达成最终一致即可。</p>
<h3 id="1-4-微服务架构"><a href="#1-4-微服务架构" class="headerlink" title="1.4 微服务架构"></a>1.4 微服务架构</h3><p>因为分布式非常复杂，所以一直以来都没有权威的架构和设计，更多的只是前人的积累和实践。前人总结出了许多有用的理念，积累了许多经验，开发了很多实施分布式的软件。近几年来，最热门的分布式架构非微服务架构莫属。它是由美国科学家Eric Brewer在其博客上发表的概念。微服务是当前分布式开发的热点内容，也是本书的核心内容。下面先来了解什么是微服务架构。</p>
<h4 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h4><p>微服务架构只是将一个单体应用程序拆分为多个相对独立的服务，每一个服务拥有独立的进程和数据，每一个服务都是以轻量级的通信机制进行交互的，一般为HTTP API（现今最流行的是REST风格）。一般来说，这些服务都是围绕着业务模块来建设的，是独立的产品，因此完全可以独立地自动化部署和维护，这样更加有利于我们进行更小粒度的开发、维护和部署。这些服务可以由不同的语言编写，采用不同的数据存储，最低限度地集中管理。</p>
<p>微服务是一个模糊的概念，而不是一个标准，没有明确的定义。但微服务存在一定的风格，只要系统架构满足一定的风格，就可以被称为微服务架构。接下来，我们来了解一下微服务的风格。</p>
<h4 id="1-4-2-微服务的风格"><a href="#1-4-2-微服务的风格" class="headerlink" title="1.4.2 微服务的风格"></a>1.4.2 微服务的风格</h4><p>为了更好地实现微服务的风格，Eric Brewer提出了微服务架构的九个风格。也就是说，对于满足以下九种风格的系统架构，我们都可以称之为微服务。</p>
<h5 id="1．组件化和服务"><a href="#1．组件化和服务" class="headerlink" title="1．组件化和服务"></a>1．组件化和服务</h5><p>这里，首先明确定义组件化（componentization）和服务（service）的含义。把一个单体系统拆分为一个个可以单独维护和升级的软件单元，每一个单元就称为组件。每一个组件能够运行在自己独立的进程里，可以调用自己内部的函数（或方法）来完成自身独立的业务功能。但是更多的时候组件之间需要相互协作才能完成业务，这些就需要通过服务来完成了。这里的<strong>服务是指进程外的组件</strong>，它允许我们调用其他的组件，服务一般会以明确的通信机制提供，如HTTP协议、Web Service或者远程过程调用（RPC）等。</p>
<p>这样的组件化和服务有助于简化系统的开发，我们可以单独维护和升级。其次，在开发人员明确了组件的含义之后，只需要开发自己的组件，无须处理其他人的组件。在他人的组件需要调用我们开发的组件功能时，我们只需要提供编写服务即可。服务只需要明确以什么协议（如HTTP协议）和规范进行提供即可，这样各个组件之间的交互就相对简单和明确了。</p>
<p>这显然带来了开发和维护的便利，但是也会引来其他的问题。首先，如何将一个单体系统拆分为各个组件，这是一个边界界定的问题。其次，在使用通信机制进行交互的情况下，性能远没有在单机内存的进程中运行高。</p>
<h5 id="2．围绕业务功能组织团队"><a href="#2．围绕业务功能组织团队" class="headerlink" title="2．围绕业务功能组织团队"></a>2．围绕业务功能组织团队</h5><p>上文谈过单体应用包含用户界面、服务逻辑和数据源等内容。如果对团队进行划分，可以分为前端团队、后端团队、数据库团队和运维团队等。如果以这样的团队划分作为微服务的划分，会出现比较大的问题。因为一个改动往往会同时牵涉到前端、后端和运维团队，所以即使是很小的业务改动，也会牵涉跨团队的协作。而跨团队的协作必然会引发沟通成本，严重时甚至会出现内耗，这会极大地增加系统的维护成本。为了避免这个问题，微服务架构建议按业务模块来划分团队。这样，每次修改系统的工作，就只需要在相关的业务团队之间进行了，不需要牵涉全局。如此，牵涉的团队最少，也减少了不必要的沟通和内耗。</p>
<h5 id="3．是产品而不是项目"><a href="#3．是产品而不是项目" class="headerlink" title="3．是产品而不是项目"></a>3．是产品而不是项目</h5><p>传统的软件开发组织一开始会按业务模块进行划分，然后进行开发。一旦开发完成，将软件交付给维护部门，开发团队就解散了。而微服务则认为，这样的模式是不可取的，并且认为开发团队应该维护整个产品的生命周期，也就是谁开发谁负责后续的改进。因为微服务是帮助用户持续处理业务功能的，所以开发者持续关注软件，不断地改善软件，让软件更好地服务于业务，而且越小的粒度也越容易促进用户和服务供应商之间的关系。</p>
<h5 id="4．强化终端及弱化通道"><a href="#4．强化终端及弱化通道" class="headerlink" title="4．强化终端及弱化通道"></a>4．强化终端及弱化通道</h5><p>微服务的应用致力松耦合和高内聚，也就是业务模块的划分具有高内聚的特点，而各个业务组件则呈现出松耦合的特点。但是系统拆分后，需要各个组件相互协助才能完成业务，因此组件之间需要相互通信，为此开发者需要引入各种各样的通信协议。通信协议分很多种，如HTTP、Web Service和RPC等。在微服务的构建中，建议弱化通信协议的复杂性，因此推荐使用以下两种。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●包含资源API的HTTP的请求-响应和轻量级消息通信协议，尤其是现在流行的REST风格。</span><br><span class="line">●用轻量级消息总线来发布消息，如RabbitMQ或者ZeroMQ等，可以提供可靠消息的中间件。</span><br></pre></td></tr></table></figure>
<p>在一些非常强调性能的网站，也许还会使用二进制来传递协议，但是这仍然不能解决分布式的丢包和请求丢失等问题。微服务推荐使用的两种方式，虽然在性能和可靠性上比不上其他的一些协议，但是在可读性上却大大提高了。也许绝大部分的系统并不需要在两者之间做出选择，因为能获得可读性的便利就已经很不错了。毕竟引入那些性能高或者可靠的协议会大大降低可读性，并且在很大程度上会提高系统的开发和日后维护的难度。</p>
<h5 id="5．分散治理"><a href="#5．分散治理" class="headerlink" title="5．分散治理"></a>5．分散治理</h5><p>和单体系统构建不一样，微服务架构允许我们分散治理。微服务架构的每一个组件所面对的业务焦点都是不一样的，因此在选型上有很大的差异。例如，C++适合做那些实时高效的组件，Node.js适合做报表组件，而Matlab则适合做数字图像分析。不同的业务组件也许需要不同的语言进行开发，而微服务架构允许我们使用各类语言构建组件，各组件之间只需要约定好服务接口即可。微服务架构没有编程语言的限制，不同的业务组件可以根据自己的需要来选择构建平台。</p>
<p>分散治理带来了很大的灵活性。与此同时，我们只需要通过接口约定即可实现组件之间的相互通信。例如，使用现在流行的HTTP请求的REST风格，就能够使系统之间十分简单地交互。</p>
<h5 id="6．分散数据管理"><a href="#6．分散数据管理" class="headerlink" title="6．分散数据管理"></a>6．分散数据管理</h5><p>单体系统拆分后，微服务架构建议使用分散的数据管理，也就是每一个组件都应该拥有自己的数据源，包括数据库和NoSQL等。这样，我们就可以按照微服务组件划分的规则，划分对应的数据。这有助于更为精确地管理数据，可以使数据存储更加合理，同时还可以简化数据模型。</p>
<p>但是，分散数据管理也会引发两个弊端。</p>
<p>第一个弊端是，因为数据库的拆分会导致原有的ACID特性不复存在，所以需要实现分布式数据库事务的一致性。为了实现它，还需要引入其他协议，如XA协议等。然而，这会使开发变得十分复杂，大大提高开发难度。所以微服务并不建议使用分布式事务来处理数据的一致性，而是建议<strong>使用最终一致性的原理</strong>。在第15章中，我们会再谈到这些问题。</p>
<p>第二个弊端是，拆分之后关联计算会十分复杂。例如，交易组件要查看产品详情的时候，而产品详情却放在产品组件里，如果是在统计分析的情况下，则无法进行数据库的表关联计算，需要大量的远程过程调用才行，这样会造成性能低下，但是从现实来说在分布式系统中使用统计分析的场景较少，所以这样的场景出现频率较低。需要统计分析时，可以抽取数据到对应的系统再进行统计分析，毕竟统计分析一般不需要实时数据。</p>
<h5 id="7．基础设施自动化"><a href="#7．基础设施自动化" class="headerlink" title="7．基础设施自动化"></a>7．基础设施自动化</h5><p>因为微服务是将一个单体系统拆分为多个组件，所以势必造成多个组件的测试和部署，这样就会大大增加测试人员和开发人员的工作量。在业务不断扩大的情况下，这些将会成为测试和运维人员的噩梦。好在当前的云计算、测试开发、容器（如Docker）等技术已经有了长足发展，减少了微服务的测试、构建和发布的复杂性。</p>
<p>正如之前所提到的，实施微服务是对每一个组件都是以产品的态度不断深化改造以满足用户需求，所以每次进行改造之时必然会涉及构建、测试和发布。对于自动化测试，当前已有许多语言可用，如Node.js、Python等语言，都可以构建测试开发，验证测试案例。这是部署之前需要做的事情，可以降低测试人员的工作量。对于部署来说，借助容器化技术（如Docker）进行构建、部署微服务，可以极大地简化部署人员重复的操作和多环境的配置。</p>
<h5 id="8．容错性设计"><a href="#8．容错性设计" class="headerlink" title="8．容错性设计"></a>8．容错性设计</h5><p>使用服务作为组件的一个结果，在于应用需要有能容忍服务的故障的设计。一般来说会出现两种情况。</p>
<p>第一种情况是，任何服务器都可能出现故障、断电和宕机。在这样的情况下，微服务架构应当可以给出仪表盘，监控每一个节点的状态是否正常、吞吐情况、内存等。一旦出现故障不可用时，微服务系统自动就会切断转发给它的请求，给出故障节点的提示，并且将被切断的请求转发给其他可用节点。微服务系统也允许监测组件节点的状态（上线、下线或不可用），在某些组件节点出现故障、断点和宕机时，系统允许组件节点优雅下线进行维护。在企业维护成功后，允许其重新上线，再次提供服务。</p>
<p>第二种情况是，当系统接收大量请求时，可能出现某个组件响应变得缓慢的情况。此时，如果其他的组件再调用该组件，就需要等待大量的时间。这样，其他的组件也会因为等待超时而引发自身组件不可用，继而出现服务器雪崩的场景。当一个组件变得响应缓慢，造成大量超时，如果微服务能够发现它，并且通过一些手段将其隔离出去，这种情况就不会蔓延到调用者了。这就好比电流突然增大，可能会发生危险，保险丝便自动熔断保护用电安全一样。因此，我们把这种情况称为断路，把微服务中处理这种情况的组件称为断路器（Circuit Breaker）。</p>
<h5 id="9．设计改进"><a href="#9．设计改进" class="headerlink" title="9．设计改进"></a>9．设计改进</h5><p>从上述的特征来看，实施微服务比实施一个单体系统复杂得多，代价也大得多。从实践的角度来说，微服务的设计是循序渐进的，在起初业务量不大的时候，系统是相对简单的，业务也是相对单一的。早期的核心架构在后期不会发生很大的变化，但系统会引入新的业务，使得一些内容发生变化，有些组件会被停用，有些组件会被加入进来。例如，用户数量不断增大且构成变得更复杂，这个时候可以把现有的用户服务拆分为高级用户服务和普通用户服务两个微服务产品，对外提供服务。经过时间的推移，那些核心架构的组件往往就会相对稳定下来，从而成为微服务的核心。而那些需要经常变化的组件，则需要不断地进行维护和改进，来满足业务的发展需要。</p>
<h4 id="1-4-3-微服务和分布式系统的关系"><a href="#1-4-3-微服务和分布式系统的关系" class="headerlink" title="1.4.3 微服务和分布式系统的关系"></a>1.4.3 微服务和分布式系统的关系</h4><p>应该说，微服务是分布式系统设计和架构的理念之一。但是从微服务的风格来看，它并不是为了克服所有的分布式系统的缺陷而设计的，而是为了追求更高的可读性、可用性和简易性。但与此同时，也弱化了其一致性，正如这句老话——“两害相较取其轻者”。</p>
<p>所以，微服务并不能解决所有的分布式系统的问题，它只是寻求一个平衡点，让架构师能够更为简单、容易地构建分布式系统。但微服务并非金科玉律，对于一些特殊的分布式需求，还需要我们使用其他的方法来得以实现，正如方法是死的，而人是活的，需要实事求是地解决问题。</p>
<h3 id="1-5-Spring-Cloud"><a href="#1-5-Spring-Cloud" class="headerlink" title="1.5 Spring Cloud"></a>1.5 Spring Cloud</h3><p>如上所述，实现微服务需要大量的软件，而这些软件是十分复杂的。应该说，大部分的企业，包括一些大企业，都无力支持这些软件的开发。但是我们并不沮丧，因为我们可以“站在巨人的肩膀上”，无论是国内还是国外，都为分布式系统做了大量的尝试，积累了丰富的成果。例如，下面的工具是我们常常在构建分布式系统中见到的。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●服务治理：阿里巴巴的Dubbo、Netflix的Eureka、Apache的Consul等。</span><br><span class="line">●分布式配置管理：阿里巴巴的Diamond、百度的Disconf、Netflix的Archaius等。</span><br><span class="line">●API网关：俄罗斯程序员Igor Sysoev开发的Nginx、Netflix的Zuul、Spring Cloud的Gateway等。</span><br></pre></td></tr></table></figure>
<p>目前，国内最流行的是阿里巴巴的Dubbo，它已经在很多互联网企业广泛使用。但无论如何，这些软件都是某些公司为了解决各自某些问题而开发出来并将其开源的。严格来说，它们并不是一套完整的解决方案。而在国外，Spring Cloud大行其道。Spring Cloud是由Pivotal团队开发的，它没有重复造轮子，而是通过考察各家开源的分布式服务框架，把经得起考验的技术整合起来，形成了现在的Spring Cloud的组件。Spring Cloud就是通过这种方式构建了一个较为完整的企业级实施微服务的方案。更令人振奋的是，Pivotal团队将这些分布式框架通过Spring Boot进行了封装，屏蔽了那些晦涩难懂的细节，给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。在引入国内之后，Spring Cloud渐渐成了构建微服务系统的主要方案，成为市场的主流。当然，这也是本书需要深入讨论的核心内容之一。</p>
<h4 id="1-5-1-Spring-Cloud的各个组件的简介"><a href="#1-5-1-Spring-Cloud的各个组件的简介" class="headerlink" title="1.5.1 Spring Cloud的各个组件的简介"></a>1.5.1 Spring Cloud的各个组件的简介</h4><p>为了构建微服务架构，Spring Cloud容纳了很多分布式开发的组件。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">●Spring Cloud Config：配置管理，允许被集中化放到远程服务器中。目前支持本地存储、Git和SVN等。</span><br><span class="line">●Spring Cloud Bus：分布式事件、消息总线、用于集群（如配置发生变化）中传播事件状态，可以与Spring Cloud Config联合实现热部署。</span><br><span class="line">●Netflix Eureka：服务治理中心，它提供微服务的治理，包括微服务的注册和发现，是Spring Cloud的核心组件。</span><br><span class="line">●Netflix Hystrix：断路器，在某个组件因为某些原因无法响应或者响应超时之际进行熔断，以避免其他微服务调用该组件造成大量线程积压。它提供了更为强大的容错能力。</span><br><span class="line">●Netflix Zuul：API网关，它可以拦截Spring Cloud的请求，提供动态路由功能。它还可以限流，保护微服务持续可用，还可以通过过滤器提供验证安全。</span><br><span class="line">●Spring Cloud Security：它是基于Spring Security的，可以给微服务提供安全控制。</span><br><span class="line">●Spring Cloud Sleuth：它是一个日志收集工具包，可以提供分布式追踪的功能。它封装了Dapper和log-based追踪以及Zipkin和HTrace操作。</span><br><span class="line">●Spring Cloud Stream：分布式数据流操作，它封装了关于Redis、RabbitMQ、Kafka等数据流的开发工具。</span><br><span class="line">●Netflix Ribbon：提供客户端的负载均衡。它提供了多种负载均衡的方案，我们可以根据自己的需要选择某种方案。它还可以配合服务发现和断路器使用。</span><br><span class="line">●Netflix Turbine：Turbine是聚合服务器发送事件流数据的工具，用来监控集群下Hystrix的metrics情况。</span><br><span class="line">●OpenFeign：它是一个声明式的调用方案，可以屏蔽REST风格的代码调用，而采用接口声明方式调用，这样就可以有效减少不必要的代码，进而提高代码的可读性。</span><br><span class="line">●Spring Cloud Task：微服务的任务计划管理和任务调度方案。</span><br><span class="line">●……</span><br></pre></td></tr></table></figure>
<p>通过上述组件描述可以相对容易地构建微服务系统。只是本书不会介绍所有的组件，而是根据需要介绍最常用的组件，这些将是后续章节的重点内容。当前，Spring Cloud以Netflix公司的各套开源组件作为主要组件，通过Spring Boot的封装，给开发者提供了简单易用的组件。但由于Netflix的断路器Hystrix已经宣布进入维护阶段，不再开发新的功能，因此，Spring Cloud即将把Resilience4j作为新的熔断器加入进来。本书会对Resilience4j进行详细的讲解，以适应未来的需要。Spring Cloud的未来趋势是去Netflix组件，因为需要大幅度地更新组件，所以周期较长。但是，即使更替新的组件，其设计思想也是大同小异的，正如这句老话——“换汤不换药”，所以我们还是会讲解Netflix组件。</p>
<h4 id="1-5-2-Spring-Cloud版本说明"><a href="#1-5-2-Spring-Cloud版本说明" class="headerlink" title="1.5.2 Spring Cloud版本说明"></a>1.5.2 Spring Cloud版本说明</h4><p>因为Spring Cloud融入了大量的其他企业的开源组件，所以这些组件的版本往往并不一致，不同的组件由不同的公司进行维护。为了统一版本号，Pivotal团队决定使用伦敦地铁站点名称作为版本名。首先是将这些站点名称进行罗列，然后按顺序使用。Spring Cloud发布的版本历史（截至本书编写时）如表1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141542192.png" alt="image-20231014154235134"></p>
<p>由于Spring Boot已经发展到了2.1.x版本，Spring Cloud也发布到了Greenwich版本，因此本书是基于Spring Boot 2.1.0和Greenwich.RELEASE进行讲解的。</p>
<h3 id="1-6-微服务系统样例简介"><a href="#1-6-微服务系统样例简介" class="headerlink" title="1.6 微服务系统样例简介"></a>1.6 微服务系统样例简介</h3><p>为了更好地讲述Spring Cloud微服务和分布式系统的知识，这里我们来模拟微服务系统。当今互联网的世界中，互联网金融是一个很大的课题，所以这里采用互联网金融的例子来讲解微服务系统和分布式应用的知识。</p>
<p>假设，有一家互联网金融公司主营互联网金融借贷业务。它先收集借款人信息，再根据借款人的资金需要生成理财产品。然后，通过理财产品约定利息、时间、还款方式等内容后，发送到公司的互联网平台。最终用户就可以在该公司互联网平台上看到这些理财产品了。那些拥有闲置资金的用户就可以购买这些理财产品，从而获得较高的利息收益。其业务如图1-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141544003.png" alt="image-20231014154408963"></p>
<p>为了使业务能够进行，这里先做业务分析，此为开发系统的第一步。</p>
<p>这里需要管理和审核借款人，公司信贷审核人员将审核借款人的身份、信用、资质和财产等情况，以保证不发生金融诈骗，因此我们需要一个借款人微服务。</p>
<p>而投资人是平台的用户，因为大额投资和经常投资的用户应该要被给予更多的优惠，所以投资人也会根据具体的情况分成不同的等级。为了更好地管理，需要一个用户微服务。</p>
<p>平台会根据借款人的资金需要来生成对应的理财产品，理财产品分为定期和活期。用户购买产品的交易记录也会记录在内。这里需要一个理财产品微服务。</p>
<p>因为涉及金钱，所以这里需要一个资金微服务，帮助投资人和借款人管理自己资金。投资人可以将自己银行卡上的闲置资金转入系统来购买理财产品，而平台也会根据借款人的资金需要将资金转到借款人账户。</p>
<p>平台也许还会和第三方合作，让第三方介绍投资人或者借款人，或者进行广告等，因此还需要一个第三方微服务……</p>
<p>不过也许并不需要考虑那么多的微服务，因为大部分情况是类似的，而且全部考虑也会太复杂。因此，本书只讨论用户（投资人）、理财产品和资金微服务，如图1-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141546718.png" alt="image-20231014154642682"></p>
<p>从图1-8中可以看到，请求会先到网关，网关会拦截请求，进行验证、路由和过滤。这样做可以保护微服务，避免一些恶意的攻击，同时还可以限制通过的流量，避免过大的请求量压垮系统。各个微服务则提供实际的业务功能，对于微服务之间需要交互才能共同完成相关的业务，按照微服务的建议进行集成，这里采用REST风格的请求进行集成。</p>
<h2 id="第2章-技术基础"><a href="#第2章-技术基础" class="headerlink" title="第2章 技术基础"></a>第2章 技术基础</h2><p>为了更好地介绍Spring Cloud，这里稍微介绍一下Spring Boot和HTTP的REST风格。因为Spring Cloud是以Spring Boot作为基石的，而各个服务系统又是通过REST风格的请求集成在一起的，所以学习它们将有助于我们深入学习Spring Cloud。当然，如果你已经对它们很熟悉了，也可以跳过本章，直接学习第3章的内容。</p>
<h3 id="2-1-Spring-Boot"><a href="#2-1-Spring-Boot" class="headerlink" title="2.1 Spring Boot"></a>2.1 Spring Boot</h3><p>从第1章可以看出，Spring Cloud的组件是通过Spring Boot的方式进行封装的，所以这里先简单地介绍一下Spring Boot的应用。Spring Boot是由Pivotal团队提供的全新框架，它采用约定优于配置的思想，极大简化了Spring项目的开发。它是当前最为流行的微服务开发框架，在企业的实际开发中，越来越受欢迎，使用率也稳步上升。</p>
<h4 id="2-1-1-创建Spring-Boot工程"><a href="#2-1-1-创建Spring-Boot工程" class="headerlink" title="2.1.1 创建Spring Boot工程"></a>2.1.1 创建Spring Boot工程</h4><p>首先让我们新建一个工程，如图2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644231.png" alt="image-20231014164412180"></p>
<p>这里选择“Spring Initializr”，然后点击选择适当的JDK，再点击“Next”，就可以看到如图2-2所示的界面。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644227.png" alt="image-20231014164425186"></p>
<p>此处我们可以根据需要配置自己的工程信息。这里的“Type”可以选择Maven或者Gradle工程。当今企业主要使用Maven，所以本书也采用Maven来介绍。如果使用的是Gradle，也没有问题，其使用方式和Maven差别不大，这里就不介绍了。这里的“Packaging”选择“War”，这意味着可以使用JSP作为视图，如果不需要使用JSP，也可以选择“Jar”。然后点击“Next”，就可以看到如图2-3所示的界面了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644891.png" alt="image-20231014164446859"></p>
<p>从图2-3中可以看到，IDEA提供了很多可以依赖的starter包。这里，我只选择了Spring Web Starter和Thymeleaf，意为开发一个关于Spring MVC的工程。其中“Template Engines”使用了Thymeleaf模板引擎。然后就可以点击“Next”了。跟着输入自己的工程名称，选择工程目录，就可以新建一个Spring Boot工程了。</p>
<h4 id="2-1-2-Spring-Boot开发简介"><a href="#2-1-2-Spring-Boot开发简介" class="headerlink" title="2.1.2 Spring Boot开发简介"></a>2.1.2 Spring Boot开发简介</h4><p>在上一节中，我们新建了一个Spring Boot工程。下面来查看它的目录，了解目录和相关文件的作用，如图2-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141645443.png" alt="image-20231014164521416"></p>
<p>从图2-4中可以看到pom.xml文件，它是Maven的配置文件。因为我们介绍的Spring Boot版本是2.1.0.RELEASE，而通过IDEA创建的是2.1.7.RELEASE，所以需要手工把版本修改为2.1.0.RELEASE。修改后的pom.xml如代码清单2-1所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目信息配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>chapter2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打包为war包--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>chapter2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>chapter2 for Spring Cloud<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--属性配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">          UTF-8</span><br><span class="line">       <span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入依赖包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring Boot插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码。下面对它们进行说明。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●packaging：这里配置为war，意味着将项目打包为war包，可以使用动态的JSP页面。</span><br><span class="line">●spring-boot-starter-thymeleaf包：引入Thymeleaf模板，这样，通过Spring MVC的机制就可以把数据渲染到Thymeleaf模板的页面中。</span><br><span class="line">●spring-boot-starter-web包：它会引入Spring基础包和Spring MVC包，此外它还会引入内嵌的Tomcat，所以我们不需要下载Tomcat就能运行工程。</span><br><span class="line">●spring-boot-starter-tomcat包：这里声明范围为provided，表明该包只在编译和测试时使用。</span><br><span class="line">●spring-boot-starter-test包：会引入测试相关的包。●spring-boot-maven-plugin包：允许我们使用java -jar命令运行Spring Boot工程。</span><br></pre></td></tr></table></figure>
<p>再看一下图2-4，这里需要对它的文件和目录进行简要说明，如表2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141648383.png" alt="image-20231014164837343"></p>
<p>我们直接通过Java Application的形式运行Chapter2Application.java，就能够运行Spring Boot项目。在默认的情况下，Spring Boot会使用8080端口启动服务。如果想切换端口，就要修改核心配置文件application.properties，这里先把它重命名为application.yml。因为在分布式和微服务开发中，使用的大部分是YAML文件，而非properties文件，所以本书也主要使用YAML文件进行配置。修改application.yml，如代码清单2-2所示。</p>
<p>代码清单2-2 application.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span> <span class="comment"># 修改内嵌Tomcat端口为8001</span></span><br></pre></td></tr></table></figure>
<p>此时，如果再次使用Java Application的形式运行Chapter2Application.java，就可以看到Spring Boot在8001端口启动服务了。接下来，改造一下Chapter2Application.java文件，如代码清单2-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.chapter2.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.spring.cloud.chapter2.*&quot;)</span></span><br><span class="line"><span class="comment">// 标识控制器</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 请求前缀</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/chapter2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Chapter2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP GET请求，且定义REST风格路径和参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index/&#123;value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">(ModelAndView mav, </span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable(&quot;value&quot;)</span> String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置数据模型</span></span><br><span class="line">        mav.getModelMap().addAttribute(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">        <span class="comment">// 请求名称，定位到Thymeleaf模板</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看一下index方法。首先是获取请求路径的参数，在数据模型中设置一个键为key的参数，然后再把视图名称设置为index，最后返回ModelAndView。因为这里返回的视图名称为index，所以需要在templates目录下新建一个视图index.html文件，如代码清单2-4所示。</p>
<p>代码清单2-4 /resources/templates/index.html（Chapter2工程）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试Thymeleaf<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个HTML很简单，只需要解释一下加粗的代码就可以了。因为之前我们在数据模型中设置了键为key的参数，所以这里加粗的代码只是读取数据模型的这个参数而已。</p>
<p>到这里，一个简单的Spring Boot工程就开发好了。让我们以Java Application的形式运行代码清单2-3，这样就可以启动Spring Boot工程了。然后使用浏览器访问地址<a target="_blank" rel="noopener" href="http://localhost:8001/chapter2/index/myvalue，就可以看到如图2-5所示的界面了。">http://localhost:8001/chapter2/index/myvalue，就可以看到如图2-5所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141651361.png" alt="image-20231014165102313"></p>
<h4 id="2-1-3-多文件配置"><a href="#2-1-3-多文件配置" class="headerlink" title="2.1.3 多文件配置"></a>2.1.3 多文件配置</h4><p>在Spring Cloud中，一个服务下可以包含多个实例，因此同一个工程可能需要在不同的配置（如端口）下启动。对于IDEA构建的工程，我们之前论述过，它会为我们创建application.properties文件，只是在分布式的开发环境下，更为流行的是YAML文件，所以本书都会将application.properties修改为application.yml文件。</p>
<p>为了更好地适应多个环境的运行，Spring Boot配置项会按照一定的优先级进行加载，优先级从高到低的顺序如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●命令行参数。●来自java:comp/env的JNDI属性。</span><br><span class="line">●Java系统属性（System.getProperties()）。</span><br><span class="line">●操作系统环境变量。●RandomValuePropertySource配置的random.<span class="emphasis">*属性值。●jar包外部的application-&#123;profile&#125;.properties或application.yml（带spring.profile）配置文件。●jar包内部的application-&#123;profile&#125;.properties或application.yml（带spring.profile）配置文件。●jar包外部的application.properties或application.yml（不带spring.profile）配置文件。●jar包内部的application.properties或application.ym（不带spring.profile）配置文件。●@Configuration注解类上的@PropertySource。●通过SpringApplication.setDefaultProperties指定的默认属性。</span></span><br></pre></td></tr></table></figure>
<p>上面的顺序比较复杂，在大部分情况下，并不需要使用所有的配置。为了能够在IDEA工程中运行同一个项目的多个实例，可以使用很简易的方法。我们先在resources目录下新增两个配置文件application-peer1.yml和application-peer2.yml，然后进行配置，如代码清单2-5和代码清单2-6所示。</p>
<p>代码清单2-5 application-peer1.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#修改内嵌Tomcat端口为8001</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br></pre></td></tr></table></figure>
<p>代码清单2-6 application-peer2.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#修改内嵌Tomcat端口为8002</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br></pre></td></tr></table></figure>
<p>这里的两个文件只是修改了启动的端口而已，Spring Boot不会识别它们。为了让它们能够启动，我们需要修改application.yml文件，如代码清单2-7所示。</p>
<p>代码清单2-7 application.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 设置环境变量，启用application-peer1.yml作为配置文件</span></span><br><span class="line">    <span class="comment"># 需要启用配置文件启用application-peer2.yml时，只需要修改为peer2即可</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>这里配置项spring.profiles.active配置为peer1，这样就可以指向application-peer1.yml文件了，Spring Boot就会以application-peer1.yml文件作为配置文件在端口8001中启动项目。同理，如果将spring.profiles.active修改为peer2，则会使用application-peer2.yml文件配置的端口8002启动项目。这样一个工程就可以启动多个实例了。</p>
<p>但是在IDEA中，默认的情况下，只允许同一个Java文件启动一次。为此，让我们选择菜单Run→EditConfigurations…，打开图2-6所示的对话框。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141655533.png" alt="image-20231014165515496"></p>
<p>将图2-6中红色方框圈起来的“Allow running in parallel”选项勾上，就可以在IDEA中让一个类运行多个实例了，然后就可以根据需要配置application.yml的配置项spring.profiles.active来选择具体的配置文件启动项目了。</p>
<p>当然，如果配置项比较少，例如，只需要考虑端口的改变，而不需要考虑其他复杂的配置，那么也可以使用命令行参数来实现上述的功能。这里，再看一下图2-6，选中“Chapter2Application”，然后点击左上角的复制键（[插图]），就可以看到一个新的运行配置，跟着修改其运行的名称和相关参数，如图2-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141656348.png" alt="image-20231014165602311"></p>
<p>在图2-7中，运行的名称被修改为“Chapter2Application 2”，命令行参数server.port的值被修改为8002。使用同样的方法，也可以将运行名称为“Chapter2Application”配置的命令行参数server.port的值修改为8001，这样就可以得到两个运行的配置了。它们将根据命令行参数所配置的端口进行运行。正常配置完毕后，IDEA会提示打开Spring Boot的运行面板（Run Dashboard）。跟着打开它，就可以在运行面板中运行对应的Spring Boot工程了，这是非常方便的，如图2-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141657439.png" alt="image-20231014165743406"></p>
<p>在图2-8所示的面板中，截取的是启动两个运行配置后的图，可以看到它们分别在8001和8002端口启动。</p>
<h4 id="2-1-4-打包和运行"><a href="#2-1-4-打包和运行" class="headerlink" title="2.1.4 打包和运行"></a>2.1.4 打包和运行</h4><p>使用Maven构建工程，可以使用IDEA进行打包，也可以自己使用命令打包。关于IDEA打包，相关资料介绍比较多，所以这里就不再介绍了。这里主要介绍命令打包。首先自己安装好Maven，并且配置好Maven的环境，做好这些后，打开工程所在的目录（我的本地的目录为E:\IdeaProjects\chapter2），然后在命令行窗口输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">package</span></span><br></pre></td></tr></table></figure>
<p>通过这个命令就能成功打包了。然后，打开工程目录下的target目录查看打包结果，如图2-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141702668.png" alt="image-20231014170250607"></p>
<p>打包结果是一个war文件。如果需要将它部署到第三方服务器，那么只需要将它放到第三方服务器的部署目录即可。例如，放到Tomcat的webapps目录下。Spring Boot还允许我们使用命令运行它，只要在这个目录下运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war</span><br></pre></td></tr></table></figure>
<p>就可以运行工程了。只是它是以application.yml配置的配置项spring.profiles.active选择对应的配置文件进行运行。如果我们想使用自己的配置项，如想使用8003端口启动项目，那么可以通过命令参数来代替它，如执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war --server.port=8003</span><br></pre></td></tr></table></figure>
<p>这样，就能在8003端口启动服务了。如果需要指定配置文件，也可以使用命令行参数进行指定。例如，使用application-peer2.yml文件启动Spring Boot工程，就可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-Spring-Boot监控"><a href="#2-1-5-Spring-Boot监控" class="headerlink" title="2.1.5 Spring Boot监控"></a>2.1.5 Spring Boot监控</h4><p>Spring Boot，除了方便我们开发外，还提供了系统监控的功能。在需要对系统进行监控时，只需要引入Actuator就可以了。下面让我们在pom.xml文件中引入Actuator，如代码清单2-8所示。</p>
<p>代码清单2-8 pom.xml引入Actuator（Chapter2工程）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.hateoas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-hateoas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是在Spring Boot 2.x之后，出于安全的考虑，大部分监控端点都不会直接暴露。要暴露这些端点，我们需要对YAML文件增加对应的配置，如代码清单2-9所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 暴露的端点，“*”代表全部暴露</span></span><br><span class="line">        <span class="attr">include :</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">          <span class="comment"># 不暴露的端点</span></span><br><span class="line">        <span class="attr">exclude :</span> <span class="string">env</span></span><br></pre></td></tr></table></figure>
<p>通过这些端点配置就可以暴露除了env之外的端点了.此时启动Spring Boot项目（假设在8001端口启动），在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/actuator/beans，就可以看到如图2-10所示的场景了。">http://localhost:8001/actuator/beans，就可以看到如图2-10所示的场景了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141707304.png" alt="image-20231014170725254"></p>
<p>从图2-10中可以看出，通过请求，已经可以查看到Actuator提供的端点了，这说明Spring Boot项目已经被监控起来了。但是这样暴露端点也会存在一定的安全隐患，这个时候可以使用Spring Security来进行安全验证，规避这些安全隐患。这部分内容比较烦琐，在第18章会有介绍，这里就不演示了。</p>
<p>实际上，Spring Boot可监控的端点还有很多。</p>
<h1 id="第二部分-Spring-Cloud微服务"><a href="#第二部分-Spring-Cloud微服务" class="headerlink" title="第二部分 Spring Cloud微服务"></a>第二部分 Spring Cloud微服务</h1><p>本部分主要介绍Spring Cloud所涉及的常用工具，其中包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">●服务治理和服务发现（Spring Cloud Netflix Eureka）；</span><br><span class="line">●服务调用（Spring Cloud Netflix Ribbon和Spring Cloud Netflix OpenFeign）；</span><br><span class="line">●断路器（Spring Cloud Netflix Hystrix和Resilience4j）；</span><br><span class="line">●网关（Spring Cloud Netflix Zuul和Spring Cloud Gateway）；</span><br><span class="line">●服务配置（Spring Cloud Config）；</span><br><span class="line">●服务监控（Spring Cloud Sleuth和Spring Boot Admin）。</span><br></pre></td></tr></table></figure>
<p>在这些组件中，前4个组件是构建Spring Cloud微服务架构的核心组件，因此它们是本书的重点和核心内容，后面的组件则是用于配置和监控微服务系统所需的组件。</p>
<h2 id="第3章-服务治理——Eureka"><a href="#第3章-服务治理——Eureka" class="headerlink" title="第3章 服务治理——Eureka"></a>第3章 服务治理——Eureka</h2><p>在Spring Cloud中，实现服务治理的是Netflix公司开发的Eureka。Netflix公司是美国加利福尼亚州的一家公司，主营业务是在线影片租赁。它为了搭建自己的网站，开发了一套分布式系统的组件。因为该网站性能卓越，所以曾经连续5次被评为顾客最满意的网站。正因为如此，Pivotal团队通过Spring Boot形式的封装将Netflix公司开发的分布式系统组件封装了起来，其中就包括Eureka，Eureka是Spring Cloud的服务治理中心。在使用Spring Boot进行了二次封装后，Eureka的使用就显得十分简易了。<strong>Eureka作为一个微服务的治理中心，它是一个服务应用，可以接收其他服务的注册</strong>，<strong>也可以发现和治理服务实例</strong>。</p>
<h3 id="3-1-服务治理中心"><a href="#3-1-服务治理中心" class="headerlink" title="3.1 服务治理中心"></a>3.1 服务治理中心</h3><p>服务治理中心是微服务（分布式）架构中最基础和最核心的功能组件，它主要对各个服务实例进行管理，包括服务注册和服务发现等。下面我们会详细进行讨论，不过首先需要把Eureka服务器搭建起来，以便在实践中学习。</p>
<h4 id="3-1-1-搭建Eureka服务治理中心"><a href="#3-1-1-搭建Eureka服务治理中心" class="headerlink" title="3.1.1 搭建Eureka服务治理中心"></a>3.1.1 搭建Eureka服务治理中心</h4><p>为了搭建Eureka服务治理中心，先新建一个工程，起名finance。然后，在IDEA中创建名为eureka-server的Spring Boot的模块（Module）放到finance下，并且在依赖上选择Eureka Server和Web。之后就可以看到pom.xml文件了，这里只讨论它和代码清单2-1之间的不同之处，如代码清单3-1所示。</p>
<p>代码清单3-1 pom.xml（eureka-server模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">&lt;!--依赖Eureka--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">&lt;!--定义Spring Cloud依赖父项目，以便于子项目继承--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码，这里先是引入了Spring Boot封装Eureka的包spring-cloud-starter-netflix-eureka- server，这样就可以把Eureka组件引入到这个模块里。\<dependencyManagement>主要是定制Spring Cloud父项目的信息（如版本号），当模块依赖Spring Cloud的开发包的时候，就会继承它，根据它的信息加载对应版本的依赖。</p>
<p>接下来，对IDEA为我们创建的EurekaServerApplication.java文件进行改造，如代码清单3-2所示。</p>
<p>代码清单3-2 EurekaServerApplication.java（eureka-server模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.eureka.server.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 驱动Eureka服务治理中心</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，就只是加入了一个新的注解@EnableEurekaServer，它代表着在Spring Boot应用启用之时，也启动Eureka服务器。此时，我们以Java Application的形式运行，就能够启用Eureka服务治理中心了。不过，如果选择JDK 8（不含）以上的版本，可能会启动失败，这是因为Spring Cloud的Netflix组件是依赖于JDK 8（含）之前的版本开发的，所以在新的JDK版本中会缺少一些包，因此我们需要引入新的依赖才能正常启动Eureka服务器，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们启动Eureka后，会发现日志中会不断地出现异常，那是因为Eureka服务治理中心会把自己作为微服务去寻找注册自己的治理中心。为了避免这种情况，需要进行额外的配置，让它停止注册自己。删除原有的application.properties文件，新建application.yml文件，然后对其进行配置，如代码清单3-3所示。</p>
<p>代码清单3-3 application.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Spring应用名称，它是一个微服务的名称，一个微服务可拥有多个实例</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span> <span class="comment">#修改内嵌Tomcat端口为5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 服务自身就是治理中心，所以这里设置为false，取消注册</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 取消服务获取，至于服务获取，本章后续会讨论</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 服务注册域地址</span></span><br><span class="line"><span class="comment">#    service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://192.168.1.100:5002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务治理中心服务器IP</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<p>有了这个配置，运行代码清单3-2，就可以看到没有异常日志的Eureka服务治理中心的启动了。然后打开浏览器在地址栏输入<a target="_blank" rel="noopener" href="http://localhost:5001/，就可以看到图3-1所示的界面了。">http://localhost:5001/，就可以看到图3-1所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141740423.png" alt="image-20231014174042364"></p>
<p>看到这个页面，就说明Eureka已经成功启动了。但是，我们可以看到，注册的微服务实例依旧为空，那是因为我们还没有注册。如何注册，是下一节要讨论的问题。代码清单3-3中的配置比较重要，不过这里有一个前提是要注意的，这个模块虽然是Eureka服务治理中心，但在Spring Cloud中，会被认为是一个微服务。在这个前提下，这里对这些配置进行一下初步的解释。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">●spring.application.name：配置的是Spring应用的名称，也是微服务的名称，在Spring Cloud中，一个微服务可以拥有多个实例。</span><br><span class="line">●eureka.client.register-with-eureka：这个配置项是取消当前微服务，寻找其他Eureka服务治理中心进行注册。</span><br><span class="line">●eureka.client.fetch-registry：取消服务获取功能，关于服务获取，本章后续会讨论。</span><br><span class="line">●eureka.client.serviceUrl.defaultZone：在我们的代码中，这个属性被注释掉了，因为我们不需要注册微服务。如果需要注册微服务，可以通过这个属性来配置服务治理中心的注册地址，完成服务注册的功能。</span><br></pre></td></tr></table></figure>
<p>因为配置项eureka.client.register-with-eureka和eureka.client.fetch-registry比较好理解，所以这里只对配置项spring.application.name和eureka.client.serviceUrl.defaultZone做进一步的解释。先看一下图3-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141742132.png" alt="image-20231014174218059"></p>
<p>图3-2中存在两个重要的概念，一个是微服务，另一个是服务实例（Service Instance，简称实例）。这里需要切实掌握它们，以避免概念混淆，导致后续学习吃力。图中把服务拆分为用户微服务和资金微服务。所谓微服务，是指完成某一业务功能的独立系统。一个微服务可以有多个实例，所谓实例，是指一个具体的服务节点。例如，图中用户微服务一共有两个实例（用户实例1和用户实例2），同样，资金微服务也存在两个实例（资金实例1和资金实例2）。同一个微服务下的实例应该具备相同的业务功能。那么Eureka具体怎么区分哪一个实例是用户服务的实例，哪一个实例是资金微服务的实例呢？其实就是使用spring.appliacation.name配置项进行区分的，它可以配置一个字符串，通过这个字符串，Eureka就能把具有相同spring.appliacation.name配置项的实例认为是同一微服务下的实例。例如，用户实例1和用户实例2都配置spring.appliacation.name为user时，Eureka就会认为他们属于同一个微服务。那么服务实例是如何注册到Eureka服务治理中心的呢？实际就是实例对Eureka服务治理中心发送REST风格的请求，将自己的相关配置发送到Eureka服务治理中心完成注册，其中请求地址是由配置项eureka.client.serviceUrl.defaultZone生成的。</p>
<p>一般来说，我们都会把一个微服务注册为多个实例，其原因主要有两个。第一，从高可用的角度来说，即使有某个微服务下的一个实例不可用，那么其他实例也可以继续使用，服务仍然可以继续。第二，从性能的角度来说，多个实例可以有效分摊大量请求的压力，从而提高响应能力和吞吐能力。至于如何将微服务实例注册到服务治理中心是下节要讨论的。</p>
<h4 id="3-1-2-服务发现"><a href="#3-1-2-服务发现" class="headerlink" title="3.1.2 服务发现"></a>3.1.2 服务发现</h4><p>搭建了服务治理中心后，接着你肯定想往里面注册属于自己的微服务及其实例。本节让我们讨论一下这个问题。</p>
<p>为了进行注册，这里我们在IDEA中创建3个Spring Boot模块，分别是user（用户）、fund（资金）和product（理财产品，简称为产品）。在IDEA中创建的时候，要依赖Eureka Discovery和Web两个库。本节我们主要讨论如何将用户（user）微服务注册到Eureka服务治理中心。至于资金（fund）和产品（product）微服务，也是类似的。</p>
<p>首先，打开user模块的pom.xml，可以看到代码清单3-4所示的节选代码。</p>
<p>代码清单3-4 pom.xml节选（user模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大家可以看到，在依赖上，依赖了spring-cloud-starter-netflix-eureka-client包，它是一个服务发现的包，我们依靠它把当前的Spring Boot模块注册到Eureka服务治理中心。</p>
<p>然后，对application.yml文件进行配置，如代码清单3-5所示。</p>
<p>代码清单3-5 application.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例主机名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>
<p>接下来，打开IDEA创建好的UserApplication.java，如代码清单3-6所示。</p>
<p>代码清单3-6 UserApplication（user模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.user.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 在新版本的 Spring Cloud中，不再需要这个注解驱动服务发现了</span></span><br><span class="line"><span class="comment">// @EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(UserApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的@EnableDiscoveryClient注解是一个用于服务发现的注解，在旧版本里，还会使用得到它，但在当前最新版本的Spring Cloud中，不需要这个注解就可以驱动服务发现功能。当这个服务启动成功后，它就会根据配置项eureka.client.serviceUrl.defaultZone发送相关的请求，注册实例了。需要注意的是，服务注册功能是在服务启动成功后，间隔一个时间戳才会执行的，所以需要稍等一会儿。</p>
<p>这里，先运行代码清单3-2(eureka-server模块)，然后再运行代码清单3-6，稍等一会儿，在浏览器中打开网址<a target="_blank" rel="noopener" href="http://localhost:5001/，就可以看到图3-3所示的IDE界面了。">http://localhost:5001/，就可以看到图3-3所示的IDE界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141801244.png" alt="image-20231014180119135"></p>
<p>从图3-3中可以看出，刚启动的用户微服务实例已经注册成功了，名称为USER。这个名称是我们application.yml中的配置项spring.application.name的值，是一个微服务的名称。</p>
<p>事实上，一个微服务可以有多个实例，为了展示这点，首先停止代码清单3-6的运行，然后在resources目录下添加两个文件application-peer1.yml和application-peer2.yml，其内容如代码清单3-7和代码清单3-8所示。</p>
<p>代码清单3-7 application-peer1.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-8 application-peer2.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6002</span></span><br></pre></td></tr></table></figure>
<p>注意，这两个配置文件只是配置启动的端口而已，也就是我们可以选择6001端口或者6002端口启动用户微服务。此时对application.yml进行配置，如代码清单3-9所示。</p>
<p>代码清单3-9 application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例主机名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件；</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件。</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>这里使用了spring.profiles.active配置项，如果配置为peer1，则项目使用配置文件application-peer1.yml启动；如果配置为peer2，则使用配置文件application-peer2.yml启动，这样就很方便我们切换了。此时，将spring.profiles.active配置项分别设置为peer1和peer2启动用户微服务，然后再观察Eureka服务治理中心平台，就可以看到图3-4所示的界面了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141809006.png" alt="image-20231014180937959"></p>
<p>从图3-4中我们可以看到，名称为USER的两个微服务实例都已经在Eureka服务治理中心注册成功了。</p>
<p>依照同样的方法处理fund（资金）模块，然后配置其application.yml、application-peer1.yml和application-peer2.yml，如代码清单3-10、代码清单3-11和代码清单3-12所示。</p>
<p>代码清单3-10 application.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 实例服务器名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fund</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件；</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件。</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-11 application-peer1.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-12 application-peer2.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br></pre></td></tr></table></figure>
<p>这里的配置和用户微服务如出一辙，只是将微服务名称配置为fund，将启动端口切换为7001和7002。这样，就可以启动微服务名称为fund的两个实例了。</p>
<p>使用同样的方法来修改product模块，将其spring.application.name设置为product，然后分别在8001和8002端口启动。稍等一会儿后，再刷新图3-4所示的页面，就可以看到图3-5了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141836567.png" alt="image-20231014183622458"></p>
<p>从图3-5中，我们看到3个微服务下都存在两个实例，它们都已经成功地注册到服务治理中心了。这样，Eureka服务治理中心就可以治理和监控各个微服务的实例了。</p>
<h4 id="3-1-3-多个服务治理中心实例"><a href="#3-1-3-多个服务治理中心实例" class="headerlink" title="3.1.3 多个服务治理中心实例"></a>3.1.3 多个服务治理中心实例</h4><p>前面，我们给各个微服务分别注册了两个实例，这保证了它们的高可用和性能。但是我们的服务治理中心却只有一个，这就不具备高可用了，因为只要服务治理中心宕机，那么整个微服务系统就垮掉了。为了解决这样的问题，我们希望服务治理中心也能有多个实例，这样就不容易垮掉了。为了达到这个目的，需要对服务治理中心和微服务实例的配置做一些修改。</p>
<p>首先，在模块eureka-server的resources目录下新建两个配置文件，分别为application-peer1.yml和application-peer2.yml，它们的配置如代码清单3-13和代码清单3-14所示。</p>
<p>代码清单3-13 application-peer1.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-14 application-peer2.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5002</span></span><br></pre></td></tr></table></figure>
<p>请注意这两段代码，Eureka启动的端口分别为5001和5002</p>
<p>然后，修改配置文件application.yml，如代码清单3-15所示。</p>
<p>代码清单3-15 application.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Spring应用名称，它是一个微服务的名称，一个微服务可拥有多个实例</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">eureka-server</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#server:</span></span><br><span class="line"><span class="comment">#  port: 5001 #修改内嵌Tomcat端口为5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 服务注册地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://192.168.1.100:5001/eureka/,http://192.168.1.100:5002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例服务器IP</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码，配置项eureka.client.serviceUrl.defaultZone将实例同时注册到了5001端口和5002端口的Eureka服务端，这样这两个治理服务中心就可以相互注册了。如果要在IDEA中运行它，可以设置spring.profiles.active为peer1或者peer2，从而选择使用application-peer1.yml或者application- peer2.yml启动不同端口的服务。</p>
<p>上面是在IDEA中运行模块，那么如何在命令行中运行多个实例呢？毕竟在实际开发环境中，使用命令行启动模块还是比较普遍的。这里先将Eureka模块打包，得到文件eureka-server-0.0.1-SNAPSHOT.war，跟着执行以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\eureka-server-0.0.1-SNAPSHOT.war --spring.profiles.active=peer1</span><br><span class="line">java -jar .\eureka-server-0.0.1-SNAPSHOT.war --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure>
<p>这两条命令都采用了一个名为spring.profiles.active的运行参数，一旦配置了它，Spring Boot就会使用application-{spring.profiles.active}.yml作为其配置文件进行运行。当将其设置为peer1时，使用application-peer1.yml文件来启用Spring Boot应用。当将其设置为peer2时，使用application-peer2.yml文件来启用Spring Boot应用。</p>
<p>接下来分别修改user、fund和product微服务的配置文件application.yml中的配置项eureka.client. serviceUrl.defaultZone，如代码清单3-16所示。</p>
<p>代码清单3-16 application.yml（user、fund和product模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/,http://localhost:5002/eureka/</span></span><br></pre></td></tr></table></figure>
<p>注意代码加粗的地方，配置项eureka.client.serviceUrl.defaultZone配置成了两个服务治理中心的域，每个域由半角逗号隔开。这样它就会对多个服务治理中心发送注册请求了。然后再重新运行这3个微服务（各自2个实例）。表3-1是我本地启动微服务的具体情况。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843082.png" alt="image-20231014184309046"></p>
<p>等待所有微服务实例启动完成后，等待一段时间，打开服务治理中心（<a href="http://localhost:5001），此时可以看到图3-6所示的界面了。">http://localhost:5001），此时可以看到图3-6所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843226.png" alt="image-20231014184322192"></p>
<p>从图3-6中可以看出，服务治理中心和各自微服务都存在两个实例。为了让大家对服务治理中心、用户微服务、资金微服务和产品微服务之间的关系有更为清晰的认知，图3-7给出了它们之间的关系图。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843180.png" alt="image-20231014184357131"></p>
<h3 id="3-2-Eureka治理机制"><a href="#3-2-Eureka治理机制" class="headerlink" title="3.2 Eureka治理机制"></a>3.2 Eureka治理机制</h3><p>在前面几节中，我们搭建了一个简单的Spring Cloud微服务系统。但是，我们没有讨论过微服务系统之间是怎么交互的，将微服务注册到服务治理中心有什么用，服务治理中心是如何管理各个微服务的，在我们需要做出改变时如何修改配置。这些问题就是本节要回答的问题，也是本章的核心内容。</p>
<h4 id="3-2-1-基础架构"><a href="#3-2-1-基础架构" class="headerlink" title="3.2.1 基础架构"></a>3.2.1 基础架构</h4><p>现实业务往往需要多个微服务相互协作才能完成。例如，当用户发出购买理财产品的请求时，这里假设是由理财产品微服务发起的，首先要在理财产品微服务里扣减理财产品对应的额度，然后到资金微服务扣减用户的资金，最后在产品微服务记录购买交易，才能完成这个请求。这个过程涉及了两个微服务的协作。正如之前讨论过的，在微服务架构中，推荐使用的是REST风格请求。为了简化微服务之间的调用，Spring Cloud封装了Ribbon和OpenFeign两个组件，本章会简单讨论Ribbon，但不会讨论OpenFeign。有关于Ribbon和OpenFeign的详细讨论会在后续的章节中进行。值得注意的是，如果已经在模块中引入了spring-cloud-starter-netflix-eureka-client，它的父pom便会自动引入spring-cloud-starter-netflix-ribbon，所以这里不再需要依赖新的包了。</p>
<p>我们来模拟一下交易流程，先在fund模块里创建一个账户控制器，并且实现扣减资金的功能，如代码清单3-17所示。</p>
<p>代码清单3-17 AccountController.java（fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fund&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">   <span class="comment">// 扣减账户资金</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/account/balance/&#123;userId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">deductingBalance</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;amount&quot;)</span> Double amount,</span></span><br><span class="line"><span class="params">          HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">// 打印当前服务的端口用于监测</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;端口：【&quot;</span> + request.getServerPort() + <span class="string">&quot;】扣减成功&quot;</span>;</span><br><span class="line">      <span class="type">ResultMessage</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>, message);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到一个结果消息类（com.spring.cloud.common.vo.ResultMessage），为此，先创建公共（common）模块，让user、fund和product模块依赖公共模块。然后，再新增结果消息类，其源码可以参考代码清单2-12。这里资金（fund）微服务提供了一个REST端点，在这个方法返回的消息里，存着当前微服务实例的端口，这样就能方便地监控调用的具体是哪个实例的服务了，毕竟我们的资金微服务是存在两个实例的。这里我们使用Spring Cloud提供的组件Ribbon来调用它，Ribbon使用的是处理过的RestTemplate模板。为了在产品微服务中使用Ribbon，我们在ProductApplication中加入RestTemplate的初始化，如代码清单3-18所示。</p>
<p>代码清单3-18 ProductApplication.java（product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product;</span><br><span class="line"><span class="comment">/****imports****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductApplication</span> &#123;</span><br><span class="line">   <span class="comment">// 负载均衡</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span></span><br><span class="line">   <span class="comment">// 创建Spring Bean</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RestTemplate <span class="title function_">initRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中使用了@LoadBalanced，它代表执行负载均衡，也就是它会使用某种策略进行路由，路由到具体的微服务实例上，在默认情况下，使用的是轮询策略。关于这些第4章会进行详细的讨论。这里还使用了注解@Bean，这样它就会作为Spring Bean存放到IoC容器中。</p>
<p>接下来，创建ProductController，在这里模拟用户购买理财产品的过程，如代码清单3-19所示。</p>
<p>代码清单3-19 ProductController.java（product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">   <span class="comment">// 依赖注入RestTempalte</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/purchase/&#123;userId&#125;/&#123;productId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">purchaseProduct</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;userId&quot;)</span>  Long userId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;productId&quot;)</span> Long productId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;amount&quot;)</span> Double amount)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;扣减产品余额。&quot;</span>);</span><br><span class="line">      <span class="comment">// 这里的FUND代表资金微服务， RestTemplate会自动负载均衡</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://FUND/fund/account/balance/&#123;userId&#125;/&#123;amount&#125;&quot;</span>;</span><br><span class="line">      <span class="comment">// 封装请求参数</span></span><br><span class="line">      Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      params.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">      params.put(<span class="string">&quot;amount&quot;</span>, amount);</span><br><span class="line">      <span class="comment">// 请求资金微服务</span></span><br><span class="line">      <span class="type">ResultMessage</span> <span class="variable">rm</span> <span class="operator">=</span> restTemplate.postForObject(url, <span class="literal">null</span>, ResultMessage.class, params );</span><br><span class="line">      <span class="comment">// 打印资金微服务返回的消息</span></span><br><span class="line">      System.out.println(rm.getMessage());</span><br><span class="line">      System.out.println(<span class="string">&quot;记录交易信息&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>,<span class="string">&quot;交易成功&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，url的服务器和端口被定义为了FUND，与资金微服务的配置项spring.application.name是一致的，这样Eureka服务治理中心就知道你在请求资金微服务，并且默认采用轮询策略做负载均衡。url里面存在着参数的占位定义。跟着使用了Map<String, Object>对象封装请求的参数，其中key和url中参数的占位定义要保持一致。最后使用了RestTemplate的postForObject方法对资金微服务进行请求，这样就可以获取资金微服务返回来的信息进行打印了。</p>
<p>现在我们来启动服务治理中心、资金微服务和理财产品微服务，它们各自存在两个实例。跟着在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/product/purchase/1/1/1000，然后再刷新页面3次，观察8001端口的理财产品微服务，就可以看到类似如下的日志：">http://localhost:8001/product/purchase/1/1/1000，然后再刷新页面3次，观察8001端口的理财产品微服务，就可以看到类似如下的日志：</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">端口：【7001】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7002】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7001】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7002】扣减成功</span><br><span class="line">记录交易信息</span><br></pre></td></tr></table></figure>
<p>从日志中可以看出：资金微服务返回了“成功”的消息；理财产品微服务分别调用了资金微服务的两个实例。</p>
<p>这里有一个重要的概念，就是服务调用。所谓服务调用，就是一个服务调用另外一个服务的过程。要解释Eureka作为服务治理中心的服务调用过程，需要讨论其基础架构的3个重要概念。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●服务治理中心：指Eureka服务器，在代码清单3-19中，使用FUND代替了服务器名称（或者地址）和端口。之所以可以这样，是因为FUND这个名称是在Eureka服务治理中心注册的微服务名称，它下面存在7001和7002两个端口资金微服务实例，所以可以轮询选择其中一个。这便是服务治理中心的作用之一。此外，服务治理中心还会提供服务注册、失败剔除、服务续约和服务下线等功能，用来治理各个微服务实例。</span><br><span class="line">●服务提供者：在代码清单3-17到代码清单3-19中，是理财产品微服务调用资金微服务，所以资金微服务是我们例子中的服务提供者。在微服务系统中，服务提供者主要是以REST风格的端点被服务消费者调用的，而服务提供者是注册在Eureka中的，所以Eureka可以对其进行治理。</span><br><span class="line">●服务消费者：这里的服务消费者是理财产品微服务（Product），它会解析类似FUND这样的微服务名称。解析的过程是，首先根据这个名称从服务治理中心获取服务提供者的实例列表，保存在本地，然后通过特定的负载均衡的策略确定具体的实例，最后通过请求该实例获取数据。例子中使用了Ribbon来实现服务消费，在未来还有更为简便的OpenFeign需要介绍。</span><br></pre></td></tr></table></figure>
<p>注意：这里的服务提供者和消费者并不是对立的，一个微服务可以同时是服务消费者和服务提供者，从这个角度来说，服务提供者和消费者都是Eureka服务治理中心的客户端。例如，在上述例子中，理财产品微服务是服务消费者，但在用户查询资金微服务交易流水的时候，可能需要顺便将理财产品的相关信息展示出来，这时，资金微服务就要调用理财产品微服务，此时，理财产品微服务就变为了服务提供者。</p>
<h4 id="3-2-2-服务治理中心工作原理"><a href="#3-2-2-服务治理中心工作原理" class="headerlink" title="3.2.2 服务治理中心工作原理"></a>3.2.2 服务治理中心工作原理</h4><p>通过前面的学习，我们知道了如何将一个微服务实例注册到服务治理中心（Eureka）中，也知道了可以通过Ribbon去实现REST风格的请求，使得系统能够交互起来。并且从实例中，我们可以看到Ribbon还实现了负载均衡。那么Spring Cloud是如何通过Eureka做到这些的呢？这便是本节要谈到的Eureka服务治理中心的工作原理。</p>
<p>为了更好地解释Eureka的运行原理，这里先按之前的实例画出图3-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141921663.png" alt="image-20231014192140470"></p>
<p>​                    图3-8 Eureka服务治理中心工作原理</p>
<p>关于图3-8需要讲解的内容还是比较多的，且相对复杂。为了方便讲解，将分3个不同的维度来讨论。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●微服务实例和服务治理中心的关系。</span><br><span class="line">●服务治理中心。</span><br><span class="line">●微服务之间的相互调用。</span><br></pre></td></tr></table></figure>
<h5 id="1．微服务实例和服务治理中心的关系"><a href="#1．微服务实例和服务治理中心的关系" class="headerlink" title="1．微服务实例和服务治理中心的关系"></a>1．微服务实例和服务治理中心的关系</h5><p>在图3-8中，任何的微服务都可以对Eureka服务治理中心（也称为Eureka服务端）发送REST风格的请求。在Eureka的机制中，一般是由具体的微服务（也称为Eureka客户端）来主动维持它们之间的关系的。Eureka客户端的请求类型包括注册、续约和下线，下面将对它们展开讨论。</p>
<p>●注册：在将具体的微服务实例注册到Eureka服务端时，是通过REST风格请求其配置的属性eureka.client.serviceUrl.defaultZone生成的URL来完成的，这时，微服务会将其自身的信息传递给Eureka服务端，完成注册。大家可以看到，这个属性有个单词zone，事实上，在Eureka中还存在着另外一个概念，那就是region，关于它们的区别后续会加以解释，这里暂时放放。配置项spring.application.name，是作为微服务名称来定义的，这样可以明确该实例归属于哪个微服务。例如，在例子中，我们会将具体的微服务配置为“product”“fund”和“user”等。在微服务实例中，存在一个配置项eureka.client.register-with-eureka，它的值是布尔（boolean）类型的，默认为true，代表默认情况下将微服务注册到Eureka服务治理中心。当我们将其配置为false的时候，微服务不会被注册到Eureka服务端。注意，当启动微服务时，它并不会马上向Eureka服务治理中心发送REST请求，在Eureka服务治理中心注册，它会延迟40秒才发起请求，所以在启动微服务的时候，需要稍等一会儿才能在Eureka服务治理中心页面中看到注册信息。</p>
<p>●续约：在我们将具体的微服务实例注册到Eureka服务端后，并不能保证该实例一直可用，因为该实例可能出现网络故障、机器故障或者服务宕机等，所以具体的微服务实例会按照一个频率对Eureka服务器维持心跳，告诉Eureka该实例是可用的，借此来避免被Eureka服务端剔除出去，这样的行为被称为续约（Renew）。在续约的过程中，存在两个配置项，它们是：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span> </span><br><span class="line">    <span class="comment"># 微服务实例超时失效秒数，默认值为90秒</span></span><br><span class="line">    <span class="comment"># 倘若续约超时，Eureka会将微服务实例剔除</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="comment"># 间隔对应的秒数执行一次续约服务，默认值为30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>这样，Eureka就可以通过续约服务来确认，对应的微服务实例是否还能正常工作了，对于不能正常工作的实例，也能够及时剔除了。</p>
<p>●下线：在系统出现故障，需要停止或者重启某个微服务实例的时候，在正常操作下，实例会对Eureka发送下线REST风格请求，告知服务治理中心，这样客户端就不能再请求这个实例了。例如，我们启动了服务治理中心和用户微服务（在实操中，我发现在IDEA中点下停止是中断服务，而非正常停止，所以测试不会成功，因此建议使用命令行进行测试），然后正常关闭6002端口的用户微服务实例，就可以看到图3-9所示的情况。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142245286.png" alt="image-20231014224549177"></p>
<p>从图3-9中可以看到，6002的微服务已经不在列表中，说明它已经下线了。</p>
<h5 id="2．服务治理中心"><a href="#2．服务治理中心" class="headerlink" title="2．服务治理中心"></a>2．服务治理中心</h5><p>通过注册、续约和下线3种服务，Eureka可以有效地管理具体的微服务实例。但是服务治理中心之间和本身也会提供一定的服务，甚至可以说服务治理中心也是Eureka客户端，因为它也可以注册到其他的Eureka服务器中，被其他的Eureka服务器治理。这一节我们来了解一下Eureka。</p>
<p>●相互复制：之前我们也讨论过，Eureka本身也会相互注册，以保证高可用和高性能。各个Eureka服务器之间也会相互复制，也就是当微服务发生注册、下线和续约这些操作的时候，Eureka会将这些消息转发到其他服务治理中心的实例上，这样就完成同步了。需要注意的是，这里的Eureka服务器之间采用的是对等模式（Peer-to-Peer），也就是每一个Eureka都是等价的，这有别于分布式中的主从模式（Master-Slave）。</p>
<p>●服务剔除：在实际的工作中，有时候有些服务会因为网络故障、内存溢出或者宕机而导致服务不能正常工作，这个时候就要将这些无效的服务实例剔除出去。Eureka Server在启动时，会创建一个定时任务，在默认的情况下，每间隔60秒就会更新一次微服务实例的清单，只要发现有超过90秒没有完成续约的实例，就会将其剔除出去。</p>
<p>●自我保护：当你在本机测试的时候，如果打开图3-9所示的Eureka平台页面，很多时候你会看到红色的英文警告：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#x27;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>事实上，这就是Eureka的自我保护机制。在我们启动实例的时候，微服务实例都会自动查找Eureka进行注册，Eureka实例也是如此。在Eureka注册之后，它自己也会通过心跳来告诉自己还活着。在Eureka运行期间，如果在15分钟内低于85%的情况下心跳测试失败，它就会出现警告（在单机测试中很容易出现，在实际生产环境中往往是网络故障）。当然，如果希望Eureka停止自我保护机制，可以这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> </span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 取消Eureka自我保护机制</span></span><br></pre></td></tr></table></figure>
<p>只是这样会存在一定的风险，在大部分情况下，只需要采用默认值true就好，不需要对其进行修改。在本机的测试中，我一般会将其配置为false，以避免发生关闭的微服务实例无法被服务治理中心剔除出去的问题。</p>
<h5 id="3．微服务之间的相互调用"><a href="#3．微服务之间的相互调用" class="headerlink" title="3．微服务之间的相互调用"></a>3．微服务之间的相互调用</h5><p>在讨论基础架构的时候，我们使用了Ribbon。从例子打出的日志中，可以看到Ribbon已经帮助我们完成了负载均衡。那么整个过程是怎么样的呢？这里就需要讨论服务获取和服务调用这两个功能了。</p>
<p>●服务获取。服务获取是指微服务实例作为Eureka的客户端，从Eureka服务治理中心获取其他微服务实例清单的功能。它还会将该服务实例清单缓存到本地，并且按一定的时间间隔刷新。当我们启动微服务实例的时候，它就会以一个时间间隔（默认是30秒）向Eureka服务治理中心发送REST风格请求，获取一份只读的服务实例清单，跟着进行缓存，在下一个时间间隔再发送REST风格请求到Eureka，获取最新的服务实例清单，以确定哪些实例可用，哪些实例不可用。例如，我们在代码清单3-19中编写URL时，采用了含有FUND字符串的URL。通过这个字符串，Ribbon就知道使用的是资金微服务，跟着从它获取的服务实例清单中，通过一种负载均衡的算法选择其中的一个实例进行调用。在默认的情况下，Ribbon会采用轮询的策略，所以会出现我们例子中的日志，轮流打印出2个实例的信息。这里有两个参数可以配置，一个是是否执行服务获取，另一个是获取服务实例清单的时间间隔，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> </span><br><span class="line">    <span class="comment"># 是否检索服务实例清单，默认值true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 检索服务实例清单的时间间隔（单位秒），默认值30</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>●服务调用。服务调用是指一个微服务调用另一个微服务的过程。在Spring Cloud中，大部分会采用REST风格请求。一个微服务下存在多个实例，那么会采用哪个实例呢？首先，我们之前谈过服务获取的功能，它会从Eureka服务治理中心拉取一份服务实例清单，然后通过某种负载均衡的算法，选择具体的实例，所以这里服务调用的过程核心往往就是负载均衡的算法了。这里我们把它称为“客户端负载均衡”，请注意，这里的“客户端”是针对Eureka服务中心而言的，也就是微服务实例自身是Eureka的客户端。这里的负载均衡是一个相当复杂的内容，在未来我们谈到Ribbon时才会详细地讨论。</p>
<h4 id="3-2-3-Region和Zone"><a href="#3-2-3-Region和Zone" class="headerlink" title="3.2.3 Region和Zone"></a>3.2.3 Region和Zone</h4><p>很多时候，很多开发者不能理解为什么在注册微服务的时候存在Region和Zone。在讨论前，我们先来谈谈它们的英文含义。在英语中，它们都有地区的意思：Region是指大的地区，如亚洲、欧洲或者北美洲等，又或者是一些大的国家，如中国、印度这样的人口大国；而Zone则是指更小的地区，如华北、华南地区，又或者是省份，如广东、江苏等。</p>
<p>实际上，Region和Zone是来自亚马逊云技术服务（Amazon Web Services，AWS）平台的概念。亚马逊之所以提出这样的概念，是因为亚马逊是全球服务的公司，它的站点是全球范围的。假设你在北京调用亚马逊在纽约的站点服务，那么至少会有以下两个问题。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●距离问题：地球很大，即使是直线距离，从北京到纽约也需要一万多公里的距离。即使网络是以光速（每秒30万公里，事实上，在地球上达不到这个速度，只会更慢）传输数据的，也会产生几十毫秒的延迟，加上光纤制作的网线还不是直线而是曲线，就需要延迟更久的时间。</span><br><span class="line">●地区差异问题：每个国家或地区的习俗和法制基本都是不一样的，存在着很大的地区差异，所以不是一个简单的系统就能够处理所有的业务的，一个服务在不同的国家或者地区需要采用不同的业务模式。</span><br></pre></td></tr></table></figure>
<p>为了解决这两个问题，亚马逊提出了Region和Zone的概念。例如，先确定一个大的范围，如定义我国为一个Region。在这个Region内法律、语言和文化等是接近的，所以在限制问题上得到很大的缓解。但是对于我国这样幅员辽阔的国家来说，主要城市之间的距离也很远，例如，北京到广州也有两千多公里，这就意味着，网络传输距离过长的问题并没有得到太大的缓解。此时，如果服务站点在北京，在经济发达的广东发生了大量的业务，那么长距离的传输就会造成大量的延迟。为了处理这个问题，就提出了Zone的概念，它代表从一个大的区域（Region）切分出来的更小的区域（Zone）。例如，在我国这个Region的基础上再进行划分，将我国南方地区划分为一个Zone，将服务站点设在广州，这样我国南方的请求就可以优先路由到广州，网络传输的距离就小了，延迟的问题就会得到大大的缓解。</p>
<p>在Eureka中也是一样的，在需要大型分布式站点的时候，微服务之间的REST风格请求交互，也应该采用就近原则。例如，深圳的请求应该调用广州的站点服务，而广州站点内部的微服务实例之间会相互调用，而不是跨Zone调用北京的站点服务，这些都是依靠Region和Zone来实现的。例如，一个跨国大型服务网站放置在北京的站点可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 确定一个大区域</span></span><br><span class="line">    <span class="attr">region:</span> <span class="string">China</span></span><br><span class="line">    <span class="comment"># 确定一个小区域</span></span><br><span class="line">    <span class="attr">availability-zones:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure>
<p>这里就将我国定为了该大型服务网站的一个大区，然后在北京放置了一个站点。配置中的availability-zones被设置为北京，这样北方的请求就主要路由到北京站点，由北京站点提供服务，北京站点的微服务实例在相互调用的时候也会采用就近原则，从而提高性能，见图3-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142257891.png" alt="image-20231014225706833"></p>
<p>通过Region和Zone概念的设计，可以将机房设置在不同的地区，从而解决距离问题和各个地区业务的差异，进一步提高微服务系统的响应能力和灵活性。</p>
<h4 id="3-2-4-Eureka关键源码解读"><a href="#3-2-4-Eureka关键源码解读" class="headerlink" title="3.2.4 Eureka关键源码解读"></a>3.2.4 Eureka关键源码解读</h4><p>为了让大家更深入地理解Eureka的机制，以及为未来章节奠定基础，本节对关键的源码进行讲解。不过，在Eureka的机制中，主要是客户端主动维护和Eureka服务端的关系，所以这里的源码都是Eureka客户端的逻辑代码。</p>
<p>首先，在旧的Spring Cloud版本中，还需要使用@EnableDiscoveryClient进行服务发现，但在新的版本中已经不需要了。我们从@EnableDiscoveryClient开始解读Eureka的源码，它的源码如代码清单3-20所示。</p>
<p>代码清单3-20 EnableDiscoveryClient的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.client.discovery;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation to enable a DiscoveryClient implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(EnableDiscoveryClientImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启动自动注册功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的配置项autoRegister是一个布尔值，默认为true，也就是启用自动注册的功能。在类注释中，我们可以看到，它的作用是标注Eureka客户端（微服务）作为服务发现的实例，这个服务发现的接口是DiscoveryClient。我们稍微研究一下这个接口，接口的设计如图3-11所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142259407.png" alt="image-20231014225951361"></p>
<p>因为其中最常用的是EurekaDiscoveryClient，所以我们将对它进行研究。在其源码中，可以看到，它有两个重要的属性，其类型分别是EurekaInstanceConfig和EurekaClient。这里需要注意的是，EurekaInstanceConfig和EurekaClient是Netflix公司的类，而EurekaDiscoveryClient则是Spring Cloud的类。简单来说，Spring Cloud使用EurekaDiscoveryClient对Netflix公司的类进行了二次封装，使得使用起来更为简单。我们从名称可以知道，EurekaInstanceConfig是一个配置类，而EurekaClient则是一个Eureka客户端类，所以这里研究的核心就是接口EurekaClient。EurekaClient是Netflix公司的接口，我们先来看看它的接口和实现类的设计，如图3-12所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142301889.png" alt="image-20231014230121845"></p>
<p>注意，这里只讨论EurekaClient上下相关的接口和类。接口LookupService和EurekaClient以及类DiscoveryClient是Netflix开发的，而CloudEurekaClient则是Spring Cloud在继承DiscoveryClient的基础上开发的。在上述的例子中，注册到服务中心是通过配置项eureka.client.serviceUrl.defaultZone进行配置的，所以我们可以顺藤摸瓜，在类DiscoveryClient中找到对应的方法getServiceUrlsFromConfig，这是一个被标注了@Deprecated的方法。从注释中可以看到，取代它的是EndpointUtils的getServiceUrlsFromConfig方法。事实上，获取这个URL的就是getServiceUrlsFromConfig方法，所以这里让我们讨论一下它，如代码清单3-21所示。</p>
<p>代码清单3-21 类EndpointUtils的getServiceUrlsFromConfig方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getServiceUrlsFromConfig</span><span class="params">(</span></span><br><span class="line"><span class="params">      EurekaClientConfig clientConfig, String instanceZone, </span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> preferSameZone)</span> &#123;</span><br><span class="line">   <span class="comment">// serviceUrl 是有序加入的</span></span><br><span class="line">   List&lt;String&gt; orderedUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">   <span class="comment">// 寻找Region</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> getRegion(clientConfig);</span><br><span class="line">   <span class="comment">// 寻找可用Zone</span></span><br><span class="line">   String[] availZones </span><br><span class="line">       = clientConfig.getAvailabilityZones(clientConfig.getRegion());</span><br><span class="line">   <span class="comment">// 可用Zone为空则使用默认值</span></span><br><span class="line">   <span class="keyword">if</span> (availZones == <span class="literal">null</span> || availZones.length == <span class="number">0</span>) &#123;</span><br><span class="line">      availZones = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">      availZones[<span class="number">0</span>] = DEFAULT_ZONE;</span><br><span class="line">   &#125;</span><br><span class="line">   logger.debug(<span class="string">&quot;The availability zone for the given region &#123;&#125; are &#123;&#125;&quot;</span>,</span><br><span class="line">      region, availZones);</span><br><span class="line">   <span class="comment">// 从可用Zone数组中检索出当前实例的Zone下标，如果找不到则返回0，从而指向默认zone</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">myZoneOffset</span> <span class="operator">=</span> getZoneOffset(instanceZone, preferSameZone, availZones);</span><br><span class="line">   <span class="comment">// 根据Zone获取已经存在的serviceUrls</span></span><br><span class="line">   List&lt;String&gt; serviceUrls </span><br><span class="line">      = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);</span><br><span class="line">   <span class="comment">// 倘若当前已经存在了对应的serviceUrls，则加入有序数组</span></span><br><span class="line">   <span class="keyword">if</span> (serviceUrls != <span class="literal">null</span>) &#123;</span><br><span class="line">      orderedUrls.addAll(serviceUrls);</span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="comment">// 循环所有的Zone，毕竟可以配置多个zone </span></span><br><span class="line">   <span class="comment">// 设置当前循环下标，</span></span><br><span class="line">   <span class="comment">// 如果当前循环下标（myZoneOffset）指向的是最后一个可用的Zone，则从0开始</span></span><br><span class="line">   <span class="comment">// 否则就从下标myZoneOffset+1开始</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">currentOffset</span> <span class="operator">=</span> </span><br><span class="line">      myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果currentOffset与myZoneOffset不等，则继续循环</span></span><br><span class="line">   <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</span><br><span class="line">      <span class="comment">// 根据zone从当前配置中读取serverUrls</span></span><br><span class="line">       serviceUrls = </span><br><span class="line">         clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);</span><br><span class="line">       <span class="comment">// 如果存在，则加入orderedUrls</span></span><br><span class="line">       <span class="keyword">if</span> (serviceUrls != <span class="literal">null</span>) &#123;</span><br><span class="line">          orderedUrls.addAll(serviceUrls);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果到达数组最后，则从0开始循环</span></span><br><span class="line">       <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</span><br><span class="line">          currentOffset = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 下标递增</span></span><br><span class="line">          currentOffset++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果都为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">          <span class="string">&quot;DiscoveryClient: invalid serviceUrl specified!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orderedUrls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●这里再次看到了Region和Zone，下面我们来描述一下整个过程。</p>
<p>●获取Region，如果没有配置，则使用默认值。一个微服务只能找到一个Region，如果没有找到，就使用默认值。</p>
<p>●通过Region获取可用的Zone数组，一个Region可以对应多个Zone，如果获取Zone失败，则使用默认值。</p>
<p>●在可用的Zone数组中查找当前的Zone实例。如果找到第一个匹配Zone的下标，则返回Zone的下标；如果没有找到，则返回0指向默认值。</p>
<p>●将与Zone匹配的已经配置好的可用serviceUrls加入到orderedUrls中。</p>
<p>●遍历可用Zone数组，找到各个Zone匹配的serviceUrls加入到orderedUrls中，最后返回。</p>
<p>这里还有一个重要的接口，EurekaClientConfig，它的作用是对Eureka客户端进行配置。接口EurekaClientConfig有两个实现，一个是Netflix公司的DefaultEurekaClientConfig，另一个是Spring Cloud自己开发的EurekaClientConfigBean。我们在配置文件（如application.yml）中以“eureka.client”为前缀的配置项就是配置它的属性。在上述代码中，用到了EurekaClientConfigBean的getEurekaServerServiceUrls方法来获取serviceUrl，为此让我们讨论一下它的源码，如代码清单3-22所示。</p>
<h4 id="3-2-5-Eureka使用注意点"><a href="#3-2-5-Eureka使用注意点" class="headerlink" title="3.2.5 Eureka使用注意点"></a>3.2.5 Eureka使用注意点</h4><p>在上述的描述中，结合第1章学习的CAP理论，可以看出Eureka是一个强调AP（可用性和分区容忍）的组件。先谈可用性，Eureka的机制是通过各种REST风格的请求来监控各个微服务甚至其他Eureka服务器是否可用，在一些情况下会剔除它们，所以即使某个微服务只存在一个实例，该微服务也依旧可用，这便是Eureka的高可用性。在Eureka机制中，如果某个微服务实例可能不能使用了，那么Eureka服务器就会通过服务续约机制将其剔除，不再让新的请求路由到这个可能不可用的实例上，从而保证请求能在正常的实例得到处理。</p>
<p>在Eureka的使用过程中，有两个延迟是需要注意的。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●对于服务注册，启动Eureka客户端，它不会马上注册到Eureka服务器。在默认情况下，启动后需要等上40秒后，才会发送REST风格请求到Eureka服务器请求注册。如果注册不成功，它会每30秒尝试注册一次。换句话说，并不是启动Eureka客户端之后，它就马上注册，这是需要注意的地方。</span><br><span class="line"></span><br><span class="line">●对于服务发现，客户端存在自己的缓存清单，在默认的情况下，它是30秒维护一次。换句话说，即使你的新微服务注册到了Eureka，该缓存清单也可能不包含这个新微服务，只有当缓存清单刷新后才能发现新注册的微服务，这是大家在实践中需要注意的。</span><br></pre></td></tr></table></figure>
<p>上述的时间间隔都可以通过配置改变，在3.2.4节的源码分析中，我都进行了详细的论述。为了避免关闭的实例无法被Eureka剔除的问题，在后续本机的测试中，我都是使用配置项关闭Eureka的自我保护机制的（将配置项eureka.server.enable-self-preservation设置为false），这是大家需要注意的地方。</p>
<h3 id="3-3-Eureka配置"><a href="#3-3-Eureka配置" class="headerlink" title="3.3 Eureka配置"></a>3.3 Eureka配置</h3><p>Eureka配置的基础是其治理机制，掌握其治理机制能更好地使用配置。实际上，在讲解其治理机制的时候，已经讲了很大一部分的配置，所以本节的讨论只是在添砖加瓦。对于Eureka的配置分为服务端和客户端，实际的Eureka客户端也是一个具体的微服务实例，甚至Eureka服务器实例也是另外一个Eureka服务器的客户端，正如之前的例子中，我们让两个Eureka服务器相互注册就是这样。</p>
<p>Eureka机制主要的配置是客户端，因为在大部分的情况下都是客户端主动通过REST请求服务端来完成续约和服务获取等重要功能。Eureka客户端的配置主要分两种，一种是服务注册配置，另外一种是服务实例配置。对于服务注册配置，主要是服务注册中心地址、服务获取时间间隔、可用区域等。对于服务实例配置，则主要是服务实例的名称、端口、心跳监测地址等。</p>
<p>Eureka服务器本身在使用时应该说并不需要太多的配置，只需保持原有的配置即可。如果需要更多的配置信息，建议查看它的配置类的源码，它的配置类是org.springframework.cloud.netflix.eureka.server. EurekaServerConfigBean，通过它可以获取更多的信息，这里就不再阐述了。</p>
<h4 id="3-3-1-客户端服务注册配置"><a href="#3-3-1-客户端服务注册配置" class="headerlink" title="3.3.1 客户端服务注册配置"></a>3.3.1 客户端服务注册配置</h4><p>客户端服务注册的配置是以eureka.client为前缀的，如果需要更为详尽的配置信息，可以看org.springframework.cloud.netflix.eureka.EurekaClientConfigBean的源码，换句话说，以eureka.client为前缀的配置项就是配置这个Bean的。</p>
<p>在客户端配置中，最为麻烦的是指定注册中心。上述是使用配置项eureka.client.serviceUrl.defaultZone进行配置的。从代码清单3-21中，我们知道，serviceUrl实际是配置类EurekaClientConfigBean的一个类型为HashMap<String, String>的属性，默认值是<a target="_blank" rel="noopener" href="http://localhost:8761/eureka。但在我们的实例中，启动Eureka的端口是5001和5002，所以我们会这样配置">http://localhost:8761/eureka。但在我们的实例中，启动Eureka的端口是5001和5002，所以我们会这样配置</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务实例注册服务治理中心的URL</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/,http://localhost:5002/eureka/</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到，可以配置多个注册中心，它们之间以半角逗号分隔，这样就能够将当前微服务实例注册到Eureka服务治理中心了。但是有时候，注册中心还需要HTTP验证来保证安全性，这个时候就需要改变配置了。例如，<a target="_blank" rel="noopener" href="http://user:password@localhost:5001/eureka，在这个URL中，user是用户名，password是密码。">http://user:password@localhost:5001/eureka，在这个URL中，user是用户名，password是密码。</a></p>
<p>当然，客户端服务注册的配置项还有很多，它们都以eureka.client开头，如表3-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142319264.png" alt="image-20231014231924190"></p>
<h4 id="3-3-2-客户端服务实例配置"><a href="#3-3-2-客户端服务实例配置" class="headerlink" title="3.3.2 客户端服务实例配置"></a>3.3.2 客户端服务实例配置</h4><p>上述注册配置的信息主要是针对服务发现、获取和续约的，这里的客户端服务实例配置，则是针对Eureka客户端所要注册的信息的。客户端服务实例的配置是以eureka.instance为前缀的，配置的类是org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean。换句话说，如果需要更多的信息，看这个类就可以了。Spring Cloud会用通过EurekaInstanceConfigBean读入的信息，创建InstanceInfo实例，然后将InstanceInfo实例通过REST请求发送给Eureka服务器。</p>
<p>首先，我们先来看服务实例名称的配置。在默认的情况下，启动Eureka客户端，就可以在Eureka服务器平台上看到图3-13所示的信息。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142320958.png" alt="image-20231014232039906"></p>
<p>从图中可以看到，每一个微服务都有两个实例，而每一个实例的名称又不尽相同，那么它的规则是怎么样的呢？在Spring Cloud中，微服务实例默认的名称规则是，如果我们配置了spring.application. instance_id，则名称为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;spring.cloud.hostname&#125;</span>:$(spring.application.name):$(spring.application.instance_id)</span><br></pre></td></tr></table></figure>
<p>如果没配置，则名称为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;spring.cloud.hostname&#125;</span>:$(spring.application.name):$(server.port)</span><br></pre></td></tr></table></figure>
<p>显然，图3-13中的微服务实例名称没有配置spring.application.instance_id，所以会采用第二种规则来产生服务实例名称。倘若开发者不想采用Spring Cloud提供的规则，那么也可以使用自定义服务实例名称，使用配置项eureka.instance.instance-id就行。例如，修改用户的application-peer2.yml文件的配置项，如代码清单3-27所示。</p>
<p>代码清单3-27 修改application-peer2.yml中的服务实例名称（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义微服务实例信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 微服务id，规则为“实例服务器名称-微服务名称-端口”</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;-user-$&#123;server.port&#125;</span></span><br><span class="line">    <span class="comment"># “实例服务器名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>
<p>然后，我们重启Eureka服务器，就可以看到图3-14所示的结果了。<img src="https://gitee.com/fjkf/images/raw/master/202310142323408.png" alt="image-20231014232307349"></p>
<p>从图3-14中可以看到，通过配置项eureka.instance.instance-id可以修改服务名称了。只是在配置服务名称的过程中，大家要尽量避免重名的发生。我还是建议使用服务器名称（或者IP）、微服务名称和端口一起构成命名，或者直接使用Spring Cloud默认的规则。</p>
<p>此外，还可以自定义服务实例的元数据，使用的配置项是eureka.instance.metadata-map，它是一个Map结构，允许我们自定义启动实例的元数据。比方说，我们的用户微服务6002端口部署的是v2版本，为了标记它的版本号，我们可以在application-peer2.yml文件中修改相关的配置项，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义微服务实例信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="comment"># 自定义元数据版本号（version）为v2</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure>
<p>自定义的元数据会被发送到Eureka服务端，其他的微服务也可以读取这个配置，这样就知道部署的是什么版本的服务了。</p>
<h2 id="第4章-客户端负载均衡——Ribbon"><a href="#第4章-客户端负载均衡——Ribbon" class="headerlink" title="第4章 客户端负载均衡——Ribbon"></a>第4章 客户端负载均衡——Ribbon</h2><p>Spring Cloud Netflix Ribbon是一种客户端负载均衡的组件，为了方便，在本书中都简称为Ribbon。在微服务架构中，我们依照业务将系统进行切分，但一个实际的业务往往需要多个微服务通过相互协作来完成，所以各种微服务之间存在服务调用。</p>
<p>在Spring Cloud中，提供的服务调用是Ribbon和OpenFeign。Ribbon是Netflix公司开发的组件，Spring Cloud通过二次封装使得它更加简单易用。OpenFeign实际也是基于Ribbon来实现的。</p>
<p>微服务之间的调用往往被称为“客户端负载均衡”，这是因为在Eureka的机制中，任何微服务都是Eureka的“客户端”。通过第3章的学习，可以知道一个微服务可以存在多个实例，在进行服务调用的时候需要选取具体实例进行调用，这就需要通过具体的负载均衡算法来实现了。正如我们第3章的例子，产品微服务可能会调用资金微服务，但是资金微服务下面又分为多个实例，如何获取资金微服务下的多个实例是服务实例清单获取和维护的功能，而如何选取具体的服务实例就是负载均衡的功能了。</p>
<h3 id="4-1-负载均衡概述"><a href="#4-1-负载均衡概述" class="headerlink" title="4.1 负载均衡概述"></a>4.1 负载均衡概述</h3><p>负载均衡是大型网络系统必须实现的功能之一，主要原因有以下4点。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●降低单机压力：因为在大量的用户、请求和数据面前，单机是无法承受的。实现了负载均衡的系统往往能够根据合理的算法将用户、请求和数据分摊到各个机器上，减少单机压力。●高可用和高性能：当某个节点出现问题时，可以测试其心跳，如果失败到达一定程度，就将它剔出系统；也可以判断它是否处于忙碌阶段，通过负载均衡算法选择是否调度它。这样就保证了高可用。因为可以无限扩展机器，所以在遇到性能瓶颈的时候，可以通过增加机器来保证性能，具备高性能的特点。</span><br><span class="line">●可伸缩性：当企业业务规模快速扩大时，可以通过增加节点的方式，提高系统的服务能力；当业务规模快速减小时，可以通过减少节点的方式，节省资源。</span><br><span class="line">●请求过滤：提供过滤器的使用，过滤器可以通过简单的判断来监测请求的合法性或者对请求流量进行限制，从而避免对具体节点系统的恶意攻击，达到保护系统和提高系统响应能力的目的。</span><br></pre></td></tr></table></figure>
<p>在实际生产中，负载均衡分为硬件负载均衡和软件负载均衡。当前最流行的硬件负载均衡当属F5，但是硬件负载均衡不是软件工程师需要掌握的内容，它是由运维和网络人员进行配置的，所以本书不讨论它。软件负载均衡是本章要讨论的核心。无论是硬件负载均衡，还是软件负载均衡，都可以用类似于图4-1所示的形式构建。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310160928398.png" alt="image-20231016092827296"></p>
<p>负载均衡需要解决两个最基本的问题：第一个是从哪里选服务实例；第二个是如何选择服务实例。关于第一个问题，实际已经讲解过了。让我们回顾第3章的内容，我们知道，在Spring Cloud微服务系统中，维护微服务实例清单的是Eureka服务治理中心，而具体微服务实例会执行服务获取，获得微服务实例清单，缓存到本地，同时，还会按照一个时间间隔更新这份实例清单（因为实例清单也是在不断维护和变化的）。关于第二个问题，就是通过负载均衡的策略从服务实例清单列表中选择具体实例。但实际会更为复杂，因为在一个请求上会出现超过、网络超时甚至是服务提供者的故障等，这时就要考虑断路器组件了，这会在后文讨论到。</p>
<h3 id="4-2-初识Ribbon"><a href="#4-2-初识Ribbon" class="headerlink" title="4.2 初识Ribbon"></a>4.2 初识Ribbon</h3><p>使用Ribbon，主要就是RestTemplate的使用，关于RestTemplate的使用在第2章介绍了很多，这里就不再赘述了。关于Ribbon负载均衡的例子，在3.2.1节中也举例说明了，这里就不再举例了。这里我们需要搞清楚Ribbon的运行机制，各种负载均衡的策略是什么，以及我们应该如何使用它们。</p>
<h4 id="4-2-1-Ribbon概述"><a href="#4-2-1-Ribbon概述" class="headerlink" title="4.2.1 Ribbon概述"></a>4.2.1 Ribbon概述</h4><p>为了更好地解释这些，先来了解一下Ribbon中相关接口和类的概念说明，如表4-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310160933257.png" alt="image-20231016093348188"></p>
<p>这些在Spring Boot中都是通过配置类RibbonClientConfiguration来自定义装配的，需要深入研究的读者可以打开这个类的源码进行进一步的学习。这里的IClientConfig是Ribbon客户端的配置，我们可以通过它配置Ribbon相关的内容。IRule是负载均衡策略接口，也就是说，具体的负载均衡是通过它来提供算法的。IPing接口能判断服务实例是否可用。服务实例存在上线、下线和故障等多种可能，通过IPing接口能判定服务实例是否可用。ServerList<Server>是从Eureka服务端拉取服务实例清单，其中包含注册过的服务实例（包括可用的和不可用的）。ServerListFilter<Server>是服务实例过滤清单，一般过滤条件包含这么几种：实例是否可用、负载是否过大、服务版本选择等，通过这些过滤条件就可以选中合适的实例了。ILoadBalancer负载均衡器，它通过IRule接口提供的算法来选取服务实例；ServerListUpdater属于服务实例列表更新，正如上述所说，服务实例列表是一个不断维护的清单，Ribbon就是通过它来及时更新清单的。有了这些基本概念，下面我们来探索一下源码，进一步理解Ribbon的工作原理。</p>
<h4 id="4-2-2-Ribbon是如何实现负载均衡的"><a href="#4-2-2-Ribbon是如何实现负载均衡的" class="headerlink" title="4.2.2 Ribbon是如何实现负载均衡的"></a>4.2.2 Ribbon是如何实现负载均衡的</h4><p>现在回到代码清单3-18，在RestTemplate上，我们加入了@LoadBalanced，也就是通过这个注解启动了负载均衡。这里打开这个注解的源码，很快就可以看到这样的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient</span><br></pre></td></tr></table></figure>
<p>从这句话可以看出，在使用了注解@LoadBalanced后，LoadBalancerClient接口对象就会对RestTemplate进行处理。所以这里我们需要稍微研究一下LoadBalancerClient接口，在Spring Cloud中，它扩展了ServiceInstanceChooser接口，并且存在一个实现类RibbonLoadBalancerClient，如图4-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310160942250.png" alt="image-20231016094240184"></p>
<p>ServiceInstanceChooser接口定义了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceInstance <span class="title function_">choose</span><span class="params">(String serviceId)</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法的参数serviceId指代的是微服务的ID，也就是实例的配置项spring.application.name，通过它根据一定的策略能返回一个具体的微服务实例。下面再看LoadBalancerClient接口的源码，如代码清单4-1所示。</p>
<p>代码清单4-1 LoadBalancerClient的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.client.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancerClient</span> <span class="keyword">extends</span> <span class="title class_">ServiceInstanceChooser</span> &#123;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> </span><br><span class="line">          <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, </span></span><br><span class="line"><span class="params">          LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">   URI <span class="title function_">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，因为LoadBalancerClient接口扩展了ServiceInstanceChooser接口，所以拥有了choose(String serviceId)方法。其次，还存在下面3个方法。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●execute(String serviceId, LoadBalancerRequest<span class="language-xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span> request)：根据serviceId找到具体的服务实例执行请求。●execute(String serviceId, ServiceInstance serviceInstance,LoadBalancerRequest<span class="language-xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span> request)：根据serviceId和serviceInstance（服务实例）执行请求。</span><br><span class="line">●URI reconstructURI(ServiceInstance instance, URI original)：根据当前给出的URI重构可用的URL。</span><br></pre></td></tr></table></figure>
<p>让我们回到代码清单3-19，该代码使用FUND代替了host:port的格式，而FUND代表资金微服务，也就是serviceId。显然，我们给出的URI是不能进行请求的，必须重写才可以。重写则需要明确对哪个具体的实例进行请求，可以通过ServiceInstanceChooser定义的choose方法的参数来获取服务实例，但是请注意，在本书撰写时这个方法还没有投入使用，稍后我会进行说明。reconstructURI方法的作用是重构URI，也就是在获取微服务实例后，需要把FUND修改为host:port的格式，来确定具体请求哪个服务实例。两个execute方法的作用是执行请求操作。</p>
<p>接下来探讨LoadBalancerClient接口的两个execute方法。在图4-2中，我们可以看到，它存在一个实现类RibbonLoadBalancerClient，先来看一下它的第一个execute方法的实现，如代码清单4-2所示。</p>
<p>代码清单4-2 RibbonLoadBalancerClient第一个execute方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> </span><br><span class="line">          <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 负载均衡器</span></span><br><span class="line">   <span class="type">ILoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> getLoadBalancer(serviceId);</span><br><span class="line">   <span class="comment">// 获取具体服务实例</span></span><br><span class="line">   <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> getServer(loadBalancer);</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123; <span class="comment">// 获取结果为空，抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No instances available for &quot;</span> </span><br><span class="line">         + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 包装为Ribbon服务实例</span></span><br><span class="line">   <span class="type">RibbonServer</span> <span class="variable">ribbonServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RibbonServer</span>(serviceId, server, </span><br><span class="line">      isSecure(server, serviceId), </span><br><span class="line">      serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">   <span class="comment">// 调度另外一个execute方法执行请求</span></span><br><span class="line">   <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在服务实例清单中，按照一定的策略选择具体的服务实例</span></span><br><span class="line"><span class="keyword">protected</span> Server <span class="title function_">getServer</span><span class="params">(ILoadBalancer loadBalancer)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (loadBalancer == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> better handling of key</span></span><br><span class="line">   <span class="keyword">return</span> loadBalancer.chooseServer(<span class="string">&quot;default&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里第一个execute方法的工作流程是，首先通过serviceId获取具体微服务的实例，然后用微服务实例作为参数，调度另外一个execute方法。这里获取具体微服务实例的方法是getServer，使用的是负载均衡器（ILoadBalancer）的chooseServer方法，而非LoadBalancerClient所定义的choose方法。关于负载均衡器，我们后面会讨论。最后这个方法会调用第二个execute方法，我们接下来探讨一下第二个execute方法的源码，如代码清单4-3所示。</p>
<p>代码清单4-3 RibbonLoadBalancerClient第二个execute方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, </span></span><br><span class="line"><span class="params">          LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">      server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No instances available for &quot;</span> </span><br><span class="line">         + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建分析记录器，有兴趣的读者可以自行阅读其源码</span></span><br><span class="line">   <span class="type">RibbonLoadBalancerContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.clientFactory</span><br><span class="line">         .getLoadBalancerContext(serviceId);</span><br><span class="line">   <span class="type">RibbonStatsRecorder</span> <span class="variable">statsRecorder</span> </span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RibbonStatsRecorder</span>(context, server);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将请求发送到具体的服务实例</span></span><br><span class="line">      <span class="type">T</span> <span class="variable">returnVal</span> <span class="operator">=</span> request.apply(serviceInstance);</span><br><span class="line">      <span class="comment">// 将结果记录到分析记录器中 </span></span><br><span class="line">      statsRecorder.recordStats(returnVal);</span><br><span class="line">      <span class="comment">// 返回请求结果 </span></span><br><span class="line">      <span class="keyword">return</span> returnVal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// catch IOException and rethrow so RestTemplate behaves correctly</span></span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      statsRecorder.recordStats(ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      statsRecorder.recordStats(ex);</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先获取了具体的服务实例。然后创建了分析记录器（RibbonStatsRecorder），用来统计分析这次请求，对服务器的情况做一定的分析。最后调用了请求返回结果。</p>
<p>在第3章的例子中，我们并没有创建任何关于LoadBalancerClient接口对象的实例，却能够实现负载均衡的效果，这说明Spring Boot为我们自动装配了相关的对象。打开配置类org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration，就可以看到创建RibbonLoadBalancerClient类对象的代码。</p>
<p>通过上述描述，大家可以看到LoadBalancerClient的功能，但是至今还没有回答LoadBalancerClient是如何让RestTemplate执行负载均衡的。答案是使用了拦截器，Ribbon中提供了拦截器LoadBalancer Interceptor，对标注@LoadBalanced注解的RestTemplate进行拦截，然后植入LoadBalancerClient的逻辑，下面看一下它的源码，如代码清单4-4所示。</p>
<p>代码清单4-4 LoadBalancerInterceptor的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.client.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">   <span class="comment">// 负载均衡客户端</span></span><br><span class="line">   <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">   <span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, </span></span><br><span class="line"><span class="params">         LoadBalancerRequestFactory requestFactory)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">      <span class="built_in">this</span>.requestFactory = requestFactory;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置属性</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> &#123;</span><br><span class="line">      <span class="comment">// for backwards compatibility</span></span><br><span class="line">      <span class="built_in">this</span>(loadBalancer, <span class="keyword">new</span> <span class="title class_">LoadBalancerRequestFactory</span>(loadBalancer));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拦截逻辑</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, </span></span><br><span class="line"><span class="params">         <span class="keyword">final</span> <span class="type">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span><br><span class="line">         <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">URI</span> <span class="variable">originalUri</span> <span class="operator">=</span> request.getURI();</span><br><span class="line">      <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> originalUri.getHost();</span><br><span class="line">      Assert.state(serviceName != <span class="literal">null</span>, </span><br><span class="line">         <span class="string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);</span><br><span class="line">      <span class="comment">// 调用execute方法，执行请求</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.loadBalancer.execute(serviceName, </span><br><span class="line">         requestFactory.createRequest(request, body, execution));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到类LoadBalancerClient的构造方法，负载均衡器（loadBalancer）就作为其参数被装配进来，而类LoadBalancerClient的核心代码是intercept方法，在最后该方法调用了LoadBalancerClient的execute方法。这里LoadBalancerInterceptor对象是通过Spring Boot的方式自动装配的，关于这一点，可以看一下类LoadBalancerAutoConfiguration（org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration）。下面节选LoadBalancerAutoConfiguration的部分代码进行讲解，如代码清单4-5所示。</p>
<p>代码清单4-5 LoadBalancerAutoConfiguration的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.client.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RestTemplate.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标注了@LoadBalanced的RestTemplate列表</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span></span><br><span class="line">   <span class="meta">@Autowired(required = false)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> SmartInitializingSingleton </span><br><span class="line">       <span class="title function_">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; </span></span><br><span class="line"><span class="params">        restTemplateCustomizers)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (RestTemplate restTemplate : </span><br><span class="line">               LoadBalancerAutoConfiguration.<span class="built_in">this</span>.restTemplates) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">               customizer.customize(restTemplate);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingClass(</span></span><br><span class="line"><span class="meta">      &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoadBalancerInterceptorConfig</span> &#123;</span><br><span class="line">      <span class="comment">// 创建拦截器</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="keyword">public</span> LoadBalancerInterceptor <span class="title function_">ribbonInterceptor</span><span class="params">(</span></span><br><span class="line"><span class="params">            LoadBalancerClient loadBalancerClient,</span></span><br><span class="line"><span class="params">            LoadBalancerRequestFactory requestFactory)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadBalancerInterceptor</span>(loadBalancerClient,</span><br><span class="line">            requestFactory);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加拦截器</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">      <span class="keyword">public</span> RestTemplateCustomizer <span class="title function_">restTemplateCustomizer</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">            List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">                   restTemplate.getInterceptors());</span><br><span class="line">            list.add(loadBalancerInterceptor);</span><br><span class="line">            restTemplate.setInterceptors(list);</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要做了3件事。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●创建LoadBalancerInterceptor对象，这样就存在了拦截器，用于拦截相应的被标注了@LoadBalanced的RestTemplate对象。</span><br><span class="line">●创建RestTemplateCustomizer对象，并且将拦截器设置到已有的拦截列表中，这样LoadBalancerInterceptor对象就可以拦截RestTemplate对象了。</span><br><span class="line">●维护一个被标注@LoadBalanced的RestTemplate列表，通过RestTemplateCustomizer给需要负载均衡的RestTemplate提供拦截器（LoadBalancerInterceptor）。</span><br></pre></td></tr></table></figure>
<p>以上就是Ribbon实现负载均衡的整个流程：首先通过LoadBalancerInterceptor拦截RestTemplate，然后在其intercept方法调用LoadBalancerClient接口的execute方法来执行负载均衡。</p>
<h3 id="4-3-Ribbon负载均衡器和策略"><a href="#4-3-Ribbon负载均衡器和策略" class="headerlink" title="4.3 Ribbon负载均衡器和策略"></a>4.3 Ribbon负载均衡器和策略</h3><p>上面我们追随着源码探究了RestTemplate是如何在Ribbon中实现负载均衡的，但是还没有讨论负载均衡的细节内容。负载均衡包括两个部分：负载均衡器和负载均衡策略。负载均衡器可以进一步过滤服务实例清单中不可用或者高负载的服务，排除它们。策略是最终决定选择服务的方法。</p>
<h4 id="4-3-1-负载均衡器"><a href="#4-3-1-负载均衡器" class="headerlink" title="4.3.1 负载均衡器"></a>4.3.1 负载均衡器</h4><p>在代码清单4-2中，选择具体实例的时候采用了ILoadBalancer接口的chooseServer方法。现在让我们来探讨一下ILoadBalancer接口，先看一下它的源码，如代码清单4-6所示。</p>
<p>代码清单4-6 IloadBalancer的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">   <span class="comment">// 新增服务实例列表</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 选择具体服务实例</span></span><br><span class="line">   <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录服务实例下线</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server server)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取具体的服务实例</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Server&gt; ~~getServerList~~(<span class="type">boolean</span> availableOnly); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取可以访问且正常运行的服务实例</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回服务的服务实例</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的方法中，我也注释了其方法的作用。它们主要分成两个部分：一是服务器的管理，关于这些会在另外一节进行讨论；二是本节讨论的chooseService方法，它是选择服务实例的方法。这里追踪一下接口ILoadBalancer的实现类，我们可以发现它存在这样的关系，如图4-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161000180.png" alt="image-20231016100043134"></p>
<p>从图中可以看到，它存在两个最底层的实现类ZoneAwareLoadBalancer和NoOpLoadBalancer。当前的NoOpLoadBalancer是一个空实现，没有太多的讨论价值，所以这里主要讨论ZoneAwareLoadBalancer，而且主要讨论chooseServer方法，对其他细节不做太多的讨论。对于chooseServer方法在图4-3的类中实现的地方有两处，一处是BaseLoadBalancer，另一处是ZoneAwareLoadBalancer。先看一下BaseLoadBalancer的源码，如代码清单4-7所示。</p>
<p>代码清单4-7 BaseLoadBalancer的chooseServer方法的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseLoadBalancer</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancer</span> <span class="keyword">implements</span></span><br><span class="line">      <span class="title class_">PrimeConnections</span>.PrimeConnectionListener, IClientConfigAware &#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 默认的路由策略，轮询</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">IRule</span> <span class="variable">DEFAULT_RULE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line">   <span class="comment">// 当前路由策略</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">IRule</span> <span class="variable">rule</span> <span class="operator">=</span> DEFAULT_RULE;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="comment">// 计数器</span></span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="literal">null</span>) &#123;</span><br><span class="line">         counter = createCounter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 线程安全+1操作</span></span><br><span class="line">      counter.increment();</span><br><span class="line">      <span class="keyword">if</span> (rule == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过路由策略获取服务</span></span><br><span class="line">            <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;LoadBalancer [&#123;&#125;]: &quot;</span> </span><br><span class="line">            + <span class="string">&quot; Error choosing server for key &#123;&#125;&quot;</span>, name, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中可以看到，存在一个计数器，每当执行chooseServer方法时，都会执行一次加1操作，记录操作的次数。代码最后使用的是IRule对象（rule）的choose方法来选择具体的服务实例。从代码来看，默认的IRule接口对象的具体实现类是RoundRobinRule，它采用的是轮询策略。这里的IRule接口是负载均衡中最重要的接口，负载均衡的策略主要是通过它来实现的。不过这里先来讨论ZoneAwareLoadBalancer的chooseServer方法，如代码清单4-8所示。</p>
<p>代码清单4-8 ZoneAwareLoadBalancer的chooseServer方法的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">   <span class="comment">// 如果不存在Zone的概念，且获取的Zone的数量小于等于1，</span></span><br><span class="line">   <span class="comment">// 则执行BaseLoadBalancer的chooseServer方法</span></span><br><span class="line">   <span class="keyword">if</span> (!ENABLED.get() </span><br><span class="line">         || getLoadBalancerStats().getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Zone aware logic disabled &quot;</span> </span><br><span class="line">         + <span class="string">&quot;or there is only one zone&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.chooseServer(key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">LoadBalancerStats</span> <span class="variable">lbStats</span> <span class="operator">=</span> getLoadBalancerStats();</span><br><span class="line">      <span class="comment">// 获取当前负载均衡器中所有Zone的快照，用于负载均衡策略的算法</span></span><br><span class="line">      Map&lt;String, ZoneSnapshot&gt; zoneSnapshot </span><br><span class="line">         = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">      logger.debug(<span class="string">&quot;Zone snapshots: &#123;&#125;&quot;</span>, zoneSnapshot);</span><br><span class="line">      <span class="comment">// 按照负载阈值过滤，按一定的比例（默认20%）去除负载最高的Zone</span></span><br><span class="line">      <span class="keyword">if</span> (triggeringLoad == <span class="literal">null</span>) &#123;</span><br><span class="line">         triggeringLoad = DynamicPropertyFactory.getInstance()</span><br><span class="line">            .getDoubleProperty(<span class="string">&quot;ZoneAwareNIWSDiscoveryLoadBalancer.&quot;</span> </span><br><span class="line">               + <span class="built_in">this</span>.getName() </span><br><span class="line">               + <span class="string">&quot;.triggeringLoadPerServerThreshold&quot;</span>, <span class="number">0.2d</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按故障率阈值（大于99.999%）排除Zone列表</span></span><br><span class="line">      <span class="keyword">if</span> (triggeringBlackoutPercentage == <span class="literal">null</span>) &#123;</span><br><span class="line">         triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance()</span><br><span class="line">            .getDoubleProperty(<span class="string">&quot;ZoneAwareNIWSDiscoveryLoadBalancer.&quot;</span> </span><br><span class="line">            + <span class="built_in">this</span>.getName() + <span class="string">&quot;.avoidZoneWithBlackoutPercetage&quot;</span>, <span class="number">0.99999d</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取可用的Zone，根据负载阈值和故障阈值过滤</span></span><br><span class="line">      Set&lt;String&gt; availableZones </span><br><span class="line">         = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, </span><br><span class="line">              triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">      logger.debug(<span class="string">&quot;Available zones: &#123;&#125;&quot;</span>, availableZones);</span><br><span class="line">      <span class="comment">// 倘若存在可用的Zone</span></span><br><span class="line">      <span class="keyword">if</span> (availableZones != <span class="literal">null</span> </span><br><span class="line">            &amp;&amp;  availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">         <span class="comment">// 随机选择Zone</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> ZoneAvoidanceRule.randomChooseZone(</span><br><span class="line">            zoneSnapshot, availableZones);</span><br><span class="line">         logger.debug(<span class="string">&quot;Zone chosen: &#123;&#125;&quot;</span>, zone);</span><br><span class="line">         <span class="keyword">if</span> (zone != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据Zone名称获取对应的负载均衡器</span></span><br><span class="line">            <span class="type">BaseLoadBalancer</span> <span class="variable">zoneLoadBalancer</span> <span class="operator">=</span> getLoadBalancer(zone);</span><br><span class="line">            <span class="comment">// 根据负载均衡器来获取服务实例</span></span><br><span class="line">            server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Error choosing server using zone aware logic &quot;</span> </span><br><span class="line">         + <span class="string">&quot;for load balancer=&#123;&#125;&quot;</span>, name, e);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果服务实例不为空，则返回</span></span><br><span class="line">   <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> server;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果服务为空，则执行BaseLoadBalancer的chooseServer方法</span></span><br><span class="line">      logger.debug(<span class="string">&quot;Zone avoidance logic is not invoked.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.chooseServer(key);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的步骤大体分为5步。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●判断是否启用了Zone的功能，如果没有Zone或者是Zone的数量只有1个，就采用BaseLoadBalancer的chooseServer方法来选择具体的服务，结束流程。</span><br><span class="line">●按照负载阈值来排除Zone，排除最高负载20%的Zone。</span><br><span class="line">●按照故障率阈值来排除Zone，排除故障率大于99.999%的Zone。</span><br><span class="line">●如果以上步骤都存在可用Zone，就采用随机算法获取Zone，选中Zone后，再通过负载均衡器（zoneLoadBalancer）的chooseServer方法选择服务。</span><br><span class="line">●如果Zone选择失败，就采用BaseLoadBalancer的chooseServer来选择服务实例。</span><br></pre></td></tr></table></figure>
<p>以上便是ZoneAwareLoadBalancer选择服务的大体逻辑流程，负载均衡器通过一定的方法过滤服务实例，从而保证微服务系统的性能。在Spring Boot自动配置的情况下，会默认使用ZoneAwareLoadBalancer作为负载均衡器，创建该对象的过程可以看到org.springframework.cloud.netflix.ribbon.RibbonClient Configuration的源码，如代码清单4-9所示。</p>
<p>代码清单4-9 RibbonClientConfiguration的部分源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负载均衡策略</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">ZoneAvoidanceRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZoneAvoidanceRule</span>();</span><br><span class="line">   rule.initWithNiwsConfig(config);</span><br><span class="line">   <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载均衡器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ILoadBalancer <span class="title function_">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span><br><span class="line"><span class="params">      ServerList&lt;Server&gt; serverList, </span></span><br><span class="line"><span class="params">      ServerListFilter&lt;Server&gt; serverListFilter,</span></span><br><span class="line"><span class="params">      IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ILoadBalancer.class, </span><br><span class="line">         config, name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">         serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码中可以知道，默认的负载均衡器是ZoneAwareLoadBalancer，默认的策略是ZoneAvoidanceRule。于是我们可以得到这样的两种情况：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●如果有Zone概念且Zone数量大于1，则根据负载情况和故障情况排除Zone，默认的负载均衡策略仍旧是轮询。</span><br><span class="line">●如果没有Zone概念或者Zone数量为1，则默认的负载均衡策略为轮询。</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-负载均衡策略"><a href="#4-3-2-负载均衡策略" class="headerlink" title="4.3.2 负载均衡策略"></a>4.3.2 负载均衡策略</h4><p>在讨论基本的负载均衡器（BaseLoadBalancer）的时候，我们谈到了一个重要的接口，那就是IRule，在Ribbon中就是通过它提供的算法来执行具体的负载均衡策略的，所以先来探讨一下它的接口和实现类之间的关系，如图4-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161006470.png" alt="image-20231016100658429"></p>
<p>从图4-4中可以看出，在默认的情况下，Ribbon就提供了许多策略给我们使用，下面通过表4-2对它们进行说明。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161007786.png" alt="image-20231016100720703"></p>
<p>表4-2列出的就是Ribbon提供的多种负载均衡策略，其中ZoneAvoidanceRule策略是其默认的选择策略，在存在Zone概念且Zone数量大于1的时候，它会先过滤那些负载大的服务或者有故障的服务。RoundRobinRule策略是轮询策略，也经常在没有Zone或者Zone判定失败的时候使用，它是现实中使用最多的策略。</p>
<p>基于实用性，这里不会讨论所有的策略，而只是讨论最常用的4种：RoundRobinRule、RetryRule、WeightedResponseTimeRule和ZoneAvoidanceRule。先看一下RoundRobinRule的源码，如代码清单4-10所示。</p>
<p><strong>代码清单4-10 RoundRobinRule的源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">   <span class="comment">// 负载均衡器为null，返回null</span></span><br><span class="line">   <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 如果server为空，并且循环次数小于10次</span></span><br><span class="line">   <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 获得可用的服务实例清单</span></span><br><span class="line">      List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">      <span class="comment">// 获取所有的服务实例清单</span></span><br><span class="line">      List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">      <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size(); <span class="comment">// 可用服务实例数量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size(); <span class="comment">// 所有服务实例数量</span></span><br><span class="line">      <span class="comment">// 如果没有服务实例或可用服务实例，则返回null</span></span><br><span class="line">      <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">         log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 线程安全加1，并取模</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">      <span class="comment">// 获取下一个服务实例</span></span><br><span class="line">      server = allServers.get(nextServerIndex);</span><br><span class="line">      <span class="comment">// 如果此时服务实例还是为空，则线程让步，继续下一次循环</span></span><br><span class="line">      <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">/* Transient. */</span></span><br><span class="line">         Thread.yield();</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果服务实例可用且已经启动好了，则返回服务实例</span></span><br><span class="line">      <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">         <span class="keyword">return</span> (server);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// sever不可用则重置为null，进行下一次循环</span></span><br><span class="line">      <span class="comment">// Next.</span></span><br><span class="line">      server = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 如果超过10次获取失败，则不再重试</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">         log.warn(<span class="string">&quot;No available alive servers after 10 &quot;</span> </span><br><span class="line">         + <span class="string">&quot;tries from load balancer: &quot;</span> + lb);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，程序将生成一个线程安全的整数，然后加1并取模来确定一个下标（index）以获取服务。如果服务为空或者不可用（包含在启动中的情况），则重新循环这个过程。但是请注意，它只循环10次，如果10次过后，依照此算法依旧无法获取服务实例，则返回空。</p>
<p>我们再来看重试策略（RetryRule）的源码，如代码清单4-11所示。</p>
<p>代码清单4-11 RetryRule的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line">   <span class="comment">// 默认的重试子策略</span></span><br><span class="line">   <span class="type">IRule</span> <span class="variable">subRule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line">   <span class="comment">// 最大尝试时间戳为500 ms</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">maxRetryMillis</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">   .......</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 其中的一个构造方法允许我们设置子策略和超时时间</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">RetryRule</span><span class="params">(IRule subRule, <span class="type">long</span> maxRetryMillis)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.subRule = (subRule != <span class="literal">null</span>) ? subRule : <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line">      <span class="built_in">this</span>.maxRetryMillis = (maxRetryMillis &gt; <span class="number">0</span>) ? maxRetryMillis : <span class="number">500</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">requestTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// 重试截止时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> requestTime + maxRetryMillis;</span><br><span class="line">      <span class="type">Server</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 重试子策略获取服务实例</span></span><br><span class="line">      answer = subRule.choose(key);</span><br><span class="line">      <span class="comment">// 获取服务实例为null或者不再可用，并且时间小于重试截止时间</span></span><br><span class="line">      <span class="keyword">if</span> (((answer == <span class="literal">null</span>) || (!answer.isAlive()))</span><br><span class="line">            &amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">         <span class="comment">// 设置线程任务终止时间</span></span><br><span class="line">         <span class="type">InterruptTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptTask</span>(deadline</span><br><span class="line">               - System.currentTimeMillis());</span><br><span class="line">         <span class="comment">// 在线程终止前循环尝试获取可用服务实例</span></span><br><span class="line">         <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            answer = subRule.choose(key);<span class="comment">// 通过子策略获取</span></span><br><span class="line">            <span class="keyword">if</span> (((answer == <span class="literal">null</span>) || (!answer.isAlive()))</span><br><span class="line">                  &amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">               <span class="comment">/* pause and retry hoping it&#x27;s transient */</span></span><br><span class="line">               Thread.yield();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取可用服务实例</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 退出线程任务</span></span><br><span class="line">         task.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果通过上面的步骤依旧没有找到服务实例或者服务实例不可用，则返回null</span></span><br><span class="line">      <span class="keyword">if</span> ((answer == <span class="literal">null</span>) || (!answer.isAlive())) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//成功返回</span></span><br><span class="line">         <span class="keyword">return</span> answer;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在代码中加入了中文注释，从代码中可以知道，在默认的情况下，默认子重试策略依旧为轮询，而超时时间为500ms，这两个参数可以通过其中的一个构造方法改变。所以这个方法是在一个时间戳（默认为500ms）内，使用某种策略（默认为轮询）进行选取，直至可以选择一个可用的服务实例或者超时返回null。</p>
<p>按响应时间权重加权轮询（WeightedResponseTimeRule），是通过一个后台线程来统计分析各个服务的响应时间。先看一下这个线程的情况，它也是在WeightedResponseTimeRule类中定义的，如代码清单4-12所示。</p>
<p>代码清单4-12 WeightedResponseTimeRule类计算权重线程的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightedResponseTimeRule</span> <span class="keyword">extends</span> <span class="title class_">RoundRobinRule</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 默认时间间隔（30秒）</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_TIMER_INTERVAL</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverWeightTaskTimerInterval</span> <span class="operator">=</span> DEFAULT_TIMER_INTERVAL;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置负载均衡器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.setLoadBalancer(lb);</span><br><span class="line">      <span class="keyword">if</span> (lb <span class="keyword">instanceof</span> BaseLoadBalancer) &#123;</span><br><span class="line">         name = ((BaseLoadBalancer) lb).getName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      initialize(lb);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化方法</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ILoadBalancer lb)</span> &#123;        </span><br><span class="line">      <span class="keyword">if</span> (serverWeightTimer != <span class="literal">null</span>) &#123;</span><br><span class="line">         serverWeightTimer.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      serverWeightTimer = <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;NFLoadBalancer-serverWeightTimer-&quot;</span></span><br><span class="line">            + name, <span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 创建计算权重的线程，并且设置时间间隔（默认为30秒）</span></span><br><span class="line">      serverWeightTimer.schedule(<span class="keyword">new</span> <span class="title class_">DynamicServerWeightTask</span>(), <span class="number">0</span>,</span><br><span class="line">            serverWeightTaskTimerInterval);</span><br><span class="line">      <span class="comment">// do a initial run</span></span><br><span class="line">      <span class="type">ServerWeight</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerWeight</span>();</span><br><span class="line">      sw.maintainWeights();</span><br><span class="line">      <span class="comment">// 在服务器退出时终止计算权重线程</span></span><br><span class="line">      Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Stopping NFLoadBalancer-serverWeightTimer-&quot;</span> + name);</span><br><span class="line">            serverWeightTimer.cancel();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">DynamicServerWeightTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ServerWeight</span> <span class="variable">serverWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerWeight</span>();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 统计各个服务权重</span></span><br><span class="line">            serverWeight.maintainWeights();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error running DynamicServerWeightTask for &#123;&#125;&quot;</span>, name, e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，在权重计算中，它首先定义了默认的时间间隔（30秒）。然后在初始化负载均衡器的时候，调用initialize方法启动了线程任务。最后在initialize方法中，使得任务按时间间隔（默认30秒）启动线程类DynamicServerWeightTask的run方法，通过调用类ServerWeight的maintainWeights方法计算权重值。</p>
<p>上面我们谈到了ServerWeight类的maintainWeights方法，它是计算权重的方法，下面我们研究一下它的源码，它也是放在WeightedResponseTimeRule类里的，如代码清单4-13所示。</p>
<p>代码清单4-13 WeightedResponseTimeRule类计算权重线程的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServerWeight</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maintainWeights</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 负载均衡器</span></span><br><span class="line">      <span class="type">ILoadBalancer</span> <span class="variable">lb</span> <span class="operator">=</span> getLoadBalancer();</span><br><span class="line">      <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断有没有被其他线程更改过，如果有，则放弃本次计算</span></span><br><span class="line">      <span class="keyword">if</span> (!serverWeightAssignmentInProgress.compareAndSet(<span class="literal">false</span>,  <span class="literal">true</span>))  &#123;</span><br><span class="line">         <span class="keyword">return</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         logger.info(<span class="string">&quot;Weight adjusting job started&quot;</span>);</span><br><span class="line">         <span class="comment">// 获取统计分析</span></span><br><span class="line">         <span class="type">AbstractLoadBalancer</span> <span class="variable">nlb</span> <span class="operator">=</span> (AbstractLoadBalancer) lb;</span><br><span class="line">         <span class="type">LoadBalancerStats</span> <span class="variable">stats</span> <span class="operator">=</span> nlb.getLoadBalancerStats();</span><br><span class="line">         <span class="comment">// 如果没有统计分析对象，则返回</span></span><br><span class="line">         <span class="keyword">if</span> (stats == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no statistics, nothing to do</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 总平均响应时间</span></span><br><span class="line">         <span class="type">double</span> <span class="variable">totalResponseTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            <span class="comment">// 如果服务实例不在缓存快照里，则自动加载它的统计数据</span></span><br><span class="line">            <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">            <span class="comment">// 总平均响应时间=各个服务实例的平均响应时间总和</span></span><br><span class="line">            totalResponseTime += ss.getResponseTimeAvg();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 计算每一个服务实例的权重</span></span><br><span class="line">         <span class="comment">// 公式：weightSoFar + totalResponseTime-服务实例平均响应时间</span></span><br><span class="line">         <span class="type">Double</span> <span class="variable">weightSoFar</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">         <span class="comment">// 重新设置权重 </span></span><br><span class="line">         List&lt;Double&gt; finalWeights = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">         <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">            <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">            weightSoFar += weight;</span><br><span class="line">            finalWeights.add(weightSoFar);   </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 重新设置权重 </span></span><br><span class="line">         setWeights(finalWeights);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.error(<span class="string">&quot;Error calculating server weights&quot;</span>, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 回写状态让新的线程可以重新获得访问锁 </span></span><br><span class="line">         serverWeightAssignmentInProgress.set(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，maintainWeights方法是在线程安全的情况下进行的，它主要有以下两个步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●通过服务的统计分析（LoadBalancerStats）对象得到各个服务的平均统计时间，然后计算各个服务实例的平均响应时间总和（totalResponseTime），用于后续的算法。</span><br><span class="line">●计算权重，使用公式“至今为止的权重+总平均响应时间-服务平均响应时间”进行计算，其中“至今为止的权重”也是一个累计的权重，它是一个个服务调用平均响应时间的累计。</span><br></pre></td></tr></table></figure>
<p>这个算法还是比较抽象的，为了更好地进行说明，我们接下来举个例子。现在一个微服务有5个实例，A、B、C、D和E，它们的平均响应时间分别为10、20、30、40和50，它们的总平均响应时间为150。按照公式“至今为止的权重+总平均响应时间-服务平均响应时间”进行计算，它们的权重分别为：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实例A：0+(150-10)=140</span><br><span class="line">实例B：140+(150-20)=270</span><br><span class="line">实例C：270+(150-30)=390</span><br><span class="line">实例D：390+(150-40)=500</span><br><span class="line">实例E：500+(150-50)=600</span><br></pre></td></tr></table></figure>
<p>这些权重值会被保存到代码中的数组里，这样各个服务实例就有了对应的权重。但是并不是权重数字越大的服务实例被选中的概率就越高，被选中的概率是根据区间来的。这里所说的区间是一个数学概念，例如，区间(100, 200]表示的范围是100到200之间的数字，符号“(”表示开区间，意为不包含100；而符号“]”表示闭区间，意为包含200。下面我们用区间来表示实例A、B、C、D和E的取值范围：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实例A：[0, 140]</span><br><span class="line">实例B：(140, 270]</span><br><span class="line">实例C：(270, 390]</span><br><span class="line">实例D：(390, 500]</span><br><span class="line">实例E：(500, 600)</span><br></pre></td></tr></table></figure>
<p>显然所有服务实例的权重都在区间[0, 600]的范围之内。此时，如果以600为最大值，那么要先产生一个随机数random=Math.random()，这个random的取值区间为(0, 1)，然后将它乘以600，如dbl=random*600，这样dbl的取值就是(0,600)。因为现实中往往需要进行舍去小数的操作，所以在计算的时候dbl的取值区间实际往往就是[0, 600)。而dbl会落到各个实例区间的概率则取决于实例区间的跨度，很明显，各个区间跨度的比较结果为：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例A&gt;实例B&gt;实例C&gt;实例D&gt;实例E</span><br></pre></td></tr></table></figure>
<p>显然，平均响应时间越短，被选中的概率就越大；反之，响应时间越长被选中的概率就越低。但是请大家注意，实例的第一个区间都是左右闭的，而第二个到倒数第二个都是左开右闭的，最后一个则是左右开的，这些是需要一定的算法来保证的。为此，我们需要继续研究WeightedResponseTimeRule类关于选择服务器的负载均衡策略的代码，如代码清单4-14。</p>
<p>代码清单4-14 WeightedResponseTimeRule类负载均衡策略的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@edu</span>.umd.cs.findbugs.annotations.SuppressWarnings(value = <span class="string">&quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123; <span class="comment">// 负载均衡器为null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 循环</span></span><br><span class="line">   <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取权重数组</span></span><br><span class="line">      List&lt;Double&gt; currentWeights = accumulatedWeights;</span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">      <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line">      <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">serverIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 获取最大的权重值，如果没有权重数组，则为0</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">maxTotalWeight</span> <span class="operator">=</span> currentWeights.size() == <span class="number">0</span> ? </span><br><span class="line">            <span class="number">0</span> : currentWeights.get(currentWeights.size() - <span class="number">1</span>); </span><br><span class="line">      <span class="comment">// 如果没有发生过请求或者权重数组没初始化，使用BaseLoadBalancer策略选择服务实例</span></span><br><span class="line">      <span class="keyword">if</span> (maxTotalWeight &lt; <span class="number">0.001d</span> || serverCount != currentWeights.size()) &#123;</span><br><span class="line">         server =  <span class="built_in">super</span>.choose(getLoadBalancer(), key);</span><br><span class="line">         <span class="keyword">if</span>(server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> server;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 产生一个随机数，取值区间为[0,最大权重值)</span></span><br><span class="line">         <span class="type">double</span> <span class="variable">randomWeight</span> <span class="operator">=</span> random.nextDouble() * maxTotalWeight;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (Double d : currentWeights) &#123;</span><br><span class="line">            <span class="comment">// 判断权重和随机数的关系，获取服务实例下标</span></span><br><span class="line">            <span class="keyword">if</span> (d &gt;= randomWeight) &#123;</span><br><span class="line">               serverIndex = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               n++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取服务实例 </span></span><br><span class="line">         server = allList.get(serverIndex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123; <span class="comment">// 判定服务实例是否被选取</span></span><br><span class="line">         <span class="comment">/* Transient. */</span></span><br><span class="line">         Thread.yield();</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (server.isAlive()) &#123; <span class="comment">// 服务实例存活，返回</span></span><br><span class="line">         <span class="keyword">return</span> (server);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无效服务实例，继续循环</span></span><br><span class="line">      server = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中首先判断：最大权重值是否小于0.001，或者权重数组长度与服务实例长度是否相等。这样就能在权重数组没有初始化的情况下，进行父负载均衡器的轮询策略。如果权重数组是有效的，就生成随机数，跟着循环权重数组，判断随机数落入哪个区间，进而选择对应的服务实例。最后判断服务的有效性，如果有效则返回，否则就继续循环查找可用服务。</p>
<p>最后，我们讨论ZoneAvoidanceRule，它是一种先过滤后执行的策略。打开它的源码时，你很快就会发现它并没有choose方法，那是因为它的实现在其父类PredicateBasedRule中，不过我们可以在其源码中看到这样的代码片段，如代码清单4-15所示。</p>
<p>代码清单4-15 ZoneAvoidanceRule的组合过滤断言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZoneAvoidanceRule</span> <span class="keyword">extends</span> <span class="title class_">PredicateBasedRule</span> &#123;</span><br><span class="line">   <span class="comment">// 随机数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">   <span class="comment">// 组合断言过滤</span></span><br><span class="line">   <span class="keyword">private</span> CompositePredicate compositePredicate;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ZoneAvoidanceRule</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="comment">// Zone断言过滤，它会找出性能最差的Zone，然后进行过滤</span></span><br><span class="line">      <span class="type">ZoneAvoidancePredicate</span> <span class="variable">zonePredicate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZoneAvoidancePredicate</span>(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">// 可用性断言过滤，它会排除熔断或者流量过大的服务</span></span><br><span class="line">      <span class="type">AvailabilityPredicate</span> <span class="variable">availabilityPredicate</span></span><br><span class="line">         <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AvailabilityPredicate</span>(<span class="built_in">this</span>);</span><br><span class="line">      compositePredicate = createCompositePredicate(zonePredicate, </span><br><span class="line">            availabilityPredicate);</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 返回组合过滤断言</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> AbstractServerPredicate <span class="title function_">getPredicate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> compositePredicate;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里的代码中可以看到，它首先创建了两个过滤断言（Predicate），一个是Zone断言（ZoneAvoidancePredicate），另一个是可用性断言（AvailabilityPredicate）。然后，将它们组合起来形成组合过滤断言（CompositePredicate）。鉴于篇幅，关于ZoneAvoidancePredicate和AvailabilityPredicate的源码，这里就不讨论了，只做简单的功能论述。ZoneAvoidancePredicate的作用是找到那些性能较差的Zone，然后将其排除在外，随机选择性能较好的Zone。AvailabilityPredicate的作用是确定服务是否被熔断或者负载过大，超过临界值，如果没有这样的情况则返回该服务。CompositePredicate的作用是组合ZoneAvoidancePredicate和AvailabilityPredicate，先使用ZoneAvoidancePredicate进行过滤，然后再使用AvailabilityPredicate进行过滤，这样就能得到性能较高的可用服务了。接下来，研究ZoneAvoidanceRule的父类PredicateBasedRule的choose方法，如代码清单4-16所示。</p>
<p>代码清单4-16 WeightedResponseTimeRule的过滤组合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PredicateBasedRule</span></span><br><span class="line">          <span class="keyword">extends</span> <span class="title class_">ClientConfigEnabledRoundRobinRule</span> &#123;</span><br><span class="line">   <span class="comment">// 获取过滤断言</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title function_">getPredicate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 选择服务</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">ILoadBalancer</span> <span class="variable">lb</span> <span class="operator">=</span> getLoadBalancer();</span><br><span class="line">      <span class="comment">// 使用过滤断言先过滤服务实例，然后再选择可用性能较好的服务实例</span></span><br><span class="line">      Optional&lt;Server&gt; server = getPredicate()</span><br><span class="line">            .chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">      <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">         <span class="keyword">return</span> server.get();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的getPredicate方法已经在ZoneAvoidanceRule类中实现，它将返回组合过滤断言；choose方法使用组合过滤先过滤服务实例，然后才选择Zone和性能较好的服务实例。</p>
<p>以上就是各种负载均衡策略，使用者应该结合实际的情况进行合理的选择。</p>
<h3 id="4-4-Ribbon服务实例清单维护"><a href="#4-4-Ribbon服务实例清单维护" class="headerlink" title="4.4 Ribbon服务实例清单维护"></a>4.4 Ribbon服务实例清单维护</h3><p>前面我们讨论了负载均衡的各类问题，但是负载均衡的前提是存在可供选择的服务实例清单。在代码清单4-6中我们可以看到，负载均衡器（ILoadBalancer）的定义中存在很多关于服务实例清单维护的方法，这些维护服务器清单的方法的实现都在BaseLoadBalancer类或者NoOpLoadBalancer类中，只是NoOpLoadBalancer是空实现，目前没有讨论的价值，所以我们这里只讨论BaseLoadBalancer类的方法，如代码清单4-17所示。</p>
<p>代码清单4-17 BaseLoadBalancer类维护服务实例清单的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有服务实例清单</span></span><br><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br><span class="line"><span class="comment">// 可用服务实例清单</span></span><br><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br><span class="line"><span class="comment">// 增加服务实例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (newServers != <span class="literal">null</span> &amp;&amp; newServers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ArrayList&lt;Server&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;();</span><br><span class="line">         newList.addAll(allServerList);</span><br><span class="line">         newList.addAll(newServers);</span><br><span class="line">         setServersList(newList);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.error(<span class="string">&quot;LoadBalancer [&#123;&#125;]: Exception while adding Servers&quot;</span>,</span><br><span class="line">            name, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务实例下线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="literal">null</span> || !server.isAlive()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   logger.error(<span class="string">&quot;LoadBalancer [&#123;&#125;]:  markServerDown called on [&#123;&#125;]&quot;</span>, </span><br><span class="line">      name, server.getId());</span><br><span class="line">   server.setAlive(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">// forceQuickPing();</span></span><br><span class="line">   notifyServerStatusChangeListener(singleton(server));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取可用服务实例清单</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有服务实例清单</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，对于服务实例清单的管理分为两份：一份是所有服务实例清单（allServerList），另一份是可用服务实例清单（upServerList）。而代码中的方法都是维护服务实例清单的，没有动态的维护逻辑，那么它是如何动态维护服务器清单的呢？这是本节需要探索的问题。</p>
<p>让我们再次回到图4-3，可以看出，BaseLoadBalancer存在一个子类DynamicServerListLoadBalancer，从其类名中的Dynamic、Server、List单词可以知道，它是维护动态服务实例清单（ServerList）的。类DynamicServerListLoadBalancer中updateListOfServers方法和updateAllServerList方法，是用来维护可用服务实例清单和所有服务实例清单的。</p>
<h4 id="4-4-1-获取服务实例清单"><a href="#4-4-1-获取服务实例清单" class="headerlink" title="4.4.1 获取服务实例清单"></a>4.4.1 获取服务实例清单</h4><p>在4.2.1节中，我们讨论过，服务实例清单是通过ServerList\<T extends Server>实现的，这里先看一下它的源码，如代码清单4-18所示。</p>
<p>代码清单4-18 ServerList接口的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServerList</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; &#123;</span><br><span class="line">   <span class="comment">// 获取初始化服务实例清单</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getInitialListOfServers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取更新后的服务实例清单</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getUpdatedListOfServers</span><span class="params">()</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，Ribbon也提供了关于ServerList的一系列实现类，如图4-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161020293.png" alt="image-20231016102017242"></p>
<p>那么在默认的情况下，Ribbon会采用哪个类作为默认的实现类呢？答案是DiscoveryEnabled NIWSServerList，关于这些可以看EurekaRibbonClientConfiguration中的自动生成代码，如代码清单4-19所示。</p>
<p>代码清单4-19 EurekaRibbonClientConfiguration的ribbonServerList方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config, </span><br><span class="line">      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">   <span class="comment">// 如果客户端自定义了，就采用客户端自定义的生成对象</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ServerList.class,</span><br><span class="line">         config, serviceId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 采用服务发现创建ServerList对象</span></span><br><span class="line">   <span class="type">DiscoveryEnabledNIWSServerList</span> <span class="variable">discoveryServerList</span> </span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscoveryEnabledNIWSServerList</span>(config, eurekaClientProvider);</span><br><span class="line">   <span class="type">DomainExtractingServerList</span> <span class="variable">serverList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DomainExtractingServerList</span>(</span><br><span class="line">         discoveryServerList, config, <span class="built_in">this</span>.approximateZoneFromHostname);</span><br><span class="line">   <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以知道，如果没有客户端自定义，就采用DiscoveryEnabledNIWSServerList作为ServerList的默认实现。从命名看，它的功能就是从Eureka服务器上获取服务实例清单，所以这里我们探索一下DiscoveryEnabledNIWSServerList的源码，如代码清单4-20所示。</p>
<p>代码清单4-20 DiscoveryEnabledNIWSServerList的源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title function_">getInitialListOfServers</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title function_">getUpdatedListOfServers</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="title function_">obtainServersViaDiscovery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList </span><br><span class="line">       = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">   <span class="comment">// 服务提供者为null或者不存在则返回空清单</span></span><br><span class="line">    <span class="keyword">if</span> (eurekaClientProvider == <span class="literal">null</span> || eurekaClientProvider.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;EurekaClient has not been initialized yet, &quot;</span></span><br><span class="line">            +<span class="string">&quot;returning an empty list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取服务提供者的服务实例客户端</span></span><br><span class="line">    <span class="type">EurekaClient</span> <span class="variable">eurekaClient</span> <span class="operator">=</span> eurekaClientProvider.get();</span><br><span class="line">    <span class="comment">// vipAddresses是一个微服务名称，如第3章种的“user”代表用户微服务</span></span><br><span class="line">    <span class="keyword">if</span> (vipAddresses!=<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 多个虚拟地址处理</span></span><br><span class="line">        <span class="keyword">for</span> (String vipAddress : vipAddresses.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果Region为空，则所有客户端都解析为同一区域（Region）</span></span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient</span><br><span class="line">               .getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo ii : listOfInstanceInfo) &#123; <span class="comment">// 循环服务实例信息</span></span><br><span class="line">                <span class="keyword">if</span> (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(shouldUseOverridePort)&#123; <span class="comment">//是否需要重写端口</span></span><br><span class="line">                        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">                            logger.debug(<span class="string">&quot;Overriding port on client name: &quot;</span> </span><br><span class="line">                               + clientName + <span class="string">&quot; to &quot;</span> + overridePort);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 复制实例</span></span><br><span class="line">                        <span class="type">InstanceInfo</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceInfo</span>(ii);</span><br><span class="line">                        <span class="keyword">if</span>(isSecure)&#123; <span class="comment">//是否需要安全验证</span></span><br><span class="line">                            ii = <span class="keyword">new</span> <span class="title class_">InstanceInfo</span>.Builder(copy)</span><br><span class="line">                               .setSecurePort(overridePort).build();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 无须安全验证</span></span><br><span class="line">                            ii = <span class="keyword">new</span> <span class="title class_">InstanceInfo</span>.Builder(copy)</span><br><span class="line">                               .setPort(overridePort).build();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 目标服务发现</span></span><br><span class="line">                    <span class="type">DiscoveryEnabledServer</span> <span class="variable">des</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscoveryEnabledServer</span>(</span><br><span class="line">                       ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    des.setZone(DiscoveryClient.getZone(ii));<span class="comment">// 设置Zone</span></span><br><span class="line">                    serverList.add(des); <span class="comment">// 加入服务实例清单</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果服务实例清单不为空，且有基于VIP地址服务器的优先级排序，则中断循环</span></span><br><span class="line">            <span class="keyword">if</span> (serverList.size()&gt;<span class="number">0</span> &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverList; <span class="comment">// 返回服务实例清单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里类DiscoveryEnabledNIWSServerList实现了ServerList接口的两个方法，它们都调用了obtainServersViaDiscovery方法，所以obtainServersViaDiscovery方法就是关注的焦点。在obtainServersViaDiscovery方法中，首先是调用服务提供者客户端来获取对应的服务提供者的信息，如果一切验证都通过了，就复制一个信息。然后创建DiscoveryEnabledServer对象，放入服务实例清单里。最后判断，如果没有基于VIP地址服务器的优先级排序，就返回服务实例清单。这里显然是通过EurekaServer来获取服务实例清单的。</p>
<h4 id="4-4-2-更新服务实例清单"><a href="#4-4-2-更新服务实例清单" class="headerlink" title="4.4.2 更新服务实例清单"></a>4.4.2 更新服务实例清单</h4><p>任何实例都可能存在开发者主动的上下线行为，或者一些网络故障以及自身硬件的意外导致实例处于不同的状态，所以服务实例清单也是处于一个不断变化的过程。为了维护这个清单，Netflix提供了ServerListUpdater接口，通过它可以及时更新服务实例清单。在Netflix的设计中有两个ServerListUpdater接口的实现类，分别是EurekaNotificationServerListUpdater和PollingServerListUpdater，如图4-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161023818.png" alt="image-20231016102323756"></p>
<p>在默认的情况下，Spring Cloud会选择初始化PollingServerListUpdater，通过它创建一个线程来完成更新服务实例清单的任务。让我们看看它的start方法，如代码清单4-21所示。</p>
<p>代码清单4-21 PollingServerListUpdater定时更新服务器清单任务代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> UpdateAction updateAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isActive.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="comment">// 当前实例存活状态是否发生变化</span></span><br><span class="line">       <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">wrapperRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="comment">// 如果不再存活</span></span><br><span class="line">                <span class="keyword">if</span> (!isActive.get()) &#123;</span><br><span class="line">                   <span class="comment">// 退出线程任务</span></span><br><span class="line">                    <span class="keyword">if</span> (scheduledFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">                        scheduledFuture.cancel(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">// 如果当前实例存活，执行更新逻辑</span></span><br><span class="line">                    updateAction.doUpdate();</span><br><span class="line">                    lastUpdated = System.currentTimeMillis();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Failed one update cycle&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      <span class="comment">// 执行线程任务</span></span><br><span class="line">        scheduledFuture = getRefreshExecutor().scheduleWithFixedDelay(</span><br><span class="line">            wrapperRunnable, <span class="comment">// 线程</span></span><br><span class="line">            initialDelayMs, <span class="comment">// 开始延迟执行时间，默认值为1秒</span></span><br><span class="line">            refreshIntervalMs, <span class="comment">// 刷新时间间隔，默认值为30秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS <span class="comment">// 单位毫秒</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Already active, no-op&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，在start方法中，它首先判断当前实例存活状态是否发生变化，如果不再存活，则退出线程任务；如果存活，则执行更新服务列表的操作。这里它先创建线程，然后启动线程池来驱动任务，只是它设置了两个时间参数，一个是任务延迟执行时间，另一个是执行任务时间间隔。这里的任务延迟时间不允许我们进行配置。执行任务时间间隔允许我们配置，它的默认值为30秒，如果需要改变它，只需要修改配置项\<service-name>.ribbon.ServerListRefreshInterval即可。</p>
<h4 id="4-4-3-服务实例的心跳监测"><a href="#4-4-3-服务实例的心跳监测" class="headerlink" title="4.4.3 服务实例的心跳监测"></a>4.4.3 服务实例的心跳监测</h4><p>在Ribbon中，维护服务实例清单中，一个实例是否可用，是通过一个线程任务来判断的，该线程任务通过心跳测试来判断实例是否继续可用。在BaseLoadBalancer中，我们还可以看到这样的定时任务线程代码，如代码清单4-22所示。</p>
<p>代码清单4-22 BaseLoadBalancer维护服务器清单定时任务的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">pingIntervalSeconds</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 定时任务时间间隔</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">maxTotalPingTimeSeconds</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 每次ping超时时间</span></span><br><span class="line">...... </span><br><span class="line"><span class="comment">// 创建定时任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setupPingTask</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (lbTimer != <span class="literal">null</span>) &#123;</span><br><span class="line">      lbTimer.cancel();</span><br><span class="line">   &#125;</span><br><span class="line">   lbTimer = <span class="keyword">new</span> <span class="title class_">ShutdownEnabledTimer</span>(<span class="string">&quot;NFLoadBalancer-PingTimer-&quot;</span> </span><br><span class="line">      + name, <span class="literal">true</span>);</span><br><span class="line">   <span class="comment">// 创建定时任务，每隔pingIntervalSeconds（默认10秒）秒执行一次</span></span><br><span class="line">   lbTimer.schedule(<span class="keyword">new</span> <span class="title class_">PingTask</span>(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">   forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，它会使用一个定时任务来ping服务器，这个任务是每隔pingIntervalSeconds秒执行一次，这样Eureka的客户端就可以得到最新服务的状态了。而这里的定时任务的执行内容是通过PingTask类来实现的，下面来看看它的源码，如代码清单4-23所示。</p>
<p>代码清单4-23 BaseLoadBalancer内部类PingTask的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时任务逻辑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PingTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// 使用心跳策略来监控服务</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Pinger</span>(pingStrategy).runPinger();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.error(<span class="string">&quot;LoadBalancer [&#123;&#125;]: Error pinging&quot;</span>, name, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pinger</span> &#123;</span><br><span class="line">   <span class="comment">// Ping策略</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> IPingStrategy pingerStrategy;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runPinger</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ......</span><br><span class="line">         <span class="type">int</span> <span class="variable">numCandidates</span> <span class="operator">=</span> allServers.length;</span><br><span class="line">         <span class="comment">// 使用pingerStrategy判定服务器是否可用</span></span><br><span class="line">         results = pingerStrategy.pingServers(ping, allServers);</span><br><span class="line">         <span class="keyword">final</span> List&lt;Server&gt; newUpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;();</span><br><span class="line">         <span class="keyword">final</span> List&lt;Server&gt; changedServers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;();</span><br><span class="line">         <span class="comment">// 找出状态发生变化的server </span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCandidates; i++) &#123; </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isAlive</span> <span class="operator">=</span> results[i];</span><br><span class="line">            <span class="type">Server</span> <span class="variable">svr</span> <span class="operator">=</span> allServers[i];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">oldIsAlive</span> <span class="operator">=</span> svr.isAlive();</span><br><span class="line">            svr.setAlive(isAlive);</span><br><span class="line">            <span class="comment">// 状态发生变化，记录变化的server</span></span><br><span class="line">            <span class="keyword">if</span> (oldIsAlive != isAlive) &#123;</span><br><span class="line">               changedServers.add(svr);</span><br><span class="line">               logger.debug(<span class="string">&quot;LoadBalancer [&#123;&#125;]:  Server [&#123;&#125;] status &quot;</span> </span><br><span class="line">               + <span class="string">&quot;changed to &#123;&#125;&quot;</span>, name, svr.getId(), </span><br><span class="line">               (isAlive ? <span class="string">&quot;ALIVE&quot;</span> : <span class="string">&quot;DEAD&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isAlive) &#123;</span><br><span class="line">               newUpList.add(svr);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         ......</span><br><span class="line">         <span class="comment">// 通知监听者</span></span><br><span class="line">         notifyServerStatusChangeListener(changedServers);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         pingInProgress.set(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的逻辑在内部类Pinger的runPinger方法，它会使用IPingStrategy的pingServers方法来监测服务实例，返回监测结果，并且对比新旧清单的服务实例状态。如果状态发生变化，则记录下来，在最后给监听者发送消息，修改服务实例的状态。这里负责服务器状态的监测的主要是IPingStrategy接口，它的唯一实现类是BaseLoadBalancer中的内部类SerialPingStrategy，下面看看它的源码，如代码清单4-24所示。</p>
<p>代码清单4-24 BaseLoadBalancer内部类SerialPingStrategy的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SerialPingStrategy</span> <span class="keyword">implements</span> <span class="title class_">IPingStrategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span>[] pingServers(IPing ping, Server[] servers) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">numCandidates</span> <span class="operator">=</span> servers.length;</span><br><span class="line">      <span class="type">boolean</span>[] results = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCandidates];</span><br><span class="line">      logger.debug(<span class="string">&quot;LoadBalancer:  PingTask executing [&#123;&#125;]&quot;</span> </span><br><span class="line">           + <span class="string">&quot; servers configured&quot;</span>, numCandidates);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCandidates; i++) &#123;</span><br><span class="line">         results[i] = <span class="literal">false</span>; <span class="comment">/* Default answer is DEAD. */</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ping != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 交由IPing接口来监测服务的心跳 </span></span><br><span class="line">               results[i] = ping.isAlive(servers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Exception while pinging Server: &#x27;&#123;&#125;&#x27;&quot;</span>,</span><br><span class="line">               servers[i], e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> results;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法相对来说比较简单，可以看到，最后也是交由IPing接口来监控具体服务的心跳服务，于是焦点就转移到了IPing接口上。</p>
<h4 id="4-4-4-IPing接口"><a href="#4-4-4-IPing接口" class="headerlink" title="4.4.4 IPing接口"></a>4.4.4 IPing接口</h4><p>上述我们可以看到，具体执行心跳监测服务实例的是IPing接口，所以我们先来探索IPing的源码，如代码清单4-25所示。</p>
<p>代码清单4-25 IPing接口的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ribbon提供了几种基于这个接口的实现，如图4-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161026316.png" alt="image-20231016102643271"></p>
<p>在Spring Boot工程中，如果没有配置Eureka服务发现的客户端，则使用DummyPing，它将恒定返回true。如果配置了Eureka服务发现的客户端，则使用NIWSDiscoveryPing，它将通过和Eureka服务治理中心通信的机制来判定。其他的实现，NoOpPing是恒定返回true；PingConstant是设置一个布尔值（boolean），让isAlive方法恒定返回这个布尔值；PingUrl是通过配置具体的url请求来断定服务是否可用。经过论述，这里唯一值得探讨的是NIWSDiscoveryPing的源码，如代码清单4-26所示。</p>
<p>代码清单4-26 NIWSDiscoveryPing的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.niws.loadbalancer;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIWSDiscoveryPing</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerPing</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">BaseLoadBalancer</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NIWSDiscoveryPing</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="keyword">public</span> BaseLoadBalancer <span class="title function_">getLb</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> lb;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLb</span><span class="params">(BaseLoadBalancer lb)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.lb = lb;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isAlive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 如果是Eureka服务器的客户端，则使用Eureka服务发现实例进行监测 </span></span><br><span class="line">      <span class="keyword">if</span> (server!=<span class="literal">null</span> &amp;&amp; server <span class="keyword">instanceof</span> DiscoveryEnabledServer)&#123;</span><br><span class="line">         <span class="type">DiscoveryEnabledServer</span> <span class="variable">dServer</span> <span class="operator">=</span> (DiscoveryEnabledServer)server;</span><br><span class="line">         <span class="type">InstanceInfo</span> <span class="variable">instanceInfo</span> <span class="operator">=</span> dServer.getInstanceInfo();</span><br><span class="line">         <span class="keyword">if</span> (instanceInfo!=<span class="literal">null</span>)&#123;                    </span><br><span class="line">            <span class="type">InstanceStatus</span> <span class="variable">status</span> <span class="operator">=</span> instanceInfo.getStatus();</span><br><span class="line">            <span class="keyword">if</span> (status!=<span class="literal">null</span>)&#123;</span><br><span class="line">               isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isAlive;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(</span></span><br><span class="line"><span class="params">      IClientConfig clientConfig)</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，如果断定服务实例是Eureka服务发现的实例，就采用实例分析的办法进行监测服务实例是否可用。</p>
<h3 id="4-5-自定义Ribbon客户端"><a href="#4-5-自定义Ribbon客户端" class="headerlink" title="4.5 自定义Ribbon客户端"></a>4.5 自定义Ribbon客户端</h3><p>上述谈到了Ribbon的工作原理，应该说在大部分情况下都不需要自定义，只有少数的情况下需要我们进行自定义。在Ribbon中，既可以进行全局配置，也可以针对具体某个微服务进行单独配置。关于这些，本书将以第3章搭建的微服务进行说明。在第3章中，我们构建了3个微服务：用户（user）、产品（product）和资金（fund）。全局配置是指在服务消费者配置的内容对所有服务提供者有效。单独配置是指服务消费者可以配置对某个服务提供者有效，而对其他服务提供者无效。本节让我们来讨论这些问题。</p>
<p>这里再来看下4.2.1节中的表4-1，通过它我们就知道，Spring Cloud在默认的情况下是采取哪些类来使用Ribbon的。在大部分的情况下，我都不建议你修改它们，当然，如果你有特殊的需要，需要改变它们也是可行的，但是你必须掌握Ribbon的工作原理，并小心处理。</p>
<h4 id="4-5-1-全局配置"><a href="#4-5-1-全局配置" class="headerlink" title="4.5.1 全局配置"></a>4.5.1 全局配置</h4><p>其实定义一个全局的策略很简单，只需要类似Spring Bean那样处理就可以了。例如，下面我们修改ServerListFilter和负载均衡的策略，如代码清单4-27所示。</p>
<p>代码清单4-27 自定义全局Ribbon组件（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.config;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalConfiguration</span> &#123;</span><br><span class="line">   <span class="comment">// Bean Name和表4-1保持一致</span></span><br><span class="line">   <span class="comment">// 服务过滤器</span></span><br><span class="line">   <span class="meta">@Bean(name=&quot;ribbonServerListFilter&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ServerListFilter&lt;Server&gt; <span class="title function_">serverListFilter</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 使用优先选择的过滤器</span></span><br><span class="line">      <span class="type">ZonePreferenceServerListFilter</span> <span class="variable">filter</span> </span><br><span class="line">         <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZonePreferenceServerListFilter</span>();</span><br><span class="line">      <span class="comment">// 使用默认Zone</span></span><br><span class="line">      filter.setZone(EndpointUtils.DEFAULT_ZONE);</span><br><span class="line">      <span class="keyword">return</span> filter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 负载均衡策略</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> IRule <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 使用随机选择服务的策略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过类似这样的代码，就可以自定义表4-1中Ribbon使用的类。但是请注意，这里定义的是全局性的，也就是针对所有的微服务都有效，在我们的实例中，当产品微服务调用用户（user）微服务和资金（fund）微服务的时候，均会采用它们。</p>
<h4 id="4-5-2-局部定义"><a href="#4-5-2-局部定义" class="headerlink" title="4.5.2 局部定义"></a>4.5.2 局部定义</h4><p>代码清单4-27是对所有的微服务启用默认的策略，但是有时候我们只想对其中的某个微服务使用特殊的策略。例如，在第3章中，我们构建了3个微服务：用户（user）、产品（product）和资金（fund），只想在产品微服务调用资金微服务时执行特殊策略，那又要怎么处理呢？为此Ribbon提供了下面这些相关配置项。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">●<span class="language-xml"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span></span>.ribbon.NFLoadBalancerClassName：负载均衡类，需实现。ILoadBalancer接口。●<span class="language-xml"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span></span>.ribbon.NFLoadBalancerRuleClassName：负载均衡策略，需实现IRule接口。●<span class="language-xml"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span></span>.ribbon.NFLoadBalancerPingClassName：心跳监测类，需实现IPing接口。●<span class="language-xml"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span></span>.ribbon.NIWSServerListClassName：服务实例清单类，需实现ServerList接口。●<span class="language-xml"><span class="tag">&lt;<span class="name">clientName</span>&gt;</span></span>.ribbon.NIWSServerListFilterClassName：服务实例清单过滤类，需实现ServerListFilter接口。</span><br></pre></td></tr></table></figure>
<p>有了这些配置，我们就可以很容易地定义对应Ribbon的具体实现策略了。例如，我们定义资金微服务（FUND）调用的负载均衡策略为BestAvailableRule，IPing为PingUrl，如代码清单4-28所示。</p>
<p>代码清单4-28 自定义资金微服务（FUND）调用Ribbon组件策略（Product模块YAML配置文件）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FUND:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.BestAvailableRule</span></span><br><span class="line">    <span class="attr">NFLoadBalancerPingClassName:</span> <span class="string">com.netflix.loadbalancer.PingUrl</span></span><br></pre></td></tr></table></figure>
<p>这里请注意，代码清单4-27的优先级要比这些配置的高，因此在测试的时候，需要先注释掉代码清单4-27生成的两个Ribbon类，才能进行这段代码的测试。通过测试你可以发现，它已经在使用我们代码清单4-28的类了。</p>
<p>其实对于局部定义，Spring Cloud还提供了@RibbonClient和@RibbonClients。针对单个微服务配置类使用@RibbonClient，针对多个微服务配置使用@RibbonClients。它们大同小异，这里先讨论@RibbonClient。</p>
<p>这里需要注意的是，这两个注解的优先级没有代码清单4-27和代码清单4-28生成的对象高，因此在需要使用这两个注解的时候，要先注释掉代码清单4-27和代码清单4-28。我们在配置类GlobalConfiguration上加入注解@RibbonClient，如代码清单4-29所示。</p>
<p>代码清单4-29 使用@RibbonClient（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">// 这是一个不被程序入口扫描的配置类，否则它将对所有的Ribbon策略生效 </span></span><br><span class="line"><span class="keyword">import</span> com.spring.cloud.config.FundConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// name配置具体的客户端， configuration指向一个配置类FundConfiguration，</span></span><br><span class="line"><span class="comment">// 测试要求FundConfiguration标注@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name=&quot;FUND&quot;, configuration=FundConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个GlobalConfiguration类中，我删掉了原来全局的两个策略类，加入了@RibbonClient，并且配置了它的两个属性，其中name代表针对哪个微服务生效，configuration指向一个配置类FundConfiguration。这样这个配置类就可以配置针对资金微服务的组件策略了。此时为了完成代码清单4-28的功能，我们编写FundConfiguration配置类，如代码清单4-30所示。</p>
<p>代码清单4-30 FundConfiguration配置类（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：要求这个包不在Spring Boot主入口文件可扫描的范围内</span></span><br><span class="line"><span class="keyword">package</span> com.spring.cloud.config;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FundConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BestAvailableRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IPing <span class="title function_">ribbonPing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PingUrl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类不能放在Spring Boot主入口文件扫描的范围内，因为如果这个类是被扫描的，那么对应的配置策略就会对全局生效，且优先级大于@RibbonClient的方式，这是在使用的时候需要注意的地方。</p>
<p>但是@RibbonClient只能配置成对一个微服务有效，如果需要配置多个微服务，可以使用@RibbonClients。例如，类似下面的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(</span></span><br><span class="line"><span class="meta">    // 配置多个客户端</span></span><br><span class="line"><span class="meta">    value = &#123;</span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;FUND&quot;, configuration = FundConfiguration.class), </span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;USER&quot;, configuration = FundConfiguration.class),</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    // 默认配置类</span></span><br><span class="line"><span class="meta">    defaultConfiguration = FundConfiguration.class)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-Ribbon使用实践"><a href="#4-6-Ribbon使用实践" class="headerlink" title="4.6 Ribbon使用实践"></a>4.6 Ribbon使用实践</h3><p>上述我们讲解了Ribbon的原理和使用的一些类，这里我们讲解一些使用的实践。首先，Ribbon的本质是HTTP请求，对于这样的请求也许会成功，也许会失败或超时。所以在默认的情况下，Ribbon会进行重试，重试的配置项是spring.cloud.loadbalancer.retry.enabled，它的默认值为true。在默认的情况下，Ribbon是会为我们进行重试的，如果不需要重试，将配置项设置为false即可。关于重试，Ribbon还允许配置其他内容。下面我先给出代码，然后再说明，如代码清单4-31所示。</p>
<p>代码清单4-31 重试与超时的配置（Product模块YAML配置文件）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FUND:</span> <span class="comment"># 代表只对资金微服务执行这样的配置</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="comment"># 连接超时时间，单位毫秒</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">    <span class="comment"># 请求超时时间，单位毫秒</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">MaxTotalHttpConnections:</span> <span class="number">500</span></span><br><span class="line">    <span class="comment"># 每个服务提供者的最大连接数</span></span><br><span class="line">    <span class="attr">MaxConnectionsPerHost:</span> <span class="number">100</span></span><br><span class="line">    <span class="comment"># 是否所有操作都重试</span></span><br><span class="line">    <span class="attr">OkToRetryONAllOperations:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 同一实例的最大重试次数，不包括首次调用</span></span><br><span class="line">    <span class="attr">MaxAutoRetries :</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里的配置格式是\<service-id>.ribbon.xxxx，我在代码中给出了配置的含义，请读者自行参考。</p>
<p>在我们讲解服务获取的时候，知道它并不是实时的，也就是即使发布了一个新的实例，服务实例清单可能也不能实时得到它的注册信息。这样的情况会对第一次服务调用产生很大的麻烦，可能会产生超时错误，为了解决这样的问题，我们可以使用Ribbon的饥渴加载。例如，我们现在配置理财产品，对于资金和用户微服务执行饥渴加载，如代码清单4-32所示。</p>
<p>代码清单4-32 配置饥渴加载（Product模块YAML配置文件）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="comment"># 是否启动饥渴加载？默认值为false</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 饥渴加载的微服务ID</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">user,</span> <span class="string">product,</span> <span class="string">fund</span></span><br></pre></td></tr></table></figure>
<p>这样就可以让Ribbon及时加载，大大降低第一次调用超时的概率。</p>
<p>在Spring Cloud的机制下，我们注册到服务治理中心Eureka服务器，通过服务获取就可以得到服务列表。事实上，Ribbon也可以脱离Eureka服务器来使用，只是服务列表就需要自己配置了，如代码清单4-33所示。</p>
<p>代码清单4-33 使用自定义的服务列表（Product模块YAML配置文件）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FUND:</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">    <span class="comment"># 不使用Eureka服务获取机制</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 自配置服务器列表</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="string">http://localhost:7001,http://localhost:7002</span></span><br></pre></td></tr></table></figure>
<h2 id="第5章-断路器——Hystrix"><a href="#第5章-断路器——Hystrix" class="headerlink" title="第5章 断路器——Hystrix"></a>第5章 断路器——Hystrix</h2><p>Spring Cloud Netflix Hystrix是一种断路器组件，在本书中，如果没有特殊说明，就将其简称为Hystrix。其实在写本章之前，我一直很犹豫要不要写Hystrix，因为Netflix开源的限流组件Hystrix已经在其GitHub主页上宣布不再开发新功能了，只基于现有的功能进行维护。因此Spring Cloud社区推荐开发者使用其他仍然活跃的开源项目，其中最推荐使用的是Resilience4J，并且Spring Cloud社区也在加紧开发spring-cloud-circuitbreaker，来取代Hystrix。但这个项目还在开发中，并没有发布，加之当前不少企业也在使用Hystrix，并且技术是相通的，所以这里还是决定介绍一下Hystrix。</p>
<h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>Hystrix这个单词的中文翻译是一种豪猪，因其背上长满了刺而具有自我保护的能力，正好断路器的作用是在一些场景下保护微服务，因此Netflix公司将其命名为Hystrix。断路器使得微服务系统可以在一些糟糕的情况下，仍然尽量保证可用性，这如同豪猪的刺一样具有自我保护的功能。不过在介绍断路器之前，我们需要理解一些重要的场景，否则将难以理解为什么需要断路器。</p>
<h4 id="5-1-1-熔断的概念"><a href="#5-1-1-熔断的概念" class="headerlink" title="5.1.1 熔断的概念"></a>5.1.1 熔断的概念</h4><p>先看一下图5-1。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161040797.png" alt="image-20231016104013722"></p>
<p>首先，在T1时刻，因为大量的请求到达产品微服务，导致其服务响应变得异常缓慢，或者其自身出现宕机又或者是其他故障（如数据库、缓存出现问题），导致其不可用；在T2时刻，用户微服务会大量调用产品微服务，此时因为产品微服务故障，必然导致其大量线程等待，最终因为线程的等待而导致自身瘫痪；在T3时刻，资金微服务大量调用用户微服务，同样也会因为用户微服务瘫痪，导致资金微服务的线程也因为等待而瘫痪；依此类推，最终的结果就会导致所有微服务实例瘫痪，整个微服务系统彻底不可用。从上述分析中，我们可以看到，因为产品微服务不可用，会导致其他正常的服务调用线程的积压，引发其自身也不可用，而且还会蔓延到其他正常的服务上，最终导致所有服务不可用，这便是分布式常说的雪崩效应。</p>
<p>发生上述雪崩效应的原因是微服务的相互依赖，毕竟一笔业务往往涉及多个微服务的协作——我们把这样的情况称为服务依赖。从另一个角度看，因为产品微服务不可用，导致所有服务不可用也并不科学。例如，产品微服务不可用，并不影响用户微服务的用户信息管理功能，也不影响用户和资金微服务之间的账户管理功能，只是影响了产品购买和产品管理而已。倘若在这个时候隔离不可用的产品微服务，那么用户微服务和资金微服务的一些功能将依旧可用，不至于所有系统全部瘫痪，这便是断路器的魅力所在。</p>
<p>那我们为什么称这样的场景为熔断呢？其实这是借用了电力系统的概念，如图5-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161041340.png" alt="image-20231016104130282"></p>
<p>从图5-2可见，如果电力过大，这个时候保险丝就会熔断，从而隔离电路，保护用电用户的安全，这便是电力系统的熔断。这与我们的微服务系统中，某个服务因为请求过大或者出现故障，Hystrix将其从系统中断开，保护其他微服务不因调用它而导致自身瘫痪十分类似，所以人们就把这样的场景形象地比喻为熔断了。</p>
<p>上述只讨论了服务之间的熔断，事实上讨论得并不完全。之前讨论过，一个微服务可能有多个实例，但并不是每一个实例都会出现故障，可能只是某个实例出现故障，而另外一个却可以正常使用，如图5-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161041762.png" alt="image-20231016104153670"></p>
<p>图中产品微服务存在两个实例，只有其中的实例1不可用，而非整个产品微服务不可用。倘若此时外部实例（服务消费者）调用产品微服务（服务提供者），按照之前Ribbon那样采用轮询的方式，那么一旦轮询到实例1就必然会存在大量的异常导致请求失败。在Spring Cloud中，为了避免这样的情况，Eureka会通过服务续约机制探测到实例1不可用，从而将它从可用服务实例清单中剔除出去，使得外部实例调用不再路由到实例1，而是直接路由到实例2，从而避免出现大量异常的情况。然后，通过监控告知我们出现了实例1不可用的情况，让我们可以及时进行维护。这样虽然避免了大量的异常，但是这里实例1不可用就意味着服务能力下降，当并发请求增大时，产品微服务可能会因为实例减少，导致单个实例负荷过大进而瘫痪，所以对这样的场景是不可掉以轻心的。</p>
<h4 id="5-1-2-服务降级"><a href="#5-1-2-服务降级" class="headerlink" title="5.1.2 服务降级"></a>5.1.2 服务降级</h4><p>上面我们只是讨论了不可用的情况，而事实上还可能存在系统繁忙的情况，毕竟机器的服务能力也是有上限的。当我们在双十一使用支付宝抢购天猫商品的时候，经常会看到支付宝返回图5-4所示的信息。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161042827.png" alt="image-20231016104237769"></p>
<p>在一些极端的情况下，某些时刻请求数量会大大超过系统服务的可接受范围，这个时候就要考虑服务降级了。服务降级是分布式中的一个重要概念，这里我将对其进行解释。图5-4是一个请求支付的场景，正常来说，我们应该从账户扣款，然后去完成商品交易。但是这个过程会比较消耗服务器的资源和时间，在高并发的情况下，请求数可能会过大，超过服务器可接受的范围。此时，如果让请求等待，势必会积压请求导致服务器崩溃，而用户也会因长期得不到结果而失去耐性。但是，如果不再让请求进入支付场景，而是将请求直接路由到网络繁忙的结果上，得到一个静态页面，那么消耗的资源和耗时就会小得多。从服务器的角度看，这样就不会存在大量的积压请求，导致其瘫痪了；从用户的角度看，用户无须等待，只需要在被告知失败之后重试即可。这个场景流程如图5-5所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161043152.png" alt="image-20231016104341066"></p>
<p>​                                        图5-5 服务降级</p>
<p>图5-5中的降级服务，只是使用最简单的静态数据或者静态页面来反馈处理结果，但对于企业实际可能更为复杂。在一些电商处理的实际场景中，不同的场景下，降级服务也有不同的层级。例如，在一些电商网站的购买产品页，正常情况下，大家可以看到用户评论以及其他的一些广告，而实际上这些都不是购买商品所必需的内容。在抢购的场景下，电商平台可能就会因为系统繁忙而不再展示这些不必要的内容，仅展示那些关键的内容，这也是一种降级服务的体现。正如平常说的，考100分很难，做到90分也不错。因为产品是核心的内容，所以如果产品服务读取失败，就会影响到整个交易流程。因此，电商平台会通过降级服务将页面路由到失败的静态页面上，提示用户系统繁忙，稍后再试。这便是降级服务的层级问题，具体的降级服务层级需要结合企业的实际业务进行定夺。</p>
<h4 id="5-1-3-Hystrix的功能简介"><a href="#5-1-3-Hystrix的功能简介" class="headerlink" title="5.1.3 Hystrix的功能简介"></a>5.1.3 Hystrix的功能简介</h4><p>通过上面的描述，相信大家对微服务之间的一些常见故障和面临的超负荷问题有了更为清晰的理解。这里再引入Hystrix官方的简介来说明它主要的功能。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">●防止单个服务的故障导致其依赖和相关的服务容器（如Tomcat）的线程资源被耗尽。</span><br><span class="line">●减少负载，并提供请求快速失败的功能，而不是让请求进行排队。</span><br><span class="line">●尽可能提供服务降级的功能，以使用户免受故障影响。</span><br><span class="line">●使用隔离技术（如隔离板、泳道和断路器等）来限制某个服务出现问题所带来的影响。</span><br><span class="line">●尽可能提供实时监控信息，通过监控和警报来优化发现故障的时间。</span><br><span class="line">●允许使用配置修改相关参数（如超时时间等），并支持Hystrix大多数方面的动态属性更改，从而允许使用低延迟反馈循环进行实时操作修改。</span><br><span class="line">●对服务调用消费者内部的故障进行保护，而不仅仅是在网络流量上进行保护降级、限流。</span><br></pre></td></tr></table></figure>
<p>Hystrix底层的实现是RxJava，它是流形式的，采用的是观察者模式（Observer）实现的，后续会再讨论到它。不过，要使用Hystrix，需要先在项目中引入它，例如，在Maven中，可以像代码清单5-1这样引入。</p>
<p><strong>代码清单5-1 引入断路器Hystrix（Product模块）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-入门实例"><a href="#5-2-入门实例" class="headerlink" title="5.2 入门实例"></a>5.2 入门实例</h3><p>本节我们不再讨论概念，而是进行实践，看看如何简单地使用Hystrix来工作。首先需要驱动Hystrix工作，需要加入注解@EnableCircuitBreaker，从英文的含义就知道它是驱动断路器的。下面我们将在理财产品微服务入口上加入它，以启用断路器，如代码清单5-2所示。</p>
<p>代码清单5-2 驱动Hystrix（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages=&quot;com.spring.cloud.product&quot;)</span></span><br><span class="line"><span class="comment">// 驱动断路器</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductApplication</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@EnableCircuitBreaker便可以驱动断路器了，所以在使用上还是十分简单的。只是单单有它还不够，我们还需要服务提供者，这里我选用了用户微服务作为服务提供者，为此需要在用户微服务加入了新的控制器，如代码清单5-3所示。</p>
<p>代码清单5-3 定义用户模块的服务提供者（User模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.user.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hystrix&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixController</span> &#123;</span><br><span class="line">   <span class="comment">//最大休眠时间</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">MAX_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">5000L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 随机超时测试，触发服务消费者启用断路器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/timeout&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">timeout</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 产生一个小于5000的长整型随机数</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>) (MAX_SLEEP_TIME * Math.random());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 线程按一个随机数字休眠，使得服务消费者能够存在一定的概率产生熔断</span></span><br><span class="line">         Thread.sleep(sleepTime);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行异常&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>, <span class="string">&quot;执行时间&quot;</span> + sleepTime);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 异常测试，触发服务消费者启用断路</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/exp/&#123;msg&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(<span class="meta">@PathVariable(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;spring&quot;</span>.equals(msg)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>, msg);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 触发异常，让服务消费者启用熔断</span></span><br><span class="line">         <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;出现了异常，请检查参数msg是否为spring&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类标注了@RestController，当我们返回对象的时候，它会转变为JSON数据集。这里需要注意类里面的两个方法，一个是timeout方法，它会产生一个随机数，该随机数小于5000，然后让线程按这个随机数进行休眠；另外一个是exp方法，它会判断字符串是否为“spring”，如果不是则抛出异常。在启用断路器后，在默认的情况下，断路器默认的超时时间是1秒，换句话说，如果服务消费者在1秒内没能从服务提供者上得到数据，那么断路器就会熔断这次请求，转发到降级服务中。这里timeout方法是用来测试超时情况的。在消费服务的时候，有时服务提供者会抛出异常，发生错误，这里exp方法是用来测试服务提供者异常情况的，如果测试到异常，断路器就会熔断服务，跳转到降级方法中。到这里，我们的服务提供者用户微服务就开发好了，下面我们再通过理财产品微服务来调用它们，产生熔断的效果。</p>
<p>为了调用用户微服务提供内容，我们先新建一个接口，如代码清单5-4所示。</p>
<p>代码清单5-4 定义用户服务调用接口（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.facade;</span><br><span class="line"><span class="keyword">import</span> com.spring.cloud.common.vo.ResultMessage;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFacade</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">timeout</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口十分简单，就不解释了，对于接口命名这里采用了“Facade”，表示它不是传统的Service调用，而是外部微服务的调用。下面就来实现这个接口，如代码清单5-5所示。</p>
<p>代码清单5-5 使用用户服务调用（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.facade.impl;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">UserFacade</span> &#123;</span><br><span class="line">   <span class="comment">// 注入RestTemplate，在Ribbon中我们标注了@LoadBalance，用以实现负载均衡</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="comment">// @HystrixCommand将方法推给Hystrix进行监控</span></span><br><span class="line">   <span class="comment">// 配置项fallbackMethod指定了降级服务的方法</span></span><br><span class="line">   <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">timeout</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://USER/hystrix/timeout&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> restTemplate.getForObject(url, ResultMessage.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://USER/hystrix/exp/&#123;msg&#125;&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> restTemplate.getForObject(url, ResultMessage.class, msg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 降级方法1</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">fallback1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">false</span>, <span class="string">&quot;超时了&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 降级方法2，带有参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Param</span> msg -- 消息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Return</span> ResultMessage -- 结果消息 </span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">fallback2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">false</span>, <span class="string">&quot;调用产生异常了，参数:&quot;</span> + msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，我们也是采用Ribbon调用用户微服务来完成timeout和exp两个方法。但是所不同的是，方法上加入了注解@HystrixCommand。这个注解的意思是，把整个方法标注为一个Hystrix命令，这样就会通过Spring AOP将方法绑定成为一个Hystrix命令进行执行。@HystrixCommand的配置项fallbackMethod，表示当正常的服务无法按预想完成（如超时、异常、服务提供者繁忙等）时，跳转到的方法，这里我们把这个方法称为降级方法。</p>
<p>为了测试UserFacadeImpl类的方法，下面来看看断路器的工作。首先需要编写一个控制器，如代码清单5-6所示。</p>
<p>代码清单5-6 使用控制器测试熔断效果（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircuitBreakerController</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">UserFacade</span> <span class="variable">userFacade</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/cr/timeout&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">timeout</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> userFacade.timeout();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/cr/exp/&#123;msg&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(<span class="meta">@PathVariable(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> userFacade.exp(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法分别测试超时和异常的情况，相信也比较好理解，就不再赘述了。启动好我们的各个服务，就可以测试了。</p>
<p>先来测试超时的情况，在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/cr/timeout，就可以看到图5-6所示的结果了。">http://localhost:8001/cr/timeout，就可以看到图5-6所示的结果了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161728128.png" alt="image-20231016172855003"></p>
<p>从结果看，调用服务提供者（用户微服务）产生了超时，导致其进入了UserFacadeImpl的fallback1方法。而事实上，你可能得不到这个结果，因为这里服务提供者采用的是产生随机数的方式，存在一定的概率不超时（Hystrix默认的超时时间是1秒），不过不要紧，多刷新几次就能看到了。</p>
<p>跟着我们测试异常的调用，在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/cr/exp/spring，就可以看到图5-7所示的结果了。">http://localhost:8001/cr/exp/spring，就可以看到图5-7所示的结果了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161730532.png" alt="image-20231016173032475"></p>
<p>这里依据服务提供者（用户微服务）的规则，由于传入的是“spring”，不存在异常的情况，因此这里正常地显示了。接下来我们换一个地址进行请求，在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/cr/exp/boot，就可以看到图5-8所示的结果了">http://localhost:8001/cr/exp/boot，就可以看到图5-8所示的结果了</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161731783.png" alt="image-20231016173103727"></p>
<p>从图5-8中我们可以知道，调用服务提供者（用户微服务）产生了异常，导致其进入了UserFacadeImpl的fallback2方法，这就完成了异常的熔断功能。</p>
<p>至此，我们完成了超时熔断和异常熔断这两种重要的熔断功能，这两种熔断是我们实际开发中最常见的，所以请大家好好地掌握好它们。事实上，Hystrix还可以有其他的功能，如服务故障、线程池拒绝等，后续我们还会讨论。</p>
<h3 id="5-3-Hystrix工作原理"><a href="#5-3-Hystrix工作原理" class="headerlink" title="5.3 Hystrix工作原理"></a>5.3 Hystrix工作原理</h3><p>上节我们实现了最常见的降级功能。那么Hystrix是如何做到降级服务的呢？这就需要讨论执行到它的执行流程，这是Hystrix工作原理的核心内容，也是本章最重要的内容，图5-9是从官方说明文档上截取的Hystrix工作流程图。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161734928.png" alt="image-20231016173406828"></p>
<p>​                                    图5-9 Hystrix的工作流程</p>
<p>图5-9是Hystrix工作原理最重要的说明，也是本章的核心内容，所以这里会详细论述这个流程。论述会比较复杂，为了方便会分在多节里讨论，在讨论的过程中，大家需要多回来看看这个图，这会对学习Hystrix大有帮助。</p>
<h4 id="5-3-1-Hystrix命令"><a href="#5-3-1-Hystrix命令" class="headerlink" title="5.3.1 Hystrix命令"></a>5.3.1 Hystrix命令</h4><p>先看图5-9中的第①和第②步，可以看到存在两个对象，一个是HystrixCommand，另一个是HystrixObservableCommand，通过它们就可以封装一个Hystrix命令了。其中HystrixCommand是同步请求命令，HystrixObservableCommand是异步请求命令，它们俩使用的都是流的概念，它们的底层实现是RxJava。</p>
<p>这里Hystrix会把服务消费者的请求封装成一个HystrixCommand对象或者一个HystrixObservable Command对象，从而使你可以用不同的请求对客户进行参数化，这便是一种命令模式，能达到对“行为请求者”和“行为实现者”解耦的目的。例如，使用这样的代码：</p>
<h2 id="第6章-新断路器——Resilience4j"><a href="#第6章-新断路器——Resilience4j" class="headerlink" title="第6章 新断路器——Resilience4j"></a>第6章 新断路器——Resilience4j</h2><p>因为当前Netflix公司已经宣布，Netflix Hystrix项目不再新增功能和发布新版本，只修复现有功能的缺陷，所以Spring Cloud打算使用Resilience4j框架取代Netflix Hystrix，并通过Spring Boot的方式封装，使开发者用起来更简单，此项目名为spring-cloud-circuitbreaker。但是这个项目在创作本书时还没有开发完成，所以本章只能介绍Resilience4j这个工具。</p>
<p>Resilience4j是一个轻量级的、易于使用的容错框架，它是受Netflix的Hystrix的启发，基于Java 8和函数式编程设计的，所以在使用它的时候，可以看到大量的函数式编程设计。它与Hystrix相比有以下几个不同点。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">●Hystrix是将调用封装为Hystrix命令的形式，而Resilience4j是使用更为高级的函数式（装饰器）和Lambda表达式进行开发，符合当前函数式编程的潮流，并且将许多组件进行了分离。</span><br><span class="line">●在默认的情况下，Hystrix会将结果存储在10个1秒的时间窗桶里，当最旧的一个时间窗桶被废弃的时候，它会创建一个新的时间窗桶，然后删除旧的时间窗桶。Resilience4j则不是那样，它是将执行结果存储到一个环形位缓冲区（后文会解释这个概念）中，如果成功，则存储0，如果失败则存储1。环形位缓冲区是一个可以配置的具有固定长度的数组，该数据使用的是bit而非布尔值，因为bit比布尔值更节省内存，使用一个长度为16的数组便可以记录1024个请求的调用状态了。这样设计的优点是，对于那些高频率或者低频率请求的背压系统来说，断路器可以开箱即用，因为请求结果不会在请求执行过后被删除。</span><br><span class="line">●Hystrix的断路器在打开5秒后，就会自动修改为半打开（HALF<span class="emphasis">_OPEN）状态，此后只通过一次请求就能关闭断路器。而Resilience4j则不是，它可以通过配置修改请求的数量，还有请求结果的数量等与阈值的比较来确定断路器的开闭状态。</span></span><br><span class="line"><span class="emphasis">●Resilience4j提供定制的RxJava操作程序，可通过使用断路器、舱壁模式或限速器等来装饰任何可观察的（observable）或可流动的（flowable）对象，从而达到想要的效果。</span></span><br></pre></td></tr></table></figure>
<p>这里的难点是分析环形位缓冲区（ring bit buffer），这对理解Resilience4j还是比较重要的，所以这里先来介绍一下它的概念，如图6-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310161743881.png" alt="image-20231016174307812"></p>
<p>环形位缓冲区是一个数组，在默认的情况下，Resilience4j提供的是一个长度为16的长整型（Long）数组，因为一个长整型在内存中占位64位二进制数字，所以这个数组一共是64 × 16=1024位二进制数字，因此可以表达1024个调用结果的成功或者失败（使用0表示成功，使用1代表失败）。这个数组有读指针（head，它代表下一次读取的位置）和写指针（tail，它代表下一次写入的位置）来支持其读写，head等于tail代表数组为空，head=(tail+1) mod buffer.length代表数组满了。环形位缓冲区最重要的作用是提供无锁的读写操作，它读取数据时，只修改指针head，写入数据时只修改指针tail，这些都是基于CAS（Compare and Set）操作的，所以它是一个线程安全且高效的数据结构。</p>
<p>Resilience4j包含多个模块，开发者可以根据自己的需要加入依赖，不用全部加载，从这一点来说，它比Hystrix要灵活得多。Resilience4j提供的模块分为核心模块和附加模块。</p>
<p>核心模块有以下几个。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">●resilience4j-circuitbreaker：断路器。</span><br><span class="line">●resilience4j-ratelimiter：限速器。</span><br><span class="line">●resilience4j-bulkhead：舱壁模式。</span><br><span class="line">●resilience4j-retry：自动重试（同步和异步）。</span><br><span class="line">●resilience4j-cache：响应结果缓存。</span><br><span class="line">●resilience4j-timelimiter：超时处理。</span><br></pre></td></tr></table></figure>
<p>附加模块有以下几个。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">●resilience4j-reactor：Spring Reactor适配器。</span><br><span class="line">●resilience4j-rxjava2：RxJava2适配器。</span><br><span class="line">●resilience4j-micrometer：Micrometer度量输出。</span><br><span class="line">●resilience4j-metrics：Dropwizard度量输出。</span><br><span class="line">●resilience4j-prometheus：Prometheus度量输出。</span><br><span class="line">●resilience4j-spring-boot2：Spring Boot 2.x启动器。●resilience4j-ratpack：Ratpack启动器。</span><br><span class="line">●resilience4j-retrofit：Retrofit Call适配器工程。●resilience4j-vertx：Vertx Future装饰器。</span><br><span class="line">●resilience4j-consumer：环形位缓冲区事件消费者。</span><br></pre></td></tr></table></figure>
<p>本章只介绍核心模块和附加模块中的resilience4j-spring-boot2。不过在介绍它们之前，我们首先需要引入resilience4j，因此需要加入Maven依赖，如代码清单6-1所示。</p>
<p>代码清单6-1 引入Resilience4j（Product模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--resilience4j Spring Boot Starter依赖，</span></span><br><span class="line"><span class="comment">   它会依赖circuitbreaker、ratelimiter和consumer包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缓存模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ehcache缓存包，它是一个JCache规范的实现--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 重试模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 舱壁模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 超时限制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里请大家注意，resilience4j-spring-boot2这个依赖包存在两方面的问题：一方面，它并不会依赖所有的核心模块，所以还需要后续的依赖引入；另一方面，数字“2”代表它只能支持Spring Boot 2.x的版本，如果需要支持Spring Boot 1.x版本，则需要依赖resilience4j-spring-boot。关于resilience4j-spring-boot这个包，本书就不再介绍了，感兴趣的读者可以在学习完本章后自行研究。代码中还依赖了ehcache，它是一个JCache规范的实现，在介绍Resilience4j缓存机制时，我们会用到它。有了这些引入，就可以开始学习Resilience4j的内容了，在学习的过程中，稍微对比一下Hystrix的机制会事半功倍，因为Resilience4j本质上就是参考Hystrix进行开发的，两者的理念还是比较接近的。</p>
<h3 id="6-1-断路器（CircuitBreaker）"><a href="#6-1-断路器（CircuitBreaker）" class="headerlink" title="6.1 断路器（CircuitBreaker）"></a>6.1 断路器（CircuitBreaker）</h3><p>和Hystrix一样，在Resilience4j中，断路器是其核心功能之一，下面让我们学习它。</p>
<h4 id="6-1-1-断路器配置和注册机"><a href="#6-1-1-断路器配置和注册机" class="headerlink" title="6.1.1 断路器配置和注册机"></a>6.1.1 断路器配置和注册机</h4><p>断路器是一个比较复杂的组件，为了构建它，Resilience4j使用了构建模式，提供了类CircuitBreakerConfig来简化使用者的开发，通过它可以配置断路器的各种属性。为了更加好地管理多个断路器，Resilience4j还提供了断路器的注册机，注册机的对应接口是CircuitBreakerRegistry，它的唯一实现类是InMemoryCircuitBreakerRegistry。我们先来看一下这个实现类的源码，如代码清单6-2所示。</p>
<p>代码清单6-2 InMemoryCircuitBreakerRegistry源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.resilience4j.circuitbreaker.internal;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InMemoryCircuitBreakerRegistry</span> <span class="keyword">implements</span> <span class="title class_">CircuitBreakerRegistry</span> &#123;</span><br><span class="line">   <span class="comment">// 默认的断路器配置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerConfig defaultCircuitBreakerConfig;</span><br><span class="line">   <span class="comment">// 同步Map接口</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, CircuitBreaker&gt; circuitBreakers;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">InMemoryCircuitBreakerRegistry</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="comment">// 采用默认值</span></span><br><span class="line">      <span class="built_in">this</span>.defaultCircuitBreakerConfig = CircuitBreakerConfig.ofDefaults();</span><br><span class="line">      <span class="built_in">this</span>.circuitBreakers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">InMemoryCircuitBreakerRegistry</span><span class="params">(</span></span><br><span class="line"><span class="params">         CircuitBreakerConfig defaultCircuitBreakerConfig)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defaultCircuitBreakerConfig = Objects.requireNonNull(</span><br><span class="line">         defaultCircuitBreakerConfig, </span><br><span class="line">         <span class="string">&quot;CircuitBreakerConfig must not be null&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.circuitBreakers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回所有的断路器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Seq&lt;CircuitBreaker&gt; <span class="title function_">getAllCircuitBreakers</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Array.ofAll(circuitBreakers.values());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据断路器名称，获取断路器，如果不存在，则采用默认配置构建新的断路器</span></span><br><span class="line">   <span class="comment">// 并存放在circuitBreakers中</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> CircuitBreaker <span class="title function_">circuitBreaker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据断路器名称，获取断路器，如果不存在，则采用自定义配置构建新的断路器</span></span><br><span class="line">   <span class="comment">// 并存放在circuitBreakers中</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> CircuitBreaker <span class="title function_">circuitBreaker</span><span class="params">(String name, </span></span><br><span class="line"><span class="params">         CircuitBreakerConfig customCircuitBreakerConfig)</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据断路器名称，获取断路器，如果不存在，则采用自定义配置构建新的断路器</span></span><br><span class="line">   <span class="comment">// 并存放在circuitBreakers中</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> CircuitBreaker <span class="title function_">circuitBreaker</span><span class="params">(String name, </span></span><br><span class="line"><span class="params">         Supplier&lt;CircuitBreakerConfig&gt; circuitBreakerConfigSupplier)</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以知道，这个类存在两个属性。一个是CircuitBreakerConfig类型，它代表默认的断路器配置。另一个是同步哈希（ConcurrentMap<String,CircuitBreaker>），用于存放多个断路器，因为它采用的是ConcurrentHashMap，而这个类可以进行局部加锁而非全局加锁，所以它在具备线程安全的同时，也在很大程度上提高了并发的效率。再看它提供的3个circuitBreaker方法，都可以构建断路器并且注册在注册机内，这3个方法的构建难点在于CircuitBreakerConfig的使用。</p>
<h4 id="6-1-2-断路器的状态"><a href="#6-1-2-断路器的状态" class="headerlink" title="6.1.2 断路器的状态"></a>6.1.2 断路器的状态</h4><p>在使用断路器之前，首先需要了解断路器的状态，在Resilience4j中存在以下5种不同的状态。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">●DISABLED：断路器失效，让所有请求通过，记为数字3。注意：该状态不对外发布事件。</span><br><span class="line">●CLOSED：初始化状态，关闭断路器，让所有请求通过，记为数字0。该状态对外发布事件。</span><br><span class="line">●OPEN：打开断路器，不让请求通过，记为数字1。该状态对外发布事件。●FORCED<span class="emphasis">_OPEN：强制打开断路器，不让请求通过，记为数字4。注意：该状态不对外发布事件，在此状态下，状态变化和事件都失效。</span></span><br><span class="line"><span class="emphasis">●HALF_</span>OPEN：半打开状态，它将等待一个时间戳，记为数字2，然后才允许请求通过，再通过一定的分析来决定是否再次打开断路器。该状态对外发布事件。</span><br></pre></td></tr></table></figure>
<p>一般来说，使用断路器最常用的状态是CLOSED、OPEN和HALF_OPEN，其余的较少用。此外，需要注意的是，只有这3个状态对外发布事件，其余的状态都不对外发布事件。这和Hystrix比较接近，只是说Resilience4j允许我们做更为灵活的配置，例如，配置一些阈值、分析请求次数等。对于每次请求，断路器都会将成功或者失败记录到环形位缓冲区中，提供数据分析。但对于它的状态来说，一般会像下面描述的这样转变。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●初始化的时候，断路器会处于CLOSED状态。</span><br><span class="line">●在调用业务逻辑到一定次数（默认为10次，可配置）时，通过环形位缓冲区中的失败比例判断是否达到阈值（默认失败比例50%以上，可配置），如果达到，断路器状态就会从CLOSED转变为OPEN，阻断其他调用。</span><br><span class="line">●如果断路器状态为OPEN，在等待一个时间戳（默认为60秒，可配置）后，断路器状态就会从OPEN转变为HALF<span class="emphasis">_OPEN。此时处于一个检测状态，当调用到了一定次数（默认为10次，可配置）时，通过环形位缓冲区中的数据判断成功比例是否达到阈值（默认成功比例50%以上，可配置），如果达到，断路器就会重新关闭（状态设置为CLOSED），放行请求；如果没有达到，就打开断路器（状态为OPEN），阻隔调用。</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-使用断路器的实例"><a href="#6-1-3-使用断路器的实例" class="headerlink" title="6.1.3 使用断路器的实例"></a>6.1.3 使用断路器的实例</h4><p>为了能够使用断路器和其注册机，这里重构产品微服务的入口类ProductApplication，如代码清单6-3所示。</p>
<p>代码清单6-3 断路器配置和注册机（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.spring.cloud.product&quot;</span></span><br><span class="line"><span class="meta">   // 排除Resilience4j Spring Boot stater的自动装配类</span></span><br><span class="line"><span class="meta">   , exclude = &#123;CircuitBreakerAutoConfiguration.class, </span></span><br><span class="line"><span class="meta">          CircuitBreakerMetricsAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">          RateLimiterAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">          RateLimiterMetricsAutoConfiguration.class</span></span><br><span class="line"><span class="meta">          &#125;)</span></span><br><span class="line"><span class="comment">// 驱动熔断器</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductApplication</span> &#123;</span><br><span class="line">   <span class="comment">// 负载均衡</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span></span><br><span class="line">   <span class="comment">// 创建Spring Bean</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RestTemplate <span class="title function_">initRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 断路器配置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">CircuitBreakerConfig</span> <span class="variable">circuitBreakerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 断路器注册机</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">CircuitBreakerRegistry</span> <span class="variable">circuitBreakerRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(name = &quot;circuitBreakerConfig&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> CircuitBreakerConfig <span class="title function_">initCircuitBreakerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (circuitBreakerConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">         circuitBreakerConfig = CircuitBreakerConfig.custom().<span class="comment">// 自定义配置</span></span><br><span class="line">                <span class="comment">// 当请求失败比例达到30%时，打开断路器，默认为50%</span></span><br><span class="line">                failureRateThreshold(<span class="number">30</span>)</span><br><span class="line">                <span class="comment">// 当断路器为打开状态时，等待多少时间，转变为半打开状态，默认为60秒</span></span><br><span class="line">                .waitDurationInOpenState(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                <span class="comment">// 配置断路器半打开时的环形位缓冲区大小（假设记为n，默认为10），</span></span><br><span class="line">                <span class="comment">// 在等待n次请求后，才重新分析请求结果来确定是否改变断路器的状态</span></span><br><span class="line">                .ringBufferSizeInHalfOpenState(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 配置断路器闭合时环形位缓冲区的大小（假设记为n，默认为100），</span></span><br><span class="line">                <span class="comment">// 在等待n次请求后，才重新分析请求结果来确定是否改变断路器的状态</span></span><br><span class="line">                .ringBufferSizeInClosedState(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 构建建立配置</span></span><br><span class="line">                .build();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> circuitBreakerConfig;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构建断路器注册机</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;circuitBreakerRegistry&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> CircuitBreakerRegistry <span class="title function_">initCircuitBreakerRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (circuitBreakerConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">         initCircuitBreakerConfig();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (circuitBreakerRegistry == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 创建断路器注册机</span></span><br><span class="line">         circuitBreakerRegistry = </span><br><span class="line">            CircuitBreakerRegistry.of(circuitBreakerConfig);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> circuitBreakerRegistry;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(ProductApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码中，首先使用了@SpringBootApplication的exclude属性排除了resilience4j-spring-boot2自动装配的类，否则这里的initCircuitBreakerConfig和initCircuitBreakerRegistry就会发生错误，因为resilience4j-spring-boot2会自动装配对应的类。initCircuitBreakerConfig方法是构建断路器配置的方法，具体的逻辑已经在代码注释中说明，请参考。initCircuitBreakerRegistry是创建断路器注册机的，设置了initCircuitBreakerConfig创建的配置为默认配置，这样就可以通过CircuitBreakerRegistry的circuitBreaker方法创建和注册断路器了。</p>
<p>接下来我们就要去使用创建好的断路器了，为此先创建接口R4jFacade，如代码清单6-4所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.facade;</span><br><span class="line"><span class="keyword">import</span> com.spring.cloud.common.vo.ResultMessage;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">R4jFacade</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中声明了一个方法，它将调用用户微服务，因此需要一个实现类，如代码清单6-5所示。</p>
<p>代码清单6-5 使用断路器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.facade.impl;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R4jFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">R4jFacade</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span> <span class="comment">// 注册机</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">CircuitBreakerRegistry</span> <span class="variable">circuitBreakerRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span> <span class="comment">// 默认配置</span></span><br><span class="line">   <span class="type">CircuitBreakerConfig</span> <span class="variable">circuitBreakerConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span> <span class="comment">// REST模板</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 错误结果ID</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ERROR_ID</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">      <span class="comment">// 根据配置创建并注册断路器（CircuitBreaker），键为“exp”，</span></span><br><span class="line">      <span class="comment">// 如果没有指定配置，则采用默认配置</span></span><br><span class="line">      <span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span></span><br><span class="line">         <span class="operator">=</span> circuitBreakerRegistry.circuitBreaker(<span class="string">&quot;exp&quot;</span>); <span class="comment">// ①</span></span><br><span class="line">      <span class="comment">// 描述事件，准备发送</span></span><br><span class="line">      CheckedFunction0&lt;ResultMessage&gt; decoratedSupplier = </span><br><span class="line">         CircuitBreaker.decorateCheckedSupplier(circuitBreaker,</span><br><span class="line">         () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://USER/hystrix/exp/&#123;msg&#125;&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(url, </span><br><span class="line">               ResultMessage.class, msg);</span><br><span class="line">         &#125;); <span class="comment">// ②</span></span><br><span class="line">      <span class="comment">// 获取断路器的状态</span></span><br><span class="line">      <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> circuitBreaker.getState(); <span class="comment">// ③</span></span><br><span class="line">      System.out.println(<span class="string">&quot;断路器状态：【&quot;</span> + state.name() + <span class="string">&quot;】&quot;</span>); </span><br><span class="line">     <span class="comment">// 发送事件</span></span><br><span class="line">      Try&lt;ResultMessage&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">         <span class="comment">// 如果发生异常，则执行降级方法</span></span><br><span class="line">         .recover(ex -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">false</span>, ex.getMessage());</span><br><span class="line">         &#125;); <span class="comment">// ④</span></span><br><span class="line">      <span class="keyword">return</span> result.get(); <span class="comment">// ⑤ </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中注入了默认的断路器配置、断路器注册机和RestTemplate模板，这些都是事先创建好的。现在来看我们的核心方法exp，其中代码①处是使用断路器注册机创建断路器，并且指定名称为“exp”，因为没有指定具体的断路器配置，所以它将会使用默认的配置。代码②处是核心逻辑，这里创建的是事件的逻辑，显然这里在执行一次REST请求，完成对用户微服务的调用，但是请大家注意，这里只是描述事件，并未发送事件。代码③处是获取断路器的状态，以监测断路器当前的状态。代码④处是调用接口Try的静态方法of，并且以事件描述为参数进行传递，意思为尝试执行事件逻辑，所以这里会发送事件。后续跟着recover方法，它代表着一个降级处理逻辑，就是当事件发生异常时执行的逻辑：将结果信息标注为false，然后传递异常信息。代码⑤处是取回结果，这里请注意，虽然Try对象（result）还有一个isSuccess方法，但是因为这里使用了降级逻辑，所以整个业务发生异常的时候，结果返回也是成功的，因此isSuccess方法最后返回的也是true，而非false。</p>
<p>为了测试断路器的业务逻辑，再创建一个控制器，如代码清单6-6所示。</p>
<p>代码清单6-6 使用控制器测试断路器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/r4j&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R4jController</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span> <span class="comment">// 注入接口</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">R4jFacade</span> <span class="variable">r4jFacade</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/exp/&#123;msg&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">(<span class="meta">@PathVariable(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> r4jFacade.exp(msg); <span class="comment">// 业务逻辑调用</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的exp方法就是测试断路器的，启动对应的服务后，可以请求以下两个URL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/r4j/exp/spring // 正常返回</span><br><span class="line">http://localhost:8001/r4j/exp/boot   // 异常返回</span><br></pre></td></tr></table></figure>
<p>对这两个请求可以多刷新几次，观测后端打出的断路器状态，再核对代码清单6-3的配置，相信这样就能对断路器有更深入的体验了。</p>
<h4 id="6-1-4-异常处理"><a href="#6-1-4-异常处理" class="headerlink" title="6.1.4 异常处理"></a>6.1.4 异常处理</h4><p>在上述的代码中，我们只考虑了业务的执行和降级服务，有时候我们还需要处理断路器发生的异常。在断路器配置类（CircuitBreakerConfig）中，还有以下这3个处理异常的方法。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">●recordFailure方法：记录异常的方法。●ignoreExceptions方法：参数是一个可变化的异常列表，表示忽略哪些异常，即当发生这些异常时，断路器不认为执行是失败的。●recordExceptions方法：参数是一个可变化的异常列表，表示记录哪些异常，即当发生的是列表中的异常时，才认为执行是失败的，如果不是，则认为执行是成功的。</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">circuitBreakerConfig = CircuitBreakerConfig.custom().<span class="comment">// 自定义配置</span></span><br><span class="line">   <span class="comment">// 当请求失败比例达到30%时，打开断路器，默认为50%</span></span><br><span class="line">   failureRateThreshold(<span class="number">30</span>)</span><br><span class="line">   <span class="comment">// 当断路器为打开状态时，等待多少时间，转变为半打开状态，默认为60秒</span></span><br><span class="line">   .waitDurationInOpenState(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">   <span class="comment">// 配置断路器半打开时的环形缓冲区大小（假设记为n，默认为10），</span></span><br><span class="line">   <span class="comment">// 在等待n次请求后，才重新分析请求结果来确定是否改变断路器的状态</span></span><br><span class="line">   .ringBufferSizeInHalfOpenState(<span class="number">5</span>)</span><br><span class="line">   <span class="comment">// 配置断路器闭合时环形缓冲区的大小（假设记为n，默认为100），</span></span><br><span class="line">   <span class="comment">// 在等待n次请求后，才重新分析请求结果来确定是否改变断路器的状态</span></span><br><span class="line">   .ringBufferSizeInClosedState(<span class="number">5</span>)</span><br><span class="line">   <span class="comment">// 断路器异常处理</span></span><br><span class="line">   .recordFailure(ex -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;发生了异常，栈追踪信息为： &quot;</span>);</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 忽略哪些异常，即当发生这些异常时，不认为执行失败</span></span><br><span class="line">   .ignoreExceptions(ClassNotFoundException.class, IOException.class)</span><br><span class="line">   <span class="comment">// 只有在发生哪些异常时，才认为执行失败</span></span><br><span class="line">   .recordExceptions(Exception.class, RuntimeException.class)</span><br><span class="line">   <span class="comment">// 构建建立配置</span></span><br><span class="line">   .build();</span><br></pre></td></tr></table></figure>
<p>此外，我们还可以给断路器模拟异常，通过它们模拟一些场景。例如，下面这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建断路器</span></span><br><span class="line"><span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span> <span class="operator">=</span> circuitBreakerRegistry.circuitBreaker(<span class="string">&quot;exp&quot;</span>);</span><br><span class="line"><span class="comment">// 在1000 ns后，以运行时异常（RuntimeException），模拟一次断路器错误情况，</span></span><br><span class="line">circuitBreaker.onError(<span class="number">1000</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>());</span><br><span class="line"><span class="comment">// 在1000 ns后，模拟一次断路器执行成功</span></span><br><span class="line">circuitBreaker.onSuccess(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h4 id="6-1-5-拾遗"><a href="#6-1-5-拾遗" class="headerlink" title="6.1.5 拾遗"></a>6.1.5 拾遗</h4><p>除了前面几节讲述的内容，断路器还有很多琐碎的东西，所以本节命名为拾遗。首先我们来谈谈获取分析数据。正如我们之前所谈到的环形位缓冲区，它是记录调用成败的地方，能为我们提供数据分析的度量。在断路器中有一个getMetrics方法，通过它可以获取度量数据（Metrics），从而获取关于断路器的度量信息，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取度量信息</span></span><br><span class="line">CircuitBreaker.<span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> circuitBreaker.getMetrics();</span><br><span class="line"><span class="comment">// 获取环形位缓冲区中记录的调用失败比例</span></span><br><span class="line"><span class="type">float</span> failureRate= circuitBreaker.getMetrics().getFailureRate();</span><br><span class="line"><span class="comment">// 获取环形位缓冲区中记录的调用次数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bufferedCalls</span> <span class="operator">=</span> metrics.getNumberOfBufferedCalls();</span><br><span class="line"><span class="comment">// 获取环形位缓冲区中记录的调用失败数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">failedCalls</span> <span class="operator">=</span> metrics.getNumberOfFailedCalls();</span><br></pre></td></tr></table></figure>
<p>此外断路器还可以给我们提供事件的监控，例如，在我们的断路器状态为OPEN时，不允许请求、调用成功后的事件和调用失败的事件。例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">circuitBreaker.getEventPublisher() <span class="comment">// 获取事件发布者</span></span><br><span class="line">   <span class="comment">// 调用不允许调用事件，例如，断路器打开，不允许请求</span></span><br><span class="line">   .onCallNotPermitted(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onCallNotPermitted】&quot;</span> + env.getEventType().name());&#125;)</span><br><span class="line">   <span class="comment">// 调用错误事件</span></span><br><span class="line">   .onError(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onError】&quot;</span> + env.getEventType().name());&#125;)</span><br><span class="line">   <span class="comment">// 调用成功事件</span></span><br><span class="line">   .onSuccess(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onSuccess】&quot;</span> + env.getEventType().name());&#125;)</span><br><span class="line">   <span class="comment">// 断路器状态改变事件</span></span><br><span class="line">   .onStateTransition(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onStateTransition】&quot;</span> + env.getEventType().name());&#125;)</span><br><span class="line">    <span class="comment">// 忽略错误事件</span></span><br><span class="line">   .onIgnoredError(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onIgnoredError】&quot;</span> + env.getEventType().name());&#125;)</span><br><span class="line">   <span class="comment">// 重置断路器事件，关于重置后续会谈及</span></span><br><span class="line">   .onReset(env-&gt;&#123;System.out.println(</span><br><span class="line">       <span class="string">&quot;【onReset】&quot;</span> + env.getEventType().name());&#125;);</span><br></pre></td></tr></table></figure>
<p>在上述onXXX方法中，参数都是EventConsumer<T>（事件消费者），只是代码中写作了Lambda表达式，这样代码看起来就精简多了。</p>
<p>如果想注册一个消费者去监听所有事件，那么按照Resilience4j的说明，可以使用断路器的onEvent方法。例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">circuitBreaker.getEventPublisher()</span><br><span class="line">   .onEvent(env-&gt;&#123; <span class="comment">// 注册消费者监听所有的事件</span></span><br><span class="line">      System.out.println(<span class="string">&quot;【onEvent】&quot;</span> </span><br><span class="line">          + env.getEventType().name());</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>不过，从我本地的监测实践来看（使用Resilience4j的0.13.2版本），这个消费者注册是失败的，也就是说，没有起到监听事件的效果，这估计是框架存在的缺陷。</p>
<p>断路器还存在一系列可以改变当前状态的方法，具体如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">●reset：重置断路器，返回原始状态，并删除原有度量数据，发布事件。●transitionToClosedState：将断路器修改为关闭状态，调用可以顺利执行，发布事件。●transitionToOpenState：将断路器修改为打开状态，阻止调用，发布事件。●transitionToHalfOpenState：将断路器修改为半打开状态，监测调用，再决定断路器的状态变化，发布事件。●transitionToDisabledState：将断路器修改为失效状态，停止断路器的状态转换，若要从此状态恢复，必须强制进行新的状态转换。此外需要注意的是，在此状态下断路器将不发布事件，并且停止度量数据采集。●transitionToForcedOpenState：将断路器修改为强制打开状态，停止断路器的状态转换，若要从此状态恢复，必须强制进行新的状态转换。此外需要注意的是，在此状态下断路器将不发布事件，并且停止度量数据采集。</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是3个方法，即reset、transitionToDisabledState和transitionToForcedOpenState。其中reset方法会让断路器返回到一个原始的状态，正如手机可以恢复到出厂状态一般，但是注意，这个重置方法会删除环形位缓冲区中的数据，也就是会删除度量数据，这就需要重新计算并确定断路器的状态了。transitionToDisabledState和transitionToForcedOpenState方法，会让断路器失去状态转换的功能，停止收集度量数据和发布事件。在代码中，我们可以很容易地运用这些方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">circuitBreaker.reset(); <span class="comment">// 重置断路器，同时删除度量数据</span></span><br><span class="line">circuitBreaker.transitionToClosedState(); <span class="comment">// 将断路器状态修改为CLOSED</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-限速器（RateLimiter）"><a href="#6-2-限速器（RateLimiter）" class="headerlink" title="6.2 限速器（RateLimiter）"></a>6.2 限速器（RateLimiter）</h3><p>限速器是高并发系统中常见的工具，因为任何机器和系统的服务能力都是有上限的，在一些高并发的场景下，太多的请求达到服务器，会造成机器超负荷工作，引发系统的诸多问题。限速器则可以在这样的情况下，让请求按照一个安全的速率通过系统，从而保证机器不超负荷工作，引发系统的各类问题。</p>
<p>在Resilience4j中，限速器和断路器十分接近，限速器中也有限速配置（RateLimiterConfig）和注册机（RateLimiterRegistry）。之前已经详细介绍过断路器的机制了，限速器与其类似，所以这里就不再赘述了，本节只谈它的应用。</p>
<h4 id="6-2-1-使用实践"><a href="#6-2-1-使用实践" class="headerlink" title="6.2.1 使用实践"></a>6.2.1 使用实践</h4><p>在使用限速器之间，我们需要创建限速器。首先要通过配置（RateLimiterConfig）来设置限速器的功能，然后将其注册到注册机（RateLimiterRegistry）内，为此我们在产品微服务的ProductApplication中加入代码清单6-7所示的代码。</p>
<p>代码清单6-7 配置、创建和注册限速器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限速器配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RateLimiterConfig</span> <span class="variable">rateLimiterConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 限速器注册机</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RateLimiterRegistry</span> <span class="variable">rateLimiterRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化限速器配置</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;rateLimiterConfig&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RateLimiterConfig <span class="title function_">initRateLimiterConfig</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (rateLimiterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 定义限制20req/s的限流器</span></span><br><span class="line">      rateLimiterConfig = RateLimiterConfig.custom() <span class="comment">// 采用自定义</span></span><br><span class="line">         <span class="comment">// 配置时间戳，默认值为500 ns</span></span><br><span class="line">         .limitRefreshPeriod(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">         <span class="comment">// 时间戳内限制通过的请求数，默认值为50</span></span><br><span class="line">         .limitForPeriod(<span class="number">20</span>)</span><br><span class="line">         <span class="comment">// 配置超时，如果等待超时则限速器丢弃请求，默认值为5秒</span></span><br><span class="line">         .timeoutDuration(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">         .build();</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> rateLimiterConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化限速器注册机</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;rateLimiterRegistry&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RateLimiterRegistry <span class="title function_">initRateLimiterRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (rateLimiterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      initRateLimiterConfig();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (rateLimiterRegistry == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置默认的限速配置，创建限速器注册机</span></span><br><span class="line">      rateLimiterRegistry = RateLimiterRegistry.of(rateLimiterConfig);</span><br><span class="line">      <span class="comment">// 创建断路器，并注册在注册机内（使用默认配置）</span></span><br><span class="line">      rateLimiterRegistry.rateLimiter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rateLimiterRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心代码是initRateLimiterConfig方法中的限速配置（RateLimiterConfig），注释已经给出了详细的说明，这里设置了20req/s（每秒20个请求）的速率，这样就可以压制请求通过的速度，保护调用，避免过大的流量压垮服务器了；之后的initRateLimiterRegistry是创建限速器注册机的，和断路器一样，它也是通过一个同步哈希（ConcurrentHashMap）存储限速器的，并且设置了默认的限速配置，创建了一个命名为“user”的限速器，以便未来使用。跟着就是使用限速器，在R4jFacadeImpl中加入代码清单6-8所示的代码。</p>
<p>跟着就是使用限速器，在R4jFacadeImpl中加入代码清单6-8所示的代码。</p>
<p>代码清单6-8 限速器的使用（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限速器注册机</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RateLimiterRegistry</span> <span class="variable">rateLimiterRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取或创建限速器</span></span><br><span class="line">   <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateLimiterRegistry.rateLimiter(<span class="string">&quot;user&quot;</span>);<span class="comment">// ①</span></span><br><span class="line">   <span class="comment">// 定义事件，但是没有发送请求</span></span><br><span class="line">   CheckedFunction0&lt;UserInfo&gt; decoratedSupplier </span><br><span class="line">      = RateLimiter.decorateCheckedSupplier(rateLimiter,</span><br><span class="line">         () -&gt; reqUser(id)); <span class="comment">// ②</span></span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   Try&lt;UserInfo&gt; result = Try.of(decoratedSupplier) <span class="comment">// ③</span></span><br><span class="line">      <span class="comment">// 降级逻辑</span></span><br><span class="line">      .recover(ex -&gt; &#123;</span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(ERROR_ID, <span class="string">&quot;&quot;</span>, ex.getMessage());</span><br><span class="line">      &#125;);</span><br><span class="line">   <span class="keyword">return</span> result.get(); <span class="comment">// ④</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">private</span> UserInfo <span class="title function_">reqUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://USER/user/info/&#123;id&#125;&quot;</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;获取用户&quot;</span> + id);</span><br><span class="line">   <span class="keyword">return</span> restTemplate.getForObject(url, UserInfo.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码①处从注册机内获取一个命名为user的限速器，如果没有获取到则自动创建一个。代码②处是创建一个函数，并且设置限速器和描述事件，请注意，此时并不执行调用。代码③处发送请求，此时才执行调用，此处仍旧使用了recover方法，设置降级逻辑。代码④处获取执行（或降级）结果。从上述过程看，和我们断路器的逻辑也是差不多的，所以多参考断路器的内容，限速器也就不难了</p>
<p>为了测试这段代码，可以在R4jController中，加入代码清单6-9所示的代码。</p>
<p>代码清单6-9 使用控制器测试限速器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title function_">getUserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 开始时间</span></span><br><span class="line">   <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">   List&lt;UserInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      id ++;</span><br><span class="line">      <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> r4jFacade.getUser(id); <span class="comment">// 调用限速器</span></span><br><span class="line">      userList.add(user);</span><br><span class="line">      <span class="comment">// 循环内的当前时间 </span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// 超过1秒，终止循环</span></span><br><span class="line">      <span class="keyword">if</span> (end - start &gt;= <span class="number">1000</span>) &#123; </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中使用了死循环：通过判断时间，让循环在1秒内结束。这样可以观察到限速器下的执行效果。请求<a target="_blank" rel="noopener" href="http://localhost:8001/r4j/users，就可以观察限速器的结果了。一般来说，获取的信息数量不超过40个，之所以是40而不是我们限速器设置的每秒20个，一方面是因为调用者和限速器之间存在细微的误差，另一方面是因为限速器的机制不是一个严格线程安全的，它只是起到了大概限速的效果，限速器之所以这么设计也是出于性能方面的考虑。在我的测试中，如果将限速器的速率设置为1000，那么每秒可以执行300左右的请求，可见限速器起到了它的作用，有效地控制了调用速率，防止了服务负荷过大。">http://localhost:8001/r4j/users，就可以观察限速器的结果了。一般来说，获取的信息数量不超过40个，之所以是40而不是我们限速器设置的每秒20个，一方面是因为调用者和限速器之间存在细微的误差，另一方面是因为限速器的机制不是一个严格线程安全的，它只是起到了大概限速的效果，限速器之所以这么设计也是出于性能方面的考虑。在我的测试中，如果将限速器的速率设置为1000，那么每秒可以执行300左右的请求，可见限速器起到了它的作用，有效地控制了调用速率，防止了服务负荷过大。</a></p>
<h4 id="6-2-2-拾遗"><a href="#6-2-2-拾遗" class="headerlink" title="6.2.2 拾遗"></a>6.2.2 拾遗</h4><p>和断路器一样，限速器也有度量数据，使用和查看它们也并不困难，如代码清单6-10所示。</p>
<p>代码清单6-10 限速器的度量（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取度量</span></span><br><span class="line">io.github.resilience4j.ratelimiter.RateLimiter.<span class="type">Metrics</span> <span class="variable">metrics</span> </span><br><span class="line">    <span class="operator">=</span> rateLimiter.getMetrics();</span><br><span class="line"><span class="comment">// 获取估计剩下可用的调用数，一般用于测试和评估，</span></span><br><span class="line"><span class="comment">// 如果有些调用还在进行，它可以为负值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ap</span> <span class="operator">=</span> metrics.getAvailablePermissions();</span><br><span class="line"><span class="comment">// 获取估计当前还在运行的调用数，一般用于测试和评估</span></span><br><span class="line"><span class="type">int</span> <span class="variable">nowt</span> <span class="operator">=</span> metrics.getNumberOfWaitingThreads();</span><br></pre></td></tr></table></figure>
<p>此外，限速器也有事件监听的功能，在限速器中有两种事件，一种是获取成功，另外一种是获取失败。可以只使用onEvent方法监听所有的事件。监听事件的方法的参数都是EventConsumer，一般来说，都写作Lambda表达式，这样看起来会简洁一些，如代码清单6-11所示。</p>
<p>代码清单6-11 限速器事件监听（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rateLimiter.getEventPublisher() <span class="comment">// 获取事件发布者</span></span><br><span class="line">   <span class="comment">// 监听调用失败事件</span></span><br><span class="line">   .onFailure(evt-&gt;System.out.println(</span><br><span class="line">      <span class="string">&quot;事件类型【&quot;</span>+evt.getEventType()+<span class="string">&quot;】&quot;</span>))</span><br><span class="line">   <span class="comment">// 监听调用成功事件</span></span><br><span class="line">   .onSuccess(evt-&gt;System.out.println(</span><br><span class="line">      <span class="string">&quot;事件类型【&quot;</span>+evt.getEventType()+<span class="string">&quot;】&quot;</span>))</span><br><span class="line">   <span class="comment">// 监听调用成功（或失败）事件</span></span><br><span class="line">   .onEvent(evt-&gt;System.out.println(</span><br><span class="line">      <span class="string">&quot;监听所有事件，事件类型【&quot;</span>+evt.getEventType()+<span class="string">&quot;】&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>其中onFailure方法是监听获取失败事件，onSuccess方法是监听获取成功事件。onEvent方法则可以监听所有的事件，然后再根据事件的类型判定当前执行是成功了还是失败了。</p>
<p>限速器还可以动态修改changeLimitForPeriod和changeTimeoutDuration的参数，如代码清单6-12所示。</p>
<p>代码清单6-12 动态修改限速器参数（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单位时间戳内限制的速率</span></span><br><span class="line">rateLimiter.changeLimitForPeriod(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 请求等待1秒，如果仍旧没有运行则将请求丢失</span></span><br><span class="line">rateLimiter.changeTimeoutDuration(Duration.ofSeconds(<span class="number">1L</span>));</span><br></pre></td></tr></table></figure>
<p>这样就可以根据具体的情况来修改限速器的相关参数了。</p>
<h3 id="6-3-舱壁隔离（Bulkhead）"><a href="#6-3-舱壁隔离（Bulkhead）" class="headerlink" title="6.3 舱壁隔离（Bulkhead）"></a>6.3 舱壁隔离（Bulkhead）</h3><p>在Hystrix中，我们讨论过舱壁模式，同样的，Resilience4j也提供了舱壁模式，和Hystrix中不同的是，Resilience4j只提供基于信号量实现的模式，不提供线程池的模式。使用舱壁模式的好处在于，可以把各种调用隔离出来，以避免某种调用占据舱壁资源太多，导致线程严重积压，甚至导致舱壁崩溃影响到其他业务调用的运行。6.3.1 使用舱壁隔离</p>
<h4 id="6-3-1-使用舱壁隔离"><a href="#6-3-1-使用舱壁隔离" class="headerlink" title="6.3.1 使用舱壁隔离"></a>6.3.1 使用舱壁隔离</h4><p>在Resilience4j中使用舱壁，首先要创建舱壁配置（BulkheadConfig）、注册机（BulkheadRegistry）和单个舱壁（Bulkhead）。为此，我们在ProductApplication中加入代码清单6-13所示的代码。</p>
<p>代码清单6-13 创建舱壁配置、注册机和单舱壁（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 舱壁注册机</span></span><br><span class="line"><span class="keyword">private</span> BulkheadRegistry bulkheadRegistry;</span><br><span class="line"><span class="comment">// 舱壁配置</span></span><br><span class="line"><span class="keyword">private</span> BulkheadConfig bulkheadConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name=&quot;bulkheadConfig&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BulkheadConfig <span class="title function_">initBulkheadConfig</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bulkheadConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 舱壁配置</span></span><br><span class="line">      bulkheadConfig = BulkheadConfig.custom()</span><br><span class="line">         <span class="comment">// 最大并发数，默认值为25</span></span><br><span class="line">         .maxConcurrentCalls(<span class="number">20</span>)</span><br><span class="line">         <span class="comment">/* 调度线程最大等待时间（单位毫秒），默认值为0，</span></span><br><span class="line"><span class="comment">          如果存在高并发场景，强烈建议设置为0，</span></span><br><span class="line"><span class="comment">          如果不设置为0，那么在高并发场景下，</span></span><br><span class="line"><span class="comment">          可能会导致线程积压，引发各类问题*/</span></span><br><span class="line">         .maxWaitTime(<span class="number">0</span>)</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bulkheadConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name=&quot;bulkheadRegistry&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BulkheadRegistry <span class="title function_">initBulkheadRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bulkheadConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      initBulkheadConfig();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (bulkheadRegistry == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建舱壁注册机，并设置默认配置</span></span><br><span class="line">      bulkheadRegistry = BulkheadRegistry.of(bulkheadConfig);</span><br><span class="line">      <span class="comment">// 创建一个命名为user的舱壁</span></span><br><span class="line">      bulkheadRegistry.bulkhead(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bulkheadRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的核心是initBulkheadConfig方法中的舱壁配置。首先将舱壁最大并发数配置为20（默认为25），然后将等待时间设置为0（默认值为0，单位毫秒），即在舱壁线程已满时，立刻放弃调用。关于舱壁设置，值得我们注意的是，如果请求存在高并发的情况，那么等待时间不为0，就意味着可能存在积压，而积压太多就可能导致系统崩溃，所以在请求存在高并发的情况时，强烈建议将等待时间设置为0，让它直接执行降级逻辑。跟着在initBulkheadRegistry方法中，根据舱壁配置创建了注册机，然后使用注册机创建了一个命名为“user”的舱壁，这样注册机和具体的舱壁就都创建好了，可以使用了。</p>
<p>接下来开发获取用户的逻辑，在R4jFacadeImpl的代码中加入代码清单6-14所示的代码。</p>
<p>代码清单6-14 使用舱壁完成服务调用（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUser3</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取舱壁</span></span><br><span class="line">   <span class="type">Bulkhead</span> <span class="variable">bulkhead</span> <span class="operator">=</span> bulkheadRegistry.bulkhead(<span class="string">&quot;user&quot;</span>); <span class="comment">// ①</span></span><br><span class="line">   <span class="comment">// 描述事件</span></span><br><span class="line">   CheckedFunction0&lt;UserInfo&gt; decoratedSupplier  <span class="comment">// ②</span></span><br><span class="line">      = Bulkhead.decorateCheckedSupplier(</span><br><span class="line">         bulkhead, () -&gt; reqUser(id));</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   Try&lt;UserInfo&gt; result = Try.of(decoratedSupplier) <span class="comment">// ③</span></span><br><span class="line">      .recover(ex -&gt; &#123; <span class="comment">// 降级服务</span></span><br><span class="line">         ex.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(ERROR_ID, <span class="string">&quot;&quot;</span>, ex.getMessage());</span><br><span class="line">      &#125;);</span><br><span class="line">   <span class="keyword">return</span> result.get(); <span class="comment">// ④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的操作也是接近的，①处是获取舱壁，②处是描述事件，③处是发送请求，④处是获取结果，这里就不赘述了。</p>
<h4 id="6-3-2-拾遗"><a href="#6-3-2-拾遗" class="headerlink" title="6.3.2 拾遗"></a>6.3.2 拾遗</h4><p>和限速器一样，舱壁配置也支持动态修改参数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BulkheadConfig</span> <span class="variable">customCfg</span> <span class="operator">=</span> BulkheadConfig.custom()</span><br><span class="line">   <span class="comment">// 重置最大并发15条</span></span><br><span class="line">   .maxWaitTime(<span class="number">15</span>)</span><br><span class="line">   <span class="comment">// 请注意：最大等待时间是不允许动态修改的，因此这里的设置是无效的</span></span><br><span class="line">   .maxWaitTime(<span class="number">2</span>).build();</span><br><span class="line">bulkhead.changeConfig(customCfg);</span><br></pre></td></tr></table></figure>
<p>这段代码中需要注意的是，配置中的maxWaitTime是不能动态修改的，所以这里的配置是无效的。同样，舱壁也有度量数据，例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取度量数据</span><br><span class="line">io.github.resilience4j.bulkhead.Bulkhead.Metrics metrics</span><br><span class="line"><span class="code">       =bulkhead.getMetrics();</span></span><br><span class="line"><span class="code">// 获取可用并发数</span></span><br><span class="line"><span class="code">metrics.getAvailableConcurrentCalls();</span></span><br></pre></td></tr></table></figure>
<p>当然也会有事件，在舱壁中有3种事件类型：允许调用事件（CALL_PERMITTED）、拒绝调用事件（CALL_REJECTED）和调用完成事件（CALL_FINISHED）。我们可以按照以下代码监听对应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bulkhead.getEventPublisher()</span><br><span class="line">    <span class="comment">// 调用许可事件</span></span><br><span class="line">    .onCallPermitted(evt-&gt;System.out.println(<span class="string">&quot;调用许可&quot;</span>))</span><br><span class="line">    <span class="comment">// 调用完成事件</span></span><br><span class="line">    .onCallFinished(evt -&gt; System.out.println(<span class="string">&quot;调用完毕&quot;</span>))</span><br><span class="line">    <span class="comment">// 拒绝调用事件</span></span><br><span class="line">    .onCallRejected(evt-&gt;System.out.println(<span class="string">&quot;拒绝调用&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以监听所有事件，可以用事件类型区分</span></span><br><span class="line">bulkhead.getEventPublisher()</span><br><span class="line">    <span class="comment">// 监听所有事件</span></span><br><span class="line">    .onEvent(evt -&gt; </span><br><span class="line">             System.out.println(evt.getEventType().name() + <span class="string">&quot;监听所有事件&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="6-4-重试器（Retry）"><a href="#6-4-重试器（Retry）" class="headerlink" title="6.4 重试器（Retry）"></a>6.4 重试器（Retry）</h3><p>实际上，Ribbon也能够支持重试，所以在选择使用Ribbon的时候，可以不使用Resilience4j的重试机制。正如我之前谈到的spring-cloud-circuitbreaker的开发，目前还在进行中，并没有完全融合进来，所以这里只能局限于Resilience4j自身重试的机制。</p>
<h4 id="6-4-1-使用重试机制"><a href="#6-4-1-使用重试机制" class="headerlink" title="6.4.1 使用重试机制"></a>6.4.1 使用重试机制</h4><p>和其他组件一样，重试（Retry）也是由配置器（RetryConfig）、注册机（RetryRegistry）和具体的重试器构成的，所以我们首先在ProductApplication中加入创建它们的代码，如代码清单6-15所示。</p>
<p>代码清单6-15 在重试器中执行服务调用（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">RetryConfig</span> <span class="variable">retryConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">RetryRegistry</span> <span class="variable">retryRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;retryConfig&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RetryConfig <span class="title function_">initRetryConfig</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (retryConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义</span></span><br><span class="line">      retryConfig  = RetryConfig.custom()</span><br><span class="line">         <span class="comment">// 最大尝试次数（默认为3次）</span></span><br><span class="line">         .maxAttempts(<span class="number">5</span>)</span><br><span class="line">         <span class="comment">// 重试时间间隔（默认为500 ms）</span></span><br><span class="line">         .waitDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> retryConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;retryRegistry&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RetryRegistry <span class="title function_">initRetryRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (retryConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.initRetryConfig();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (retryRegistry == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建重试注册机</span></span><br><span class="line">      retryRegistry = RetryRegistry.of(retryConfig);</span><br><span class="line">      <span class="comment">// 创建命名为exp的重试器</span></span><br><span class="line">      retryRegistry.retry(<span class="string">&quot;exp&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> retryRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码创建了配置、注册机和命名为“exp”的重试。其中，maxAttempts方法配置的是最大尝试次数（默认为3次），这里配置为5次，意思是存在1次正常请求和4次重试请求。waitDuration方法配置的是重试时间间隔（默认为500ms），这里配置为1秒。为了使用它，我们在业务层的R4jFacadeImpl类中加入相关代码，如代码清单6-16所示。</p>
<p>代码清单6-16 测试重试器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册重试注册机</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RetryRegistry</span> <span class="variable">retryRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 获取或创建重试</span></span><br><span class="line">   <span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> retryRegistry.retry(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   <span class="comment">// 监听重试事件</span></span><br><span class="line">   retry.getEventPublisher()</span><br><span class="line">      .onRetry(evt-&gt;System.out.println(<span class="string">&quot;重试&quot;</span>)); <span class="comment">// ①</span></span><br><span class="line">   <span class="comment">// 描述事件</span></span><br><span class="line">   CheckedFunction0&lt;ResultMessage&gt; decoratedSupplier </span><br><span class="line">      = Retry.decorateCheckedSupplier(retry,</span><br><span class="line">         () -&gt; reqExp());</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   Try&lt;ResultMessage&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">      <span class="comment">// 降级逻辑</span></span><br><span class="line">      .recover(ex-&gt; <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">false</span>, <span class="string">&quot;异常信息&quot;</span> + ex.getMessage()));</span><br><span class="line">   <span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ResultMessage <span class="title function_">reqExp</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 不使用注入的RestTemplate，原因是Ribbon存在重试机制</span></span><br><span class="line">   RestTemplate restTmpl= <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(); <span class="comment">// ②</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:6001/hystrix/exp/boot&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> restTmpl.getForObject(url, ResultMessage.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码逻辑和之前的差不多，就不再赘述了。但是，有两个需要注意的要点：①处是监听重试事件，之前配置的是尝试5次，即可以有1次正常调用和4次重试调用，所以如果请求失败，会发送4次重试调用；②处代码避免使用了注入的RestTemplate，这是为了避免触发Ribbon的重试机制，以免影响到对Retry的测试。</p>
<p>有了业务方法，我们就可以编写控制器测试它了，在R4jController类中加入代码清单6-17所示的代码。</p>
<p>代码清单6-17 测试重试机制（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/exp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">exp</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> r4jFacade.exp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动对应服务后，在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/r4j/exp，然后观察后台日志就可以看到4次“重试”的打印了，说明请求总共重试了4次。这说明我们使用的重试机制成功了。">http://localhost:8001/r4j/exp，然后观察后台日志就可以看到4次“重试”的打印了，说明请求总共重试了4次。这说明我们使用的重试机制成功了。</a></p>
<h4 id="6-4-2-拾遗"><a href="#6-4-2-拾遗" class="headerlink" title="6.4.2 拾遗"></a>6.4.2 拾遗</h4><p>首先是度量，和之前的组件一样，重试也有自己的度量，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io.github.resilience4j.retry.Retry.<span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> retry.getMetrics();</span><br><span class="line"><span class="comment">// 返回未重试的失败调用数。</span></span><br><span class="line">metrics.getNumberOfFailedCallsWithoutRetryAttempt();</span><br><span class="line"><span class="comment">// 返回所有重试后的失败调用数。</span></span><br><span class="line">metrics.getNumberOfFailedCallsWithRetryAttempt();</span><br><span class="line"><span class="comment">// 返回未重试的成功调用数。</span></span><br><span class="line">metrics.getNumberOfSuccessfulCallsWithoutRetryAttempt();</span><br><span class="line"><span class="comment">// 返回重试后成功调用的次数。</span></span><br><span class="line">metrics.getNumberOfSuccessfulCallsWithRetryAttempt();</span><br></pre></td></tr></table></figure>
<p>此外，通过重试配置器（RetryConfig）还可以忽略某些异常，或者根据结果再判断是否还需要再次重试，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">retryConfig  = RetryConfig.custom()</span><br><span class="line">   <span class="comment">// 最大尝试次数（默认为3次）</span></span><br><span class="line">   .maxAttempts(<span class="number">5</span>)</span><br><span class="line">   <span class="comment">// 重试时间间隔（默认为500 ms）</span></span><br><span class="line">   .waitDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">   <span class="comment">// 配置在何种异常下，放弃重试</span></span><br><span class="line">   .ignoreExceptions(HttpServerErrorException.InternalServerError.class)</span><br><span class="line">   <span class="comment">// 根据请求所得结果判断是否继续重试</span></span><br><span class="line">   .retryOnResult(result -&gt; (result == <span class="literal">null</span>))</span><br><span class="line">   .build();</span><br></pre></td></tr></table></figure>
<p>这里，ignoreExceptions方法的参数是一个可变化的异常参数，可以根据需要在发生那些异常时放弃重试。retryOnResult方法则是，即使请求成功，也要通过评估所得来确定是否还需要执行重试。</p>
<p>同样，重试器也有对应的事件。按定义一共分为4种类型：重试（RETRY）、执行错误（ERROR）、执行成功（SUCCESS）和忽略错误（IGNORED_ERROR）。所以我们可以监听的也是4类事件，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听重试事件</span></span><br><span class="line">retry.getEventPublisher()</span><br><span class="line">   <span class="comment">// 监听重试事件</span></span><br><span class="line">   .onRetry(evt -&gt; System.out.println(<span class="string">&quot;重试&quot;</span>))</span><br><span class="line">   <span class="comment">// 监听执行错误事件</span></span><br><span class="line">   .onError(evt -&gt; System.out.println(<span class="string">&quot;执行错误&quot;</span>))</span><br><span class="line">   <span class="comment">// 监听忽略错误事件</span></span><br><span class="line">   .onIgnoredError(evt -&gt; System.out.println(<span class="string">&quot;忽略错误&quot;</span>))</span><br><span class="line">   <span class="comment">// 监听执行成功事件</span></span><br><span class="line">   .onSuccess(evt -&gt; System.out.println(<span class="string">&quot;执行成功&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 也可以通过onEvent方法，监听所有事件，然后用事件类型判断是何种事件</span></span><br><span class="line">   retry.getEventPublisher().onEvent(evt-&gt;&#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">evtName</span> <span class="operator">=</span> evt.getEventType().name();</span><br><span class="line">   System.out.println(<span class="string">&quot;事件类型名称&quot;</span>+ evtName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>显然事件和其他组件也是类似的，只是事件类型不同而已，稍微区分一下就可以套用之前的规则了。</p>
<h3 id="6-5-缓存（Cache）"><a href="#6-5-缓存（Cache）" class="headerlink" title="6.5 缓存（Cache）"></a>6.5 缓存（Cache）</h3><p>和Hystrix一样，Resilience4j也能够支持缓存机制。代码清单6-1中引入了缓存框架Ecache的包，Ecache是一个JCache规范（JSR107，它是Jakarta EE缓存的规范）的实现包。和Hystrix不一样的是，Resilience4j中没有缓存的注册机制，所以我们需要自己使用缓存。</p>
<h4 id="6-5-1-使用Resilience4j缓存"><a href="#6-5-1-使用Resilience4j缓存" class="headerlink" title="6.5.1 使用Resilience4j缓存"></a>6.5.1 使用Resilience4j缓存</h4><p>这里我们使用的是Ecache缓存，所以首先需要创建一个Ecache缓存的实例，为此在R4jFacadeImpl中加入代码清单6-18所示的代码。</p>
<p>代码清单6-18 创建Ecache缓存实例（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取Ecache的一个缓存实例</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id -- 用户编号</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> javax.cache.Cache&lt;String, UserInfo&gt; <span class="title function_">getCacheInstance</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取缓存提供者，适合只有一个JCache实现的情况</span></span><br><span class="line">   <span class="type">CachingProvider</span> <span class="variable">cachingProvider</span> <span class="operator">=</span> Caching.getCachingProvider(); <span class="comment">// ①</span></span><br><span class="line">   <span class="comment">/* // 如果系统有多种Jcache，则根据具体实现类名获取缓存提供者</span></span><br><span class="line"><span class="comment">   CachingProvider cachingProvider  // ②</span></span><br><span class="line"><span class="comment">      = Caching.getCachingProvider(</span></span><br><span class="line"><span class="comment">         &quot;org.ehcache.jsr107.EhcacheCachingProvider&quot;);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// 获取缓存管理器</span></span><br><span class="line">   <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> cachingProvider.getCacheManager();</span><br><span class="line">   <span class="comment">// 尝试获取名称为&quot;user_&quot;+id的缓存</span></span><br><span class="line">   javax.cache.Cache&lt;String, UserInfo&gt; cacheInstance </span><br><span class="line">      = cacheManager.getCache(<span class="string">&quot;user_&quot;</span> + id);</span><br><span class="line">   <span class="keyword">if</span> (cacheInstance == <span class="literal">null</span>) &#123; <span class="comment">// 获取失败，则创建缓存实例</span></span><br><span class="line">      <span class="comment">// 缓存配置类 </span></span><br><span class="line">      MutableConfiguration&lt;String, UserInfo&gt; config </span><br><span class="line">         = <span class="keyword">new</span> <span class="title class_">MutableConfiguration</span>&lt;&gt;(); <span class="comment">// ③</span></span><br><span class="line">      <span class="comment">// 设置缓存键值类型</span></span><br><span class="line">      config.setTypes(String.class, UserInfo.class);</span><br><span class="line">      <span class="comment">// 创建一个JCache对象，键值为&quot;user_&quot;+id</span></span><br><span class="line">      cacheInstance = cacheManager.createCache(<span class="string">&quot;user_&quot;</span> + id, config);<span class="comment">// ④</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cacheInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要用来处理Ecache的逻辑，获取一个缓存实例。代码①处是获取JCache实现方法的具体提供者（CachingProvider，Ecache所提供的具体类是org.ehcache.jsr107.EhcacheCachingProvider），注意，这个方法只适合只有一个JEcache实现方案上下文的环境。再看被注释掉的代码，也就是代码②处，它是通过具体的类名获取缓存提供者，所以它适合在有多个JEcache实现方案上下文的环境中使用。然后通过缓存提供者获取缓存管理器（CacheManager），有了缓存管理器就可以尝试获取键为”user_”+id的缓存实例了，如果获取失败，则创建一个缓存实例。创建缓存实例的难点在于配置，看代码③处，它可以配置缓存键值类型、超时时间和其他规则。最后代码④处创建缓存实例，将缓存实例返回给调用者，结束方法逻辑。</p>
<p>下面到展示使用Resilience4j缓存的时候了，同样在R4jFacadeImpl中加入代码清单6-19所示的代码。</p>
<p>代码清单6-19 使用Resilience4j缓存（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">cacheUserInfo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取名称为【&quot;user_&quot;+id】的缓存</span></span><br><span class="line">   javax.cache.Cache&lt;String, UserInfo&gt; cacheInstance = getCacheInstance(id);</span><br><span class="line">   <span class="comment">// 通过Resilience4j的Cache捆绑JCache的缓存实例</span></span><br><span class="line">   <span class="comment">// 此处的Cache类全限定名为io.github.resilience4j.cache.Cache</span></span><br><span class="line">   <span class="comment">// 和getCacheInstance方法的javax.cache.Cache不同</span></span><br><span class="line">   Cache&lt;String, UserInfo&gt; cache = Cache.of(cacheInstance); <span class="comment">// ①</span></span><br><span class="line">   <span class="comment">// 描述事件</span></span><br><span class="line">   CheckedFunction1&lt;String, UserInfo&gt; cachedFunction  </span><br><span class="line">      = Cache.decorateCheckedSupplier(cache, () -&gt; reqUser(id)); <span class="comment">// ②</span></span><br><span class="line">   <span class="comment">// 获取结果，先从缓存获取，键为【&quot;user_&quot;+id】，失败则从执行请求逻辑</span></span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> Try.of(() -&gt; cachedFunction.apply(<span class="string">&quot;user_&quot;</span> + id)).get();</span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要是执行业务逻辑。首先获取Ecache缓存的实例（键为”user<em>“+id），然后使用①处的代码和Resilience4j的缓存（Cache）进行捆绑。跟着在②处描述事件，这里使用的是CheckedFunction1类，它有两个泛型，正好对应缓存的键和值的类型。最后再用Try进行请求结果，在之前的组件中，相信大家对此已经比较熟悉了，只是这里apply方法的参数是键”user</em>“ + id，意味着尝试从缓存中读取数据。</p>
<h4 id="6-5-2-拾遗"><a href="#6-5-2-拾遗" class="headerlink" title="6.5.2 拾遗"></a>6.5.2 拾遗</h4><p>同样，缓存也有度量，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.github.resilience4j.cache.Cache.<span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> cache.getMetrics();</span><br><span class="line"><span class="comment">// 获取缓存命中的次数</span></span><br><span class="line">metrics.getNumberOfCacheHits();</span><br><span class="line"><span class="comment">// 获取缓存未命中的次数</span></span><br><span class="line">metrics.getNumberOfCacheMisses();</span><br></pre></td></tr></table></figure>
<p>当然，缓存也有事件可以监听。在缓存中存在命中（CACHE_HIT）、未命中（CACHE_MISS）和错误（ERROR）3种类型的事件，也可以通过onEvent方法对所有事件进行监听，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cache.getEventPublisher()</span><br><span class="line">   <span class="comment">// 缓存命中事件</span></span><br><span class="line">    .onCacheHit(evt-&gt; System.out.println(<span class="string">&quot;命中&quot;</span>))</span><br><span class="line">    <span class="comment">// 缓存未命中事件</span></span><br><span class="line">    .onCacheMiss(evt-&gt;System.out.println(<span class="string">&quot;未命中&quot;</span>))</span><br><span class="line">    <span class="comment">// 错误事件</span></span><br><span class="line">    .onError(evt-&gt; System.out.println(<span class="string">&quot;出现错误&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性监听所有事件，可通过类型区分具体事件</span></span><br><span class="line">cache.getEventPublisher().onEvent(evt-&gt;&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">evtName</span> <span class="operator">=</span> evt.getEventType().name();</span><br><span class="line">    System.out.println(<span class="string">&quot;事件类型名称&quot;</span>+ evtName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-6-时间限制器（TimeLimiter）"><a href="#6-6-时间限制器（TimeLimiter）" class="headerlink" title="6.6 时间限制器（TimeLimiter）"></a>6.6 时间限制器（TimeLimiter）</h3><p>在Hystrix中，在超时之后，就会进入降级服务。但在Resilience4j中，超时则是由时间限制器（TimeLimiter）来实现的。和之前的组件一样，时间限制器也有自己的配置（TimeLimiterConfig），通过配置可以很容易地创建时间限制器。要使用时间限制器，首先需要创建时间限制器配置（TimeLimiterConfig），为此在类ProductApplication中加入代码清单6-20所示的代码。</p>
<p>代码清单6-20 创建时间限制器配置（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;timeLimiter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> TimeLimiterConfig <span class="title function_">initTimeLimiterConfig</span><span class="params">()</span>  &#123;</span><br><span class="line">   <span class="type">TimeLimiterConfig</span> <span class="variable">timeLimiterConfig</span> <span class="operator">=</span> TimeLimiterConfig.custom()</span><br><span class="line">       <span class="comment">// 配置调用超时时间，默认值为1秒</span></span><br><span class="line">       .timeoutDuration(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">       <span class="comment">// 设置线程是否可中断将来再运行，默认值为true</span></span><br><span class="line">       .cancelRunningFuture(<span class="literal">false</span>)</span><br><span class="line">       .build();</span><br><span class="line">   <span class="keyword">return</span> timeLimiterConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑主要是配置，其中timeoutDuration方法配置的是一个超时时间，默认值为1秒。cancelRunningFuture方法配置的是线程是否可中断将来再运行。这样配置器就配置完了。跟着让我们在R4jFacadeImpl中编写使用时间限制器的逻辑，如代码清单6-21所示。</p>
<p>代码清单6-21 使用时间限制器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 时间限制配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">TimeLimiterConfig</span> <span class="variable">timeLimiterConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">timeout</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 创建事件限制器</span></span><br><span class="line">   <span class="type">TimeLimiter</span> <span class="variable">timeLimiter</span> <span class="operator">=</span> TimeLimiter.of(timeLimiterConfig); <span class="comment">// ①</span></span><br><span class="line">   <span class="comment">// 采用单线程</span></span><br><span class="line">   <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">   <span class="comment">// 创建Supplier对象，并描述Supplier事件逻辑</span></span><br><span class="line">   Supplier&lt;Future&lt;ResultMessage&gt;&gt; futureSupplier = <span class="comment">// ②</span></span><br><span class="line">      <span class="comment">// submit方法，提交任务执行并等待返回结果</span></span><br><span class="line">      () -&gt; executorService.submit(()-&gt;&#123;</span><br><span class="line">         <span class="comment">// 不使用注入的RestTemplate，因为不想启用Ribbon的超时机制</span></span><br><span class="line">         <span class="type">RestTemplate</span> <span class="variable">restTmpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">         <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:6001/hystrix/timeout&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> restTmpl.getForObject(url, ResultMessage.class);</span><br><span class="line">      &#125;);</span><br><span class="line">   <span class="comment">// 时间限制器捆绑事件</span></span><br><span class="line">   Callable&lt;ResultMessage&gt; callable <span class="comment">// ③</span></span><br><span class="line">      = TimeLimiter.decorateFutureSupplier(timeLimiter, futureSupplier);</span><br><span class="line">   <span class="comment">// 获取结果</span></span><br><span class="line">   Try&lt;ResultMessage&gt; result = Try.of(() -&gt; callable.call())</span><br><span class="line">      <span class="comment">// 降级逻辑</span></span><br><span class="line">      .recover(ex-&gt;<span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">false</span>, <span class="string">&quot;执行超时&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，①处是通过配置来创建时间限制器。然后通过线程池的执行方式创建单线程池。②处是描述事件，创建一个Supplier<Future\<ResultMessage>&gt;对象，这段代码有点复杂，这里分两步进行分析。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●首先，executorService的submit方法返回的是一个Future<span class="language-xml"><span class="tag">&lt;<span class="name">ResultMessage</span>&gt;</span></span>接口对象，它的参数是一个Callable<span class="language-xml"><span class="tag">&lt;<span class="name">ResultMessage</span>&gt;</span></span>对象，该对象有一个用来描述事件的call定义，只是这里写作了Lambda表达式，所以看起来较为简洁。</span><br><span class="line">●其次，要创建Supplier<span class="language-xml">&lt;Future<span class="tag">&lt;<span class="name">ResultMessage</span>&gt;</span></span>&gt;对象，就要覆盖它的get方法。get方法返回的是Future<span class="language-xml"><span class="tag">&lt;<span class="name">ResultMessage</span>&gt;</span></span>类型的结果，这正好和executorService的submit方法返回的一致，所以依此写为Lambda表达式。</span><br></pre></td></tr></table></figure>
<p>在代码③处，将时间限制器与事件进行了绑定，这样就可以给事件加入时间限制了。最后通过Try对象来获取结果，这也是之前讨论过的，这里就不再赘述了。</p>
<h3 id="6-7-组件混用"><a href="#6-7-组件混用" class="headerlink" title="6.7 组件混用"></a>6.7 组件混用</h3><p>在本章的各节中，已经介绍了最基本的Resilience4j组件。但实际上，还需要考虑各个组件的混用，例如，一个调用可以存在断路器、限速器、舱壁隔离和限时器等。本节就来讲这些组件的混用。首先从一段可运行的代码开始，如代码清单6-22所示。</p>
<p>代码清单6-22 混用组件（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合使用组件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">mixUserInfo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 断路器</span></span><br><span class="line">   <span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span> </span><br><span class="line">       <span class="operator">=</span> circuitBreakerRegistry.circuitBreaker(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="comment">// 具体事件</span></span><br><span class="line">   Callable&lt;UserInfo&gt; call = () -&gt; reqUser(id);</span><br><span class="line">   <span class="comment">// 断路器绑定事件</span></span><br><span class="line">   Callable&lt;UserInfo&gt; call1 = CircuitBreaker.decorateCallable(circuitBreaker, call);</span><br><span class="line">   <span class="comment">// 舱壁</span></span><br><span class="line">   <span class="type">Bulkhead</span> <span class="variable">bulkhead</span> <span class="operator">=</span> bulkheadRegistry.bulkhead(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="comment">// 舱壁捆绑断路器逻辑</span></span><br><span class="line">   Callable&lt;UserInfo&gt; call2 = Bulkhead.decorateCallable(bulkhead, call1);</span><br><span class="line">   <span class="comment">// 获取或创建限速器</span></span><br><span class="line">   <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateLimiterRegistry.rateLimiter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="comment">// 限速器捆绑舱壁事件</span></span><br><span class="line">   Callable&lt;UserInfo&gt; call3 = RateLimiter.decorateCallable(rateLimiter, call2);</span><br><span class="line">   <span class="comment">// 重试机制</span></span><br><span class="line">   <span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> retryRegistry.retry(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   <span class="comment">// 重试捆绑事件 </span></span><br><span class="line">   Callable&lt;UserInfo&gt; call4 = Retry.decorateCallable(retry, call3);</span><br><span class="line">   <span class="comment">// 获取名称为&quot;user_&quot;+id的缓存实例</span></span><br><span class="line">   javax.cache.Cache&lt;String, UserInfo&gt; cacheInstance = getCacheInstance(id);</span><br><span class="line">   Cache&lt;String, UserInfo&gt; cache = Cache.of(cacheInstance); </span><br><span class="line">   <span class="comment">// 缓存捆绑限速事件</span></span><br><span class="line">   CheckedFunction1&lt;String, UserInfo&gt; cacheFunc = Cache.decorateCallable(cache, call4);</span><br><span class="line">   <span class="comment">// 创建事件限制器</span></span><br><span class="line">   <span class="type">TimeLimiter</span> <span class="variable">timeLimiter</span> <span class="operator">=</span> TimeLimiter.of(timeLimiterConfig);</span><br><span class="line">   <span class="comment">// 采用单线程池</span></span><br><span class="line">   <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">   <span class="comment">// 描述限时事件</span></span><br><span class="line">   Supplier&lt;Future&lt;UserInfo&gt;&gt; supplier </span><br><span class="line">      = () -&gt; executorService.submit(()-&gt; &#123;</span><br><span class="line">         <span class="type">UserInfo</span> <span class="variable">cacheResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            cacheResult = cacheFunc.apply(<span class="string">&quot;user_&quot;</span>+id);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cacheResult;</span><br><span class="line">      &#125;);</span><br><span class="line">   <span class="comment">// 限时器捆绑缓存事件</span></span><br><span class="line">   Callable&lt;UserInfo&gt; call5 = TimeLimiter.decorateFutureSupplier(timeLimiter, supplier);</span><br><span class="line">   <span class="comment">// 获取结果</span></span><br><span class="line">   Try&lt;UserInfo&gt; result = Try.of(() -&gt; call5.call())</span><br><span class="line">      <span class="comment">// 降级逻辑</span></span><br><span class="line">      .recover(ex-&gt; <span class="keyword">new</span> <span class="title class_">UserInfo</span>(ERROR_ID, <span class="string">&quot;&quot;</span>, ex.getMessage()));</span><br><span class="line">   <span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中使用了Resilience4j所有常用的组件，包括断路器、限速器、舱壁隔离、重试器、缓存和限时器，这些组件在上述各节已经介绍过了。代码的逻辑核心是5个Callable\<UserInfo>对象，几乎每一个组件的事件都是通过Callable\<UserInfo>来描述的，然后通过层层的传递，将上一个组件的事件传递到下一个组件，从而完成启用所有组件的功能。</p>
<h3 id="6-8-使用Spring-Boot-2的配置方式"><a href="#6-8-使用Spring-Boot-2的配置方式" class="headerlink" title="6.8 使用Spring Boot 2的配置方式"></a>6.8 使用Spring Boot 2的配置方式</h3><p>上面都是通过代码的方式来创建断路器和限速器等Resilience4j核心组件，当然也可以使用Spring Boot的配置方式进行使用。下面我们就对配置的方式进行介绍。不过resilience4j-spring-boot2当前只支持断路器（CircuitBreaker）和限速器（RateLimiter）的配置，所以在开始介绍之前，需要先删除（或注释掉）创建Resilience4j断路器注册机的方法（initCircuitBreakerRegistry）和创建Resilience4j限速器注册机的方法（initRateLimiterRegistry）。然后修改启动类ProductApplication，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.spring.cloud.product&quot;</span></span><br><span class="line"><span class="meta">   // 排除Resilience4j Spring Boot stater自动装配类</span></span><br><span class="line"><span class="meta">   /* </span></span><br><span class="line"><span class="meta">   , exclude = &#123;CircuitBreakerAutoConfiguration.class, </span></span><br><span class="line"><span class="meta">         CircuitBreakerMetricsAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">         RateLimiterAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">         RateLimiterMetricsAutoConfiguration.class</span></span><br><span class="line"><span class="meta">         &#125; </span></span><br><span class="line"><span class="meta">   */ </span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 驱动熔断器</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductApplication</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中注释掉了代码清单6-3中的自动装配类，这样Resilience4j就能以Spring Boot的方式进行配置了。</p>
<h4 id="6-8-1-通过配置创建断路器"><a href="#6-8-1-通过配置创建断路器" class="headerlink" title="6.8.1 通过配置创建断路器"></a>6.8.1 通过配置创建断路器</h4><p>断路器是Resilience4j的核心组件，为此resilience4j-spring-boot2提供了配置的方式，下面我们通过代码清单6-23进行演示。</p>
<p>代码清单6-23 配置断路器（Product模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="comment"># 配置断路器，配置的断路器会注册到断路器注册机（CircuitBreakerRegistry）中</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">backends:</span></span><br><span class="line">      <span class="comment"># 名称为“user”的断路器</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="comment"># 当断路器为关闭状态时，监测环形数组多少位信息，</span></span><br><span class="line">        <span class="comment"># 才重新分析请求结果来确定断路器的状态是否改变</span></span><br><span class="line">        <span class="attr">ring-Buffer-size-in-closed-state:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当断路器为打开状态时，监测环形数组多少位信息，</span></span><br><span class="line">        <span class="comment"># 才重新分析请求结果来确定断路器的状态是否改变</span></span><br><span class="line">        <span class="attr">ring-buffer-size-in-half-open-state:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当断路器为打开状态时，等待多少时间（单位毫秒），</span></span><br><span class="line">        <span class="comment"># 转变为半打开状态，默认为60秒</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 当请求失败比例达到30%时，打开断路器，默认为50%</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">30</span></span><br><span class="line">        <span class="comment"># 是否注册metrics监控</span></span><br><span class="line">        <span class="attr">register-health-indicator:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 名称为“product”的断路器</span></span><br><span class="line">      <span class="attr">product:</span></span><br><span class="line">        <span class="comment"># 当断路器为关闭状态时，监测环形数组多少位信息，</span></span><br><span class="line">        <span class="comment"># 才重新分析请求结果来确定断路器的状态是否改变</span></span><br><span class="line">        <span class="attr">ring-Buffer-size-in-closed-state:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当断路器为打开状态时，监测环形数组多少位信息，</span></span><br><span class="line">        <span class="comment"># 才重新分析请求结果来确定断路器的状态是否改变</span></span><br><span class="line">        <span class="attr">ring-buffer-size-in-half-open-state:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当断路器为打开状态时，等待多少时间（单位毫秒），</span></span><br><span class="line">        <span class="comment"># 转变为半打开状态，默认为60秒</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 当请求失败比例达到30%时，打开断路器，默认为50%</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">30</span></span><br><span class="line">        <span class="comment"># 是否注册metrics监控</span></span><br><span class="line">        <span class="attr">register-health-indicator:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这段代码比较长，我也在代码中添加了详尽的注释，请自行参考。注意加粗的代码，就可以知道配置了两个断路器，名称分别为“user”和“product”。这两个断路器都会注册到断路器注册机（CircuitBreakerRegistry）中，而断路器注册机是Spring Boot自动帮助我们配置的，因此可以采用“拿来主义”获取断路器。下面让我们演示使用的场景，如代码清单6-24所示。</p>
<p>代码清单6-24 使用配置的断路器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.facade.impl;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">ConfigFacade</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 断路器注册机</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">CircuitBreakerRegistry</span> <span class="variable">circuitBreakerRegistry</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> UserInfo <span class="title function_">getUserWithCircuitBreaker</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="comment">// 从断路器注册机中获取“user”断路器</span></span><br><span class="line">      <span class="type">CircuitBreaker</span> <span class="variable">userCircuitBreaker</span> </span><br><span class="line">             <span class="operator">=</span> circuitBreakerRegistry.circuitBreaker(<span class="string">&quot;user&quot;</span>); <span class="comment">// ②</span></span><br><span class="line">      <span class="comment">// 描述事件</span></span><br><span class="line">      CheckedFunction0&lt;UserInfo&gt; decoratedSupplier =</span><br><span class="line">             CircuitBreaker.decorateCheckedSupplier(</span><br><span class="line">             userCircuitBreaker, ()-&gt;reqUser(id));</span><br><span class="line">      <span class="comment">// 发送事件</span></span><br><span class="line">      Try&lt;UserInfo&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">             <span class="comment">// 如果发生异常，则执行降级方法</span></span><br><span class="line">             .recover(ex -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(Long.MIN_VALUE, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">             &#125;);</span><br><span class="line">      <span class="comment">// 返回结果</span></span><br><span class="line">      <span class="keyword">return</span> result.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Ribbon服务调用</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo <span class="title function_">reqUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://USER/user/info/&#123;id&#125;&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;获取用户&quot;</span> + id);</span><br><span class="line">      <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, UserInfo.class, id);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里省略了接口ConfigFacade的定义，相信声明也比较简单，就不再赘述了。代码①处进行了断路器注册机（CircuitBreakerRegistry）的注入，这个对象是Spring Boot为我们自动装配的，所以可以拿来就用。代码②处，是从断路器注册机中获取我们配置的名为“user”的断路器，这样就可以直接使用了。</p>
<h4 id="6-8-2-通过配置创建限速器"><a href="#6-8-2-通过配置创建限速器" class="headerlink" title="6.8.2 通过配置创建限速器"></a>6.8.2 通过配置创建限速器</h4><p>除了可以配置断路器，通过resilience4j-spring-boot2，还可以配置限速器。下面我们通过代码清单6-25进行学习。</p>
<p>代码清单6-25 配置限速器（Product模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="comment"># 限速器</span></span><br><span class="line">  <span class="attr">ratelimiter:</span></span><br><span class="line">    <span class="comment"># 配置限速器，配置的限速器会注册到限速器注册机（RateLimiterRegistry）中</span></span><br><span class="line">    <span class="attr">limiters:</span></span><br><span class="line">      <span class="comment"># 名称为“user”的限速器</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="comment"># 时间戳内限制通过的请求数，默认为50个</span></span><br><span class="line">        <span class="attr">limitForPeriod:</span> <span class="number">60</span></span><br><span class="line">        <span class="comment"># 配置时间戳（单位毫秒），默认值为500 ns</span></span><br><span class="line">        <span class="attr">limitRefreshPeriodInMillis:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">timeoutInMillis:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 是否注册监控指标</span></span><br><span class="line">        <span class="attr">registerHealthIndicator:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 事件消费环形位缓冲区位数</span></span><br><span class="line">        <span class="attr">eventConsumerBufferSize:</span> <span class="number">50</span></span><br><span class="line">      <span class="comment"># 名称为“product”的限速器</span></span><br><span class="line">      <span class="attr">product:</span></span><br><span class="line">        <span class="comment"># 时间戳内限制通过的请求数，默认为50个</span></span><br><span class="line">        <span class="attr">limitForPeriod:</span> <span class="number">30</span></span><br><span class="line">        <span class="comment"># 配置时间戳（单位毫秒）。默认值为500 ns</span></span><br><span class="line">        <span class="attr">limitRefreshPeriodInMillis:</span> <span class="number">3000</span></span><br><span class="line">        <span class="comment"># 超时时间</span></span><br><span class="line">        <span class="attr">timeoutInMillis:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>代码中已经进行了详尽的注释，请自行参考。注意加粗的代码，可以看到声明了两个限速器，名称分别为”user”和”product”。在Spring Boot中，它会默认将限速器注册机（RateLimiterRegistry）装配到IoC容器中，并且将这两个限速器注册在内，所以通过这层关系也可以类似配置断路器那样使用配置限速器。下面让我们演示使用的场景，在类ConfigFacadeImpl中加入代码清单6-26所示的代码。</p>
<p>代码清单6-26 使用配置的限速器（Product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限速器注册机</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RateLimiterRegistry</span> <span class="variable">rateLimiterRegistry</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUserWithRatelimiter</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   <span class="comment">// 从限速器注册机中获取&quot;user&quot;限速器</span></span><br><span class="line">   <span class="type">RateLimiter</span> <span class="variable">userRateLimiter</span> </span><br><span class="line">         <span class="operator">=</span> rateLimiterRegistry.rateLimiter(<span class="string">&quot;user&quot;</span>); <span class="comment">// ②</span></span><br><span class="line">   <span class="comment">// 描述事件</span></span><br><span class="line">   CheckedFunction0&lt;UserInfo&gt; decoratedSupplier =</span><br><span class="line">          RateLimiter.decorateCheckedSupplier(</span><br><span class="line">          userRateLimiter, ()-&gt;reqUser(id));</span><br><span class="line">   <span class="comment">// 发送事件</span></span><br><span class="line">   Try&lt;UserInfo&gt; result = Try.of(decoratedSupplier)</span><br><span class="line">          <span class="comment">// 如果发生异常，则执行降级方法</span></span><br><span class="line">          .recover(ex -&gt; &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(Long.MIN_VALUE, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">   <span class="comment">// 返回结果</span></span><br><span class="line">   <span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中①处，先获取IoC容器中的限速器注册机。代码②处是获取注册机里名为”user”的限速器，这是我们自己配置的限速器。通过这样就能使用配置的限速器了。</p>
<h2 id="第7章-声明式调用——OpenFeign"><a href="#第7章-声明式调用——OpenFeign" class="headerlink" title="第7章 声明式调用——OpenFeign"></a>第7章 声明式调用——OpenFeign</h2><p>本书从第3章到第6章，介绍了微服务的核心内容：服务治理、服务调用（Ribbon）和熔断器（Hystrix和Resilience4j）。这些都是微服务的利器，只是从开发者的角度来说，和我们打交道最多的是服务调用和熔断器。服务调用使得多个微服务可以通过相互调用，为同一个业务服务。熔断器则可以在很大的程度上保证服务调用。但是严格来讲，Ribbon使用REST请求方式编写还是比较麻烦的，对于开发者也不算友好，因此在REST请求方式的基础上，一些开发者又提供了接口声明方式的调用，例如，我们本章要介绍的GitHub OpenFeign就是这样的。</p>
<p>GitHub OpenFeign是一种声明式调用，我们只需要按照一定的规则描述我们的接口，它就能帮我们完成REST风格的调用，大大减少代码的编写量，提高代码的可读性。注意，这里谈到的GitHub OpenFeign是一个第三方组件，为了降低开发者的学习成本，Spring Cloud将GitHub OpenFeign封装后，给出的规则完全采用了Spring MVC的风格，也就是只要开发者熟悉Spring MVC，就能很轻松地完成接口的描述，完成服务调用的功能，而不必学习GitHub OpenFeign自身的声明规则。</p>
<p>Spring Cloud提供了对GitHub OpenFeign的封装，那就是spring-cloud-starter-openfeign（为了简便，本书在没有歧义的情况下，一律将其简称为OpenFeign）。只是这个Starter包含了对Ribbon和Hystrix的支持，注意，只是对Hystrix的支持，而不包含Hystrix本身，所以要使用Hystrix，还需要自己引入Hystrix的依赖。之所以引入Ribbon，是因为OpenFeign的底层就是通过Ribbon来实现的。而引入对Hystrix的支持，是为了让微服务之间的调用支持熔断的功能。另外，因为Hystrix不再更新功能，在不久的将来Spring Cloud还会引入Resilience4j，所以本章也会谈到Resilience4j和OpenFeign相结合的问题。</p>
<p>这里我将通过使用资金微服务调用用户微服务来介绍OpenFeign的使用。有了上述的介绍，大家可以知道，首先需要导入OpenFeign和Hystrix的依赖，所以在资金微服务的Maven依赖上加入代码清单7-1所示的代码。</p>
<p>代码清单7-1 加入Feign和Hystrix（Fund模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖feign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 依赖hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有了这些，就可以通过Feign的声明式来完成Ribbon的调用了。一切还是从一个简单的例子开始。</p>
<h3 id="7-1-OpenFeign的使用"><a href="#7-1-OpenFeign的使用" class="headerlink" title="7.1 OpenFeign的使用"></a>7.1 OpenFeign的使用</h3><p>也许到现在为止，OpenFeign对你来讲还是有些陌生，但是开发的过程相信你会很熟悉，因为它采用的就是Spring MVC的注解风格。本节打算先介绍OpenFeign的入门实例，让大家先入门。OpenFeign真正的难点在于如何传递参数，所以会再介绍一些常见的传参场景来让大家熟悉OpenFeign的使用。最后再谈一下OpenFeign的继承性和配置。</p>
<h4 id="7-1-1-入门实例"><a href="#7-1-1-入门实例" class="headerlink" title="7.1.1 入门实例"></a>7.1.1 入门实例</h4><p>在之前的章节中，我们的用户微服务提供了两个这样的请求，如表7-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171601918.png" alt="image-20231017160122725"></p>
<p>在Ribbon中，需要使用RestTemplate的方式进行开发。但在OpenFeign中，只需要声明接口，而且风格是Spring MVC方式的。这里将使用实例进行说明，为此创建UserFacade接口，如代码清单7-2所示。</p>
<p>代码清单7-2 声明OpenFeign的客户端接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.facade;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;user&quot;)</span> <span class="comment">// 声明为OpenFeign的客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id -- 用户编号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span>  <span class="comment">// 注意方法和注解的对应选择</span></span><br><span class="line">   <span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userInfo -- 用户</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PutMapping(&quot;/user/info&quot;)</span> <span class="comment">// 注意方法和注解的对应选择</span></span><br><span class="line">   <span class="keyword">public</span> UserInfo <span class="title function_">putUser</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个接口的声明，熟悉Spring MVC的读者定然会觉得是在开发控制器，因为使用的注解风格十分接近，但是这并不是在开发控制器，而是在声明调用接口，区别的重点在于注解。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●@FeignClient(&quot;user&quot;)：表示这个接口是一个OpenFeign的客户端，底层将使用Ribbon执行REST风格调用，配置的&quot;user&quot;是一个微服务的名称，指向用户微服务，也就是准备调用的是用户微服务。●@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)：GetMapping表示使用HTTP的GET请求调用用户微服务，而&quot;/user/info/&#123;id&#125;&quot;则表示URI，其中&quot;&#123;id&#125;&quot;表示参数占位，因此方法中的参数也使用注解@PathVariable(&quot;id&quot;)修改参数id，来和这个占位对应。</span><br><span class="line">●@PutMapping(&quot;/user/info&quot;)： PutMapping表示使用HTTP的PUT请求调用用户微服务，而&quot;/user/info&quot;则表示URI，对于这个请求，需要一个JSON的请求体，因此参数使用@RequestBody修饰UserInfo类型的参数，代表将参数转换为JSON请求体，对该URI进行请求。</span><br></pre></td></tr></table></figure>
<p>有没有觉得和Spring MVC十分相近？这便是OpenFeign的接口风格，它大大地降低了开发者学习的成本。为了测试这个接口，这里来开发一个控制器（FeignController），如代码清单7-3所示。</p>
<p>代码清单7-3 测试OpenFeign接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserFacade</span> <span class="variable">userFacade</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> userFacade.getUser(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;userName&#125;/&#123;note&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, </span></span><br><span class="line"><span class="params">             <span class="meta">@PathVariable(&quot;userName&quot;)</span> String userName, </span></span><br><span class="line"><span class="params">             <span class="meta">@PathVariable(&quot;note&quot;)</span> String note)</span> &#123;</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(id, userName, note);</span><br><span class="line">        <span class="keyword">return</span> userFacade.putUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样控制器就开发好了。但光这样还不行，我们还没有将OpenFeign的客户端接口注入Spring MVC的IoC容器中，因此，还需要修改Spring Boot的启动入口（FundApplication），如代码清单7-4所示。</p>
<p>代码清单7-4 测试OpenFeign接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication( // 扫描装配Bean</span></span><br><span class="line"><span class="meta">   scanBasePackages = &quot;com.spring.cloud.fund&quot;)</span></span><br><span class="line"><span class="meta">@EnableFeignClients( // 扫描装配OpenFeign接口到IoC容器中</span></span><br><span class="line"><span class="meta">   basePackages=&quot;com.spring.cloud.fund&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FundApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(FundApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样控制器就开发好了。但光这样还不行，我们还没有将OpenFeign的客户端接口注入Spring MVC的IoC容器中，因此，还需要修改Spring Boot的启动入口（FundApplication），如代码清单7-4所示。</p>
<p>代码清单7-4 测试OpenFeign接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication( // 扫描装配Bean</span></span><br><span class="line"><span class="meta">   scanBasePackages = &quot;com.spring.cloud.fund&quot;)</span></span><br><span class="line"><span class="meta">@EnableFeignClients( // 扫描装配OpenFeign接口到IoC容器中</span></span><br><span class="line"><span class="meta">   basePackages=&quot;com.spring.cloud.fund&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FundApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(FundApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的核心是注解@EnableFeignClients，使用它的目的是驱动OpenFeign工作并指定扫描包，对带有注解@FeignClient的接口进行扫描，并将它们装配到IoC容器中，这样就能够在Spring的工作环境中使用该接口进行声明式调用了。</p>
<p>在启动相关服务后，在浏览器中请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:7001/feign/user/4</span><br><span class="line">http://localhost:7001/feign/user/3/username3/note3</span><br></pre></td></tr></table></figure>
<p>就可以观测到成功的结果了。</p>
<p>这里要注意的是，OpenFeign的本质是Ribbon调用，因此还是会使用Ribbon的机制实现相关的负载均衡等策略，相关内容参见第4章。只是相对于Ribbon来说，它更为简单，可读性更高，开发的成本也更低，所以我更加建议使用OpenFeign的声明式调用，取代Ribbon的编码式调用。因此，在后续的章节中，我也会以使用OpenFeign的方式为主。</p>
<h4 id="7-1-2-常见的传参场景"><a href="#7-1-2-常见的传参场景" class="headerlink" title="7.1.2 常见的传参场景"></a>7.1.2 常见的传参场景</h4><p>门实例谈到了使用路径和请求体进行传参的场景，事实上，还有其他的常用传参方式。本节将讨论这些常见的传参方式，包括传递请求参数（URI后以“?”开始的请求参数）、请求头和文件参数等。</p>
<p>为了介绍这些传参方式，首先需要编写服务提供者（用户微服务）的代码，为此在UserInfoController中加入代码清单7-5所示的代码。</p>
<p>代码清单7-5 编写服务提供者的代码（User模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  以url?ids=xxx的形式传递参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids -- 参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/infoes2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;UserInfo&gt;&gt; <span class="title function_">findUsers2</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="meta">@RequestParam(&quot;ids&quot;)</span> Long []ids)</span> &#123;</span><br><span class="line">    List&lt;UserInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> </span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(id, <span class="string">&quot;user_name_&quot;</span> + id, <span class="string">&quot;note_&quot;</span> + id);</span><br><span class="line">        userList.add(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    ResponseEntity&lt;List&lt;UserInfo&gt;&gt; response </span><br><span class="line">       = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(userList, HttpStatus.OK);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id -- 使用请求头传递参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/info&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@RequestHeader(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> id != <span class="literal">null</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> success? <span class="string">&quot;传递成功&quot;</span>:<span class="string">&quot;传递失败&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(success, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file -- 文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成败结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(value=&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file != <span class="literal">null</span> &amp;&amp; file.getSize() &gt; <span class="number">0</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> success? <span class="string">&quot;文件传递成功&quot;</span> : <span class="string">&quot;文件传递失败&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(success, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是3个方法的传参方式。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">●findUsers2方法：它采用了URL传参的办法，在地址后面加入参数。●deleteUser方法：它采用了请求头传参的办法，将参数放在了请求头中。●uploadFile方法：它传递的是一个文件，所以在调用它的时候需要给它传递文件。</span><br></pre></td></tr></table></figure>
<p>为了能够对这3个方法进行请求，还需要在资金微服务的OpenFeign客户端接口UserFacade上加入对应的接口声明，如代码清单7-6所示。</p>
<p>代码清单7-6 写OpenFeign客户端接口声明调用用户微服务（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id数组获取用户列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids -- 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/infoes2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;UserInfo&gt;&gt; <span class="title function_">findUsers2</span><span class="params">(</span></span><br><span class="line"><span class="params">   // <span class="meta">@RequestParam</span>代表请求参数</span></span><br><span class="line"><span class="params">   <span class="meta">@RequestParam(&quot;ids&quot;)</span> Long []ids)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户信息，使用请求头传参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id -- 用户编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成败结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/user/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">deleteUser</span><span class="params">(</span></span><br><span class="line"><span class="params">   // <span class="meta">@RequestHeader</span>代表请求头传参</span></span><br><span class="line"><span class="params">   <span class="meta">@RequestHeader(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递文件流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file -- 文件流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成败结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/upload&quot;,</span></span><br><span class="line"><span class="meta">   // MediaType.MULTIPART_FORM_DATA_VALUE</span></span><br><span class="line"><span class="meta">   // 说明提交一个&quot;multipart/form-data&quot;类型的表单</span></span><br><span class="line"><span class="meta">   consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> ResultMessage <span class="title function_">uploadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">   // <span class="meta">@RequestPart</span>代表传递文件流</span></span><br><span class="line"><span class="params">   <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file)</span>;</span><br></pre></td></tr></table></figure>
<p>通过入门实例，相信大家对@GetMapping、@PostMapping和@DeleteMapping的含义已经比较了解了，它们是在定义HTTP请求的URI和方法。所以这里就只着重分析参数的声明。先看一下findUsers2方法，它采用的是请求参数的方式传参，因此只需要声明注解@RequestParam即可。再看到deleteUser方法，可以看到，它的参数上标注了@RequestHeader，代表以请求头传递参数。最后来看uploadFile方法，它标注了注解@PostMapping，并且将配置项consumes声明为了”multipart/form-data”，这样，OpenFeign就能用文件表单向用户微服务提交请求，传递文件流了。这里配置项consumes是必须配置的。文件流参数标注@RequestPart，就能传递文件了，只是传递文件这样的方式性能比较低下，在没有必要的情况下，开发者应该尽可能避免这样的设计。</p>
<h4 id="7-1-3-OpenFeign客户端接口的继承"><a href="#7-1-3-OpenFeign客户端接口的继承" class="headerlink" title="7.1.3 OpenFeign客户端接口的继承"></a>7.1.3 OpenFeign客户端接口的继承</h4><p>OpenFeign客户端接口还可以提供继承的功能。现在对原有的UserFacade进行修改，大致如代码清单7-7所示。</p>
<p>代码清单7-7 改造UserFacade接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.facade;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="comment">// 此处删除注解@FeignClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFacade</span>  &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id -- 用户编号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span>  <span class="comment">// 注意方法和注解的对应选择</span></span><br><span class="line">   <span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里唯一的变化是删除了@FeignClient，此时，该接口不会再被扫描为OpenFeign的客户端接口了。接下来，再新建一个接口来扩展它，如代码清单7-8所示。</p>
<p>代码清单7-8 改造UserFacade接口（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.client;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@FeignClient(value=&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 此处继承UserFacade，那么OpenFeign定义的方法也能继承下来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> <span class="keyword">extends</span> <span class="title class_">UserFacade</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里UserClient扩展了UserFacade，并且因为标注了@FeignClient，会被OpenFeign机制扫描成OpenFeign的客户端，它所继承的UserFacade方法也会被OpenFeign扫描，成为可以调用远程服务器的方法。</p>
<p>这时让我们换一个角度进行思考，倘若用户微服务（user）的开发者，将接口UserFacade发布到了一个公共的依赖模块中，那么其他微服务的开发者就可以直接通过依赖该公共模块来获取UserFacade，把它当作本地接口，通过继承的方法直接使用它，而不再需要自定义调用方法了。从客观的角度来说，由用户微服务的开发者来维护UserFacade接口是最佳的，因为他们熟悉当中的业务和逻辑，然后再通过详尽的说明（如提供API文档）就可以大大降低其他微服务使用接口的难度了。但是这种模式也有弊端，如果公共的接口需要修改，那么所有的消费者也需要做出对应的修改，尤其是那些使用十分广泛的接口，影响就更大了。</p>
<h4 id="7-1-4-OpenFeign客户端的配置"><a href="#7-1-4-OpenFeign客户端的配置" class="headerlink" title="7.1.4 OpenFeign客户端的配置"></a>7.1.4 OpenFeign客户端的配置</h4><p>配置OpenFeign的方法有很多种，最直观的当属在注解@FeignClient上配置。关于@FeignClient配置项的解释如表7-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171614788.png" alt="image-20231017161426706"></p>
<p>这里的配置项除加粗的3项比较复杂外，其他的相对来说都比较简单，就不再赘述了。在加粗的这3项中，fallback和fallbackFactory是有关Hystrix使用的，我打算放到配置Hystrix时再讨论，所以这里就暂时不讨论了，这里只讨论configuration。</p>
<p>configuration这个配置项的内容是一个标注@Configuration的类，配置它的目的是创建OpenFeign所需的解码器、编码器和协议。严格来讲，GitHub OpenFeign本身是不能支持文件操作的，所以在旧版本中，还需要开发者自行编写OpenFeign的解码器、编码器和协议来对应各种Spring MVC请求类型进行处理。现在已经不需要这样做了，因为在当前版本的OpenFeign中已经提供了这些内容的默认实现。首先，spring-cloud-starter-openfeign会加载feign-form-spring和feign-form的依赖，通过它们Spring可以为我们提供对应OpenFeign的编码器（SpringEncoder）、解码器（OptionalDecoder，这个类是一个代理，实际使用的是ResponseEntityDecoder）和协议（SpringMvcContract）。其次，在OpenFeign的自动配置类的FeignClientsConfiguration中也进行了自动装配，如代码清单7-9所示。</p>
<p>代码清单7-9 FeignClientsConfiguration的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.openfeign;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientsConfiguration</span> &#123;</span><br><span class="line">   <span class="comment">// Spring MVC消息转换器工厂</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line">   <span class="comment">// Spring MVC的参数处理器</span></span><br><span class="line">   <span class="meta">@Autowired(required = false)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;AnnotatedParameterProcessor&gt; </span><br><span class="line">      parameterProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// OpenFeign的参数格式化器</span></span><br><span class="line">   <span class="meta">@Autowired(required = false)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;FeignFormatterRegistrar&gt; </span><br><span class="line">      feignFormatterRegistrars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// OpenFeign解码器</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="keyword">public</span> Decoder <span class="title function_">feignDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptionalDecoder</span>(<span class="keyword">new</span> <span class="title class_">ResponseEntityDecoder</span>(</span><br><span class="line">      <span class="comment">// 先经Spring MVC消息转换器工厂处理</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">SpringDecoder</span>(<span class="built_in">this</span>.messageConverters)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="keyword">public</span> Encoder <span class="title function_">feignEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 先经Spring MVC消息转换器工厂处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringEncoder</span>(<span class="built_in">this</span>.messageConverters);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="keyword">public</span> Contract <span class="title function_">feignContract</span><span class="params">(ConversionService feignConversionService)</span> &#123;</span><br><span class="line">      <span class="comment">// 先经Spring MVC消息转换器工厂处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringMvcContract</span>(</span><br><span class="line">         <span class="built_in">this</span>.parameterProcessors, feignConversionService);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**** 其他代码 ****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以知道，在通过编码器、解码器和协议之前，都会先经Spring MVC消息转换器工厂进行处理，这样OpenFeign就能处理各种各样的Spring MVC请求，从而支持文件解析了。因此，在大部分的情况下，我们使用默认的这些配置就可以了，无须再自定义，如需自定义，通过@FeignClient配置即可。</p>
<p>除了可以在@FeignClient上配置外，OpenFeign还允许我们使用YAML文件进行配置。这些配置是由配置类org.springframework.cloud.openfeign.FeignClientProperties定义的，要求以”feign.client”作为开头，在它的属性中存在一个Map<String,FeignClientConfiguration>类型的属性config，通过它就可以根据需要配置OpenFeign客户端接口。这里要配置的config是一个Map，所以必然有键和值，其中键是微服务名称的字符串，值是一个客户端的配置类FeignClientConfiguration。下面将使用YAML文件配置的形式进行说明，如代码清单7-10所示。</p>
<p>代码清单7-10 使用YAML文件配置OpenFeign客户端接口</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">Client:</span></span><br><span class="line">    <span class="comment"># 默认配置key，默认值为default</span></span><br><span class="line">    <span class="attr">default-config:</span> <span class="string">default</span> <span class="string">//</span> <span class="string">①</span></span><br><span class="line">    <span class="comment"># 是否启用默认的属性配置的机制</span></span><br><span class="line">    <span class="attr">default-to-properties:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">config:</span> <span class="comment"># ②</span></span><br><span class="line">      <span class="comment"># 配置default，启用为全局OpenFeign客户端接口提供默认配置</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># ③ </span></span><br><span class="line">        <span class="comment"># 当发生HTTP的404（无对应的资源）错误时，</span></span><br><span class="line">        <span class="comment"># 是否解码而非抛出FeignExceptions异常</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment"># 读取请求超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 连接远程服务器超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 重试器全限定名（要求是feign.Retryer接口的实现类）</span></span><br><span class="line">        <span class="attr">retryer:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="comment"># OpenFeign协议全限定名（要求是feign.Contract接口的实现类） </span></span><br><span class="line">        <span class="attr">contract:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="comment"># OpenFeign解码器全限定名（要求是feign.codec.Decoder接口的实现类）</span></span><br><span class="line">        <span class="attr">decoder:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="comment"># OpenFeign编码器全限定名（要求是feign.codec.Encoder接口的实现类）</span></span><br><span class="line">        <span class="attr">encoder:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="comment"># 日志级别, 分为4级：</span></span><br><span class="line">        <span class="comment"># 1. NONE: 不记录任何日志（默认值）</span></span><br><span class="line">        <span class="comment"># 2. BASIC:只记录请求方法和URL以及响应状态代码和执行时间，且只记录基本信息以及请求和响应头</span></span><br><span class="line">        <span class="comment"># 3. HEADERS:记录基本信息以及请求和响应头</span></span><br><span class="line">        <span class="comment"># 4. FULL：记录全部请求头和请求体，并记录请求和响应的各类数据</span></span><br><span class="line">        <span class="attr">logger-level:</span> <span class="string">basic</span></span><br><span class="line">        <span class="comment"># OpenFeign调用拦截器， List&lt;Class&lt;RequestInterceptor&gt;&gt;类型，</span></span><br><span class="line">        <span class="comment"># 主要拦截OpenFeign请求，一般可以加入一些请求头</span></span><br><span class="line">        <span class="attr">request-interceptors:</span> <span class="string">xxx,xxx,xxx</span></span><br><span class="line">        <span class="comment"># OpenFeign错误解码器全限定名（要求是feign.codec.ErrorDecoder接口的实现类）</span></span><br><span class="line">        <span class="attr">error-decoder:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="comment"># OpenFeign客户端名称，也是用户微服务名称，</span></span><br><span class="line">       <span class="comment"># 这样就是配置名称为user的OpenFeign客户端</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">//</span> <span class="string">④</span>  </span><br><span class="line">        <span class="comment"># 连接远程服务器超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 执行请求超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>关于配置项，上述注释已经进行了较为详细的说明，所以这里只就重点和难点进行说明。看代码①处，这里配置的是一个键，配置为default，注意，配置项feign.client.config是Map<String, FeignClientConfiguration>类型的，这意味着当它存在键为default的元素时，该元素为全局默认的配置。代码②处显然指向了FeignClientProperties的config配置项，接下来的层级配置的就是feign.client.config这个Map对象，代码③和④处的default和user都是配置项config中元素的键。因为feign.client.default-config的配置为default，所以代码③处的default配置代表的是全局默认配置，而user只是用户微服务的OpenFeign客户端的配置，这是大家需要注意的地方之一。这里的配置虽多，但是实际常用的并不多，对于retryer、contract、decoder、encoder和error-decoder，一般使用OpenFeign为我们默认提供的即可。配置request-interceptors的目的是配置拦截器，而拦截器则需要实现RequestInterceptor接口。例如，现在开发一个拦截器，如代码清单7-11所示。</p>
<p>代码清单7-11 OpenFeign拦截器（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.facade.interceptor;</span><br><span class="line"><span class="comment">/*** imports ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 拦截器的意义在于，根据自己的需要定制RestTemplate和请求参数、请求体等</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  template -- 请求模板</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">      <span class="comment">// 这里只是随意给出一个请求头参数，实践中一般可以传递token参数等</span></span><br><span class="line">      template.header(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然有了拦截器，但是还需要在配置文件中加入配置，才能启用这个拦截器，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># “user”代表用户微服务的OpenFeign客户端</span></span><br><span class="line">      <span class="attr">user:</span> </span><br><span class="line">        <span class="comment"># 连接远程服务器超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 读取请求超时时间（单位毫秒）</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 配置拦截器</span></span><br><span class="line">        <span class="attr">request-interceptors:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">com.spring.cloud.fund.facade.interceptor.UserInterceptor</span></span><br></pre></td></tr></table></figure>
<p>这样拦截器UserInterceptor就能对OpenFeign客户端接口的所有请求进行拦截了。对于request- interceptors配置项来说，可以配置多个拦截器，但是请注意，OpenFeign并不保证拦截器的顺序。</p>
<p>上面是通过YAML文件进行配置，有时候需要特别地指定和处理日志，这时可以使用配置类的方法，也就是用@FeignClient的配置项configuration指定配置文件。那么可以配置些什么内容呢？如表7-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310171616958.png" alt="image-20231017161652873"></p>
<p>注意，表中的“是否自动装配”列，可以看出配置项分成两大类，一类是已经装配的，另一类是未装配的。对于已经装配的，OpenFeign都给出了默认值和对应的Bean名称，这就意味着，当根据自己的需要替换时，应该按照对应的Bean名称进行替换。对于那些未装配的，按照类型编写即可。OpenFeign已经为我们提供了许多默认配置，我们可以拿来就用，如果要替换它们，只要新建对应的Bean即可。下面让我们举例说明，如代码清单7-12所示。</p>
<p>代码清单7-12 使用配置类组装OpenFeign组件（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.facade;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@FeignClient(value=&quot;user&quot;, </span></span><br><span class="line"><span class="meta">   // 指定配置类</span></span><br><span class="line"><span class="meta">   configuration = UserFacade.UserFeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFacade</span> &#123;</span><br><span class="line">   ...... </span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">UserFeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注入Spring MVC消息转换器工厂</span></span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">      <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 此处需要注意， Bean的名称要和默认装配的保持一致</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 编码器</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Bean(name = &quot;feignDecoder&quot;)</span></span><br><span class="line">      <span class="comment">// 设置为&quot;prototype&quot;，代表只对当前客户端使用</span></span><br><span class="line">      <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">      <span class="keyword">public</span> Decoder <span class="title function_">clientDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringDecoder</span>(messageConverters);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  创建拦截器，非自动装配的组件会通过类型查找</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 拦截器</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="comment">// 设置为&quot;prototype&quot;，代表只对当前客户端使用</span></span><br><span class="line">      <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">      <span class="keyword">public</span> RequestInterceptor <span class="title function_">userInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInterceptor</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  日志级别，非自动装配的组件会通过类型查找</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 日志级别</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="comment">// 设置为&quot;prototype&quot;，代表只对当前客户端使用</span></span><br><span class="line">      <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">      Logger.Level <span class="title function_">loggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看一下clientDecoder方法，这里的@Bean重新定义了Bean的名称为”feignDecoder”，与自动装配的保持一致，这样才能覆盖自动装配的Bean。然后又用@Scope将Bean的作用域设置为”prototype”，这说明只对当前的客户端使用，不具备通用的效果。再看userInterceptor和loggerLevel两个方法，@Scope的作用域也声明为了”prototype”，因为这两个不是自动装配的，所以不需要遵循名称的规则，只要类型匹配便可以了。</p>
<p>当然，如果想让这个配置设置为默认全局的OpenFeign客户端配置，可以在注解@EnableFeignClients的配置项defaultConfiguration中配置，并将各个类的作用域删除或者声明为单例。这里还需要将日志级别设置为DEBUG，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
<p>这样运行后就可以看到对应的信息了。</p>
<h4 id="7-1-5-OpenFeign的全局配置"><a href="#7-1-5-OpenFeign的全局配置" class="headerlink" title="7.1.5 OpenFeign的全局配置"></a>7.1.5 OpenFeign的全局配置</h4><p>上一节只是配置了OpenFeign客户端，本节将讲述Feign的全局配置。OpenFeign的全局配置可以配置与是否启动Hystrix、压缩配置和HTTP客户端相关的配置项。这里先谈Hystrix和压缩配置的配置项，下面使用YAML文件配置的形式进行说明，如代码清单7-13所示。</p>
<p>代码清单7-13 OpenFeign的Hystrix和压缩的全局配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment"># Hystrix配置</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="comment"># 是否将OpenFeign调度封装为Hystrix命令，然后通过断路器执行，</span></span><br><span class="line">    <span class="comment"># 默认值为false（旧版本为true）</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 压缩    </span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="comment"># 请求</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="comment"># 是否支持请求GZIP压缩，默认值为false</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># GZIP压缩什么类型，默认值为text/xml,application/xml,application/json</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">      <span class="comment"># 当请求内容大于多少阈值后，进行GZIP压缩请求，默认值为2048（单位KB）</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">4096</span></span><br><span class="line">    <span class="comment"># 响应</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="comment"># 请求响应结果是否允许压缩</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，feign.hystrix.enabled的默认值为false，也就是说，不主动将OpenFeign的调用封装为一个Hystrix命令，这一点和旧版的Hystrix是相反的。关于请求和响应压缩的配置项的内容注释已经比较清晰了，请自行参考。</p>
<p>OpenFeign底层默认使用的是Ribbon，而Ribbon默认使用的是Apache HTTP Client作为底层连接，因此OpenFeign也给出了对应的配置项，如代码清单7-14所示。</p>
<p>代码清单7-14 OpenFeign的Hystrix和压缩的全局配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="comment"># 是否启用Apache HTTP Client作为底层连接（Ribbon的默认方法）</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 尝试连接超时时间</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="number">2000</span></span><br><span class="line">    <span class="comment"># 是否禁止SSL协议验证</span></span><br><span class="line">    <span class="attr">disable-ssl-validation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 连接重新尝试</span></span><br><span class="line">    <span class="attr">connection-timer-repeat:</span> <span class="number">2000</span></span><br><span class="line">    <span class="comment"># 默认最大连接数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">100</span></span><br><span class="line">    <span class="comment"># 单个调用最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">30</span></span><br><span class="line">    <span class="comment"># HttpClient的存活时间，默认为900，单位通过time-to-live-unit配置</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">500</span></span><br><span class="line">    <span class="comment"># HttpClient的存活时间单位，默认为秒（second）</span></span><br><span class="line">    <span class="attr">time-to-live-unit:</span> <span class="string">milliseconds</span></span><br><span class="line">    <span class="comment"># 当HTTP返回码为3xx（重定向）时，是否执行重定向操作，默认为true</span></span><br><span class="line">    <span class="attr">follow-redirects:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>通过这些就可以配置底层的内容了。这里还可以通过将feign.httpclient.enabled设置为false进行禁用。OpenFeign还提供了OK HTTP Client的选择给我们使用，这是一个支持谷歌SPDY协议的客户端，只是SPDY协议随着HTTP/2协议的推出已经被谷歌宣布淘汰。SPDY协议可以有效减少GZIP压缩传输的数据大小，并且提供了缓存功能，提高了调用性能。这里将配置项feign.okhttp.enabled设置为true，意味着OpenFeign将采用OK HTTP Client作为底层连接，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="comment"># 启用Ok HTTP Client，默认值为false</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="comment"># 是否启用Apache HTTP Client作为底层连接</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>此时，OpenFeign提供的自动配置类就会自动为我们装配与OK HTTP Client相关的Bean。可以看类HttpClientConfiguration的源码，它还有一个内部类OkHttpClientConfiguration，如代码清单7-15所示。</p>
<p>代码清单7-15 OpenFeign装配与OK HTTP Client相关的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.commons.httpclient;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientConfiguration</span> &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">          name = &quot;spring.cloud.httpclientfactories.ok.enabled&quot;,</span></span><br><span class="line"><span class="meta">         matchIfMissing = true)</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass(OkHttpClient.class)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OkHttpClientConfiguration</span> &#123;</span><br><span class="line">      <span class="comment">// 装配OK HTTP Client连接池工厂</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">      <span class="keyword">public</span> OkHttpClientConnectionPoolFactory <span class="title function_">connPoolFactory</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultOkHttpClientConnectionPoolFactory</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 装配OK HTTP Client生成器 </span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">      <span class="keyword">public</span> OkHttpClient.Builder <span class="title function_">okHttpClientBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 装配OK HTTP Client连接工厂</span></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">      <span class="keyword">public</span> OkHttpClientFactory <span class="title function_">okHttpClientFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            OkHttpClient.Builder builder)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultOkHttpClientFactory</span>(builder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，工厂、连接池和生成器（OkHttpClient.Builder）都已经自动装配了。一般来说，工厂和连接池都不需要进行改变，如果不进行改变，它就会使用默认的属性。设置属性的工作是在生成器中进行的，所以我们可以自行编写一个Spring Bean来代替okHttpClientBuilder方法，这样就能自定义OK HTTP Client的参数了，例如，在FundApplication中加入代码清单7-16所示的代码。</p>
<p>代码清单7-16 自定义OK HTTP Client的相关参数（Fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OkHttpClient.Builder <span class="title function_">okHttpClientBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">      <span class="comment">// 读取超时时间（不包含解析地址，提交请求的耗时）</span></span><br><span class="line">      .readTimeout(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">      <span class="comment">// 写入超时时间</span></span><br><span class="line">      .writeTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">      <span class="comment">// 连接远程服务器超时时间</span></span><br><span class="line">      .connectTimeout(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">      <span class="comment">// 如果连接远程服务器失败是否重试                </span></span><br><span class="line">      .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">      <span class="comment">// 当HTTP返回码为3xx（重定向）时，是否执行重定向操作</span></span><br><span class="line">      .followRedirects(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是OK HTTP Client并不是一个自动依赖的包，因此还需要我们自行依赖，在pom.xml文件中增加如下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以使用OK HTTP Client了。</p>
<h3 id="7-2-配置Hystrix"><a href="#7-2-配置Hystrix" class="headerlink" title="7.2 配置Hystrix"></a>7.2 配置Hystrix</h3><p>上面我们讲到过，只要将feign.hystrix.enabled配置为true，OpenFeign就会将接口方法的调用包装成一个Hystrix命令，然后采用断路器机制运行，因此本节的学习都需要将该配置项配置为true。</p>
<p>如果将feign.hystrix.enabled配置为true，就会全局使用Hystrix，那么如果想局部不使用该怎么办呢？这里让我们回到代码清单7-12中的内部配置类UserFeignConfig，我们在其当中自定义客户端配置器（Client）即可，如代码清单7-17所示。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/">https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图解HTTP</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Boot从入门到实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2022/10/30/Spring5%E5%9F%BA%E7%A1%80/" title="Spring5基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Spring5基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">第一部分 概述和基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 分布式和微服务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 互联网系统的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 分布式系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%88%87%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 分布式的切分方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">1．水平切分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">2．垂直切分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%B7%B7%E5%90%88%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">3．混合切分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 分布式系统所面临的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 分布式系统的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-CAP%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 CAP原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-BASE%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 BASE理论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2 微服务的风格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">1．组件化和服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9B%B4%E7%BB%95%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%84%E7%BB%87%E5%9B%A2%E9%98%9F"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2．围绕业务功能组织团队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%98%AF%E4%BA%A7%E5%93%81%E8%80%8C%E4%B8%8D%E6%98%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">3．是产品而不是项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E5%BC%BA%E5%8C%96%E7%BB%88%E7%AB%AF%E5%8F%8A%E5%BC%B1%E5%8C%96%E9%80%9A%E9%81%93"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">4．强化终端及弱化通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E5%88%86%E6%95%A3%E6%B2%BB%E7%90%86"><span class="toc-number">1.1.4.2.5.</span> <span class="toc-text">5．分散治理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%8E%E5%88%86%E6%95%A3%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.4.2.6.</span> <span class="toc-text">6．分散数据管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%EF%BC%8E%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">1.1.4.2.7.</span> <span class="toc-text">7．基础设施自动化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%8E%E5%AE%B9%E9%94%99%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.4.2.8.</span> <span class="toc-text">8．容错性设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%EF%BC%8E%E8%AE%BE%E8%AE%A1%E6%94%B9%E8%BF%9B"><span class="toc-number">1.1.4.2.9.</span> <span class="toc-text">9．设计改进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3 微服务和分布式系统的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Spring-Cloud"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-Spring-Cloud%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1 Spring Cloud的各个组件的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-Spring-Cloud%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2 Spring Cloud版本说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A0%B7%E4%BE%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 微服务系统样例简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 技术基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Spring-Boot"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BASpring-Boot%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 创建Spring Boot工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Spring-Boot%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 Spring Boot开发简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%A4%9A%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 多文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%89%93%E5%8C%85%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 打包和运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-Spring-Boot%E7%9B%91%E6%8E%A7"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5 Spring Boot监控</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">第二部分 Spring Cloud微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94Eureka"><span class="toc-number">2.1.</span> <span class="toc-text">第3章 服务治理——Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1 服务治理中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%90%AD%E5%BB%BAEureka%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">3.1.1 搭建Eureka服务治理中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">3.1.2 服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">3.1.3 多个服务治理中心实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Eureka%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.2 Eureka治理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">3.2.1 基础架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">3.2.2 服务治理中心工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">1．微服务实例和服务治理中心的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">2．服务治理中心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.2.2.3.</span> <span class="toc-text">3．微服务之间的相互调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Region%E5%92%8CZone"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">3.2.3 Region和Zone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Eureka%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">3.2.4 Eureka关键源码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-Eureka%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">3.2.5 Eureka使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Eureka%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.3 Eureka配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">3.3.1 客户端服务注册配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">3.3.2 客户端服务实例配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E2%80%94%E2%80%94Ribbon"><span class="toc-number">2.2.</span> <span class="toc-text">第4章 客户端负载均衡——Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.1 负载均衡概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%88%9D%E8%AF%86Ribbon"><span class="toc-number">2.2.2.</span> <span class="toc-text">4.2 初识Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Ribbon%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">4.2.1 Ribbon概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Ribbon%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">4.2.2 Ribbon是如何实现负载均衡的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">4.3 Ribbon负载均衡器和策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">4.3.1 负载均衡器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">4.3.2 负载均衡策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Ribbon%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%B8%85%E5%8D%95%E7%BB%B4%E6%8A%A4"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.4 Ribbon服务实例清单维护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%B8%85%E5%8D%95"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">4.4.1 获取服务实例清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%B8%85%E5%8D%95"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">4.4.2 更新服务实例清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E7%9B%91%E6%B5%8B"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">4.4.3 服务实例的心跳监测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-IPing%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">4.4.4 IPing接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%87%AA%E5%AE%9A%E4%B9%89Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.2.5.</span> <span class="toc-text">4.5 自定义Ribbon客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">4.5.1 全局配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%B1%80%E9%83%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">4.5.2 局部定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Ribbon%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.2.6.</span> <span class="toc-text">4.6 Ribbon使用实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%96%AD%E8%B7%AF%E5%99%A8%E2%80%94%E2%80%94Hystrix"><span class="toc-number">2.3.</span> <span class="toc-text">第5章 断路器——Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">5.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E7%86%94%E6%96%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">5.1.1 熔断的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">5.1.2 服务降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-Hystrix%E7%9A%84%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">5.1.3 Hystrix的功能简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">5.2 入门实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Hystrix%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">5.3 Hystrix工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Hystrix%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">5.3.1 Hystrix命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%96%B0%E6%96%AD%E8%B7%AF%E5%99%A8%E2%80%94%E2%80%94Resilience4j"><span class="toc-number">2.4.</span> <span class="toc-text">第6章 新断路器——Resilience4j</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%88CircuitBreaker%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">6.1 断路器（CircuitBreaker）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E6%96%AD%E8%B7%AF%E5%99%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E5%86%8C%E6%9C%BA"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">6.1.1 断路器配置和注册机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">6.1.2 断路器的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E4%BD%BF%E7%94%A8%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">6.1.3 使用断路器的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">6.1.4 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-%E6%8B%BE%E9%81%97"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">6.1.5 拾遗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%99%90%E9%80%9F%E5%99%A8%EF%BC%88RateLimiter%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">6.2 限速器（RateLimiter）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">6.2.1 使用实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%8B%BE%E9%81%97"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">6.2.2 拾遗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%88%B1%E5%A3%81%E9%9A%94%E7%A6%BB%EF%BC%88Bulkhead%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">6.3 舱壁隔离（Bulkhead）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E4%BD%BF%E7%94%A8%E8%88%B1%E5%A3%81%E9%9A%94%E7%A6%BB"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">6.3.1 使用舱壁隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%8B%BE%E9%81%97"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">6.3.2 拾遗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E9%87%8D%E8%AF%95%E5%99%A8%EF%BC%88Retry%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">6.4 重试器（Retry）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E4%BD%BF%E7%94%A8%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">6.4.1 使用重试机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E6%8B%BE%E9%81%97"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">6.4.2 拾遗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%BC%93%E5%AD%98%EF%BC%88Cache%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">6.5 缓存（Cache）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-%E4%BD%BF%E7%94%A8Resilience4j%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">6.5.1 使用Resilience4j缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-%E6%8B%BE%E9%81%97"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">6.5.2 拾遗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%E5%99%A8%EF%BC%88TimeLimiter%EF%BC%89"><span class="toc-number">2.4.6.</span> <span class="toc-text">6.6 时间限制器（TimeLimiter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E7%BB%84%E4%BB%B6%E6%B7%B7%E7%94%A8"><span class="toc-number">2.4.7.</span> <span class="toc-text">6.7 组件混用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E4%BD%BF%E7%94%A8Spring-Boot-2%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.8.</span> <span class="toc-text">6.8 使用Spring Boot 2的配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BA%E6%96%AD%E8%B7%AF%E5%99%A8"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">6.8.1 通过配置创建断路器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BA%E9%99%90%E9%80%9F%E5%99%A8"><span class="toc-number">2.4.8.2.</span> <span class="toc-text">6.8.2 通过配置创建限速器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94OpenFeign"><span class="toc-number">2.5.</span> <span class="toc-text">第7章 声明式调用——OpenFeign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">7.1 OpenFeign的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">7.1.1 入门实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%A0%E5%8F%82%E5%9C%BA%E6%99%AF"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">7.1.2 常见的传参场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-OpenFeign%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">7.1.3 OpenFeign客户端接口的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-OpenFeign%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">7.1.4 OpenFeign客户端的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-OpenFeign%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.1.5.</span> <span class="toc-text">7.1.5 OpenFeign的全局配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%85%8D%E7%BD%AEHystrix"><span class="toc-number">2.5.2.</span> <span class="toc-text">7.2 配置Hystrix</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/14/redis%E7%9F%A5%E8%AF%86%E7%82%B9/" title="redis知识点"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis知识点"/></a><div class="content"><a class="title" href="/2023/12/14/redis%E7%9F%A5%E8%AF%86%E7%82%B9/" title="redis知识点">redis知识点</a><time datetime="2023-12-14T12:59:31.000Z" title="发表于 2023-12-14 20:59:31">2023-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/14/API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/" title="API开放平台"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="API开放平台"/></a><div class="content"><a class="title" href="/2023/12/14/API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/" title="API开放平台">API开放平台</a><time datetime="2023-12-14T06:46:44.000Z" title="发表于 2023-12-14 14:46:44">2023-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="github搜索技巧"/></a><div class="content"><a class="title" href="/2023/12/10/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" title="github搜索技巧">github搜索技巧</a><time datetime="2023-12-10T12:59:37.000Z" title="发表于 2023-12-10 20:59:37">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="伙伴匹配系统"/></a><div class="content"><a class="title" href="/2023/12/10/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/" title="伙伴匹配系统">伙伴匹配系统</a><time datetime="2023-12-10T05:50:00.000Z" title="发表于 2023-12-10 13:50:00">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码托管怎么搞"/></a><div class="content"><a class="title" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞">代码托管怎么搞</a><time datetime="2023-12-09T01:20:35.000Z" title="发表于 2023-12-09 09:20:35">2023-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>