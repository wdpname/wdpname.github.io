<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring Cloud微服务和分布式系统实践 | 平博社</title><meta name="keywords" content="Java"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第一部分 概述和基础本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。 本部分包含以下内容： ●分布式和微服务概述； ●技术基础。 第1章 分布式和微服务概述1.1 互联网系统的特征在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Cloud微服务和分布式系统实践">
<meta property="og:url" content="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第一部分 概述和基础本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。 本部分包含以下内容： ●分布式和微服务概述； ●技术基础。 第1章 分布式和微服务概述1.1 互联网系统的特征在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-13T10:57:16.000Z">
<meta property="article:modified_time" content="2023-10-15T15:34:43.446Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Cloud微服务和分布式系统实践',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-15 23:34:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">160</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Cloud微服务和分布式系统实践</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T10:57:16.000Z" title="发表于 2023-10-13 18:57:16">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-15T15:34:43.446Z" title="更新于 2023-10-15 23:34:43">2023-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Cloud微服务和分布式系统实践"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第一部分-概述和基础"><a href="#第一部分-概述和基础" class="headerlink" title="第一部分 概述和基础"></a>第一部分 概述和基础</h1><p>本部分将讲解分布式和微服务的基础知识和理念，并且简单介绍本书需要用到的基础知识。</p>
<p>本部分包含以下内容：</p>
<p>●分布式和微服务概述；</p>
<p>●技术基础。</p>
<h2 id="第1章-分布式和微服务概述"><a href="#第1章-分布式和微服务概述" class="headerlink" title="第1章 分布式和微服务概述"></a>第1章 分布式和微服务概述</h2><h3 id="1-1-互联网系统的特征"><a href="#1-1-互联网系统的特征" class="headerlink" title="1.1 互联网系统的特征"></a>1.1 互联网系统的特征</h3><p>在大数据、高并发和快响应的要求下，单机系统已经不可能满足现今互联网了。为了满足互联网的苛刻要求，网站系统已经从单机系统发展为多台机器协作的系统，因而互联网系统已经从单机系统演变为多台机器的系统，我们把这种多台机器相互协作完成企业业务功能的系统，称为分布式系统。</p>
<h3 id="1-2-分布式系统概述"><a href="#1-2-分布式系统概述" class="headerlink" title="1.2 分布式系统概述"></a>1.2 分布式系统概述</h3><p>分布式系统由一组为了完成共同任务而协调工作的计算机节点组成，它们通过网络进行通信。分布式系统能满足互联网对大数据存储、高并发和快响应的要求，采用了分而治之的思想。从实际成本来说，可以使用廉价的普通机器进行独立运算。然后通过相互协助来完成网站业务，这样就可以完成单个计算机节点无法完成的计算和存储任务了。为了让大家能够更好地了解分布式系统的好处，这里先给出一个简易的分布式架构，如图1-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141444580.png" alt="image-20231014144436444"></p>
<h4 id="1-2-1-分布式的切分方法"><a href="#1-2-1-分布式的切分方法" class="headerlink" title="1.2.1 分布式的切分方法"></a>1.2.1 分布式的切分方法</h4><p>使用分布式系统，就意味着需要将系统按照不同的维度（如业务、数据等）切分给各个不同节点的机器。因此，需要对业务或者数据进行合理切分，让多个机器节点能够相互协作，以满足业务功能的需要。在下面几节中，我们将讨论分布式常见的切分方法。但是请注意，这里只是讨论了常用的切分方法，并不是只有这些切分方法。</p>
<h5 id="1．水平切分"><a href="#1．水平切分" class="headerlink" title="1．水平切分"></a>1．水平切分</h5><p>所谓水平切分，就是将同一个系统部署到多台机器上，如图1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141445823.png" alt="image-20231014144534794"></p>
<p>从图1-3中可以看到，单体的Web服务器变成了多个Web服务器节点，每台服务器都有相同的应用，都能独立完成计算，互不相干。这样的切分有以下几个好处。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●简单：只需要实现一个路由算法，将请求合理地分配到各个节点即可。目前能够快速方便地实现这个功能的网关包括Nginx、Netflix Zuul和Spring Cloud Gateway等。</span><br><span class="line">●独立：每个节点都有完整的运算功能，不需要依赖其他节点，因此系统之间不需要太多的交互。</span><br><span class="line">●高可用：当出现不能工作的节点时，系统仍然可以继续运行，无须停机，因为路由算法不会给不能工作的节点分配请求。</span><br><span class="line">●可伸缩：可以随着业务的增长，增加服务节点，也可以随着业务的缩减，减少服务节点，二者都十分容易。</span><br><span class="line">●高性能：因为都是在单机内完成，不需要做外部调用，因此可以得到很高的性能。</span><br></pre></td></tr></table></figure>
<p>以上就是水平切分的优势，但是这样的分法，也有很大的弊端。随着业务的发展，业务会从简单变复杂。例如，一个电商的网站，用户和业务不断膨胀，所需的产品、卖家、交易和评论业务也会日趋复杂。如果此时还将所有的业务全部集中在一套系统里开发，那么显然所有业务都会耦合到一套系统里，日后的扩展和维护会越来越困难。一方面，我们会不断地通过打包来升级系统，使得系统的稳定性和可靠性不断下降；另一方面，维护起来也不方便，例如，要升级产品业务，就需要对全部节点进行升级，而这样的升级会比较麻烦。</p>
<h5 id="2．垂直切分"><a href="#2．垂直切分" class="headerlink" title="2．垂直切分"></a>2．垂直切分</h5><p>如上所述，随着业务的增加和深入，以及用户数的膨胀，有时候，单一业务也会随之变得异常复杂，有必要按照业务的维度进行拆分，将各个业务独立出来，单独开发和维护。假设，我们将用户、交易和产品系统拆分出来，独立开发，就可以得到图1-4所示的架构。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141446321.png" alt="image-20231014144659292"></p>
<p>从图1-4中可以看出，我们把系统按照业务维度进行了切分，这样每一个系统就都能独立开发和维护了。垂直切分有以下好处。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">●提高业务独立性：只要根据业务把系统划分成高内聚、低耦合的模块，就能极大地降低开发难度。</span><br><span class="line">●提高灵活性：任何一个业务发生改变，都只需要维护相关的系统，而无须将全部系统打包上线。</span><br><span class="line">●提高可维护性：独立的系统更容易发现问题。因为将业务分离出去后，发生的异常情况更容易被定位了，所以开发者和业务人员维护起来更方便了。虽然这样的划分带来了以上诸多好处，但其存在的弊端也是值得我们重视的。</span><br><span class="line">●增加了系统之间的协作：系统之间往往需要协作完成任务，也就是说，系统之间是相互依赖的。例如，购买一件商品，需要买家系统提供买家信息，产品系统扣减产品库存，交易系统记录商品交易，这需要3个系统共同协作来完成。从这个角度来说，系统之间必须进行协作。现今流行的系统交互有远程过程调用（RPC）、面向服务的架构（SOA）、REST风格请求和消息机制等。</span><br><span class="line">●降低了可用性：因为系统之间存在依赖，所以任何一个系统出现问题，都会影响其他系统。例如，产品系统不可用，就无法扣减库存，也就无法进行购买产品的交易了。由此可见，可用性大大降低。</span><br><span class="line">●数据一致性难以保证：因为节点之间需要通信，而网络通信往往并不可靠，所以节点之间数据的一致性难以保证。只能通过某些方法尽量减少不一致性。</span><br></pre></td></tr></table></figure>
<h5 id="3．混合切分"><a href="#3．混合切分" class="headerlink" title="3．混合切分"></a>3．混合切分</h5><p>上文我们讨论了水平切分和垂直切分，也讨论了它们的利弊。本节的混合切分是将水平切分和垂直切分结合起来的一种切分方法。现今微服务架构大部分采用了这种分法，因此这也是本章的重点内容之一。先看一下图1-5。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141447967.png" alt="image-20231014144759925"></p>
<p>在图1-5中，先是把系统按照业务维度切分到不同的服务器群里。然后，又对其中一种业务系统进行了水平切分，使得这种业务系统可以在多个节点中运行。最后，系统之间采用了交互机制进行协作。</p>
<p>通过其中的垂直切分，我们能够将业务分隔为独立的系统。这样就不会形成大耦合，有利于灵活的管理和简化后续的开发。而对每一个独立的业务系统又采用了水平切分，即使某个节点因为某种原因不可用，也有其他业务系统节点可以代替它。这样系统就可以变为高可用的了。这样的划分依旧不能克服系统之间大量交互和难以维护的数据一致性的问题，同时，切分节点比较多也会使实施分布式系统的硬件成本提高。实际上，无论何种划分，都不可能使得分布式系统只有优点，没有缺点。相对于耦合性和缺乏灵活性来说，大量交互和数据一致性的问题则更容易处理，因此混合划分渐渐成为主流划分方式。</p>
<h4 id="1-2-2-分布式系统所面临的问题"><a href="#1-2-2-分布式系统所面临的问题" class="headerlink" title="1.2.2 分布式系统所面临的问题"></a>1.2.2 分布式系统所面临的问题</h4><p>略</p>
<h3 id="1-3-分布式系统的设计原则"><a href="#1-3-分布式系统的设计原则" class="headerlink" title="1.3 分布式系统的设计原则"></a>1.3 分布式系统的设计原则</h3><p>鉴于分布式系统的复杂性，一些专家和学者提出了不同的理论，其中最著名、最有影响力的当属CAP原则和BASE理论。</p>
<h4 id="1-3-1-CAP原则"><a href="#1-3-1-CAP原则" class="headerlink" title="1.3.1 CAP原则"></a>1.3.1 CAP原则</h4><p>分布式系统有许多优点和缺点，其主要特点是一致性、可用性和分区容忍。它们的具体含义如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●一致性（consistency）：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。</span><br><span class="line">●可用性（availability）：保证每个请求不管成功还是失败都有响应。</span><br><span class="line">●分区容忍性（partition tolerance）：系统中任何的信息丢失或者失败都不会影响系统的继续运作。</span><br></pre></td></tr></table></figure>
<p>针对这3个特点，Eric Brewer教授在2000年提出了CAP原则，也称为CAP定理。该原则指出，任何分布式系统都不能同时满足3个特点，如图1-6所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141451950.png" alt="image-20231014145103913"></p>
<p>也就是说，任何的分布式系统都只能较好地完成其中的两个指标，无法完成3个指标。</p>
<p>在当今互联网中，保持可用性往往是第一位的，其次是性能。因为从客户的感知来说，可用和快速响应能够提供更好的体验。一致性可以通过其他手段来保证，本书后面会给出具体的方法。</p>
<p>微服务主要<strong>追求可用性和分区容忍性（AP），轻一致性（C）</strong>。</p>
<h4 id="1-3-2-BASE理论"><a href="#1-3-2-BASE理论" class="headerlink" title="1.3.2 BASE理论"></a>1.3.2 BASE理论</h4><p>在现实的业务中，金额和商品的库存数据是企业生产的核心数据，在分布式系统中保证这些数据的一致性，是分布式系统的核心任务之一。在不同的线程和机器之间保持数据的一致性是十分困难的，需要使用很多协议才能保证。在保证一致性的同时，也会给系统带来复杂性和性能的丢失。在BASE理论中，一致性又分为强一致性和弱一致性。需要注意的是，CAP原则中的一致性是指强一致性。这里，我们先来了解什么是强一致性和弱一致性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●强一致性：当用户完成数据更新操作之后，任何后续线程或者其他节点都能访问到最新值。这样的设计是最友好的，即用户上一次的操作，下一次都能读到。但根据CAP原则，这种实现需要对性能做出较大的牺牲。</span><br><span class="line">●弱一致性：当用户完成数据更新操作之后，并不能保证后续线程或者其他节点马上访问到最新值。它只能通过某种方法来保证最后的一致性。</span><br></pre></td></tr></table></figure>
<p>BASE理论是eBay的架构师Dan Pritchett在ACM上发表的文章中正式提出来的，是对大型分布式系统的实践总结。</p>
<p>BASE理论的核心思想是：即使分布式系统无法做到<strong>强一致性</strong>，也可以采用适当的方法达到<strong>最终一致性</strong>。</p>
<p>BASE并非一个英文单词，而是几个英文单词的简写。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●BA（Basically Available，基本可用）：在分布式系统中，最重要的需求是保证基本可用，有响应结果返回。例如，在“双十一抢购”的苛刻环境下，用户到电商处进行抢购。即使抢购失败，系统也会提示“系统繁忙，请过会儿再来”。我们分析一下这样的场景。用户是来购买商品的，而在抢购的环境下可能因为资源瓶颈，无法完成。为了避免用户长时间等待，系统会提示用户过会儿再来。这里的提示信息不需要消耗太多的系统资源，因而这样的场景就是典型的降级服务。虽然没有完成客户需要的抢购，但是却给了用户明确的信息，避免了用户长时间等待的情况，这样会给用户带来良好的体验。●S（Soft State，软状态）：其意义在于允许系统存在中间状态。一般来说，系统之间的数据通信都会存有副本，而这些副本都会存在一定的延迟。这时推荐使用弱一致性代替强一致性。这样的好处在于，提高系统的可用和性能。在网站用户的体验中，快速显示结果往往比一致性更为重要，因为没人愿意使用一个几十秒都不能响应的网站。</span><br><span class="line">●E（Eventual Consistency，最终一致性）：是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，以保证数据的正确性。</span><br></pre></td></tr></table></figure>
<p>BASE理论的应用场景是大型分布式系统，它的核心内容是放弃强一致性，保证系统的可用性。因为分布式系统自身的融合和扩展就相当复杂，如果需要保证强一致性就需要额外引入许多复杂的协议，这会导致技术的复杂化，同时对性能也有影响。BASE理论则建议让数据在一段时间内不一致，从而降低技术实现的复杂性，并提高系统的性能，最后再通过某种手段使得数据达成最终一致即可。</p>
<h3 id="1-4-微服务架构"><a href="#1-4-微服务架构" class="headerlink" title="1.4 微服务架构"></a>1.4 微服务架构</h3><p>因为分布式非常复杂，所以一直以来都没有权威的架构和设计，更多的只是前人的积累和实践。前人总结出了许多有用的理念，积累了许多经验，开发了很多实施分布式的软件。近几年来，最热门的分布式架构非微服务架构莫属。它是由美国科学家Eric Brewer在其博客上发表的概念。微服务是当前分布式开发的热点内容，也是本书的核心内容。下面先来了解什么是微服务架构。</p>
<h4 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h4><p>微服务架构只是将一个单体应用程序拆分为多个相对独立的服务，每一个服务拥有独立的进程和数据，每一个服务都是以轻量级的通信机制进行交互的，一般为HTTP API（现今最流行的是REST风格）。一般来说，这些服务都是围绕着业务模块来建设的，是独立的产品，因此完全可以独立地自动化部署和维护，这样更加有利于我们进行更小粒度的开发、维护和部署。这些服务可以由不同的语言编写，采用不同的数据存储，最低限度地集中管理。</p>
<p>微服务是一个模糊的概念，而不是一个标准，没有明确的定义。但微服务存在一定的风格，只要系统架构满足一定的风格，就可以被称为微服务架构。接下来，我们来了解一下微服务的风格。</p>
<h4 id="1-4-2-微服务的风格"><a href="#1-4-2-微服务的风格" class="headerlink" title="1.4.2 微服务的风格"></a>1.4.2 微服务的风格</h4><p>为了更好地实现微服务的风格，Eric Brewer提出了微服务架构的九个风格。也就是说，对于满足以下九种风格的系统架构，我们都可以称之为微服务。</p>
<h5 id="1．组件化和服务"><a href="#1．组件化和服务" class="headerlink" title="1．组件化和服务"></a>1．组件化和服务</h5><p>这里，首先明确定义组件化（componentization）和服务（service）的含义。把一个单体系统拆分为一个个可以单独维护和升级的软件单元，每一个单元就称为组件。每一个组件能够运行在自己独立的进程里，可以调用自己内部的函数（或方法）来完成自身独立的业务功能。但是更多的时候组件之间需要相互协作才能完成业务，这些就需要通过服务来完成了。这里的<strong>服务是指进程外的组件</strong>，它允许我们调用其他的组件，服务一般会以明确的通信机制提供，如HTTP协议、Web Service或者远程过程调用（RPC）等。</p>
<p>这样的组件化和服务有助于简化系统的开发，我们可以单独维护和升级。其次，在开发人员明确了组件的含义之后，只需要开发自己的组件，无须处理其他人的组件。在他人的组件需要调用我们开发的组件功能时，我们只需要提供编写服务即可。服务只需要明确以什么协议（如HTTP协议）和规范进行提供即可，这样各个组件之间的交互就相对简单和明确了。</p>
<p>这显然带来了开发和维护的便利，但是也会引来其他的问题。首先，如何将一个单体系统拆分为各个组件，这是一个边界界定的问题。其次，在使用通信机制进行交互的情况下，性能远没有在单机内存的进程中运行高。</p>
<h5 id="2．围绕业务功能组织团队"><a href="#2．围绕业务功能组织团队" class="headerlink" title="2．围绕业务功能组织团队"></a>2．围绕业务功能组织团队</h5><p>上文谈过单体应用包含用户界面、服务逻辑和数据源等内容。如果对团队进行划分，可以分为前端团队、后端团队、数据库团队和运维团队等。如果以这样的团队划分作为微服务的划分，会出现比较大的问题。因为一个改动往往会同时牵涉到前端、后端和运维团队，所以即使是很小的业务改动，也会牵涉跨团队的协作。而跨团队的协作必然会引发沟通成本，严重时甚至会出现内耗，这会极大地增加系统的维护成本。为了避免这个问题，微服务架构建议按业务模块来划分团队。这样，每次修改系统的工作，就只需要在相关的业务团队之间进行了，不需要牵涉全局。如此，牵涉的团队最少，也减少了不必要的沟通和内耗。</p>
<h5 id="3．是产品而不是项目"><a href="#3．是产品而不是项目" class="headerlink" title="3．是产品而不是项目"></a>3．是产品而不是项目</h5><p>传统的软件开发组织一开始会按业务模块进行划分，然后进行开发。一旦开发完成，将软件交付给维护部门，开发团队就解散了。而微服务则认为，这样的模式是不可取的，并且认为开发团队应该维护整个产品的生命周期，也就是谁开发谁负责后续的改进。因为微服务是帮助用户持续处理业务功能的，所以开发者持续关注软件，不断地改善软件，让软件更好地服务于业务，而且越小的粒度也越容易促进用户和服务供应商之间的关系。</p>
<h5 id="4．强化终端及弱化通道"><a href="#4．强化终端及弱化通道" class="headerlink" title="4．强化终端及弱化通道"></a>4．强化终端及弱化通道</h5><p>微服务的应用致力松耦合和高内聚，也就是业务模块的划分具有高内聚的特点，而各个业务组件则呈现出松耦合的特点。但是系统拆分后，需要各个组件相互协助才能完成业务，因此组件之间需要相互通信，为此开发者需要引入各种各样的通信协议。通信协议分很多种，如HTTP、Web Service和RPC等。在微服务的构建中，建议弱化通信协议的复杂性，因此推荐使用以下两种。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●包含资源API的HTTP的请求-响应和轻量级消息通信协议，尤其是现在流行的REST风格。</span><br><span class="line">●用轻量级消息总线来发布消息，如RabbitMQ或者ZeroMQ等，可以提供可靠消息的中间件。</span><br></pre></td></tr></table></figure>
<p>在一些非常强调性能的网站，也许还会使用二进制来传递协议，但是这仍然不能解决分布式的丢包和请求丢失等问题。微服务推荐使用的两种方式，虽然在性能和可靠性上比不上其他的一些协议，但是在可读性上却大大提高了。也许绝大部分的系统并不需要在两者之间做出选择，因为能获得可读性的便利就已经很不错了。毕竟引入那些性能高或者可靠的协议会大大降低可读性，并且在很大程度上会提高系统的开发和日后维护的难度。</p>
<h5 id="5．分散治理"><a href="#5．分散治理" class="headerlink" title="5．分散治理"></a>5．分散治理</h5><p>和单体系统构建不一样，微服务架构允许我们分散治理。微服务架构的每一个组件所面对的业务焦点都是不一样的，因此在选型上有很大的差异。例如，C++适合做那些实时高效的组件，Node.js适合做报表组件，而Matlab则适合做数字图像分析。不同的业务组件也许需要不同的语言进行开发，而微服务架构允许我们使用各类语言构建组件，各组件之间只需要约定好服务接口即可。微服务架构没有编程语言的限制，不同的业务组件可以根据自己的需要来选择构建平台。</p>
<p>分散治理带来了很大的灵活性。与此同时，我们只需要通过接口约定即可实现组件之间的相互通信。例如，使用现在流行的HTTP请求的REST风格，就能够使系统之间十分简单地交互。</p>
<h5 id="6．分散数据管理"><a href="#6．分散数据管理" class="headerlink" title="6．分散数据管理"></a>6．分散数据管理</h5><p>单体系统拆分后，微服务架构建议使用分散的数据管理，也就是每一个组件都应该拥有自己的数据源，包括数据库和NoSQL等。这样，我们就可以按照微服务组件划分的规则，划分对应的数据。这有助于更为精确地管理数据，可以使数据存储更加合理，同时还可以简化数据模型。</p>
<p>但是，分散数据管理也会引发两个弊端。</p>
<p>第一个弊端是，因为数据库的拆分会导致原有的ACID特性不复存在，所以需要实现分布式数据库事务的一致性。为了实现它，还需要引入其他协议，如XA协议等。然而，这会使开发变得十分复杂，大大提高开发难度。所以微服务并不建议使用分布式事务来处理数据的一致性，而是建议<strong>使用最终一致性的原理</strong>。在第15章中，我们会再谈到这些问题。</p>
<p>第二个弊端是，拆分之后关联计算会十分复杂。例如，交易组件要查看产品详情的时候，而产品详情却放在产品组件里，如果是在统计分析的情况下，则无法进行数据库的表关联计算，需要大量的远程过程调用才行，这样会造成性能低下，但是从现实来说在分布式系统中使用统计分析的场景较少，所以这样的场景出现频率较低。需要统计分析时，可以抽取数据到对应的系统再进行统计分析，毕竟统计分析一般不需要实时数据。</p>
<h5 id="7．基础设施自动化"><a href="#7．基础设施自动化" class="headerlink" title="7．基础设施自动化"></a>7．基础设施自动化</h5><p>因为微服务是将一个单体系统拆分为多个组件，所以势必造成多个组件的测试和部署，这样就会大大增加测试人员和开发人员的工作量。在业务不断扩大的情况下，这些将会成为测试和运维人员的噩梦。好在当前的云计算、测试开发、容器（如Docker）等技术已经有了长足发展，减少了微服务的测试、构建和发布的复杂性。</p>
<p>正如之前所提到的，实施微服务是对每一个组件都是以产品的态度不断深化改造以满足用户需求，所以每次进行改造之时必然会涉及构建、测试和发布。对于自动化测试，当前已有许多语言可用，如Node.js、Python等语言，都可以构建测试开发，验证测试案例。这是部署之前需要做的事情，可以降低测试人员的工作量。对于部署来说，借助容器化技术（如Docker）进行构建、部署微服务，可以极大地简化部署人员重复的操作和多环境的配置。</p>
<h5 id="8．容错性设计"><a href="#8．容错性设计" class="headerlink" title="8．容错性设计"></a>8．容错性设计</h5><p>使用服务作为组件的一个结果，在于应用需要有能容忍服务的故障的设计。一般来说会出现两种情况。</p>
<p>第一种情况是，任何服务器都可能出现故障、断电和宕机。在这样的情况下，微服务架构应当可以给出仪表盘，监控每一个节点的状态是否正常、吞吐情况、内存等。一旦出现故障不可用时，微服务系统自动就会切断转发给它的请求，给出故障节点的提示，并且将被切断的请求转发给其他可用节点。微服务系统也允许监测组件节点的状态（上线、下线或不可用），在某些组件节点出现故障、断点和宕机时，系统允许组件节点优雅下线进行维护。在企业维护成功后，允许其重新上线，再次提供服务。</p>
<p>第二种情况是，当系统接收大量请求时，可能出现某个组件响应变得缓慢的情况。此时，如果其他的组件再调用该组件，就需要等待大量的时间。这样，其他的组件也会因为等待超时而引发自身组件不可用，继而出现服务器雪崩的场景。当一个组件变得响应缓慢，造成大量超时，如果微服务能够发现它，并且通过一些手段将其隔离出去，这种情况就不会蔓延到调用者了。这就好比电流突然增大，可能会发生危险，保险丝便自动熔断保护用电安全一样。因此，我们把这种情况称为断路，把微服务中处理这种情况的组件称为断路器（Circuit Breaker）。</p>
<h5 id="9．设计改进"><a href="#9．设计改进" class="headerlink" title="9．设计改进"></a>9．设计改进</h5><p>从上述的特征来看，实施微服务比实施一个单体系统复杂得多，代价也大得多。从实践的角度来说，微服务的设计是循序渐进的，在起初业务量不大的时候，系统是相对简单的，业务也是相对单一的。早期的核心架构在后期不会发生很大的变化，但系统会引入新的业务，使得一些内容发生变化，有些组件会被停用，有些组件会被加入进来。例如，用户数量不断增大且构成变得更复杂，这个时候可以把现有的用户服务拆分为高级用户服务和普通用户服务两个微服务产品，对外提供服务。经过时间的推移，那些核心架构的组件往往就会相对稳定下来，从而成为微服务的核心。而那些需要经常变化的组件，则需要不断地进行维护和改进，来满足业务的发展需要。</p>
<h4 id="1-4-3-微服务和分布式系统的关系"><a href="#1-4-3-微服务和分布式系统的关系" class="headerlink" title="1.4.3 微服务和分布式系统的关系"></a>1.4.3 微服务和分布式系统的关系</h4><p>应该说，微服务是分布式系统设计和架构的理念之一。但是从微服务的风格来看，它并不是为了克服所有的分布式系统的缺陷而设计的，而是为了追求更高的可读性、可用性和简易性。但与此同时，也弱化了其一致性，正如这句老话——“两害相较取其轻者”。</p>
<p>所以，微服务并不能解决所有的分布式系统的问题，它只是寻求一个平衡点，让架构师能够更为简单、容易地构建分布式系统。但微服务并非金科玉律，对于一些特殊的分布式需求，还需要我们使用其他的方法来得以实现，正如方法是死的，而人是活的，需要实事求是地解决问题。</p>
<h3 id="1-5-Spring-Cloud"><a href="#1-5-Spring-Cloud" class="headerlink" title="1.5 Spring Cloud"></a>1.5 Spring Cloud</h3><p>如上所述，实现微服务需要大量的软件，而这些软件是十分复杂的。应该说，大部分的企业，包括一些大企业，都无力支持这些软件的开发。但是我们并不沮丧，因为我们可以“站在巨人的肩膀上”，无论是国内还是国外，都为分布式系统做了大量的尝试，积累了丰富的成果。例如，下面的工具是我们常常在构建分布式系统中见到的。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●服务治理：阿里巴巴的Dubbo、Netflix的Eureka、Apache的Consul等。</span><br><span class="line">●分布式配置管理：阿里巴巴的Diamond、百度的Disconf、Netflix的Archaius等。</span><br><span class="line">●API网关：俄罗斯程序员Igor Sysoev开发的Nginx、Netflix的Zuul、Spring Cloud的Gateway等。</span><br></pre></td></tr></table></figure>
<p>目前，国内最流行的是阿里巴巴的Dubbo，它已经在很多互联网企业广泛使用。但无论如何，这些软件都是某些公司为了解决各自某些问题而开发出来并将其开源的。严格来说，它们并不是一套完整的解决方案。而在国外，Spring Cloud大行其道。Spring Cloud是由Pivotal团队开发的，它没有重复造轮子，而是通过考察各家开源的分布式服务框架，把经得起考验的技术整合起来，形成了现在的Spring Cloud的组件。Spring Cloud就是通过这种方式构建了一个较为完整的企业级实施微服务的方案。更令人振奋的是，Pivotal团队将这些分布式框架通过Spring Boot进行了封装，屏蔽了那些晦涩难懂的细节，给开发者提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。在引入国内之后，Spring Cloud渐渐成了构建微服务系统的主要方案，成为市场的主流。当然，这也是本书需要深入讨论的核心内容之一。</p>
<h4 id="1-5-1-Spring-Cloud的各个组件的简介"><a href="#1-5-1-Spring-Cloud的各个组件的简介" class="headerlink" title="1.5.1 Spring Cloud的各个组件的简介"></a>1.5.1 Spring Cloud的各个组件的简介</h4><p>为了构建微服务架构，Spring Cloud容纳了很多分布式开发的组件。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">●Spring Cloud Config：配置管理，允许被集中化放到远程服务器中。目前支持本地存储、Git和SVN等。</span><br><span class="line">●Spring Cloud Bus：分布式事件、消息总线、用于集群（如配置发生变化）中传播事件状态，可以与Spring Cloud Config联合实现热部署。</span><br><span class="line">●Netflix Eureka：服务治理中心，它提供微服务的治理，包括微服务的注册和发现，是Spring Cloud的核心组件。</span><br><span class="line">●Netflix Hystrix：断路器，在某个组件因为某些原因无法响应或者响应超时之际进行熔断，以避免其他微服务调用该组件造成大量线程积压。它提供了更为强大的容错能力。</span><br><span class="line">●Netflix Zuul：API网关，它可以拦截Spring Cloud的请求，提供动态路由功能。它还可以限流，保护微服务持续可用，还可以通过过滤器提供验证安全。</span><br><span class="line">●Spring Cloud Security：它是基于Spring Security的，可以给微服务提供安全控制。</span><br><span class="line">●Spring Cloud Sleuth：它是一个日志收集工具包，可以提供分布式追踪的功能。它封装了Dapper和log-based追踪以及Zipkin和HTrace操作。</span><br><span class="line">●Spring Cloud Stream：分布式数据流操作，它封装了关于Redis、RabbitMQ、Kafka等数据流的开发工具。</span><br><span class="line">●Netflix Ribbon：提供客户端的负载均衡。它提供了多种负载均衡的方案，我们可以根据自己的需要选择某种方案。它还可以配合服务发现和断路器使用。</span><br><span class="line">●Netflix Turbine：Turbine是聚合服务器发送事件流数据的工具，用来监控集群下Hystrix的metrics情况。</span><br><span class="line">●OpenFeign：它是一个声明式的调用方案，可以屏蔽REST风格的代码调用，而采用接口声明方式调用，这样就可以有效减少不必要的代码，进而提高代码的可读性。</span><br><span class="line">●Spring Cloud Task：微服务的任务计划管理和任务调度方案。●……</span><br></pre></td></tr></table></figure>
<p>通过上述组件描述可以相对容易地构建微服务系统。只是本书不会介绍所有的组件，而是根据需要介绍最常用的组件，这些将是后续章节的重点内容。当前，Spring Cloud以Netflix公司的各套开源组件作为主要组件，通过Spring Boot的封装，给开发者提供了简单易用的组件。但由于Netflix的断路器Hystrix已经宣布进入维护阶段，不再开发新的功能，因此，Spring Cloud即将把Resilience4j作为新的熔断器加入进来。本书会对Resilience4j进行详细的讲解，以适应未来的需要。Spring Cloud的未来趋势是去Netflix组件，因为需要大幅度地更新组件，所以周期较长。但是，即使更替新的组件，其设计思想也是大同小异的，正如这句老话——“换汤不换药”，所以我们还是会讲解Netflix组件。</p>
<h4 id="1-5-2-Spring-Cloud版本说明"><a href="#1-5-2-Spring-Cloud版本说明" class="headerlink" title="1.5.2 Spring Cloud版本说明"></a>1.5.2 Spring Cloud版本说明</h4><p>因为Spring Cloud融入了大量的其他企业的开源组件，所以这些组件的版本往往并不一致，不同的组件由不同的公司进行维护。为了统一版本号，Pivotal团队决定使用伦敦地铁站点名称作为版本名。首先是将这些站点名称进行罗列，然后按顺序使用。Spring Cloud发布的版本历史（截至本书编写时）如表1-3所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141542192.png" alt="image-20231014154235134"></p>
<p>由于Spring Boot已经发展到了2.1.x版本，Spring Cloud也发布到了Greenwich版本，因此本书是基于Spring Boot 2.1.0和Greenwich.RELEASE进行讲解的。</p>
<h3 id="1-6-微服务系统样例简介"><a href="#1-6-微服务系统样例简介" class="headerlink" title="1.6 微服务系统样例简介"></a>1.6 微服务系统样例简介</h3><p>为了更好地讲述Spring Cloud微服务和分布式系统的知识，这里我们来模拟微服务系统。当今互联网的世界中，互联网金融是一个很大的课题，所以这里采用互联网金融的例子来讲解微服务系统和分布式应用的知识。</p>
<p>假设，有一家互联网金融公司主营互联网金融借贷业务。它先收集借款人信息，再根据借款人的资金需要生成理财产品。然后，通过理财产品约定利息、时间、还款方式等内容后，发送到公司的互联网平台。最终用户就可以在该公司互联网平台上看到这些理财产品了。那些拥有闲置资金的用户就可以购买这些理财产品，从而获得较高的利息收益。其业务如图1-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141544003.png" alt="image-20231014154408963"></p>
<p>为了使业务能够进行，这里先做业务分析，此为开发系统的第一步。</p>
<p>这里需要管理和审核借款人，公司信贷审核人员将审核借款人的身份、信用、资质和财产等情况，以保证不发生金融诈骗，因此我们需要一个借款人微服务。</p>
<p>而投资人是平台的用户，因为大额投资和经常投资的用户应该要被给予更多的优惠，所以投资人也会根据具体的情况分成不同的等级。为了更好地管理，需要一个用户微服务。</p>
<p>平台会根据借款人的资金需要来生成对应的理财产品，理财产品分为定期和活期。用户购买产品的交易记录也会记录在内。这里需要一个理财产品微服务。</p>
<p>因为涉及金钱，所以这里需要一个资金微服务，帮助投资人和借款人管理自己资金。投资人可以将自己银行卡上的闲置资金转入系统来购买理财产品，而平台也会根据借款人的资金需要将资金转到借款人账户。</p>
<p>平台也许还会和第三方合作，让第三方介绍投资人或者借款人，或者进行广告等，因此还需要一个第三方微服务……</p>
<p>不过也许并不需要考虑那么多的微服务，因为大部分情况是类似的，而且全部考虑也会太复杂。因此，本书只讨论用户（投资人）、理财产品和资金微服务，如图1-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141546718.png" alt="image-20231014154642682"></p>
<p>从图1-8中可以看到，请求会先到网关，网关会拦截请求，进行验证、路由和过滤。这样做可以保护微服务，避免一些恶意的攻击，同时还可以限制通过的流量，避免过大的请求量压垮系统。各个微服务则提供实际的业务功能，对于微服务之间需要交互才能共同完成相关的业务，按照微服务的建议进行集成，这里采用REST风格的请求进行集成。</p>
<h2 id="第2章-技术基础"><a href="#第2章-技术基础" class="headerlink" title="第2章 技术基础"></a>第2章 技术基础</h2><p>为了更好地介绍Spring Cloud，这里稍微介绍一下Spring Boot和HTTP的REST风格。因为Spring Cloud是以Spring Boot作为基石的，而各个服务系统又是通过REST风格的请求集成在一起的，所以学习它们将有助于我们深入学习Spring Cloud。当然，如果你已经对它们很熟悉了，也可以跳过本章，直接学习第3章的内容。</p>
<h3 id="2-1-Spring-Boot"><a href="#2-1-Spring-Boot" class="headerlink" title="2.1 Spring Boot"></a>2.1 Spring Boot</h3><p>从第1章可以看出，Spring Cloud的组件是通过Spring Boot的方式进行封装的，所以这里先简单地介绍一下Spring Boot的应用。Spring Boot是由Pivotal团队提供的全新框架，它采用约定优于配置的思想，极大简化了Spring项目的开发。它是当前最为流行的微服务开发框架，在企业的实际开发中，越来越受欢迎，使用率也稳步上升。</p>
<h4 id="2-1-1-创建Spring-Boot工程"><a href="#2-1-1-创建Spring-Boot工程" class="headerlink" title="2.1.1 创建Spring Boot工程"></a>2.1.1 创建Spring Boot工程</h4><p>首先让我们新建一个工程，如图2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644231.png" alt="image-20231014164412180"></p>
<p>这里选择“Spring Initializr”，然后点击选择适当的JDK，再点击“Next”，就可以看到如图2-2所示的界面。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644227.png" alt="image-20231014164425186"></p>
<p>此处我们可以根据需要配置自己的工程信息。这里的“Type”可以选择Maven或者Gradle工程。当今企业主要使用Maven，所以本书也采用Maven来介绍。如果使用的是Gradle，也没有问题，其使用方式和Maven差别不大，这里就不介绍了。这里的“Packaging”选择“War”，这意味着可以使用JSP作为视图，如果不需要使用JSP，也可以选择“Jar”。然后点击“Next”，就可以看到如图2-3所示的界面了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141644891.png" alt="image-20231014164446859"></p>
<p>从图2-3中可以看到，IDEA提供了很多可以依赖的starter包。这里，我只选择了Spring Web Starter和Thymeleaf，意为开发一个关于Spring MVC的工程。其中“Template Engines”使用了Thymeleaf模板引擎。然后就可以点击“Next”了。跟着输入自己的工程名称，选择工程目录，就可以新建一个Spring Boot工程了。</p>
<h4 id="2-1-2-Spring-Boot开发简介"><a href="#2-1-2-Spring-Boot开发简介" class="headerlink" title="2.1.2 Spring Boot开发简介"></a>2.1.2 Spring Boot开发简介</h4><p>在上一节中，我们新建了一个Spring Boot工程。下面来查看它的目录，了解目录和相关文件的作用，如图2-4所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141645443.png" alt="image-20231014164521416"></p>
<p>从图2-4中可以看到pom.xml文件，它是Maven的配置文件。因为我们介绍的Spring Boot版本是2.1.0.RELEASE，而通过IDEA创建的是2.1.7.RELEASE，所以需要手工把版本修改为2.1.0.RELEASE。修改后的pom.xml如代码清单2-1所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目信息配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>chapter2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打包为war包--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>chapter2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>chapter2 for Spring Cloud<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--属性配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">          UTF-8</span><br><span class="line">       <span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入依赖包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring Boot插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码。下面对它们进行说明。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●packaging：这里配置为war，意味着将项目打包为war包，可以使用动态的JSP页面。</span><br><span class="line">●spring-boot-starter-thymeleaf包：引入Thymeleaf模板，这样，通过Spring MVC的机制就可以把数据渲染到Thymeleaf模板的页面中。</span><br><span class="line">●spring-boot-starter-web包：它会引入Spring基础包和Spring MVC包，此外它还会引入内嵌的Tomcat，所以我们不需要下载Tomcat就能运行工程。</span><br><span class="line">●spring-boot-starter-tomcat包：这里声明范围为provided，表明该包只在编译和测试时使用。</span><br><span class="line">●spring-boot-starter-test包：会引入测试相关的包。●spring-boot-maven-plugin包：允许我们使用java -jar命令运行Spring Boot工程。</span><br></pre></td></tr></table></figure>
<p>再看一下图2-4，这里需要对它的文件和目录进行简要说明，如表2-1所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141648383.png" alt="image-20231014164837343"></p>
<p>我们直接通过Java Application的形式运行Chapter2Application.java，就能够运行Spring Boot项目。在默认的情况下，Spring Boot会使用8080端口启动服务。如果想切换端口，就要修改核心配置文件application.properties，这里先把它重命名为application.yml。因为在分布式和微服务开发中，使用的大部分是YAML文件，而非properties文件，所以本书也主要使用YAML文件进行配置。修改application.yml，如代码清单2-2所示。</p>
<p>代码清单2-2 application.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span> <span class="comment"># 修改内嵌Tomcat端口为8001</span></span><br></pre></td></tr></table></figure>
<p>此时，如果再次使用Java Application的形式运行Chapter2Application.java，就可以看到Spring Boot在8001端口启动服务了。接下来，改造一下Chapter2Application.java文件，如代码清单2-3所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.chapter2.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.spring.cloud.chapter2.*&quot;)</span></span><br><span class="line"><span class="comment">// 标识控制器</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 请求前缀</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/chapter2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Chapter2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP GET请求，且定义REST风格路径和参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index/&#123;value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">(ModelAndView mav, </span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable(&quot;value&quot;)</span> String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置数据模型</span></span><br><span class="line">        mav.getModelMap().addAttribute(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">        <span class="comment">// 请求名称，定位到Thymeleaf模板</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看一下index方法。首先是获取请求路径的参数，在数据模型中设置一个键为key的参数，然后再把视图名称设置为index，最后返回ModelAndView。因为这里返回的视图名称为index，所以需要在templates目录下新建一个视图index.html文件，如代码清单2-4所示。</p>
<p>代码清单2-4 /resources/templates/index.html（Chapter2工程）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试Thymeleaf<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个HTML很简单，只需要解释一下加粗的代码就可以了。因为之前我们在数据模型中设置了键为key的参数，所以这里加粗的代码只是读取数据模型的这个参数而已。</p>
<p>到这里，一个简单的Spring Boot工程就开发好了。让我们以Java Application的形式运行代码清单2-3，这样就可以启动Spring Boot工程了。然后使用浏览器访问地址<a target="_blank" rel="noopener" href="http://localhost:8001/chapter2/index/myvalue，就可以看到如图2-5所示的界面了。">http://localhost:8001/chapter2/index/myvalue，就可以看到如图2-5所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141651361.png" alt="image-20231014165102313"></p>
<h4 id="2-1-3-多文件配置"><a href="#2-1-3-多文件配置" class="headerlink" title="2.1.3 多文件配置"></a>2.1.3 多文件配置</h4><p>在Spring Cloud中，一个服务下可以包含多个实例，因此同一个工程可能需要在不同的配置（如端口）下启动。对于IDEA构建的工程，我们之前论述过，它会为我们创建application.properties文件，只是在分布式的开发环境下，更为流行的是YAML文件，所以本书都会将application.properties修改为application.yml文件。</p>
<p>为了更好地适应多个环境的运行，Spring Boot配置项会按照一定的优先级进行加载，优先级从高到低的顺序如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●命令行参数。●来自java:comp/env的JNDI属性。</span><br><span class="line">●Java系统属性（System.getProperties()）。</span><br><span class="line">●操作系统环境变量。●RandomValuePropertySource配置的random.<span class="emphasis">*属性值。●jar包外部的application-&#123;profile&#125;.properties或application.yml（带spring.profile）配置文件。●jar包内部的application-&#123;profile&#125;.properties或application.yml（带spring.profile）配置文件。●jar包外部的application.properties或application.yml（不带spring.profile）配置文件。●jar包内部的application.properties或application.ym（不带spring.profile）配置文件。●@Configuration注解类上的@PropertySource。●通过SpringApplication.setDefaultProperties指定的默认属性。</span></span><br></pre></td></tr></table></figure>
<p>上面的顺序比较复杂，在大部分情况下，并不需要使用所有的配置。为了能够在IDEA工程中运行同一个项目的多个实例，可以使用很简易的方法。我们先在resources目录下新增两个配置文件application-peer1.yml和application-peer2.yml，然后进行配置，如代码清单2-5和代码清单2-6所示。</p>
<p>代码清单2-5 application-peer1.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#修改内嵌Tomcat端口为8001</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br></pre></td></tr></table></figure>
<p>代码清单2-6 application-peer2.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#修改内嵌Tomcat端口为8002</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br></pre></td></tr></table></figure>
<p>这里的两个文件只是修改了启动的端口而已，Spring Boot不会识别它们。为了让它们能够启动，我们需要修改application.yml文件，如代码清单2-7所示。</p>
<p>代码清单2-7 application.yml（Chapter2工程）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 设置环境变量，启用application-peer1.yml作为配置文件</span></span><br><span class="line">    <span class="comment"># 需要启用配置文件启用application-peer2.yml时，只需要修改为peer2即可</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>这里配置项spring.profiles.active配置为peer1，这样就可以指向application-peer1.yml文件了，Spring Boot就会以application-peer1.yml文件作为配置文件在端口8001中启动项目。同理，如果将spring.profiles.active修改为peer2，则会使用application-peer2.yml文件配置的端口8002启动项目。这样一个工程就可以启动多个实例了。</p>
<p>但是在IDEA中，默认的情况下，只允许同一个Java文件启动一次。为此，让我们选择菜单Run→EditConfigurations…，打开图2-6所示的对话框。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141655533.png" alt="image-20231014165515496"></p>
<p>将图2-6中红色方框圈起来的“Allow running in parallel”选项勾上，就可以在IDEA中让一个类运行多个实例了，然后就可以根据需要配置application.yml的配置项spring.profiles.active来选择具体的配置文件启动项目了。</p>
<p>当然，如果配置项比较少，例如，只需要考虑端口的改变，而不需要考虑其他复杂的配置，那么也可以使用命令行参数来实现上述的功能。这里，再看一下图2-6，选中“Chapter2Application”，然后点击左上角的复制键（[插图]），就可以看到一个新的运行配置，跟着修改其运行的名称和相关参数，如图2-7所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141656348.png" alt="image-20231014165602311"></p>
<p>在图2-7中，运行的名称被修改为“Chapter2Application 2”，命令行参数server.port的值被修改为8002。使用同样的方法，也可以将运行名称为“Chapter2Application”配置的命令行参数server.port的值修改为8001，这样就可以得到两个运行的配置了。它们将根据命令行参数所配置的端口进行运行。正常配置完毕后，IDEA会提示打开Spring Boot的运行面板（Run Dashboard）。跟着打开它，就可以在运行面板中运行对应的Spring Boot工程了，这是非常方便的，如图2-8所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141657439.png" alt="image-20231014165743406"></p>
<p>在图2-8所示的面板中，截取的是启动两个运行配置后的图，可以看到它们分别在8001和8002端口启动。</p>
<h4 id="2-1-4-打包和运行"><a href="#2-1-4-打包和运行" class="headerlink" title="2.1.4 打包和运行"></a>2.1.4 打包和运行</h4><p>使用Maven构建工程，可以使用IDEA进行打包，也可以自己使用命令打包。关于IDEA打包，相关资料介绍比较多，所以这里就不再介绍了。这里主要介绍命令打包。首先自己安装好Maven，并且配置好Maven的环境，做好这些后，打开工程所在的目录（我的本地的目录为E:\IdeaProjects\chapter2），然后在命令行窗口输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">package</span></span><br></pre></td></tr></table></figure>
<p>通过这个命令就能成功打包了。然后，打开工程目录下的target目录查看打包结果，如图2-9所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141702668.png" alt="image-20231014170250607"></p>
<p>打包结果是一个war文件。如果需要将它部署到第三方服务器，那么只需要将它放到第三方服务器的部署目录即可。例如，放到Tomcat的webapps目录下。Spring Boot还允许我们使用命令运行它，只要在这个目录下运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war</span><br></pre></td></tr></table></figure>
<p>就可以运行工程了。只是它是以application.yml配置的配置项spring.profiles.active选择对应的配置文件进行运行。如果我们想使用自己的配置项，如想使用8003端口启动项目，那么可以通过命令参数来代替它，如执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war --server.port=8003</span><br></pre></td></tr></table></figure>
<p>这样，就能在8003端口启动服务了。如果需要指定配置文件，也可以使用命令行参数进行指定。例如，使用application-peer2.yml文件启动Spring Boot工程，就可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\chapter2-0.0.1-SNAPSHOT.war --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-Spring-Boot监控"><a href="#2-1-5-Spring-Boot监控" class="headerlink" title="2.1.5 Spring Boot监控"></a>2.1.5 Spring Boot监控</h4><p>Spring Boot，除了方便我们开发外，还提供了系统监控的功能。在需要对系统进行监控时，只需要引入Actuator就可以了。下面让我们在pom.xml文件中引入Actuator，如代码清单2-8所示。</p>
<p>代码清单2-8 pom.xml引入Actuator（Chapter2工程）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.hateoas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-hateoas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是在Spring Boot 2.x之后，出于安全的考虑，大部分监控端点都不会直接暴露。要暴露这些端点，我们需要对YAML文件增加对应的配置，如代码清单2-9所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 暴露的端点，“*”代表全部暴露</span></span><br><span class="line">        <span class="attr">include :</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">          <span class="comment"># 不暴露的端点</span></span><br><span class="line">        <span class="attr">exclude :</span> <span class="string">env</span></span><br></pre></td></tr></table></figure>
<p>通过这些端点配置就可以暴露除了env之外的端点了.此时启动Spring Boot项目（假设在8001端口启动），在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/actuator/beans，就可以看到如图2-10所示的场景了。">http://localhost:8001/actuator/beans，就可以看到如图2-10所示的场景了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141707304.png" alt="image-20231014170725254"></p>
<p>从图2-10中可以看出，通过请求，已经可以查看到Actuator提供的端点了，这说明Spring Boot项目已经被监控起来了。但是这样暴露端点也会存在一定的安全隐患，这个时候可以使用Spring Security来进行安全验证，规避这些安全隐患。这部分内容比较烦琐，在第18章会有介绍，这里就不演示了。</p>
<p>实际上，Spring Boot可监控的端点还有很多。</p>
<h1 id="第二部分-Spring-Cloud微服务"><a href="#第二部分-Spring-Cloud微服务" class="headerlink" title="第二部分 Spring Cloud微服务"></a>第二部分 Spring Cloud微服务</h1><p>本部分主要介绍Spring Cloud所涉及的常用工具，其中包括：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">●服务治理和服务发现（Spring Cloud Netflix Eureka）；</span><br><span class="line">●服务调用（Spring Cloud Netflix Ribbon和Spring Cloud Netflix OpenFeign）；</span><br><span class="line">●断路器（Spring Cloud Netflix Hystrix和Resilience4j）；</span><br><span class="line">●网关（Spring Cloud Netflix Zuul和Spring Cloud Gateway）；</span><br><span class="line">●服务配置（Spring Cloud Config）；</span><br><span class="line">●服务监控（Spring Cloud Sleuth和Spring Boot Admin）。</span><br></pre></td></tr></table></figure>
<p>在这些组件中，前4个组件是构建Spring Cloud微服务架构的核心组件，因此它们是本书的重点和核心内容，后面的组件则是用于配置和监控微服务系统所需的组件。</p>
<h2 id="第3章-服务治理——Eureka"><a href="#第3章-服务治理——Eureka" class="headerlink" title="第3章 服务治理——Eureka"></a>第3章 服务治理——Eureka</h2><p>在Spring Cloud中，实现服务治理的是Netflix公司开发的Eureka。Netflix公司是美国加利福尼亚州的一家公司，主营业务是在线影片租赁。它为了搭建自己的网站，开发了一套分布式系统的组件。因为该网站性能卓越，所以曾经连续5次被评为顾客最满意的网站。正因为如此，Pivotal团队通过Spring Boot形式的封装将Netflix公司开发的分布式系统组件封装了起来，其中就包括Eureka，Eureka是Spring Cloud的服务治理中心。在使用Spring Boot进行了二次封装后，Eureka的使用就显得十分简易了。<strong>Eureka作为一个微服务的治理中心，它是一个服务应用，可以接收其他服务的注册</strong>，<strong>也可以发现和治理服务实例</strong>。</p>
<h3 id="3-1-服务治理中心"><a href="#3-1-服务治理中心" class="headerlink" title="3.1 服务治理中心"></a>3.1 服务治理中心</h3><p>服务治理中心是微服务（分布式）架构中最基础和最核心的功能组件，它主要对各个服务实例进行管理，包括服务注册和服务发现等。下面我们会详细进行讨论，不过首先需要把Eureka服务器搭建起来，以便在实践中学习。</p>
<h4 id="3-1-1-搭建Eureka服务治理中心"><a href="#3-1-1-搭建Eureka服务治理中心" class="headerlink" title="3.1.1 搭建Eureka服务治理中心"></a>3.1.1 搭建Eureka服务治理中心</h4><p>为了搭建Eureka服务治理中心，先新建一个工程，起名finance。然后，在IDEA中创建名为eureka-server的Spring Boot的模块（Module）放到finance下，并且在依赖上选择Eureka Server和Web。之后就可以看到pom.xml文件了，这里只讨论它和代码清单2-1之间的不同之处，如代码清单3-1所示。</p>
<p>代码清单3-1 pom.xml（eureka-server模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">&lt;!--依赖Eureka--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">&lt;!--定义Spring Cloud依赖父项目，以便于子项目继承--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码，这里先是引入了Spring Boot封装Eureka的包spring-cloud-starter-netflix-eureka- server，这样就可以把Eureka组件引入到这个模块里。\<dependencyManagement>主要是定制Spring Cloud父项目的信息（如版本号），当模块依赖Spring Cloud的开发包的时候，就会继承它，根据它的信息加载对应版本的依赖。</p>
<p>接下来，对IDEA为我们创建的EurekaServerApplication.java文件进行改造，如代码清单3-2所示。</p>
<p>代码清单3-2 EurekaServerApplication.java（eureka-server模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.eureka.server.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 驱动Eureka服务治理中心</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，就只是加入了一个新的注解@EnableEurekaServer，它代表着在Spring Boot应用启用之时，也启动Eureka服务器。此时，我们以Java Application的形式运行，就能够启用Eureka服务治理中心了。不过，如果选择JDK 8（不含）以上的版本，可能会启动失败，这是因为Spring Cloud的Netflix组件是依赖于JDK 8（含）之前的版本开发的，所以在新的JDK版本中会缺少一些包，因此我们需要引入新的依赖才能正常启动Eureka服务器，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们启动Eureka后，会发现日志中会不断地出现异常，那是因为Eureka服务治理中心会把自己作为微服务去寻找注册自己的治理中心。为了避免这种情况，需要进行额外的配置，让它停止注册自己。删除原有的application.properties文件，新建application.yml文件，然后对其进行配置，如代码清单3-3所示。</p>
<p>代码清单3-3 application.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Spring应用名称，它是一个微服务的名称，一个微服务可拥有多个实例</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span> <span class="comment">#修改内嵌Tomcat端口为5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 服务自身就是治理中心，所以这里设置为false，取消注册</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 取消服务获取，至于服务获取，本章后续会讨论</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 服务注册域地址</span></span><br><span class="line"><span class="comment">#    service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://192.168.1.100:5002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务治理中心服务器IP</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<p>有了这个配置，运行代码清单3-2，就可以看到没有异常日志的Eureka服务治理中心的启动了。然后打开浏览器在地址栏输入<a target="_blank" rel="noopener" href="http://localhost:5001/，就可以看到图3-1所示的界面了。">http://localhost:5001/，就可以看到图3-1所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141740423.png" alt="image-20231014174042364"></p>
<p>看到这个页面，就说明Eureka已经成功启动了。但是，我们可以看到，注册的微服务实例依旧为空，那是因为我们还没有注册。如何注册，是下一节要讨论的问题。代码清单3-3中的配置比较重要，不过这里有一个前提是要注意的，这个模块虽然是Eureka服务治理中心，但在Spring Cloud中，会被认为是一个微服务。在这个前提下，这里对这些配置进行一下初步的解释。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●spring.application.name：配置的是Spring应用的名称，也是微服务的名称，在Spring Cloud中，一个微服务可以拥有多个实例。</span><br><span class="line">●eureka.client.register-with-eureka：这个配置项是取消当前微服务，寻找其他Eureka服务治理中心进行注册。●eureka.client.fetch-registry：取消服务获取功能，关于服务获取，本章后续会讨论。●eureka.client.serviceUrl.defaultZone：在我们的代码中，这个属性被注释掉了，因为我们不需要注册微服务。如果需要注册微服务，可以通过这个属性来配置服务治理中心的注册地址，完成服务注册的功能。</span><br></pre></td></tr></table></figure>
<p>因为配置项eureka.client.register-with-eureka和eureka.client.fetch-registry比较好理解，所以这里只对配置项spring.application.name和eureka.client.serviceUrl.defaultZone做进一步的解释。先看一下图3-2。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141742132.png" alt="image-20231014174218059"></p>
<p>图3-2中存在两个重要的概念，一个是微服务，另一个是服务实例（Service Instance，简称实例）。这里需要切实掌握它们，以避免概念混淆，导致后续学习吃力。图中把服务拆分为用户微服务和资金微服务。所谓微服务，是指完成某一业务功能的独立系统。一个微服务可以有多个实例，所谓实例，是指一个具体的服务节点。例如，图中用户微服务一共有两个实例（用户实例1和用户实例2），同样，资金微服务也存在两个实例（资金实例1和资金实例2）。同一个微服务下的实例应该具备相同的业务功能。那么Eureka具体怎么区分哪一个实例是用户服务的实例，哪一个实例是资金微服务的实例呢？其实就是使用spring.appliacation.name配置项进行区分的，它可以配置一个字符串，通过这个字符串，Eureka就能把具有相同spring.appliacation.name配置项的实例认为是同一微服务下的实例。例如，用户实例1和用户实例2都配置spring.appliacation.name为user时，Eureka就会认为他们属于同一个微服务。那么服务实例是如何注册到Eureka服务治理中心的呢？实际就是实例对Eureka服务治理中心发送REST风格的请求，将自己的相关配置发送到Eureka服务治理中心完成注册，其中请求地址是由配置项eureka.client.serviceUrl.defaultZone生成的。</p>
<p>一般来说，我们都会把一个微服务注册为多个实例，其原因主要有两个。第一，从高可用的角度来说，即使有某个微服务下的一个实例不可用，那么其他实例也可以继续使用，服务仍然可以继续。第二，从性能的角度来说，多个实例可以有效分摊大量请求的压力，从而提高响应能力和吞吐能力。至于如何将微服务实例注册到服务治理中心是下节要讨论的。</p>
<h4 id="3-1-2-服务发现"><a href="#3-1-2-服务发现" class="headerlink" title="3.1.2 服务发现"></a>3.1.2 服务发现</h4><p>搭建了服务治理中心后，接着你肯定想往里面注册属于自己的微服务及其实例。本节让我们讨论一下这个问题。</p>
<p>为了进行注册，这里我们在IDEA中创建3个Spring Boot模块，分别是user（用户）、fund（资金）和product（理财产品，简称为产品）。在IDEA中创建的时候，要依赖Eureka Discovery和Web两个库。本节我们主要讨论如何将用户（user）微服务注册到Eureka服务治理中心。至于资金（fund）和产品（product）微服务，也是类似的。</p>
<p>首先，打开user模块的pom.xml，可以看到代码清单3-4所示的节选代码。</p>
<p>代码清单3-4 pom.xml节选（user模块）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大家可以看到，在依赖上，依赖了spring-cloud-starter-netflix-eureka-client包，它是一个服务发现的包，我们依靠它把当前的Spring Boot模块注册到Eureka服务治理中心。</p>
<p>然后，对application.yml文件进行配置，如代码清单3-5所示。</p>
<p>代码清单3-5 application.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例主机名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>
<p>接下来，打开IDEA创建好的UserApplication.java，如代码清单3-6所示。</p>
<p>代码清单3-6 UserApplication（user模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.user.main;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 在新版本的 Spring Cloud中，不再需要这个注解驱动服务发现了</span></span><br><span class="line"><span class="comment">// @EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(UserApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的@EnableDiscoveryClient注解是一个用于服务发现的注解，在旧版本里，还会使用得到它，但在当前最新版本的Spring Cloud中，不需要这个注解就可以驱动服务发现功能。当这个服务启动成功后，它就会根据配置项eureka.client.serviceUrl.defaultZone发送相关的请求，注册实例了。需要注意的是，服务注册功能是在服务启动成功后，间隔一个时间戳才会执行的，所以需要稍等一会儿。</p>
<p>这里，先运行代码清单3-2(eureka-server模块)，然后再运行代码清单3-6，稍等一会儿，在浏览器中打开网址<a target="_blank" rel="noopener" href="http://localhost:5001/，就可以看到图3-3所示的IDE界面了。">http://localhost:5001/，就可以看到图3-3所示的IDE界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141801244.png" alt="image-20231014180119135"></p>
<p>从图3-3中可以看出，刚启动的用户微服务实例已经注册成功了，名称为USER。这个名称是我们application.yml中的配置项spring.application.name的值，是一个微服务的名称。</p>
<p>事实上，一个微服务可以有多个实例，为了展示这点，首先停止代码清单3-6的运行，然后在resources目录下添加两个文件application-peer1.yml和application-peer2.yml，其内容如代码清单3-7和代码清单3-8所示。</p>
<p>代码清单3-7 application-peer1.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-8 application-peer2.yml（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6002</span></span><br></pre></td></tr></table></figure>
<p>注意，这两个配置文件只是配置启动的端口而已，也就是我们可以选择6001端口或者6002端口启动用户微服务。此时对application.yml进行配置，如代码清单3-9所示。</p>
<p>代码清单3-9 application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例主机名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件；</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件。</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>这里使用了spring.profiles.active配置项，如果配置为peer1，则项目使用配置文件application-peer1.yml启动；如果配置为peer2，则使用配置文件application-peer2.yml启动，这样就很方便我们切换了。此时，将spring.profiles.active配置项分别设置为peer1和peer2启动用户微服务，然后再观察Eureka服务治理中心平台，就可以看到图3-4所示的界面了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141809006.png" alt="image-20231014180937959"></p>
<p>从图3-4中我们可以看到，名称为USER的两个微服务实例都已经在Eureka服务治理中心注册成功了。</p>
<p>依照同样的方法处理fund（资金）模块，然后配置其application.yml、application-peer1.yml和application-peer2.yml，如代码清单3-10、代码清单3-11和代码清单3-12所示。</p>
<p>代码清单3-10 application.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 实例服务器名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring应用名称（微服务名称）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fund</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件；</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件。</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-11 application-peer1.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-12 application-peer2.yml（fund模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br></pre></td></tr></table></figure>
<p>这里的配置和用户微服务如出一辙，只是将微服务名称配置为fund，将启动端口切换为7001和7002。这样，就可以启动微服务名称为fund的两个实例了。</p>
<p>使用同样的方法来修改product模块，将其spring.application.name设置为product，然后分别在8001和8002端口启动。稍等一会儿后，再刷新图3-4所示的页面，就可以看到图3-5了。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141836567.png" alt="image-20231014183622458"></p>
<p>从图3-5中，我们看到3个微服务下都存在两个实例，它们都已经成功地注册到服务治理中心了。这样，Eureka服务治理中心就可以治理和监控各个微服务的实例了。</p>
<h4 id="3-1-3-多个服务治理中心实例"><a href="#3-1-3-多个服务治理中心实例" class="headerlink" title="3.1.3 多个服务治理中心实例"></a>3.1.3 多个服务治理中心实例</h4><p>前面，我们给各个微服务分别注册了两个实例，这保证了它们的高可用和性能。但是我们的服务治理中心却只有一个，这就不具备高可用了，因为只要服务治理中心宕机，那么整个微服务系统就垮掉了。为了解决这样的问题，我们希望服务治理中心也能有多个实例，这样就不容易垮掉了。为了达到这个目的，需要对服务治理中心和微服务实例的配置做一些修改。</p>
<p>首先，在模块eureka-server的resources目录下新建两个配置文件，分别为application-peer1.yml和application-peer2.yml，它们的配置如代码清单3-13和代码清单3-14所示。</p>
<p>代码清单3-13 application-peer1.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5001</span></span><br></pre></td></tr></table></figure>
<p>代码清单3-14 application-peer2.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5002</span></span><br></pre></td></tr></table></figure>
<p>请注意这两段代码，Eureka启动的端口分别为5001和5002</p>
<p>然后，修改配置文件application.yml，如代码清单3-15所示。</p>
<p>代码清单3-15 application.yml（eureka-server模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Spring应用名称，它是一个微服务的名称，一个微服务可拥有多个实例</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">eureka-server</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 当配置为“peer1”时选择application-peer1.yml作为配置文件</span></span><br><span class="line">    <span class="comment"># 当配置为“peer2”时选择application-peer2.yml作为配置文件</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#server:</span></span><br><span class="line"><span class="comment">#  port: 5001 #修改内嵌Tomcat端口为5001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 服务注册地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://192.168.1.100:5001/eureka/,http://192.168.1.100:5002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务实例服务器IP</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<p>注意加粗的代码，配置项eureka.client.serviceUrl.defaultZone将实例同时注册到了5001端口和5002端口的Eureka服务端，这样这两个治理服务中心就可以相互注册了。如果要在IDEA中运行它，可以设置spring.profiles.active为peer1或者peer2，从而选择使用application-peer1.yml或者application- peer2.yml启动不同端口的服务。</p>
<p>上面是在IDEA中运行模块，那么如何在命令行中运行多个实例呢？毕竟在实际开发环境中，使用命令行启动模块还是比较普遍的。这里先将Eureka模块打包，得到文件eureka-server-0.0.1-SNAPSHOT.war，跟着执行以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\eureka-server-0.0.1-SNAPSHOT.war --spring.profiles.active=peer1</span><br><span class="line">java -jar .\eureka-server-0.0.1-SNAPSHOT.war --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure>
<p>这两条命令都采用了一个名为spring.profiles.active的运行参数，一旦配置了它，Spring Boot就会使用application-{spring.profiles.active}.yml作为其配置文件进行运行。当将其设置为peer1时，使用application-peer1.yml文件来启用Spring Boot应用。当将其设置为peer2时，使用application-peer2.yml文件来启用Spring Boot应用。</p>
<p>接下来分别修改user、fund和product微服务的配置文件application.yml中的配置项eureka.client. serviceUrl.defaultZone，如代码清单3-16所示。</p>
<p>代码清单3-16 application.yml（user、fund和product模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求URL指向Eureka服务治理中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/,http://localhost:5002/eureka/</span></span><br></pre></td></tr></table></figure>
<p>注意代码加粗的地方，配置项eureka.client.serviceUrl.defaultZone配置成了两个服务治理中心的域，每个域由半角逗号隔开。这样它就会对多个服务治理中心发送注册请求了。然后再重新运行这3个微服务（各自2个实例）。表3-1是我本地启动微服务的具体情况。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843082.png" alt="image-20231014184309046"></p>
<p>等待所有微服务实例启动完成后，等待一段时间，打开服务治理中心（<a href="http://localhost:5001），此时可以看到图3-6所示的界面了。">http://localhost:5001），此时可以看到图3-6所示的界面了。</a></p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843226.png" alt="image-20231014184322192"></p>
<p>从图3-6中可以看出，服务治理中心和各自微服务都存在两个实例。为了让大家对服务治理中心、用户微服务、资金微服务和产品微服务之间的关系有更为清晰的认知，图3-7给出了它们之间的关系图。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141843180.png" alt="image-20231014184357131"></p>
<h3 id="3-2-Eureka治理机制"><a href="#3-2-Eureka治理机制" class="headerlink" title="3.2 Eureka治理机制"></a>3.2 Eureka治理机制</h3><p>在前面几节中，我们搭建了一个简单的Spring Cloud微服务系统。但是，我们没有讨论过微服务系统之间是怎么交互的，将微服务注册到服务治理中心有什么用，服务治理中心是如何管理各个微服务的，在我们需要做出改变时如何修改配置。这些问题就是本节要回答的问题，也是本章的核心内容。</p>
<h4 id="3-2-1-基础架构"><a href="#3-2-1-基础架构" class="headerlink" title="3.2.1 基础架构"></a>3.2.1 基础架构</h4><p>现实业务往往需要多个微服务相互协作才能完成。例如，当用户发出购买理财产品的请求时，这里假设是由理财产品微服务发起的，首先要在理财产品微服务里扣减理财产品对应的额度，然后到资金微服务扣减用户的资金，最后在产品微服务记录购买交易，才能完成这个请求。这个过程涉及了两个微服务的协作。正如之前讨论过的，在微服务架构中，推荐使用的是REST风格请求。为了简化微服务之间的调用，Spring Cloud封装了Ribbon和OpenFeign两个组件，本章会简单讨论Ribbon，但不会讨论OpenFeign。有关于Ribbon和OpenFeign的详细讨论会在后续的章节中进行。值得注意的是，如果已经在模块中引入了spring-cloud-starter-netflix-eureka-client，它的父pom便会自动引入spring-cloud-starter-netflix-ribbon，所以这里不再需要依赖新的包了。</p>
<p>我们来模拟一下交易流程，先在fund模块里创建一个账户控制器，并且实现扣减资金的功能，如代码清单3-17所示。</p>
<p>代码清单3-17 AccountController.java（fund模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.fund.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fund&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">   <span class="comment">// 扣减账户资金</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/account/balance/&#123;userId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">deductingBalance</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;amount&quot;)</span> Double amount,</span></span><br><span class="line"><span class="params">          HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">// 打印当前服务的端口用于监测</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;端口：【&quot;</span> + request.getServerPort() + <span class="string">&quot;】扣减成功&quot;</span>;</span><br><span class="line">      <span class="type">ResultMessage</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>, message);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到一个结果消息类（com.spring.cloud.common.vo.ResultMessage），为此，先创建公共（common）模块，让user、fund和product模块依赖公共模块。然后，再新增结果消息类，其源码可以参考代码清单2-12。这里资金（fund）微服务提供了一个REST端点，在这个方法返回的消息里，存着当前微服务实例的端口，这样就能方便地监控调用的具体是哪个实例的服务了，毕竟我们的资金微服务是存在两个实例的。这里我们使用Spring Cloud提供的组件Ribbon来调用它，Ribbon使用的是处理过的RestTemplate模板。为了在产品微服务中使用Ribbon，我们在ProductApplication中加入RestTemplate的初始化，如代码清单3-18所示。</p>
<p>代码清单3-18 ProductApplication.java（product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product;</span><br><span class="line"><span class="comment">/****imports****/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductApplication</span> &#123;</span><br><span class="line">   <span class="comment">// 负载均衡</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span></span><br><span class="line">   <span class="comment">// 创建Spring Bean</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RestTemplate <span class="title function_">initRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中使用了@LoadBalanced，它代表执行负载均衡，也就是它会使用某种策略进行路由，路由到具体的微服务实例上，在默认情况下，使用的是轮询策略。关于这些第4章会进行详细的讨论。这里还使用了注解@Bean，这样它就会作为Spring Bean存放到IoC容器中。</p>
<p>接下来，创建ProductController，在这里模拟用户购买理财产品的过程，如代码清单3-19所示。</p>
<p>代码清单3-19 ProductController.java（product模块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.cloud.product.controller;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">   <span class="comment">// 依赖注入RestTempalte</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/purchase/&#123;userId&#125;/&#123;productId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultMessage <span class="title function_">purchaseProduct</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;userId&quot;)</span>  Long userId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;productId&quot;)</span> Long productId,</span></span><br><span class="line"><span class="params">          <span class="meta">@PathVariable(&quot;amount&quot;)</span> Double amount)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;扣减产品余额。&quot;</span>);</span><br><span class="line">      <span class="comment">// 这里的FUND代表资金微服务， RestTemplate会自动负载均衡</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://FUND/fund/account/balance/&#123;userId&#125;/&#123;amount&#125;&quot;</span>;</span><br><span class="line">      <span class="comment">// 封装请求参数</span></span><br><span class="line">      Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      params.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">      params.put(<span class="string">&quot;amount&quot;</span>, amount);</span><br><span class="line">      <span class="comment">// 请求资金微服务</span></span><br><span class="line">      <span class="type">ResultMessage</span> <span class="variable">rm</span> <span class="operator">=</span> restTemplate.postForObject(url, <span class="literal">null</span>, ResultMessage.class, params );</span><br><span class="line">      <span class="comment">// 打印资金微服务返回的消息</span></span><br><span class="line">      System.out.println(rm.getMessage());</span><br><span class="line">      System.out.println(<span class="string">&quot;记录交易信息&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultMessage</span>(<span class="literal">true</span>,<span class="string">&quot;交易成功&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，url的服务器和端口被定义为了FUND，与资金微服务的配置项spring.application.name是一致的，这样Eureka服务治理中心就知道你在请求资金微服务，并且默认采用轮询策略做负载均衡。url里面存在着参数的占位定义。跟着使用了Map<String, Object>对象封装请求的参数，其中key和url中参数的占位定义要保持一致。最后使用了RestTemplate的postForObject方法对资金微服务进行请求，这样就可以获取资金微服务返回来的信息进行打印了。</p>
<p>现在我们来启动服务治理中心、资金微服务和理财产品微服务，它们各自存在两个实例。跟着在浏览器地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8001/product/purchase/1/1/1000，然后再刷新页面3次，观察8001端口的理财产品微服务，就可以看到类似如下的日志：">http://localhost:8001/product/purchase/1/1/1000，然后再刷新页面3次，观察8001端口的理财产品微服务，就可以看到类似如下的日志：</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">端口：【7001】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7002】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7001】扣减成功</span><br><span class="line">记录交易信息</span><br><span class="line">扣减产品余额。</span><br><span class="line">端口：【7002】扣减成功</span><br><span class="line">记录交易信息</span><br></pre></td></tr></table></figure>
<p>从日志中可以看出：资金微服务返回了“成功”的消息；理财产品微服务分别调用了资金微服务的两个实例。</p>
<p>这里有一个重要的概念，就是服务调用。所谓服务调用，就是一个服务调用另外一个服务的过程。要解释Eureka作为服务治理中心的服务调用过程，需要讨论其基础架构的3个重要概念。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●服务治理中心：指Eureka服务器，在代码清单3-19中，使用FUND代替了服务器名称（或者地址）和端口。之所以可以这样，是因为FUND这个名称是在Eureka服务治理中心注册的微服务名称，它下面存在7001和7002两个端口资金微服务实例，所以可以轮询选择其中一个。这便是服务治理中心的作用之一。此外，服务治理中心还会提供服务注册、失败剔除、服务续约和服务下线等功能，用来治理各个微服务实例。</span><br><span class="line">●服务提供者：在代码清单3-17到代码清单3-19中，是理财产品微服务调用资金微服务，所以资金微服务是我们例子中的服务提供者。在微服务系统中，服务提供者主要是以REST风格的端点被服务消费者调用的，而服务提供者是注册在Eureka中的，所以Eureka可以对其进行治理。</span><br><span class="line">●服务消费者：这里的服务消费者是理财产品微服务（Product），它会解析类似FUND这样的微服务名称。解析的过程是，首先根据这个名称从服务治理中心获取服务提供者的实例列表，保存在本地，然后通过特定的负载均衡的策略确定具体的实例，最后通过请求该实例获取数据。例子中使用了Ribbon来实现服务消费，在未来还有更为简便的OpenFeign需要介绍。</span><br></pre></td></tr></table></figure>
<p>注意：这里的服务提供者和消费者并不是对立的，一个微服务可以同时是服务消费者和服务提供者，从这个角度来说，服务提供者和消费者都是Eureka服务治理中心的客户端。例如，在上述例子中，理财产品微服务是服务消费者，但在用户查询资金微服务交易流水的时候，可能需要顺便将理财产品的相关信息展示出来，这时，资金微服务就要调用理财产品微服务，此时，理财产品微服务就变为了服务提供者。</p>
<h4 id="3-2-2-服务治理中心工作原理"><a href="#3-2-2-服务治理中心工作原理" class="headerlink" title="3.2.2 服务治理中心工作原理"></a>3.2.2 服务治理中心工作原理</h4><p>通过前面的学习，我们知道了如何将一个微服务实例注册到服务治理中心（Eureka）中，也知道了可以通过Ribbon去实现REST风格的请求，使得系统能够交互起来。并且从实例中，我们可以看到Ribbon还实现了负载均衡。那么Spring Cloud是如何通过Eureka做到这些的呢？这便是本节要谈到的Eureka服务治理中心的工作原理。</p>
<p>为了更好地解释Eureka的运行原理，这里先按之前的实例画出图3-8。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310141921663.png" alt="image-20231014192140470"></p>
<p>​                    图3-8 Eureka服务治理中心工作原理</p>
<p>关于图3-8需要讲解的内容还是比较多的，且相对复杂。为了方便讲解，将分3个不同的维度来讨论。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●微服务实例和服务治理中心的关系。</span><br><span class="line">●服务治理中心。</span><br><span class="line">●微服务之间的相互调用。</span><br></pre></td></tr></table></figure>
<h5 id="1．微服务实例和服务治理中心的关系"><a href="#1．微服务实例和服务治理中心的关系" class="headerlink" title="1．微服务实例和服务治理中心的关系"></a>1．微服务实例和服务治理中心的关系</h5><p>在图3-8中，任何的微服务都可以对Eureka服务治理中心（也称为Eureka服务端）发送REST风格的请求。在Eureka的机制中，一般是由具体的微服务（也称为Eureka客户端）来主动维持它们之间的关系的。Eureka客户端的请求类型包括注册、续约和下线，下面将对它们展开讨论。</p>
<p>●注册：在将具体的微服务实例注册到Eureka服务端时，是通过REST风格请求其配置的属性eureka.client.serviceUrl.defaultZone生成的URL来完成的，这时，微服务会将其自身的信息传递给Eureka服务端，完成注册。大家可以看到，这个属性有个单词zone，事实上，在Eureka中还存在着另外一个概念，那就是region，关于它们的区别后续会加以解释，这里暂时放放。配置项spring.application.name，是作为微服务名称来定义的，这样可以明确该实例归属于哪个微服务。例如，在例子中，我们会将具体的微服务配置为“product”“fund”和“user”等。在微服务实例中，存在一个配置项eureka.client.register-with-eureka，它的值是布尔（boolean）类型的，默认为true，代表默认情况下将微服务注册到Eureka服务治理中心。当我们将其配置为false的时候，微服务不会被注册到Eureka服务端。注意，当启动微服务时，它并不会马上向Eureka服务治理中心发送REST请求，在Eureka服务治理中心注册，它会延迟40秒才发起请求，所以在启动微服务的时候，需要稍等一会儿才能在Eureka服务治理中心页面中看到注册信息。</p>
<p>●续约：在我们将具体的微服务实例注册到Eureka服务端后，并不能保证该实例一直可用，因为该实例可能出现网络故障、机器故障或者服务宕机等，所以具体的微服务实例会按照一个频率对Eureka服务器维持心跳，告诉Eureka该实例是可用的，借此来避免被Eureka服务端剔除出去，这样的行为被称为续约（Renew）。在续约的过程中，存在两个配置项，它们是：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span> </span><br><span class="line">    <span class="comment"># 微服务实例超时失效秒数，默认值为90秒</span></span><br><span class="line">    <span class="comment"># 倘若续约超时，Eureka会将微服务实例剔除</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="comment"># 间隔对应的秒数执行一次续约服务，默认值为30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>这样，Eureka就可以通过续约服务来确认，对应的微服务实例是否还能正常工作了，对于不能正常工作的实例，也能够及时剔除了。</p>
<p>●下线：在系统出现故障，需要停止或者重启某个微服务实例的时候，在正常操作下，实例会对Eureka发送下线REST风格请求，告知服务治理中心，这样客户端就不能再请求这个实例了。例如，我们启动了服务治理中心和用户微服务（在实操中，我发现在IDEA中点下停止是中断服务，而非正常停止，所以测试不会成功，因此建议使用命令行进行测试），然后正常关闭6002端口的用户微服务实例，就可以看到图3-9所示的情况。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142245286.png" alt="image-20231014224549177"></p>
<p>从图3-9中可以看到，6002的微服务已经不在列表中，说明它已经下线了。</p>
<h5 id="2．服务治理中心"><a href="#2．服务治理中心" class="headerlink" title="2．服务治理中心"></a>2．服务治理中心</h5><p>通过注册、续约和下线3种服务，Eureka可以有效地管理具体的微服务实例。但是服务治理中心之间和本身也会提供一定的服务，甚至可以说服务治理中心也是Eureka客户端，因为它也可以注册到其他的Eureka服务器中，被其他的Eureka服务器治理。这一节我们来了解一下Eureka。</p>
<p>●相互复制：之前我们也讨论过，Eureka本身也会相互注册，以保证高可用和高性能。各个Eureka服务器之间也会相互复制，也就是当微服务发生注册、下线和续约这些操作的时候，Eureka会将这些消息转发到其他服务治理中心的实例上，这样就完成同步了。需要注意的是，这里的Eureka服务器之间采用的是对等模式（Peer-to-Peer），也就是每一个Eureka都是等价的，这有别于分布式中的主从模式（Master-Slave）。</p>
<p>●服务剔除：在实际的工作中，有时候有些服务会因为网络故障、内存溢出或者宕机而导致服务不能正常工作，这个时候就要将这些无效的服务实例剔除出去。Eureka Server在启动时，会创建一个定时任务，在默认的情况下，每间隔60秒就会更新一次微服务实例的清单，只要发现有超过90秒没有完成续约的实例，就会将其剔除出去。</p>
<p>●自我保护：当你在本机测试的时候，如果打开图3-9所示的Eureka平台页面，很多时候你会看到红色的英文警告：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#x27;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>事实上，这就是Eureka的自我保护机制。在我们启动实例的时候，微服务实例都会自动查找Eureka进行注册，Eureka实例也是如此。在Eureka注册之后，它自己也会通过心跳来告诉自己还活着。在Eureka运行期间，如果在15分钟内低于85%的情况下心跳测试失败，它就会出现警告（在单机测试中很容易出现，在实际生产环境中往往是网络故障）。当然，如果希望Eureka停止自我保护机制，可以这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> </span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 取消Eureka自我保护机制</span></span><br></pre></td></tr></table></figure>
<p>只是这样会存在一定的风险，在大部分情况下，只需要采用默认值true就好，不需要对其进行修改。在本机的测试中，我一般会将其配置为false，以避免发生关闭的微服务实例无法被服务治理中心剔除出去的问题。</p>
<h5 id="3．微服务之间的相互调用"><a href="#3．微服务之间的相互调用" class="headerlink" title="3．微服务之间的相互调用"></a>3．微服务之间的相互调用</h5><p>在讨论基础架构的时候，我们使用了Ribbon。从例子打出的日志中，可以看到Ribbon已经帮助我们完成了负载均衡。那么整个过程是怎么样的呢？这里就需要讨论服务获取和服务调用这两个功能了。</p>
<p>●服务获取。服务获取是指微服务实例作为Eureka的客户端，从Eureka服务治理中心获取其他微服务实例清单的功能。它还会将该服务实例清单缓存到本地，并且按一定的时间间隔刷新。当我们启动微服务实例的时候，它就会以一个时间间隔（默认是30秒）向Eureka服务治理中心发送REST风格请求，获取一份只读的服务实例清单，跟着进行缓存，在下一个时间间隔再发送REST风格请求到Eureka，获取最新的服务实例清单，以确定哪些实例可用，哪些实例不可用。例如，我们在代码清单3-19中编写URL时，采用了含有FUND字符串的URL。通过这个字符串，Ribbon就知道使用的是资金微服务，跟着从它获取的服务实例清单中，通过一种负载均衡的算法选择其中的一个实例进行调用。在默认的情况下，Ribbon会采用轮询的策略，所以会出现我们例子中的日志，轮流打印出2个实例的信息。这里有两个参数可以配置，一个是是否执行服务获取，另一个是获取服务实例清单的时间间隔，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> </span><br><span class="line">    <span class="comment"># 是否检索服务实例清单，默认值true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 检索服务实例清单的时间间隔（单位秒），默认值30</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>●服务调用。服务调用是指一个微服务调用另一个微服务的过程。在Spring Cloud中，大部分会采用REST风格请求。一个微服务下存在多个实例，那么会采用哪个实例呢？首先，我们之前谈过服务获取的功能，它会从Eureka服务治理中心拉取一份服务实例清单，然后通过某种负载均衡的算法，选择具体的实例，所以这里服务调用的过程核心往往就是负载均衡的算法了。这里我们把它称为“客户端负载均衡”，请注意，这里的“客户端”是针对Eureka服务中心而言的，也就是微服务实例自身是Eureka的客户端。这里的负载均衡是一个相当复杂的内容，在未来我们谈到Ribbon时才会详细地讨论。</p>
<h4 id="3-2-3-Region和Zone"><a href="#3-2-3-Region和Zone" class="headerlink" title="3.2.3 Region和Zone"></a>3.2.3 Region和Zone</h4><p>很多时候，很多开发者不能理解为什么在注册微服务的时候存在Region和Zone。在讨论前，我们先来谈谈它们的英文含义。在英语中，它们都有地区的意思：Region是指大的地区，如亚洲、欧洲或者北美洲等，又或者是一些大的国家，如中国、印度这样的人口大国；而Zone则是指更小的地区，如华北、华南地区，又或者是省份，如广东、江苏等。</p>
<p>实际上，Region和Zone是来自亚马逊云技术服务（Amazon Web Services，AWS）平台的概念。亚马逊之所以提出这样的概念，是因为亚马逊是全球服务的公司，它的站点是全球范围的。假设你在北京调用亚马逊在纽约的站点服务，那么至少会有以下两个问题。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">●距离问题：地球很大，即使是直线距离，从北京到纽约也需要一万多公里的距离。即使网络是以光速（每秒30万公里，事实上，在地球上达不到这个速度，只会更慢）传输数据的，也会产生几十毫秒的延迟，加上光纤制作的网线还不是直线而是曲线，就需要延迟更久的时间。</span><br><span class="line">●地区差异问题：每个国家或地区的习俗和法制基本都是不一样的，存在着很大的地区差异，所以不是一个简单的系统就能够处理所有的业务的，一个服务在不同的国家或者地区需要采用不同的业务模式。</span><br></pre></td></tr></table></figure>
<p>为了解决这两个问题，亚马逊提出了Region和Zone的概念。例如，先确定一个大的范围，如定义我国为一个Region。在这个Region内法律、语言和文化等是接近的，所以在限制问题上得到很大的缓解。但是对于我国这样幅员辽阔的国家来说，主要城市之间的距离也很远，例如，北京到广州也有两千多公里，这就意味着，网络传输距离过长的问题并没有得到太大的缓解。此时，如果服务站点在北京，在经济发达的广东发生了大量的业务，那么长距离的传输就会造成大量的延迟。为了处理这个问题，就提出了Zone的概念，它代表从一个大的区域（Region）切分出来的更小的区域（Zone）。例如，在我国这个Region的基础上再进行划分，将我国南方地区划分为一个Zone，将服务站点设在广州，这样我国南方的请求就可以优先路由到广州，网络传输的距离就小了，延迟的问题就会得到大大的缓解。</p>
<p>在Eureka中也是一样的，在需要大型分布式站点的时候，微服务之间的REST风格请求交互，也应该采用就近原则。例如，深圳的请求应该调用广州的站点服务，而广州站点内部的微服务实例之间会相互调用，而不是跨Zone调用北京的站点服务，这些都是依靠Region和Zone来实现的。例如，一个跨国大型服务网站放置在北京的站点可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 确定一个大区域</span></span><br><span class="line">    <span class="attr">region:</span> <span class="string">China</span></span><br><span class="line">    <span class="comment"># 确定一个小区域</span></span><br><span class="line">    <span class="attr">availability-zones:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure>
<p>这里就将我国定为了该大型服务网站的一个大区，然后在北京放置了一个站点。配置中的availability-zones被设置为北京，这样北方的请求就主要路由到北京站点，由北京站点提供服务，北京站点的微服务实例在相互调用的时候也会采用就近原则，从而提高性能，见图3-10。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142257891.png" alt="image-20231014225706833"></p>
<p>通过Region和Zone概念的设计，可以将机房设置在不同的地区，从而解决距离问题和各个地区业务的差异，进一步提高微服务系统的响应能力和灵活性。</p>
<h4 id="3-2-4-Eureka关键源码解读"><a href="#3-2-4-Eureka关键源码解读" class="headerlink" title="3.2.4 Eureka关键源码解读"></a>3.2.4 Eureka关键源码解读</h4><p>为了让大家更深入地理解Eureka的机制，以及为未来章节奠定基础，本节对关键的源码进行讲解。不过，在Eureka的机制中，主要是客户端主动维护和Eureka服务端的关系，所以这里的源码都是Eureka客户端的逻辑代码。</p>
<p>首先，在旧的Spring Cloud版本中，还需要使用@EnableDiscoveryClient进行服务发现，但在新的版本中已经不需要了。我们从@EnableDiscoveryClient开始解读Eureka的源码，它的源码如代码清单3-20所示。</p>
<p>代码清单3-20 EnableDiscoveryClient的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.client.discovery;</span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation to enable a DiscoveryClient implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(EnableDiscoveryClientImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启动自动注册功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的配置项autoRegister是一个布尔值，默认为true，也就是启用自动注册的功能。在类注释中，我们可以看到，它的作用是标注Eureka客户端（微服务）作为服务发现的实例，这个服务发现的接口是DiscoveryClient。我们稍微研究一下这个接口，接口的设计如图3-11所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142259407.png" alt="image-20231014225951361"></p>
<p>因为其中最常用的是EurekaDiscoveryClient，所以我们将对它进行研究。在其源码中，可以看到，它有两个重要的属性，其类型分别是EurekaInstanceConfig和EurekaClient。这里需要注意的是，EurekaInstanceConfig和EurekaClient是Netflix公司的类，而EurekaDiscoveryClient则是Spring Cloud的类。简单来说，Spring Cloud使用EurekaDiscoveryClient对Netflix公司的类进行了二次封装，使得使用起来更为简单。我们从名称可以知道，EurekaInstanceConfig是一个配置类，而EurekaClient则是一个Eureka客户端类，所以这里研究的核心就是接口EurekaClient。EurekaClient是Netflix公司的接口，我们先来看看它的接口和实现类的设计，如图3-12所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142301889.png" alt="image-20231014230121845"></p>
<p>注意，这里只讨论EurekaClient上下相关的接口和类。接口LookupService和EurekaClient以及类DiscoveryClient是Netflix开发的，而CloudEurekaClient则是Spring Cloud在继承DiscoveryClient的基础上开发的。在上述的例子中，注册到服务中心是通过配置项eureka.client.serviceUrl.defaultZone进行配置的，所以我们可以顺藤摸瓜，在类DiscoveryClient中找到对应的方法getServiceUrlsFromConfig，这是一个被标注了@Deprecated的方法。从注释中可以看到，取代它的是EndpointUtils的getServiceUrlsFromConfig方法。事实上，获取这个URL的就是getServiceUrlsFromConfig方法，所以这里让我们讨论一下它，如代码清单3-21所示。</p>
<p>代码清单3-21 类EndpointUtils的getServiceUrlsFromConfig方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getServiceUrlsFromConfig</span><span class="params">(</span></span><br><span class="line"><span class="params">      EurekaClientConfig clientConfig, String instanceZone, </span></span><br><span class="line"><span class="params">      <span class="type">boolean</span> preferSameZone)</span> &#123;</span><br><span class="line">   <span class="comment">// serviceUrl 是有序加入的</span></span><br><span class="line">   List&lt;String&gt; orderedUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">   <span class="comment">// 寻找Region</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> getRegion(clientConfig);</span><br><span class="line">   <span class="comment">// 寻找可用Zone</span></span><br><span class="line">   String[] availZones </span><br><span class="line">       = clientConfig.getAvailabilityZones(clientConfig.getRegion());</span><br><span class="line">   <span class="comment">// 可用Zone为空则使用默认值</span></span><br><span class="line">   <span class="keyword">if</span> (availZones == <span class="literal">null</span> || availZones.length == <span class="number">0</span>) &#123;</span><br><span class="line">      availZones = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">      availZones[<span class="number">0</span>] = DEFAULT_ZONE;</span><br><span class="line">   &#125;</span><br><span class="line">   logger.debug(<span class="string">&quot;The availability zone for the given region &#123;&#125; are &#123;&#125;&quot;</span>,</span><br><span class="line">      region, availZones);</span><br><span class="line">   <span class="comment">// 从可用Zone数组中检索出当前实例的Zone下标，如果找不到则返回0，从而指向默认zone</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">myZoneOffset</span> <span class="operator">=</span> getZoneOffset(instanceZone, preferSameZone, availZones);</span><br><span class="line">   <span class="comment">// 根据Zone获取已经存在的serviceUrls</span></span><br><span class="line">   List&lt;String&gt; serviceUrls </span><br><span class="line">      = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);</span><br><span class="line">   <span class="comment">// 倘若当前已经存在了对应的serviceUrls，则加入有序数组</span></span><br><span class="line">   <span class="keyword">if</span> (serviceUrls != <span class="literal">null</span>) &#123;</span><br><span class="line">      orderedUrls.addAll(serviceUrls);</span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="comment">// 循环所有的Zone，毕竟可以配置多个zone </span></span><br><span class="line">   <span class="comment">// 设置当前循环下标，</span></span><br><span class="line">   <span class="comment">// 如果当前循环下标（myZoneOffset）指向的是最后一个可用的Zone，则从0开始</span></span><br><span class="line">   <span class="comment">// 否则就从下标myZoneOffset+1开始</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">currentOffset</span> <span class="operator">=</span> </span><br><span class="line">      myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果currentOffset与myZoneOffset不等，则继续循环</span></span><br><span class="line">   <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</span><br><span class="line">      <span class="comment">// 根据zone从当前配置中读取serverUrls</span></span><br><span class="line">       serviceUrls = </span><br><span class="line">         clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);</span><br><span class="line">       <span class="comment">// 如果存在，则加入orderedUrls</span></span><br><span class="line">       <span class="keyword">if</span> (serviceUrls != <span class="literal">null</span>) &#123;</span><br><span class="line">          orderedUrls.addAll(serviceUrls);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果到达数组最后，则从0开始循环</span></span><br><span class="line">       <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</span><br><span class="line">          currentOffset = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 下标递增</span></span><br><span class="line">          currentOffset++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果都为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">          <span class="string">&quot;DiscoveryClient: invalid serviceUrl specified!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orderedUrls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●这里再次看到了Region和Zone，下面我们来描述一下整个过程。</p>
<p>●获取Region，如果没有配置，则使用默认值。一个微服务只能找到一个Region，如果没有找到，就使用默认值。</p>
<p>●通过Region获取可用的Zone数组，一个Region可以对应多个Zone，如果获取Zone失败，则使用默认值。</p>
<p>●在可用的Zone数组中查找当前的Zone实例。如果找到第一个匹配Zone的下标，则返回Zone的下标；如果没有找到，则返回0指向默认值。</p>
<p>●将与Zone匹配的已经配置好的可用serviceUrls加入到orderedUrls中。</p>
<p>●遍历可用Zone数组，找到各个Zone匹配的serviceUrls加入到orderedUrls中，最后返回。</p>
<p>这里还有一个重要的接口，EurekaClientConfig，它的作用是对Eureka客户端进行配置。接口EurekaClientConfig有两个实现，一个是Netflix公司的DefaultEurekaClientConfig，另一个是Spring Cloud自己开发的EurekaClientConfigBean。我们在配置文件（如application.yml）中以“eureka.client”为前缀的配置项就是配置它的属性。在上述代码中，用到了EurekaClientConfigBean的getEurekaServerServiceUrls方法来获取serviceUrl，为此让我们讨论一下它的源码，如代码清单3-22所示。</p>
<h4 id="3-2-5-Eureka使用注意点"><a href="#3-2-5-Eureka使用注意点" class="headerlink" title="3.2.5 Eureka使用注意点"></a>3.2.5 Eureka使用注意点</h4><p>在上述的描述中，结合第1章学习的CAP理论，可以看出Eureka是一个强调AP（可用性和分区容忍）的组件。先谈可用性，Eureka的机制是通过各种REST风格的请求来监控各个微服务甚至其他Eureka服务器是否可用，在一些情况下会剔除它们，所以即使某个微服务只存在一个实例，该微服务也依旧可用，这便是Eureka的高可用性。在Eureka机制中，如果某个微服务实例可能不能使用了，那么Eureka服务器就会通过服务续约机制将其剔除，不再让新的请求路由到这个可能不可用的实例上，从而保证请求能在正常的实例得到处理。</p>
<p>在Eureka的使用过程中，有两个延迟是需要注意的。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●对于服务注册，启动Eureka客户端，它不会马上注册到Eureka服务器。在默认情况下，启动后需要等上40秒后，才会发送REST风格请求到Eureka服务器请求注册。如果注册不成功，它会每30秒尝试注册一次。换句话说，并不是启动Eureka客户端之后，它就马上注册，这是需要注意的地方。</span><br><span class="line"></span><br><span class="line">●对于服务发现，客户端存在自己的缓存清单，在默认的情况下，它是30秒维护一次。换句话说，即使你的新微服务注册到了Eureka，该缓存清单也可能不包含这个新微服务，只有当缓存清单刷新后才能发现新注册的微服务，这是大家在实践中需要注意的。</span><br></pre></td></tr></table></figure>
<p>上述的时间间隔都可以通过配置改变，在3.2.4节的源码分析中，我都进行了详细的论述。为了避免关闭的实例无法被Eureka剔除的问题，在后续本机的测试中，我都是使用配置项关闭Eureka的自我保护机制的（将配置项eureka.server.enable-self-preservation设置为false），这是大家需要注意的地方。</p>
<h3 id="3-3-Eureka配置"><a href="#3-3-Eureka配置" class="headerlink" title="3.3 Eureka配置"></a>3.3 Eureka配置</h3><p>Eureka配置的基础是其治理机制，掌握其治理机制能更好地使用配置。实际上，在讲解其治理机制的时候，已经讲了很大一部分的配置，所以本节的讨论只是在添砖加瓦。对于Eureka的配置分为服务端和客户端，实际的Eureka客户端也是一个具体的微服务实例，甚至Eureka服务器实例也是另外一个Eureka服务器的客户端，正如之前的例子中，我们让两个Eureka服务器相互注册就是这样。</p>
<p>Eureka机制主要的配置是客户端，因为在大部分的情况下都是客户端主动通过REST请求服务端来完成续约和服务获取等重要功能。Eureka客户端的配置主要分两种，一种是服务注册配置，另外一种是服务实例配置。对于服务注册配置，主要是服务注册中心地址、服务获取时间间隔、可用区域等。对于服务实例配置，则主要是服务实例的名称、端口、心跳监测地址等。</p>
<p>Eureka服务器本身在使用时应该说并不需要太多的配置，只需保持原有的配置即可。如果需要更多的配置信息，建议查看它的配置类的源码，它的配置类是org.springframework.cloud.netflix.eureka.server. EurekaServerConfigBean，通过它可以获取更多的信息，这里就不再阐述了。</p>
<h4 id="3-3-1-客户端服务注册配置"><a href="#3-3-1-客户端服务注册配置" class="headerlink" title="3.3.1 客户端服务注册配置"></a>3.3.1 客户端服务注册配置</h4><p>客户端服务注册的配置是以eureka.client为前缀的，如果需要更为详尽的配置信息，可以看org.springframework.cloud.netflix.eureka.EurekaClientConfigBean的源码，换句话说，以eureka.client为前缀的配置项就是配置这个Bean的。</p>
<p>在客户端配置中，最为麻烦的是指定注册中心。上述是使用配置项eureka.client.serviceUrl.defaultZone进行配置的。从代码清单3-21中，我们知道，serviceUrl实际是配置类EurekaClientConfigBean的一个类型为HashMap<String, String>的属性，默认值是<a target="_blank" rel="noopener" href="http://localhost:8761/eureka。但在我们的实例中，启动Eureka的端口是5001和5002，所以我们会这样配置">http://localhost:8761/eureka。但在我们的实例中，启动Eureka的端口是5001和5002，所以我们会这样配置</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务实例注册服务治理中心的URL</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone :</span> <span class="string">http://localhost:5001/eureka/,http://localhost:5002/eureka/</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到，可以配置多个注册中心，它们之间以半角逗号分隔，这样就能够将当前微服务实例注册到Eureka服务治理中心了。但是有时候，注册中心还需要HTTP验证来保证安全性，这个时候就需要改变配置了。例如，<a target="_blank" rel="noopener" href="http://user:password@localhost:5001/eureka，在这个URL中，user是用户名，password是密码。">http://user:password@localhost:5001/eureka，在这个URL中，user是用户名，password是密码。</a></p>
<p>当然，客户端服务注册的配置项还有很多，它们都以eureka.client开头，如表3-2所示。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142319264.png" alt="image-20231014231924190"></p>
<h4 id="3-3-2-客户端服务实例配置"><a href="#3-3-2-客户端服务实例配置" class="headerlink" title="3.3.2 客户端服务实例配置"></a>3.3.2 客户端服务实例配置</h4><p>上述注册配置的信息主要是针对服务发现、获取和续约的，这里的客户端服务实例配置，则是针对Eureka客户端所要注册的信息的。客户端服务实例的配置是以eureka.instance为前缀的，配置的类是org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean。换句话说，如果需要更多的信息，看这个类就可以了。Spring Cloud会用通过EurekaInstanceConfigBean读入的信息，创建InstanceInfo实例，然后将InstanceInfo实例通过REST请求发送给Eureka服务器。</p>
<p>首先，我们先来看服务实例名称的配置。在默认的情况下，启动Eureka客户端，就可以在Eureka服务器平台上看到图3-13所示的信息。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310142320958.png" alt="image-20231014232039906"></p>
<p>从图中可以看到，每一个微服务都有两个实例，而每一个实例的名称又不尽相同，那么它的规则是怎么样的呢？在Spring Cloud中，微服务实例默认的名称规则是，如果我们配置了spring.application. instance_id，则名称为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;spring.cloud.hostname&#125;</span>:$(spring.application.name):$(spring.application.instance_id)</span><br></pre></td></tr></table></figure>
<p>如果没配置，则名称为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;spring.cloud.hostname&#125;</span>:$(spring.application.name):$(server.port)</span><br></pre></td></tr></table></figure>
<p>显然，图3-13中的微服务实例名称没有配置spring.application.instance_id，所以会采用第二种规则来产生服务实例名称。倘若开发者不想采用Spring Cloud提供的规则，那么也可以使用自定义服务实例名称，使用配置项eureka.instance.instance-id就行。例如，修改用户的application-peer2.yml文件的配置项，如代码清单3-27所示。</p>
<p>代码清单3-27 修改application-peer2.yml中的服务实例名称（user模块）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义微服务实例信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 微服务id，规则为“实例服务器名称-微服务名称-端口”</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;-user-$&#123;server.port&#125;</span></span><br><span class="line">    <span class="comment"># “实例服务器名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>
<p>然后，我们重启Eureka服务器，就可以看到图3-14所示的结果了。<img src="https://gitee.com/fjkf/images/raw/master/202310142323408.png" alt="image-20231014232307349"></p>
<p>从图3-14中可以看到，通过配置项eureka.instance.instance-id可以修改服务名称了。只是在配置服务名称的过程中，大家要尽量避免重名的发生。我还是建议使用服务器名称（或者IP）、微服务名称和端口一起构成命名，或者直接使用Spring Cloud默认的规则。</p>
<p>此外，还可以自定义服务实例的元数据，使用的配置项是eureka.instance.metadata-map，它是一个Map结构，允许我们自定义启动实例的元数据。比方说，我们的用户微服务6002端口部署的是v2版本，为了标记它的版本号，我们可以在application-peer2.yml文件中修改相关的配置项，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义微服务实例信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="comment"># 自定义元数据版本号（version）为v2</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure>
<p>自定义的元数据会被发送到Eureka服务端，其他的微服务也可以读取这个配置，这样就知道部署的是什么版本的服务了。</p>
<h2 id="第4章-客户端负载均衡——Ribbon"><a href="#第4章-客户端负载均衡——Ribbon" class="headerlink" title="第4章 客户端负载均衡——Ribbon"></a>第4章 客户端负载均衡——Ribbon</h2><p>Spring Cloud Netflix Ribbon是一种客户端负载均衡的组件，为了方便，在本书中都简称为Ribbon。在微服务架构中，我们依照业务将系统进行切分，但一个实际的业务往往需要多个微服务通过相互协作来完成，所以各种微服务之间存在服务调用。</p>
<p>在Spring Cloud中，提供的服务调用是Ribbon和OpenFeign。Ribbon是Netflix公司开发的组件，Spring Cloud通过二次封装使得它更加简单易用。OpenFeign实际也是基于Ribbon来实现的。</p>
<p>微服务之间的调用往往被称为“客户端负载均衡”，这是因为在Eureka的机制中，任何微服务都是Eureka的“客户端”。通过第3章的学习，可以知道一个微服务可以存在多个实例，在进行服务调用的时候需要选取具体实例进行调用，这就需要通过具体的负载均衡算法来实现了。正如我们第3章的例子，产品微服务可能会调用资金微服务，但是资金微服务下面又分为多个实例，如何获取资金微服务下的多个实例是服务实例清单获取和维护的功能，而如何选取具体的服务实例就是负载均衡的功能了。</p>
<h3 id="4-1-负载均衡概述"><a href="#4-1-负载均衡概述" class="headerlink" title="4.1 负载均衡概述"></a>4.1 负载均衡概述</h3><p>负载均衡是大型网络系统必须实现的功能之一，主要原因有以下4点。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">●降低单机压力：因为在大量的用户、请求和数据面前，单机是无法承受的。实现了负载均衡的系统往往能够根据合理的算法将用户、请求和数据分摊到各个机器上，减少单机压力。●高可用和高性能：当某个节点出现问题时，可以测试其心跳，如果失败到达一定程度，就将它剔出系统；也可以判断它是否处于忙碌阶段，通过负载均衡算法选择是否调度它。这样就保证了高可用。因为可以无限扩展机器，所以在遇到性能瓶颈的时候，可以通过增加机器来保证性能，具备高性能的特点。</span><br><span class="line">●可伸缩性：当企业业务规模快速扩大时，可以通过增加节点的方式，提高系统的服务能力；当业务规模快速减小时，可以通过减少节点的方式，节省资源。</span><br><span class="line">●请求过滤：提供过滤器的使用，过滤器可以通过简单的判断来监测请求的合法性或者对请求流量进行限制，从而避免对具体节点系统的恶意攻击，达到保护系统和提高系统响应能力的目的。</span><br></pre></td></tr></table></figure>
<p>在实际生产中，负载均衡分为硬件负载均衡和软件负载均衡。当前最流行的硬件负载均衡当属F5，但是硬件负载均衡不是软件工程师需要掌握的内容，它是由运维和网络人员进行配置的，所以本书不讨论它。软件负载均衡是本章要讨论的核心。无论是硬件负载均衡，还是软件负载均衡，都可以用类似于图4-1所示的形式构建。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/">https://wdpname.github.io/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图解HTTP</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Boot从入门到实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/JDBC%E5%9F%BA%E7%A1%80/" title="JDBC基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">JDBC基础</div></div></a></div><div><a href="/2022/09/25/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java基础笔记</div></div></a></div><div><a href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java编程的逻辑</div></div></a></div><div><a href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">Maven实战</div></div></a></div><div><a href="/2023/03/05/MyBatis%E5%9F%BA%E7%A1%80/" title="MyBatis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">MyBatis基础</div></div></a></div><div><a href="/2023/03/12/SpringBoot%E5%9F%BA%E7%A1%80/" title="SpringBoot基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">SpringBoot基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">160</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">第一部分 概述和基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 分布式和微服务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 互联网系统的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 分布式系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%88%87%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 分布式的切分方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">1．水平切分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">2．垂直切分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%B7%B7%E5%90%88%E5%88%87%E5%88%86"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">3．混合切分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 分布式系统所面临的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 分布式系统的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-CAP%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 CAP原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-BASE%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 BASE理论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2 微服务的风格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">1．组件化和服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E5%9B%B4%E7%BB%95%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%BB%84%E7%BB%87%E5%9B%A2%E9%98%9F"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2．围绕业务功能组织团队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E6%98%AF%E4%BA%A7%E5%93%81%E8%80%8C%E4%B8%8D%E6%98%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">3．是产品而不是项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%8E%E5%BC%BA%E5%8C%96%E7%BB%88%E7%AB%AF%E5%8F%8A%E5%BC%B1%E5%8C%96%E9%80%9A%E9%81%93"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">4．强化终端及弱化通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%8E%E5%88%86%E6%95%A3%E6%B2%BB%E7%90%86"><span class="toc-number">1.1.4.2.5.</span> <span class="toc-text">5．分散治理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%8E%E5%88%86%E6%95%A3%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.4.2.6.</span> <span class="toc-text">6．分散数据管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%EF%BC%8E%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">1.1.4.2.7.</span> <span class="toc-text">7．基础设施自动化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%8E%E5%AE%B9%E9%94%99%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.4.2.8.</span> <span class="toc-text">8．容错性设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%EF%BC%8E%E8%AE%BE%E8%AE%A1%E6%94%B9%E8%BF%9B"><span class="toc-number">1.1.4.2.9.</span> <span class="toc-text">9．设计改进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3 微服务和分布式系统的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Spring-Cloud"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-Spring-Cloud%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1 Spring Cloud的各个组件的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-Spring-Cloud%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2 Spring Cloud版本说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A0%B7%E4%BE%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 微服务系统样例简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 技术基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Spring-Boot"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BASpring-Boot%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 创建Spring Boot工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Spring-Boot%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 Spring Boot开发简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%A4%9A%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 多文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%89%93%E5%8C%85%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 打包和运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-Spring-Boot%E7%9B%91%E6%8E%A7"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5 Spring Boot监控</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">第二部分 Spring Cloud微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94Eureka"><span class="toc-number">2.1.</span> <span class="toc-text">第3章 服务治理——Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1 服务治理中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%90%AD%E5%BB%BAEureka%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">3.1.1 搭建Eureka服务治理中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">3.1.2 服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">3.1.3 多个服务治理中心实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Eureka%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.2 Eureka治理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">3.2.1 基础架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">3.2.2 服务治理中心工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">1．微服务实例和服务治理中心的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%8E%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">2．服务治理中心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.2.2.3.</span> <span class="toc-text">3．微服务之间的相互调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Region%E5%92%8CZone"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">3.2.3 Region和Zone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Eureka%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">3.2.4 Eureka关键源码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-Eureka%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">3.2.5 Eureka使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Eureka%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.3 Eureka配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">3.3.1 客户端服务注册配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">3.3.2 客户端服务实例配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E2%80%94%E2%80%94Ribbon"><span class="toc-number">2.2.</span> <span class="toc-text">第4章 客户端负载均衡——Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.1 负载均衡概述</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven实战"/></a><div class="content"><a class="title" href="/2023/10/15/Maven%E5%AE%9E%E6%88%98/" title="Maven实战">Maven实战</a><time datetime="2023-10-15T11:12:27.000Z" title="发表于 2023-10-15 19:12:27">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解HTTP"/></a><div class="content"><a class="title" href="/2023/10/15/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2023-10-15T10:39:45.000Z" title="发表于 2023-10-15 18:39:45">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud微服务和分布式系统实践"/></a><div class="content"><a class="title" href="/2023/10/13/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/" title="Spring Cloud微服务和分布式系统实践">Spring Cloud微服务和分布式系统实践</a><time datetime="2023-10-13T10:57:16.000Z" title="发表于 2023-10-13 18:57:16">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot从入门到实战"/></a><div class="content"><a class="title" href="/2023/10/09/Spring-Boot%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/" title="Spring Boot从入门到实战">Spring Boot从入门到实战</a><time datetime="2023-10-09T07:04:53.000Z" title="发表于 2023-10-09 15:04:53">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程的逻辑"/></a><div class="content"><a class="title" href="/2023/10/07/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" title="Java编程的逻辑">Java编程的逻辑</a><time datetime="2023-10-07T08:55:18.000Z" title="发表于 2023-10-07 16:55:18">2023-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>