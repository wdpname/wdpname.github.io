<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL是怎样运行的 | 平博社</title><meta name="keywords" content="MySQL"><meta name="author" content="dpWu"><meta name="copyright" content="dpWu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第1章 装作自己是个小白—初识MySQL1.1 MySQL的客户端&#x2F;服务器架构以我们平时使用的微信为例，它其实是由客户端程序(可以简称为客户端)和服务器程序(可以简称为服务器)两部分组成的。微信客户端可能具有多种形式，比如手机App、桌面端的软件或者网页版的微信。微信的每个客户端都有一个唯一的用户名，即微信号。另一方面，腾讯公司在它们的机房里运行着微信的服务器程序。我们平时在微信上的各种操作，其实">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL是怎样运行的">
<meta property="og:url" content="https://wdpname.github.io/2023/10/21/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/index.html">
<meta property="og:site_name" content="平博社">
<meta property="og:description" content="第1章 装作自己是个小白—初识MySQL1.1 MySQL的客户端&#x2F;服务器架构以我们平时使用的微信为例，它其实是由客户端程序(可以简称为客户端)和服务器程序(可以简称为服务器)两部分组成的。微信客户端可能具有多种形式，比如手机App、桌面端的软件或者网页版的微信。微信的每个客户端都有一个唯一的用户名，即微信号。另一方面，腾讯公司在它们的机房里运行着微信的服务器程序。我们平时在微信上的各种操作，其实">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-21T01:12:50.000Z">
<meta property="article:modified_time" content="2023-11-06T14:56:56.804Z">
<meta property="article:author" content="dpWu">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/assets/avatar.jpeg"><link rel="canonical" href="https://wdpname.github.io/2023/10/21/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL是怎样运行的',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-06 22:56:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平博社</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySQL是怎样运行的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-21T01:12:50.000Z" title="发表于 2023-10-21 09:12:50">2023-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-06T14:56:56.804Z" title="更新于 2023-11-06 22:56:56">2023-11-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL是怎样运行的"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第1章-装作自己是个小白—初识MySQL"><a href="#第1章-装作自己是个小白—初识MySQL" class="headerlink" title="第1章 装作自己是个小白—初识MySQL"></a>第1章 装作自己是个小白—初识MySQL</h1><h2 id="1-1-MySQL的客户端-服务器架构"><a href="#1-1-MySQL的客户端-服务器架构" class="headerlink" title="1.1 MySQL的客户端/服务器架构"></a>1.1 MySQL的客户端/服务器架构</h2><p>以我们平时使用的微信为例，它其实是由客户端程序(可以简称为客户端)和服务器程序(可以简称为服务器)两部分组成的。微信客户端可能具有多种形式，比如手机App、桌面端的软件或者网页版的微信。微信的每个客户端都有一个唯一的用户名，即微信号。另一方面，腾讯公司在它们的机房里运行着微信的服务器程序。我们平时在微信上的各种操作，其实就是使用微信客户端与微信服务器打交道。比如狗哥使用微信给猫爷发一条微信消息的过程大致如下所示。</p>
<p>1.狗哥发出的微信消息被客户端进行包装，添加了发送者和接收者的信息，然后从客户端发送到微信服务器。</p>
<h2 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h2><p>在安装MySQL 时，无论是通过下载源代码的方式自行编译安装，还是直接使用官方提供的安装包进行安装，MySQL的服务器程和客户端程序都会安装到机器上。无论采用上述哪种安装方式，一定要记住MySQL安装在哪里了。换句话说，一定一定一定要记住MySQL 的安装目录。</p>
<p>mysql在请求数据，会缓存释放连接所拥有的线程，</p>
<p>查询缓存是什么：为什么要有查询缓存 ？ 因为查询缓存可以加速请求的响应时间，让客户端有更好的体验。</p>
<p>表的 结构  索引  约束</p>
<p>查询缓存</p>
<p>server层与存储引擎层交互时，一般是以记录为单位的。</p>
<h1 id="第2章-MySQL的调控按钮—-启动选项和系统变量"><a href="#第2章-MySQL的调控按钮—-启动选项和系统变量" class="headerlink" title="第2章 MySQL的调控按钮—-启动选项和系统变量"></a>第2章 MySQL的调控按钮—-启动选项和系统变量</h1><p>启动选项：在程序启动时指定的设置项也称之为启动选项(startup option)，可以在命令行中配置或者配置文件中</p>
<h2 id="2-3-状态变量"><a href="#2-3-状态变量" class="headerlink" title="2.3 状态变量"></a>2.3 状态变量</h2><h1 id="第三章-字符集和比较规则"><a href="#第三章-字符集和比较规则" class="headerlink" title="第三章 字符集和比较规则"></a>第三章 字符集和比较规则</h1><h1 id="第4章-从一条记录说起—-InnoDB记录存储结构"><a href="#第4章-从一条记录说起—-InnoDB记录存储结构" class="headerlink" title="第4章 从一条记录说起—-InnoDB记录存储结构"></a>第4章 从一条记录说起—-InnoDB记录存储结构</h1><h2 id="4-1准备工作"><a href="#4-1准备工作" class="headerlink" title="4.1准备工作"></a>4.1准备工作</h2><h2 id="4-2-InnoDB页简介"><a href="#4-2-InnoDB页简介" class="headerlink" title="4.2 InnoDB页简介"></a>4.2 InnoDB页简介</h2><p>一般内存和磁盘交互，通过页来进行交互。为什么使用页来交互？而不用字节，块，啥的呢？ 因为磁盘一般使用块来读取写入数据，这样我们设置相同于磁盘块大小的页交互，这样更加快速和方便。</p>
<h2 id="4-3-InnoDB行格式"><a href="#4-3-InnoDB行格式" class="headerlink" title="4.3 InnoDB行格式"></a>4.3 InnoDB行格式</h2><p>为什么有行格式这一说辞？</p>
<p>因为平时我们都是以记录为单位向表中插入数据，这些记录在磁盘上的存储的形式是什么呢？</p>
<p>这种形式就是行格式。</p>
<p>compact   redundant dynamic compressed 四种行格式</p>
<h3 id="4-3-1指定行格式的语法"><a href="#4-3-1指定行格式的语法" class="headerlink" title="4.3.1指定行格式的语法"></a>4.3.1指定行格式的语法</h3><p>使用row_format=【】</p>
<h3 id="4-3-2-COMPACT行格式"><a href="#4-3-2-COMPACT行格式" class="headerlink" title="4.3.2 COMPACT行格式"></a>4.3.2 COMPACT行格式</h3><p><img src="https://gitee.com/fjkf/images/raw/master/202310211451266.png" alt="image-20231021145128057"></p>
<p>❓为什么一条记录除了记录真实数据外，还要记录一些额外信息？</p>
<p>因为这些额外信息可以让我们更好的管理记录。</p>
<p>❓当使用变长字段的时候，我们不知道这些字段是存储了多大的字节数据，所以存储引擎就会被这些变长字段搞懵！那怎么应对这种情况？</p>
<p>可以在额外信息中记录这些变长字段所占用的字节数。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202310211502149.png" alt="image-20231021150215041"></p>
<p>❓有些情况某个变长字段占有的字节数可以使用一个字节表示，而有些需要两个字节，那些情况使用一个字节，那些情况使用两个字节？</p>
<p>为此，InnoDB存储引擎引入W,M,L符号，W：utf8mb4字符集中的W就是4，VARCHAR（M）表示能存储M个字符，L:表示当前这个字段实际占用的字节数。显而易见，WxM&lt;=255,无论L怎么样，都使用一个字节即可。反之，如果L&lt;=127,使用一个字节，否则使用两个字节。这样就可以通过判断某个字节的第一个二进制位是否为0，来断定该字节是一个单独的字段长度，还是半个字段长度。（非常巧妙，太聪明啦！！！）</p>
<p>❓为什么额外信息中的变长字段长度列表只存储非null变长字段的字节数信息？</p>
<p>因为要是存储null类型，本身null类型只有一种值，你存不存储，存储引擎在拿到这个记录，只需要去查看真实数据中的字段，发现是null，就确定了这个字段的大小啦！！！</p>
<p>❓为什么要存在额外信息中NULL值列表？</p>
<p>因为为了节省空间。对于一个满是null的记录，我们没有必要在真实数据中为每个字段都记录null，这样非常浪费空间。</p>
<p>❓我们应该怎样在NULL值列表加入什么，从而可以记录每个列的null值情况？</p>
<p>我们可以通过每个二进制位来表示某个列是否存储的是null，1表示存储的是null。</p>
<p>❓在什么情况下列字段所占字节数会被放入变长字段长度列表中？</p>
<p>在列字段数据类型为变长类型或者字符集为不定长的，如utf8</p>
<h3 id="4-3-3-REDUNDANT行格式"><a href="#4-3-3-REDUNDANT行格式" class="headerlink" title="4.3.3 REDUNDANT行格式"></a>4.3.3 REDUNDANT行格式</h3><p><img src="https://gitee.com/fjkf/images/raw/master/202310212154446.png" alt="image-20231021215455286"></p>
<p>❓为啥可以使用字段长度偏移列表来代替变长字段长度列表？</p>
<p>通过两个相邻偏移量的差值就能得出某个列所占用的字节数。</p>
<p>❓为啥使用真实数据的结束位置作为偏移，而不是开头位置？</p>
<p>要是开头位置，那么就不能计算最后一个字段占用的字节数。</p>
<p>❓每个字段的偏移量怎么确定？</p>
<p>由于每个字段的偏移量都需要存储在字段长度偏移列表，而每个偏移量是根据每个字段的结束位置，所以每个字段的偏移量的字节大小是根据存储真实数据的总字节数来决定的。而又不可能无限大。超过某个数，就会将记录的一部分存放在一个叫做溢出页当中。</p>
<p>❓为什么当真实数据大于127时，偏移量使用2字节？</p>
<p>因为在这种行格式中，并没有在额外信息中添加NULL值列表，所以在表示偏移量的字节中用首个二进制位表示是否为NULL。</p>
<h3 id="4-3-4-溢出列"><a href="#4-3-4-溢出列" class="headerlink" title="4.3.4 溢出列"></a>4.3.4 溢出列</h3><p>❓为什么会发生列的溢出？</p>
<p>顾名思义，对于列都有自己的存储极限，并且记录是存储在页中的，页一般是16kB，极有可能出现列的溢出。</p>
<p>❓我们应该怎么解决列的溢出呢？</p>
<p>在上面提及的两种行格式中，由于实在存不下这么多数据，可以选择存储一部分，将剩余一大部分数据存储在<strong>其他页</strong>（溢出页）中，然后拿出20个字节来保存其他页的地址和在每一页中所占有的字节数。</p>
<h3 id="4-3-5-DYNAMIC行格式和COMPRESSED行格式"><a href="#4-3-5-DYNAMIC行格式和COMPRESSED行格式" class="headerlink" title="4.3.5 DYNAMIC行格式和COMPRESSED行格式"></a>4.3.5 DYNAMIC行格式和COMPRESSED行格式</h3><p>❓首先，请问这两种格式是借鉴上面提及的两种格式的哪一种？</p>
<p>由于REDUNDANT行格式使用存储空间不紧凑，故排除。</p>
<p>所以这两种新的行格式都是类似于COMPACT行格式。</p>
<p>❓但是总得有所区别吧，相对于COMPACT行格式？</p>
<p>不同之处就在于记录中只存储溢出页的地址和字节数，不存储部分数据。并且顾名思义，COMPRESSED行格式会使用压缩算法对页面进行压缩，节省空间。</p>
<h1 id="第5章-盛放记录的大盒子一InnoDB数据页结构"><a href="#第5章-盛放记录的大盒子一InnoDB数据页结构" class="headerlink" title="第5章 盛放记录的大盒子一InnoDB数据页结构"></a>第5章 盛放记录的大盒子一InnoDB数据页结构</h1><h2 id="5-1-不同类型的页简介"><a href="#5-1-不同类型的页简介" class="headerlink" title="5.1 不同类型的页简介"></a>5.1 不同类型的页简介</h2><p>有数据页（索引页），存放表空间头部信息的页</p>
<h2 id="5-2-数据页结构快览"><a href="#5-2-数据页结构快览" class="headerlink" title="5.2 数据页结构快览"></a>5.2 数据页结构快览</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310220937876.png" alt="image-20231022093714703"></p>
<h2 id="5-3-记录在页中的存储"><a href="#5-3-记录在页中的存储" class="headerlink" title="5.3 记录在页中的存储"></a>5.3 记录在页中的存储</h2><p>❓我们的记录存储在哪里？</p>
<p>看上面的图，我们是用户，所以记录存储在User Records中。</p>
<p>❓为什么User Records结构占用的空间大小是不确定的？</p>
<p>因为一开始，页中是没有这一结构的，如果要往页中插入记录，就需要从空闲空间中请求空间给用户记录。</p>
<p>❓那么等到空闲空间没有剩余空间给用户记录时，咋办？</p>
<p>那么就需要申请新的页了</p>
<h3 id="5-3-1-记录头信息的秘密"><a href="#5-3-1-记录头信息的秘密" class="headerlink" title="5.3.1 记录头信息的秘密"></a>5.3.1 记录头信息的秘密</h3><p>❓deleted_flag是什么？</p>
<p>他是一个用来标记当前记录是否被删除。那存在这种标签，说明记录并未真真实实地被删除，而是虚假的删除。</p>
<p>❓为什么要这样设置？</p>
<p>首先要是真实的删除这样一个记录，那么InnoDB引擎就需要重新将记录排列，这样会造成性能消耗。</p>
<p>❓那这样的话，未删除的记录和已经删除的记录都存储在用户记录中，不利于快速分辨这两种记录，该如何解决？</p>
<p>这里有一个垃圾链表，也是通过next_record组织的，专门存储这些被删除的记录，</p>
<p>❓那要是有新的记录插入到表中，会如何处理？</p>
<p>因为有了垃圾链表，我们可以将新记录去覆盖掉一个被删除的记录。</p>
<p>❓heap_no是什么？</p>
<p>首先heap其实就是页中的用户记录，每条记录都有一个heap_no，从0开始计数，每次+1。并且0和1被自动向页中添加两个虚拟记录占据，一个是页中的最小记录，一个是页中的最大记录。</p>
<p>❓记录可以比大小吗？</p>
<p>当然可以。但是记录中存在许多信息，我们不可能将这么多信息进行比较，所以选出一个代表性的字段进行比较即可，同样为了可以进行比较，所以需要唯一，所以选用主键进行比较。</p>
<p>❓为什么heap_no的值无论记录是否被删除，都不会改变？</p>
<p>这应该还是由于性能消耗的问题。</p>
<p>❓一个页的记录是怎样进行遍历的？</p>
<p>记录头信息中有这样一个字段：next_record，他指示了当前记录的真实数据到下一个记录的真实数据的距离，可正可负；</p>
<p>并且Infimum记录是开头，Supremum记录是结尾。</p>
<p>❓那这些记录是怎样进行组织的？</p>
<p>通过比较主键大小，主键小的在前，主键大的在后。通过next_record指向，相当于组织成了一个单向链表。</p>
<p>❓为啥变长字段列表和NULL值列表是逆序排列的？</p>
<p>因为会用到高速缓存，而记录中靠前的字段和他的字段长度信息在内存中的距离会越近，提高高速缓存的命中率。</p>
<h2 id="5-4-Page-Directory-页目录"><a href="#5-4-Page-Directory-页目录" class="headerlink" title="5.4 Page Directory(页目录)"></a>5.4 Page Directory(页目录)</h2><p>❓为什么需要页目录？</p>
<p>因为要是没有页目录，那么我们查找某一记录时，就必须按照单向链表一个一个遍历，非常的笨，非常的低效。</p>
<p>❓怎么设计这个页目录？</p>
<p>首先有许多的记录，所以我们可以将这些记录分成若干个组，每个组中有多条记录，设置最大主键的那条记录为带头大哥，每个组的带头大哥的偏移量（从第0个字节到这个带头大哥的真实数据的距离）被称为槽，放入到页目录中，并且按照每个槽所属的带头大哥的主键从大到小排序。</p>
<p>❓这样设计页目录的目的？</p>
<p>可以使用二分法，来快速定位某一要查找的记录，根据主键id查找。</p>
<h2 id="5-5-Page-Header-页面头部"><a href="#5-5-Page-Header-页面头部" class="headerlink" title="5.5 Page Header(页面头部)"></a>5.5 Page Header(页面头部)</h2><p>❓为什么要有页面头部？</p>
<p>页目录只是说明了怎么去更快的查询记录，而我们不能去O(1)的时间复杂度去得到一些信息。就好如一个数组的数据结构，却未设置一个size的属性来绑定当前使用的数组的长度。</p>
<h2 id="5-6-File-Header-文件头部"><a href="#5-6-File-Header-文件头部" class="headerlink" title="5.6 File Header(文件头部)"></a>5.6 File Header(文件头部)</h2><p><img src="https://gitee.com/fjkf/images/raw/master/202310221625235.png" alt="image-20231022162513960"></p>
<p>❓我们知道InnoDB存储引擎时使用页来作为存储单位的，那么当一个页不能存储完某些数据，那么怎么进行多个页面的存储和管理？</p>
<p>对于这一部分的页结构，会通过FIL_PAGE_NEXT和FIL_PAGE_PREV两种名称来维护一个双向链表。</p>
<h2 id="5-7-File-Trailer-文件尾部"><a href="#5-7-File-Trailer-文件尾部" class="headerlink" title="5.7 File Trailer(文件尾部)"></a>5.7 File Trailer(文件尾部)</h2><p>❓为什么FIle Header和File Trailer中都存在当前页面的校验和？</p>
<p>因为页总会被用户修改（比如增加一个记录），页修改了，就会将新的页同步到磁盘中，而同步过程中可能发生错误（比如，断电），如何对这种错误进行捕捉，无论如何在同步的时候，首先都是将File Header中的页的校验和覆盖到磁盘上，如果期间发生错误，那么File Trailer中的校验和就还是原来的页的校验和，而File Header中的校验和始终是新的校验和，这两者不同。发现错误</p>
<h1 id="第6章-快速查询的秘籍—-B-树索引"><a href="#第6章-快速查询的秘籍—-B-树索引" class="headerlink" title="第6章 快速查询的秘籍—-B+树索引"></a>第6章 快速查询的秘籍—-B+树索引</h1><h2 id="6-1-没有索引时进行查找"><a href="#6-1-没有索引时进行查找" class="headerlink" title="6.1 没有索引时进行查找"></a>6.1 没有索引时进行查找</h2><h3 id="6-1-1在一个页中查找"><a href="#6-1-1在一个页中查找" class="headerlink" title="6.1.1在一个页中查找"></a>6.1.1在一个页中查找</h3><p>对于通过主键查找的情况，可以使用（有页目录提供支持）二分法查找，</p>
<p>对于不是通过主键查找的情况，就只能通过从Infimum记录开始沿着单向链表进行遍历查找，非常的慢。</p>
<h3 id="6-1-2-在很多页中查找"><a href="#6-1-2-在很多页中查找" class="headerlink" title="6.1.2 在很多页中查找"></a>6.1.2 在很多页中查找</h3><p>❓为什么在很多页中没有索引的时候，查找效率非常低下？</p>
<p>因为你只能从开始第一页通过双向链表遍历这些页，在每个页中，又还要从Infimum记录开始沿着单向链表进行遍历查找。非常非常慢。</p>
<h2 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引"></a>6.2 索引</h2><p>❓为什么要有索引？</p>
<p>就是解决在不根据主键来查找记录的时候，效率非常慢的情况</p>
<h3 id="6-2-1-一个简单的索引方案"><a href="#6-2-1-一个简单的索引方案" class="headerlink" title="6.2.1 一个简单的索引方案"></a>6.2.1 一个简单的索引方案</h3><p>中心思想：现在又很多页，规定前一个页的最大主键id都小于下一个页的任何主键id，每个页有自己的编号，每个页选出主键最小的主键id和当前页号，将这些信息组建成一个数组，这样就可以通过二分法知道当前搜索的主键id是存在于那个页中，然后在这个页中根据单向链表进行遍历查找。</p>
<p>而这个数组就是索引</p>
<h3 id="6-2-2-InnoDB中的索引方案"><a href="#6-2-2-InnoDB中的索引方案" class="headerlink" title="6.2.2 InnoDB中的索引方案"></a>6.2.2 InnoDB中的索引方案</h3><p>❓为什么存在记录类型为1的目录项记录？</p>
<p>对于上面所提及的简单的索引方案中，数组就是索引。而数组是连续存储的，当存储的页数非常多，那么数组就非常大，需要的连续空间就非常大，当我们删除一个页后，就需要牵一发而动全身的将数组移动，这很不合理。而我们可以使用目录项记录来存储数组（索引）中的的两个列：主键和页号。</p>
<p>❓在InnoDB存储引擎中，是怎样存储记录的？</p>
<p>通过聚簇索引，也就是所谓的”索引即数据，数据即索引“。</p>
<p>❓为什么存在二级索引？</p>
<p>二级索引其实就是根据非主键的大小顺序建立的b+树，这样我们就能通过非主键使用二分法快速找到记录</p>
<p>❓为什么二级索引需要回表？</p>
<p>因为我们不能将每个二级索引的叶子节点都带上完整的记录，因为这样非常的浪费存储空间</p>
<p>❓什么是回表？</p>
<p>其实就是在二级索引中找到满足条件的第一个记录的时候，当心！二级索引的每个叶子节点存储的都是该非主键id和主键id。在找到满足条件的第一个记录的时候，就回到聚簇索引中根据主键id找到完整的记录，然后回到二级索引中继续遍历找到第二个满足条件的记录，然后再回表。</p>
<p>❓上面的情况都是一个条件，那么多个条件怎么快速查找呢？</p>
<p>这个时候需要建立联合索引，联合索引也是一种二级索引，不同在于列值更多，叶子节点上的列值包括各个列和主键id。</p>
<h3 id="6-2-3-InnoDB中B-树索引的注意事项"><a href="#6-2-3-InnoDB中B-树索引的注意事项" class="headerlink" title="6.2.3 InnoDB中B+树索引的注意事项"></a>6.2.3 InnoDB中B+树索引的注意事项</h3><p>❓为什么对于某个列的索引B+树的根页面保持不动？</p>
<p>对于数据库查询，当根据某个列查询时，通过一个固定的内存位置查询索引，能够快速的查到。</p>
<p>❓为什么B+索引的根节点页面一开始也能存储用户记录？</p>
<p>因为一开始表是空的，所以根节点页面也是什么都没有，一旦又新纪录加入，那么会首先再根节点页面的可用空间中存储，一旦存储满了之后，会新开页面，并将根节点页面的记录都复制到这个新页面中。此时根节点页面就升级为存储目录项记录的页。也就是record_type=1</p>
<p>❓为什么在二级索引的b+树的内节点中的目录项记录必须是索引列+主键+页号？</p>
<p>因为如果只有索引列+页号，就会存在在内节点中各个目录项记录的索引列的值都是同一个，那么InnoDB引擎就不清楚该怎么选择页号来存储这个新纪录。所以加上主键id，实现唯一性。</p>
<p>❓为什么声明为unique列的索引的B+树的建立同样也会加上主键id呢？如上面所说的二级索引。</p>
<p>因为unique列的值有可能同时存在多个NULL值的列。</p>
<h1 id="第7章-B-树索引的使用"><a href="#第7章-B-树索引的使用" class="headerlink" title="第7章 B+树索引的使用"></a>第7章 B+树索引的使用</h1><h2 id="7-1-B-树索引示意图的简化"><a href="#7-1-B-树索引示意图的简化" class="headerlink" title="7.1 B+树索引示意图的简化"></a>7.1 B+树索引示意图的简化</h2><p>略，其实就是将b+树的内节点都抽象掉。只留有叶子几点。</p>
<h2 id="7-2-索引的代价"><a href="#7-2-索引的代价" class="headerlink" title="7.2 索引的代价"></a>7.2 索引的代价</h2><p>❓为什么索引在空间和时间上都在拖后腿？</p>
<p>因为对于每建立一个索引，都要生成一个对应的b+树，树中的节点都是一个页，每个页都固定大小16KB，这部妥妥的浪费内存空间嘛。对于时间上，每次进行记录的修改，都会对每个相关联的索引B+树都会进行维护，比如页中的记录的单向链表需要维护，亦或者是页的分裂，超出了页的存储范围。还有就是每执行查询语句前，都会生成一个执行计划，并且分析众多索引中花销最小的索引来进行查找。这样当索引越来越多时，就会产生严重的时延。</p>
<h2 id="7-3-应用B-树索引"><a href="#7-3-应用B-树索引" class="headerlink" title="7.3 应用B+树索引"></a>7.3 应用B+树索引</h2><h3 id="7-3-1-扫描区间和边界条件"><a href="#7-3-1-扫描区间和边界条件" class="headerlink" title="7.3.1 扫描区间和边界条件"></a>7.3.1 扫描区间和边界条件</h3><p>❓什么是扫描区间？</p>
<p>where或者in啥的关键词后带的区间</p>
<p>❓什么是边界条件？</p>
<p>其实就是扫描区间中的边界。</p>
<p>❓对于区间匹配的搜索，步骤是怎样的？</p>
<p>通过b+树的二分法快速定位到第一个匹配的记录，然后通过单向链表向后扫描，如果这个也扫描完了，就根据页与页之间的双向链表继续扫描，知道超过右区间的值为止。</p>
<p>❓如何选出适当的索引进行搜索？</p>
<p>那就必须要将所有的索引的搜索情况都了解清楚，然后选出合适的索引。或者不适合使用索引，可能使用索引会比直接使用聚簇索引更加的慢。</p>
<p>❓索引条件下推开启和关闭的区别？</p>
<p>索引条件下推默认开启，那么在二级索引下，搜索到第一条符合扫描区间的记录，不会马上进行回表，而是判断其余不能构成扫描区间的搜索条件是否满足，若满足，就回表，不满足，直接抛弃这个记录，然后遍历单向链表。反之，关闭情况下，就会立马回表，然后根据拿到的完整记录，过滤其余不能构成扫描区间的搜索条件。</p>
<h3 id="7-3-2-索引用于排序"><a href="#7-3-2-索引用于排序" class="headerlink" title="7.3.2 索引用于排序"></a>7.3.2 索引用于排序</h3><p>❓索引为什么可以用于排序？</p>
<p>说到排序，其实就是使用到了order by子句，加入order by 后面接着的列字段，这些字段定义了一个索引，那么可以直接使用这个索引从第一个记录开始搜索，紧接着进行回表即可。省去了排序的时间。</p>
<p>❓为什么order by 子句给出的列字段的顺序要和某一索引给出的顺序相同？</p>
<p>如果不相同，怎么可能可以省区排序的操作，可以结合B+索引一看便知。</p>
<h3 id="7-3-3-索引用于分组"><a href="#7-3-3-索引用于分组" class="headerlink" title="7.3.3 索引用于分组"></a>7.3.3 索引用于分组</h3><p>❓在group by中使用多个列字段进行排序是什么样的步骤？</p>
<p>首先通过第一个字段进行分组，然后通过在每个分组中按照第二个字段再进行分小组，然后在每个小组中根据第三个字段进行分组。</p>
<p>❓没有索引进行排序和有索引有什么区别？</p>
<p>在没有索引的情况下，分组会临时建立一个临时表，然后通过全局扫描聚簇索引填充这个临时表。</p>
<p>有索引的情况下，并且顺序要是一样的，这和索引排序是一个道理。这样就不会建立临时表了。</p>
<h2 id="7-4-回表的代价"><a href="#7-4-回表的代价" class="headerlink" title="7.4 回表的代价"></a>7.4 回表的代价</h2><p>❓为什么回表会有时比聚簇索引全局搜索还要消耗资源？</p>
<p>因为一般我们的数据页都是存储在磁盘中的，需要的时候才会使用磁盘IO加载到内存中，比如我们使用二级索引查找某个范围的时候，加入这个范围的记录占全部记录的99%，那么几乎就是每找到一个记录的时候就要进行回表，这还不如直接使用聚簇索引来的快！！！</p>
<p>❓为什么通常使用limit子句来限制查询条数时，更加倾向于使用二级索引+回表的操作，而不是全表查找？</p>
<p>因为使用limit子句，说明查询条数较少，那么需要进行徽标的次数就越少，那么效率就会越高。</p>
<h2 id="7-5-更好地创建和使用索引"><a href="#7-5-更好地创建和使用索引" class="headerlink" title="7.5 更好地创建和使用索引"></a>7.5 更好地创建和使用索引</h2><h3 id="7-5-1-只为用于搜索、排序或分组的列创建索引"><a href="#7-5-1-只为用于搜索、排序或分组的列创建索引" class="headerlink" title="7.5.1 只为用于搜索、排序或分组的列创建索引"></a>7.5.1 只为用于搜索、排序或分组的列创建索引</h3><p>❓为什么索引普遍用在where子句，order by，group by子句的列字段中？</p>
<p>因为索引是有顺序的，而这些限制条件（where。。。）都是跟顺序相关的。</p>
<h3 id="7-5-2-考虑索引列中不重复值的个数"><a href="#7-5-2-考虑索引列中不重复值的个数" class="headerlink" title="7.5.2 考虑索引列中不重复值的个数"></a>7.5.2 考虑索引列中不重复值的个数</h3><p>❓为什么列中重复值越多，越不会使用二级索引+回表操作？</p>
<p>因为重复值越多，当扫描区间存在这些重复值时，那么回表操作就会变多，对系统不利，拉低处理时延。</p>
<h3 id="7-5-3-索引列的类型尽量小"><a href="#7-5-3-索引列的类型尽量小" class="headerlink" title="7.5.3 索引列的类型尽量小"></a>7.5.3 索引列的类型尽量小</h3><p>❓为什么索引列的类型的大小尽量小？</p>
<p>因为从节省空间的角度看，索引列占用空间越小，b+树就占用空间越小。并且从磁盘加载数据页时，一个页中也能存储更多的记录。</p>
<h3 id="7-5-4-为列前缀建立索引"><a href="#7-5-4-为列前缀建立索引" class="headerlink" title="7.5.4 为列前缀建立索引"></a>7.5.4 为列前缀建立索引</h3><p>❓在什么时候不能只为列前缀建立索引？</p>
<p>当使用字符串类型的列字段建立索引，可以使用列前缀建立索引，比如字符串的前5个字符。这样可以节省索引空间。但是在使用索引排序的时候，我们不能为5个字符之后的字符进行排序。</p>
<h3 id="7-5-5-覆盖索引"><a href="#7-5-5-覆盖索引" class="headerlink" title="7.5.5 覆盖索引"></a>7.5.5 覆盖索引</h3><p>❓什么是覆盖索引？</p>
<p>覆盖索引是对于我们在select 后面接的搜索字段名。当这些字段包含在所使用的索引中时，就称为覆盖索引。</p>
<p>❓覆盖索引为什么可以不执行回表操作？</p>
<p>因为在二级索引中已经有了所需要查找的字段了。</p>
<p>所以我们在查找时，优先使用覆盖索引。</p>
<h3 id="7-5-6-让索引列以列名的形式在搜索条件中单独出现"><a href="#7-5-6-让索引列以列名的形式在搜索条件中单独出现" class="headerlink" title="7.5.6 让索引列以列名的形式在搜索条件中单独出现"></a>7.5.6 让索引列以列名的形式在搜索条件中单独出现</h3><p>❓什么是搜索条件？</p>
<p>其实就是where后跟着的语句。比如 key1 &lt; 3等</p>
<p>❓为什么要让索引列以列名的形式在搜索条件中单独出现？</p>
<p>因为不单独出现，比如 key1 * 2 &lt; 3这样的搜索条件，MySQL并不会简化这样的搜索条件为 key1 &lt; 1.5，所以也就生成不了能够缩减范围的扫描区间，所以就只能使用全表从扫描，其实这样的搜索条件我们可以认为其实是可以用二级索引+回表操作的。</p>
<h3 id="7-5-7-新插入记录时主键大小对效率的影响"><a href="#7-5-7-新插入记录时主键大小对效率的影响" class="headerlink" title="7.5.7 新插入记录时主键大小对效率的影响"></a>7.5.7 新插入记录时主键大小对效率的影响</h3><p>❓你知道为什么要有主键id设置auto increment了吧？</p>
<p>因为当不让主键随意大小插入到一个满了的数据页中时，会进行页分裂操作，这种操作会大大消耗资源。</p>
<h3 id="7-5-8-冗余和重复索引"><a href="#7-5-8-冗余和重复索引" class="headerlink" title="7.5.8 冗余和重复索引"></a>7.5.8 冗余和重复索引</h3><p>❓冗余索引和重复索引是一个东西？</p>
<p>是的，并且这些冗余索引和重复索引是不必要的。</p>
<p>❓什么时候会产生冗余索引？</p>
<p>比如MySQL会自动为主键创建一个索引（聚簇索引），而我们这时也为主键创建一个普通索引或者唯一索引，这就叫做冗余索引或重复索引！</p>
<h1 id="第8章-数据的家一MySQL的数据目录"><a href="#第8章-数据的家一MySQL的数据目录" class="headerlink" title="第8章 数据的家一MySQL的数据目录"></a>第8章 数据的家一MySQL的数据目录</h1><h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系"></a>8.1 数据库和文件系统的关系</h2><p>❓数据库和文件系统是怎样有关系的？</p>
<p>首先我们是使用存储引擎，比如InnoDB，来将表存储到磁盘中的，而操作系统是通过文件系统来管理磁盘的。所以InnoDB存储引擎是将表存储到文件系统上。</p>
<h2 id="8-2-MySQL数据目录"><a href="#8-2-MySQL数据目录" class="headerlink" title="8.2 MySQL数据目录"></a>8.2 MySQL数据目录</h2><p>❓为什么要有数据目录？</p>
<p>首先mysql启动的时候，会在某个目录中加载一些数据，而这个目录就是mysql的数据目录。</p>
<h3 id="8-2-2-如何确定MySQL中的数据目录"><a href="#8-2-2-如何确定MySQL中的数据目录" class="headerlink" title="8.2.2 如何确定MySQL中的数据目录"></a>8.2.2 如何确定MySQL中的数据目录</h3><p>可以在mysql容器中运行如下命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;datadir&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-数据目录的结构"><a href="#8-3-数据目录的结构" class="headerlink" title="8.3 数据目录的结构"></a>8.3 数据目录的结构</h2><p>在mysql数据目录下的每个子文件夹都对应一个数据库。唯一特殊的是，information_schema数据库却没有对应的文件夹。</p>
<h3 id="8-3-2-表在文件系统中的表示"><a href="#8-3-2-表在文件系统中的表示" class="headerlink" title="8.3.2 表在文件系统中的表示"></a>8.3.2 表在文件系统中的表示</h3><h4 id="1-InnoDB是如何存储表数据的"><a href="#1-InnoDB是如何存储表数据的" class="headerlink" title="1. InnoDB是如何存储表数据的"></a>1. InnoDB是如何存储表数据的</h4><p>归根结底来说，表数据是存储在页里的，我们知道索引也是数据同时也是一个B+树，叶子节点存储着所有的记录。每个节点就是一个页。</p>
<p>❓为啥要新提出一个表空间的概念，用来存储表数据？</p>
<p>其实就是为了更好的管理这些页。</p>
<p>❓有哪些种类的表空间</p>
<p>有系统表空间和独立表空间</p>
<p>其中系统表空间是对于较低版本mysql5.5.7-5.6.5，这些版本中在一个mysql服务器中系统表空间只有一份。随着表的增大而自适应的扩展系统表空间的大小。默认开始大小为12MB</p>
<p>而独立表空间，是对于mysql5.6.5以及之后的版本中，会为每个表建立一个独立表空间。每个表对应mysql数据目录中的对应的数据库文件名之中建立一个表名.ibd文件。</p>
<h1 id="第9章-存放页面的大池子一InnoDB的表空间"><a href="#第9章-存放页面的大池子一InnoDB的表空间" class="headerlink" title="第9章 存放页面的大池子一InnoDB的表空间"></a>第9章 存放页面的大池子一InnoDB的表空间</h1><h2 id="9-1回忆一些旧知识"><a href="#9-1回忆一些旧知识" class="headerlink" title="9.1回忆一些旧知识"></a>9.1回忆一些旧知识</h2><h3 id="9-1-1页面类型"><a href="#9-1-1页面类型" class="headerlink" title="9.1.1页面类型"></a>9.1.1页面类型</h3><p>❓有哪些页面类型？</p>
<p>首先我们用来存储表数据的页称为数据页（索引页），</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202311062119961.png" alt="image-20231106211954784"></p>
<h3 id="9-1-2-页面通用部分"><a href="#9-1-2-页面通用部分" class="headerlink" title="9.1.2 页面通用部分"></a>9.1.2 页面通用部分</h3><p>所有类型的页面都是具有一种通用的页面结构，也就是索引页的页面结构。</p>
<p>首先每种页面类型都具有File Header和File Trailer两个部分。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202311062122720.png" alt="image-20231106212222660"></p>
<p>❓File Header中有没有可以快速定位指定的页面的信息呢？</p>
<p>有的，就是File_Page_Offset，这个信息长4个字节，所以理论可以表示2的32次方个页，通常一个页大小为16KB，所以一个表空间理论可以容纳64TB。第一个页号为0。</p>
<h2 id="9-2-独立表空间结构"><a href="#9-2-独立表空间结构" class="headerlink" title="9.2 独立表空间结构"></a>9.2 独立表空间结构</h2><p>❓独立表空间和系统表空间，哪一个比较简单？</p>
<p>独立表空间，因为系统表空间包含了一些额外的关于整个系统的信息。</p>
<h3 id="9-2-1区的概念"><a href="#9-2-1区的概念" class="headerlink" title="9.2.1区的概念"></a>9.2.1区的概念</h3><p>❓为什么要在表空间中提出区的概念？</p>
<p>因为表空间中页一般都比较多，统一一起管理会比较不好管理。最主要的原因还是，我么在做搜索的时候，一般都是通过聚簇索引和二级索引从叶子节点中找到第一个满足条件的记录，然后一句页中单向链表和页间的双向链表来遍历查找，但是从一个页到另一个页的过程中，我们会进行磁盘IO，若是页与页之间普遍都是不相邻的，那么就非常影响磁盘的性能，所以引入<strong>区</strong>的概念。所以一般默认每64个页为一个区，也就是说默认一个区的大小为1MB。</p>
<p>并且256个区组成一个<strong>组</strong>。</p>
<p>❓在一个表空间中每个组的最开头几个页面都是用来标识一些信息的。</p>
<h3 id="9-2-2段的概念"><a href="#9-2-2段的概念" class="headerlink" title="9.2.2段的概念"></a>9.2.2段的概念</h3><p>❓什么是段？</p>
<p>其实段是区的集合！</p>
<p>❓为什么要有段？</p>
<p>因为我们在做查询的时候，只是在扫描叶子节点的记录，所以我们没有必要将所有非叶子节点的页面加载到内存中。所以我们要对叶子节点和非叶子节点所在的区做区分，所以就有了以专属于叶子节点的段和非叶子节点的段。这样一个索引就会生成两个段。</p>
<p>❓为什么要有碎片区？</p>
<p>默认情况下一个区中的所有页面都是分配给某一个段（要么是叶子节点段，要么是非叶子节点段），段的分配单位是区，而不是页，一个区中的页面比较少，我们还是要分配1MB内存（一个区就是1MB默认）然后分配给段。这样会浪费内存。所以碎片区的作用就是在这个区中不同的页用于分配给不同的段。</p>
<p>所以不同于其他区，碎片区不属于任何一个段，属于表空间。</p>
<p>❓那么段现在就不是简简单单的区的集合了？</p>
<p>是的，现在段是由一些碎片区的页面和一些完整的区的集合</p>
<p>❓那么现在有了碎片区之后，为某个段分配存储空间的策略是怎么样的？</p>
<p>在刚开始向表插入数据时，段是从碎片区请求单个页面</p>
<p>当某个段占据了32（一个区由64个页）个碎片区页面后，就会以完整的区为单位来分配存储空间。</p>
<h3 id="9-2-3区的分类"><a href="#9-2-3区的分类" class="headerlink" title="9.2.3区的分类"></a>9.2.3区的分类</h3><p><img src="https://gitee.com/fjkf/images/raw/master/202311062241264.png" alt="image-20231106224103123"></p>
<p>❓什么是XDES Entry结构？</p>
<p>其实就是用来方便管理这些区的一个数据结构。XDES Entry（Extent Descriptor Entry）。每个区都对应一个这个结构。</p>
<p><img src="https://gitee.com/fjkf/images/raw/master/202311062250828.png" alt="image-20231106225024725"></p>
<p>其中：</p>
<ol>
<li>Segmeng Id 表示这个区是属于那个段的。当这个区为上面区的4个状态除了FSEG的话，那么这个id是无意义的。</li>
<li>List Node: 用它就能将多个区连成一个链表。</li>
<li>State：由四种状态，如上所示区的分类。</li>
<li>Page State Bitmap：由16字节，128位，每2位为一组，那么就有64组，而一个区由64个页面，所以，每两位对应一个页面。每2位中的前1位表示该页是否是空闲的，后一位暂未用到。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wdpname.github.io">dpWu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wdpname.github.io/2023/10/21/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/">https://wdpname.github.io/2023/10/21/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wdpname.github.io" target="_blank">平博社</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/27/A-review-of-research-on-malicious-code-visual-detection-technology/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">A review of research on malicious code visual detection technology</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/20/%E9%80%BB%E8%BE%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%AC%AC15%E7%89%88%EF%BC%89/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">逻辑学导论（第15版）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dpWu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wdpname" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://1939317922@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD%E2%80%94%E5%88%9D%E8%AF%86MySQL"><span class="toc-number">1.</span> <span class="toc-text">第1章 装作自己是个小白—初识MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-MySQL%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 MySQL的客户端&#x2F;服务器架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-MySQL%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 MySQL的安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE%E2%80%94-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">第2章 MySQL的调控按钮—-启动选项和系统变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">2.3 状态变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">第三章 字符集和比较规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7%E2%80%94-InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">第4章 从一条记录说起—-InnoDB记录存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">4.1准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-InnoDB%E9%A1%B5%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 InnoDB页简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 InnoDB行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1指定行格式的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 COMPACT行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-REDUNDANT%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 REDUNDANT行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E6%BA%A2%E5%87%BA%E5%88%97"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4 溢出列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-DYNAMIC%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%92%8CCOMPRESSED%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5 DYNAMIC行格式和COMPRESSED行格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90%E4%B8%80InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">第5章 盛放记录的大盒子一InnoDB数据页结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%A1%B5%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 不同类型的页简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%E5%BF%AB%E8%A7%88"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 数据页结构快览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%AE%B0%E5%BD%95%E5%9C%A8%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 记录在页中的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%A7%98%E5%AF%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 记录头信息的秘密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Page-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 Page Directory(页目录)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 Page Header(页面头部)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-File-Header-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 File Header(文件头部)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 File Trailer(文件尾部)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D%E2%80%94-B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">第6章 快速查询的秘籍—-B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 没有索引时进行查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1在一个页中查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%9C%A8%E5%BE%88%E5%A4%9A%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 在很多页中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 一个简单的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 InnoDB中的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-InnoDB%E4%B8%ADB-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 InnoDB中B+树索引的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">第7章 B+树索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 B+树索引示意图的简化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 索引的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%BA%94%E7%94%A8B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 应用B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 扫描区间和边界条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E7%B4%A2%E5%BC%95%E7%94%A8%E4%BA%8E%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 索引用于排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E7%B4%A2%E5%BC%95%E7%94%A8%E4%BA%8E%E5%88%86%E7%BB%84"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3 索引用于分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%9B%9E%E8%A1%A8%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 回表的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 更好地创建和使用索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E5%8F%AA%E4%B8%BA%E7%94%A8%E4%BA%8E%E6%90%9C%E7%B4%A2%E3%80%81%E6%8E%92%E5%BA%8F%E6%88%96%E5%88%86%E7%BB%84%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.5.1 只为用于搜索、排序或分组的列创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E8%80%83%E8%99%91%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.5.2 考虑索引列中不重复值的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%BD%E9%87%8F%E5%B0%8F"><span class="toc-number">7.5.3.</span> <span class="toc-text">7.5.3 索引列的类型尽量小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-%E4%B8%BA%E5%88%97%E5%89%8D%E7%BC%80%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.4.</span> <span class="toc-text">7.5.4 为列前缀建立索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.5.</span> <span class="toc-text">7.5.5 覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-6-%E8%AE%A9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BB%A5%E5%88%97%E5%90%8D%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%9C%A8%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%B8%AD%E5%8D%95%E7%8B%AC%E5%87%BA%E7%8E%B0"><span class="toc-number">7.5.6.</span> <span class="toc-text">7.5.6 让索引列以列名的形式在搜索条件中单独出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-7-%E6%96%B0%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E6%97%B6%E4%B8%BB%E9%94%AE%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%95%88%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">7.5.7.</span> <span class="toc-text">7.5.7 新插入记录时主键大小对效率的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-8-%E5%86%97%E4%BD%99%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.8.</span> <span class="toc-text">7.5.8 冗余和重复索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6%E4%B8%80MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">8.</span> <span class="toc-text">第8章 数据的家一MySQL的数据目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 数据库和文件系统的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 MySQL数据目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9AMySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.2 如何确定MySQL中的数据目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 数据目录的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E8%A1%A8%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.3.2 表在文件系统中的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">1. InnoDB是如何存储表数据的</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%AD%98%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90%E4%B8%80InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">9.</span> <span class="toc-text">第9章 存放页面的大池子一InnoDB的表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E5%9B%9E%E5%BF%86%E4%B8%80%E4%BA%9B%E6%97%A7%E7%9F%A5%E8%AF%86"><span class="toc-number">9.1.</span> <span class="toc-text">9.1回忆一些旧知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1%E9%A1%B5%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1页面类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%94%A8%E9%83%A8%E5%88%86"><span class="toc-number">9.1.2.</span> <span class="toc-text">9.1.2 页面通用部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 独立表空间结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1区的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2段的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3区的分类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码托管怎么搞"/></a><div class="content"><a class="title" href="/2023/12/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%80%8E%E4%B9%88%E6%90%9E/" title="代码托管怎么搞">代码托管怎么搞</a><time datetime="2023-12-09T01:20:35.000Z" title="发表于 2023-12-09 09:20:35">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用户中心"/></a><div class="content"><a class="title" href="/2023/12/05/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83/" title="用户中心">用户中心</a><time datetime="2023-12-05T06:58:33.000Z" title="发表于 2023-12-05 14:58:33">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/12/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2023-12-04T15:23:36.000Z" title="发表于 2023-12-04 23:23:36">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB/" title="分布式系统和集群的区别"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式系统和集群的区别"/></a><div class="content"><a class="title" href="/2023/12/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB/" title="分布式系统和集群的区别">分布式系统和集群的区别</a><time datetime="2023-12-04T15:19:40.000Z" title="发表于 2023-12-04 23:19:40">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/03/dp%E6%80%BB%E7%BB%93/" title="dp总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dp总结"/></a><div class="content"><a class="title" href="/2023/12/03/dp%E6%80%BB%E7%BB%93/" title="dp总结">dp总结</a><time datetime="2023-12-03T07:38:53.000Z" title="发表于 2023-12-03 15:38:53">2023-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dpWu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>